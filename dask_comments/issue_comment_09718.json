[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1338225846",
        "html_url": "https://github.com/dask/dask/issues/9718#issuecomment-1338225846",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9718",
        "id": 1338225846,
        "node_id": "IC_kwDOAbcwm85Pw7S2",
        "user": {
            "login": "phobson",
            "id": 1163939,
            "node_id": "MDQ6VXNlcjExNjM5Mzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1163939?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/phobson",
            "html_url": "https://github.com/phobson",
            "followers_url": "https://api.github.com/users/phobson/followers",
            "following_url": "https://api.github.com/users/phobson/following{/other_user}",
            "gists_url": "https://api.github.com/users/phobson/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/phobson/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/phobson/subscriptions",
            "organizations_url": "https://api.github.com/users/phobson/orgs",
            "repos_url": "https://api.github.com/users/phobson/repos",
            "events_url": "https://api.github.com/users/phobson/events{/privacy}",
            "received_events_url": "https://api.github.com/users/phobson/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-12-05T21:53:40Z",
        "updated_at": "2022-12-05T21:53:40Z",
        "author_association": "MEMBER",
        "body": "@NickleDave thanks for the report. While I certainly agree that our docs could be improved, I'm struggling to think of the best path forward here.\r\n\r\nTo be sure, the dask API is deep, fairly complex, and there are often many correct ways to accomplish something.\r\n\r\nWithout knowing more about your use case, I'm inclined to think that something like this would work and be simpler to document:\r\n\r\n```python\r\nimport dask\r\nfrom distributed import Client\r\n\r\ndef my_expensive_function(**kwargs):\r\n   ... \r\n   return result, stats, history\r\n\r\ntask_kwargs = {...}\r\nn = 100\r\n\r\nwith Client() as client:\r\n    results = client.map(lambda x: my_expensive_function(**task_kwargs), range(n)))\r\n    ...\r\n```\r\n\r\nDoes something like the above work for your use case? Does that change anything about what you think should be documented?",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1338225846/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1338264258",
        "html_url": "https://github.com/dask/dask/issues/9718#issuecomment-1338264258",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9718",
        "id": 1338264258,
        "node_id": "IC_kwDOAbcwm85PxErC",
        "user": {
            "login": "NickleDave",
            "id": 11934090,
            "node_id": "MDQ6VXNlcjExOTM0MDkw",
            "avatar_url": "https://avatars.githubusercontent.com/u/11934090?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/NickleDave",
            "html_url": "https://github.com/NickleDave",
            "followers_url": "https://api.github.com/users/NickleDave/followers",
            "following_url": "https://api.github.com/users/NickleDave/following{/other_user}",
            "gists_url": "https://api.github.com/users/NickleDave/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/NickleDave/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/NickleDave/subscriptions",
            "organizations_url": "https://api.github.com/users/NickleDave/orgs",
            "repos_url": "https://api.github.com/users/NickleDave/repos",
            "events_url": "https://api.github.com/users/NickleDave/events{/privacy}",
            "received_events_url": "https://api.github.com/users/NickleDave/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-12-05T22:24:27Z",
        "updated_at": "2022-12-05T22:26:15Z",
        "author_association": "NONE",
        "body": "Thanks @phobson.\r\n\r\nThat looks like it would work, but there's two things I'm not sure about.\r\n\r\n- [ ] why use `map` with a `lambda`? It feels \"extra\" to map a function to a sequence where we don't even really use the input. I tried to map a `bag` in the same way, but it kept giving me the range back, I guess because I didn't use the `lambda` approach. Appending to a list of `Delayed` instances felt a bit more readable.\r\n- [ ] why prefer the `Client` interface over `dask.delayed`?\r\n\r\nI'm not trying to turn this into a request for help, just providing feedback from the POV of a relative novice reading the docs.\r\n\r\nI do think part of what might be happening is my understanding of the `dask` API is out of date. I see that most (all?) of the examples on examples.dask.org now favor the `distributed` module using the `Client`. And looking again at the landing page (it's been a while \ud83d\ude33 ) I see that the snippet for `concurrent.futures` uses the `Client` interface that \"provides general submission of custom tasks\". \r\n\r\nIn case the context helps clarify what I'm looking for in the docs: my use case is to parallelize library code so tasks run faster for users. `my_expensive_function` runs a simulation; there's no long chain of operations downstream of it that also need to be parallelized. I should still use the `Client` for that?\r\n\r\nI'm not doing something like working interactively with a giant dataframe on a notebook connected remotely with a cluster where I need the dashboard(but obvs would like to be scale to a cluster later, I heard `dask` was good at that \ud83d\ude42 ). \r\n\r\nThe [Futures docs](https://docs.dask.org/en/stable/futures.html) (that I have failed to read until now) are making me think the answer is *maybe*?\r\n> Though Dask futures is one of Dask\u2019s more powerful APIs, it is often not needed unless you have a particular use case for handling concurrency on the client. One of the higher-level Dask APIs, e.g. Dask Array or Dask Delayed, will suit most users\u2019 needs, without introducing the additional complexity that comes with concurrency.\r\n\r\nI guess that last sentence makes me think I should favor `Delayed` here if I'm just trying to parallelize one function call.\r\n\r\nIf the answer is yes, I should still be using `Client`, then your example makes sense to me.\r\n\r\nThank you again! The docs are very good, by the way, I didn't mean to imply they're not--it's just this one use case that has tripped me up more than once now",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1338264258/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1338388035",
        "html_url": "https://github.com/dask/dask/issues/9718#issuecomment-1338388035",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9718",
        "id": 1338388035,
        "node_id": "IC_kwDOAbcwm85Pxi5D",
        "user": {
            "login": "phobson",
            "id": 1163939,
            "node_id": "MDQ6VXNlcjExNjM5Mzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1163939?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/phobson",
            "html_url": "https://github.com/phobson",
            "followers_url": "https://api.github.com/users/phobson/followers",
            "following_url": "https://api.github.com/users/phobson/following{/other_user}",
            "gists_url": "https://api.github.com/users/phobson/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/phobson/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/phobson/subscriptions",
            "organizations_url": "https://api.github.com/users/phobson/orgs",
            "repos_url": "https://api.github.com/users/phobson/repos",
            "events_url": "https://api.github.com/users/phobson/events{/privacy}",
            "received_events_url": "https://api.github.com/users/phobson/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-12-06T00:02:11Z",
        "updated_at": "2022-12-06T00:02:11Z",
        "author_association": "MEMBER",
        "body": "> why use map with a lambda?\r\n\r\nIn my illustration, I did this since I was throwing away the value of the iterator. In other words:\r\n\r\n```python\r\nclient.map(my_expensive_function, range(n)))\r\n```\r\n\r\n...would pass the values of `range(n)` to `my_expensive_function`, and that didn't seemed desired in your case. \r\n\r\n>  why prefer the Client interface over dask.delayed\r\n\r\nFor me, it's a combination of familiarity and brevity. There are many ways to do most things, but that's just where my brain goes.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1338388035/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1855407552",
        "html_url": "https://github.com/dask/dask/issues/9718#issuecomment-1855407552",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9718",
        "id": 1855407552,
        "node_id": "IC_kwDOAbcwm85ul0XA",
        "user": {
            "login": "Andrew-S-Rosen",
            "id": 8674072,
            "node_id": "MDQ6VXNlcjg2NzQwNzI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8674072?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/Andrew-S-Rosen",
            "html_url": "https://github.com/Andrew-S-Rosen",
            "followers_url": "https://api.github.com/users/Andrew-S-Rosen/followers",
            "following_url": "https://api.github.com/users/Andrew-S-Rosen/following{/other_user}",
            "gists_url": "https://api.github.com/users/Andrew-S-Rosen/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/Andrew-S-Rosen/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/Andrew-S-Rosen/subscriptions",
            "organizations_url": "https://api.github.com/users/Andrew-S-Rosen/orgs",
            "repos_url": "https://api.github.com/users/Andrew-S-Rosen/repos",
            "events_url": "https://api.github.com/users/Andrew-S-Rosen/events{/privacy}",
            "received_events_url": "https://api.github.com/users/Andrew-S-Rosen/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-12-14T08:36:37Z",
        "updated_at": "2023-12-14T08:57:29Z",
        "author_association": "CONTRIBUTOR",
        "body": "@NickleDave: After hours of struggling, I stumbled upon your extremely helpful issue report here and want to express my deepest thanks. I had no clue about `nout` and was coming up with all kinds of terribly hacky workarounds.\r\n\r\nI agree that this should be explicitly documented somewhere. But perhaps even better, I would argue that there is a need for a custom decorator (e.g. `@subdelayed`) that would allow for decorating a Python function in this way when the number of iterations or outputs is not known _a priori_. Indeed, it's possible to use the `client.map` approach, but if one is building a library of Dask-decorated functions, this is not particularly ideal if one wants to keep the underlying Python code as close to native Python as possible. After all, that's one of the benefits of decorators in the first place --- to keep the workflow logic out of the domain knowledge. How to achieve this, however, is a different issue altogether.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1855407552/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]