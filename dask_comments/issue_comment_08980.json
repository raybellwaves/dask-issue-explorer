[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1109105430",
        "html_url": "https://github.com/dask/dask/issues/8980#issuecomment-1109105430",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/8980",
        "id": 1109105430,
        "node_id": "IC_kwDOAbcwm85CG5sW",
        "user": {
            "login": "ian-r-rose",
            "id": 5728311,
            "node_id": "MDQ6VXNlcjU3MjgzMTE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/5728311?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ian-r-rose",
            "html_url": "https://github.com/ian-r-rose",
            "followers_url": "https://api.github.com/users/ian-r-rose/followers",
            "following_url": "https://api.github.com/users/ian-r-rose/following{/other_user}",
            "gists_url": "https://api.github.com/users/ian-r-rose/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/ian-r-rose/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ian-r-rose/subscriptions",
            "organizations_url": "https://api.github.com/users/ian-r-rose/orgs",
            "repos_url": "https://api.github.com/users/ian-r-rose/repos",
            "events_url": "https://api.github.com/users/ian-r-rose/events{/privacy}",
            "received_events_url": "https://api.github.com/users/ian-r-rose/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-04-25T22:31:21Z",
        "updated_at": "2022-04-25T22:31:21Z",
        "author_association": "MEMBER",
        "body": "I think the north star of designing the next version of High Level Graph layers should be Blockwise + Slicing:\r\n```python\r\nx = da.random.uniform(size=(1_000_000, 1_000_000))\r\ny = x * 2\r\nz = y[::2, ::2]\r\nz.compute()\r\n```\r\nThe layer design for those should:\r\n\r\n1. Be able to interoperate in a similar way that Blockwise layers do with themselves.\r\n2. Scale with the number of output keys, not the number of input keys (cf. #8570 )\r\n\r\nI'm given to talking through exactly that problem (either for dataframes or arrays) as a means of making constraint discovery more explicit.\r\n\r\nOne thing that we may need to teach the interface about is partitions. The current interface assumes almost nothing about the actual structure of the graph, just that it is dict-like and maps hashables onto tasks/values. This may be leading us to push excessive complexity into actual layer implementations. For a concrete example see some of the discussion around `PartitionedLayer` in #8672 . Should a HighLevelGraph know if a layer has output partitions/chunks, and how many? Should it know if the keys for a collection are of the form `(name, *indices)`? The loss of generality from making such an assumption might not be worth it, but I think it's worth a discussion.\r\n\r\nOther thoughts:\r\n\r\n* How do non-graph activities like the shuffle service fit into the design here? I haven't followed the design of that very closely, so might not have much to contribute there.\r\n* In any event: I think one requirement should be to write down a `Protocol` for layers, then actually use and enforce it. I think a lot of complexity has come about from adding one-off flags/kwargs/bits-of-detritus to get things working for specific use-cases. Those have come at a cost of very few people understanding how HLG construction actually works, or only having partial views (:hand:).",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1109105430/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1118368572",
        "html_url": "https://github.com/dask/dask/issues/8980#issuecomment-1118368572",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/8980",
        "id": 1118368572,
        "node_id": "IC_kwDOAbcwm85CqPM8",
        "user": {
            "login": "sjperkins",
            "id": 3530212,
            "node_id": "MDQ6VXNlcjM1MzAyMTI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3530212?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sjperkins",
            "html_url": "https://github.com/sjperkins",
            "followers_url": "https://api.github.com/users/sjperkins/followers",
            "following_url": "https://api.github.com/users/sjperkins/following{/other_user}",
            "gists_url": "https://api.github.com/users/sjperkins/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/sjperkins/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/sjperkins/subscriptions",
            "organizations_url": "https://api.github.com/users/sjperkins/orgs",
            "repos_url": "https://api.github.com/users/sjperkins/repos",
            "events_url": "https://api.github.com/users/sjperkins/events{/privacy}",
            "received_events_url": "https://api.github.com/users/sjperkins/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-05-05T09:48:38Z",
        "updated_at": "2022-05-05T09:48:38Z",
        "author_association": "MEMBER",
        "body": "> The current interface assumes almost nothing about the actual structure of the graph, just that it is dict-like and maps hashables onto tasks/values. This may be leading us to push excessive complexity into actual layer implementations.\r\n\r\nI think this is the crux of the problem.\r\n\r\nThis https://en.wikipedia.org/wiki/Bijection,_injection_and_surjection might be useful for organising our thoughts, because I think the various types of mapping are implemented in different places through the codebase and as Matt says, we're now trying to force them all into a dictionary interface. This works fine for elementwise operations but is conceptually difficult for anything else.\r\n\r\nFor example Blockwise implements a bijection mapping for elementwise operations\r\n\r\n```python\r\n(out_prefix, i): (func, (in_prefix, i))\r\n```\r\n\r\nwhile reduction implements a surjective mapping. Here's a 4 layer reduction:\r\n\r\n```python\r\n(out_prefix, i // 4): (agg, (combine, (in_prefix, i+0), (in_prefix, i+1))\r\n                            (combine, (in_prefix, i+2), (in_prefix, i+3)))\r\n```\r\n\r\nConceptually, I think Layers describe these operations/mappings so I think this is the place where they should happen.\r\nEither as single operations for each output key like the pseudo-code above or all-at-once operations like `make_blockwise_graph`. All-at-once is probably easier.\r\n\r\n> This may be leading us to push excessive complexity into actual layer implementations.\r\n\r\nThis suggestion does move complexity into the Layer implementation so it might be undesirable, but I would argue that it's better to collect these behaviours in a well-defined location. For e.g. a `ReductionLayer` might be parameterised on `axis`, `keepdims` etc. But perhaps the current complexity around Layers is that we're trying to represent them as dicts?\r\n\r\nAlso, I realise I'm probably stepping into the middle of a conversation.\r\nI just read:\r\n- https://github.com/dask/distributed/pull/5728\r\n- https://github.com/dask/dask/pull/8672\r\n\r\nwhich imply that `__dask_distributed_{pack,unpack}__` are targetted for removal so I may have spent time arguing for something that is has been scoped elsehwere.\r\n\r\nHowever, the major point that I want to re-emphasise is that conceptually, to me, a Layer is implementing\r\nhttps://en.wikipedia.org/wiki/Bijection,_injection_and_surjection so this operation should\r\nbe defined on Layers. Or perhaps as a protocol associated with a Layer.\r\n\r\nIf this is impractical, feel free to ignore though! Perhaps this will stimulate further thought on the matter.\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1118368572/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1122832415",
        "html_url": "https://github.com/dask/dask/issues/8980#issuecomment-1122832415",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/8980",
        "id": 1122832415,
        "node_id": "IC_kwDOAbcwm85C7RAf",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-05-10T20:31:49Z",
        "updated_at": "2022-05-10T20:31:49Z",
        "author_association": "MEMBER",
        "body": "Others should feel free to reject this idea outright, but I\u2019m wondering if there is any appetite to move away from the `Collection->HighLevelGraph->Layer` structure altogether?  Now that we are likley to be free from the original constraint that was forcing us to avoid importing/using `numpy`/`pandas` within a `Layer`, it seems reasonable to simply \u201ccut out\u201d the `HighLevelGraph` class and redesign the collection APIs to simply wrap a collection-aware `Layer`-like object.\r\n\r\nTo avoid confusion with the HLG `Layer`, we could use a completely different name for this `Layer`-like object, sush as `CollectionOperation`.  The general idea would be to move collection attributes like `name`/`meta`/`divisions` into a single `CollectionOperation` object defined as an `operation` attribute (and simply point to `self.operator.name/meta/divisions` from the collection API).\r\n\r\n\r\n![operator_idea](https://user-images.githubusercontent.com/20461013/167715967-440ed131-51f0-45e6-9191-c634d0cd2cf2.png)\r\n\r\n\r\nThe motivation for wrapping a single `Layer`-like  `CollectionOperation` object, rather than a larger `HighLevelGraph`-like object, is that each `CollectionOperation` object can be designed to store its own dependencies.  This means that, when \u201cmaterializing\u201d a low-level graph, the collection can simply ask its `operation` attribute to materialize the necessary graph to compute a specified list of keys (e.g. `self.operation.subgraph(self.__dask_keys__)`), and that `CollectionOperation` object can generate the full graph by recursively calling  `subgraph` on its dependencies.  This gives us culling without the need for an explicit `cull` optimization. Since the `operation` object also knows the \u201ctypes\u201d of its dependencies, task fusion can be performed at materialization time (and would no longer required a `Blockwise`-fusion optimization). For example, a `DataFrameMap` flavor of a `CollectionOperation` will know that it can fuse with another `DataFrameMap` (or `DataFrameCreation`) dependency. \r\n\r\n\r\nBy requiring each `CollectionOperation` object to store its own dependencies, we also make it pretty easy to \u201creplay\u201d a collection to perform optimizations like column projection and predicate pushdown.\r\n\r\nThe obvious problem with this approach is that the design is clearly very different from what we have now, and so it would require many DataFrame/Array API functions to be rewritten to use `CollectionOperation`s. With this said, it probably wouldn\u2019t be too difficult to fall back on HLG\u2019s when a non-`CollectionOperation`-conforming API is used.\r\n\r\nIf others think this might make sense, I\u2019d be happy to discuss further and work through a design document and reference implementation.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1122832415/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1122935468",
        "html_url": "https://github.com/dask/dask/issues/8980#issuecomment-1122935468",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/8980",
        "id": 1122935468,
        "node_id": "IC_kwDOAbcwm85C7qKs",
        "user": {
            "login": "mrocklin",
            "id": 306380,
            "node_id": "MDQ6VXNlcjMwNjM4MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/306380?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mrocklin",
            "html_url": "https://github.com/mrocklin",
            "followers_url": "https://api.github.com/users/mrocklin/followers",
            "following_url": "https://api.github.com/users/mrocklin/following{/other_user}",
            "gists_url": "https://api.github.com/users/mrocklin/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mrocklin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mrocklin/subscriptions",
            "organizations_url": "https://api.github.com/users/mrocklin/orgs",
            "repos_url": "https://api.github.com/users/mrocklin/repos",
            "events_url": "https://api.github.com/users/mrocklin/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mrocklin/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-05-10T22:06:48Z",
        "updated_at": "2022-05-10T22:06:48Z",
        "author_association": "MEMBER",
        "body": "I do not immediately hate this plan\n\nOn Tue, May 10, 2022 at 3:32 PM Richard (Rick) Zamora <\n***@***.***> wrote:\n\n> Others should feel free to reject this idea outright, but I\u2019m wondering if\n> there is any appetite to move away from the\n> Collection->HighLevelGraph->Layer structure altogether? Now that we are\n> likley to be free from the original constraint that was forcing us to avoid\n> importing/using numpy/pandas within a Layer, it seems reasonable to\n> simply \u201ccut out\u201d the HighLevelGraph class and redesign the collection\n> APIs to simply wrap a collection-aware Layer-like object.\n>\n> To avoid confusion with the HLG Layer, we could use a completely\n> different name for this Layer-like object, sush as CollectionOperation.\n> The general idea would be to move collection attributes like name/meta/\n> divisions into a single CollectionOperation object defined as an operation\n> attribute (and simply point to self.operator.name/meta/divisions from the\n> collection API).\n>\n> [image: operator_idea]\n> <https://user-images.githubusercontent.com/20461013/167715967-440ed131-51f0-45e6-9191-c634d0cd2cf2.png>\n>\n> The motivation for wrapping a single Layer-like CollectionOperation\n> object, rather than a larger HighLevelGraph-like object, is that each\n> CollectionOperation object can be designed to store its own dependencies.\n> This means that, when \u201cmaterializing\u201d a low-level graph, the collection can\n> simply ask its operation attribute to materialize the necessary graph to\n> compute a specified list of keys (e.g.\n> self.operation.subgraph(self.__dask_keys__)), and that CollectionOperation\n> object can generate the full graph by recursively calling subgraph on its\n> dependencies. This gives us culling without the need for an explicit cull\n> optimization. Since the operation object also knows the \u201ctypes\u201d of its\n> dependencies, task fusion can be performed at materialization time (and\n> would no longer required a Blockwise-fusion optimization). For example, a\n> DataFrameMap flavor of a CollectionOperation will know that it can fuse\n> with another DataFrameMap (or DataFrameCreation) dependency.\n>\n> By requiring each CollectionOperation object to store its own\n> dependencies, we also make it pretty easy to \u201creplay\u201d a collection to\n> perform optimizations like column projection and predicate pushdown.\n>\n> The obvious problem with this approach is that the design is clearly very\n> different from what we have now, and so it would require many\n> DataFrame/Array API functions to be rewritten to use CollectionOperations.\n> With this said, it probably wouldn\u2019t be too difficult to fall back on HLG\u2019s\n> when a non-CollectionOperation-conforming API is used.\n>\n> If others think this might make sense, I\u2019d be happy to discuss further and\n> work through a design document and reference implementation.\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dask/dask/issues/8980#issuecomment-1122832415>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AACKZTAHJALBXQXPPPG2BJ3VJLBUBANCNFSM5UJ3P7FQ>\n> .\n> You are receiving this because you authored the thread.Message ID:\n> ***@***.***>\n>\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1122935468/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1123942905",
        "html_url": "https://github.com/dask/dask/issues/8980#issuecomment-1123942905",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/8980",
        "id": 1123942905,
        "node_id": "IC_kwDOAbcwm85C_gH5",
        "user": {
            "login": "douglasdavis",
            "id": 3202090,
            "node_id": "MDQ6VXNlcjMyMDIwOTA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3202090?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/douglasdavis",
            "html_url": "https://github.com/douglasdavis",
            "followers_url": "https://api.github.com/users/douglasdavis/followers",
            "following_url": "https://api.github.com/users/douglasdavis/following{/other_user}",
            "gists_url": "https://api.github.com/users/douglasdavis/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/douglasdavis/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/douglasdavis/subscriptions",
            "organizations_url": "https://api.github.com/users/douglasdavis/orgs",
            "repos_url": "https://api.github.com/users/douglasdavis/repos",
            "events_url": "https://api.github.com/users/douglasdavis/events{/privacy}",
            "received_events_url": "https://api.github.com/users/douglasdavis/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-05-11T15:39:22Z",
        "updated_at": "2022-05-11T15:39:22Z",
        "author_association": "MEMBER",
        "body": "> If others think this might make sense, I\u2019d be happy to discuss further and work through a design document and reference implementation.\r\n\r\nI'd definitely be interested in seeing a reference implementation ",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1123942905/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1125350081",
        "html_url": "https://github.com/dask/dask/issues/8980#issuecomment-1125350081",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/8980",
        "id": 1125350081,
        "node_id": "IC_kwDOAbcwm85DE3rB",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-05-12T19:31:33Z",
        "updated_at": "2022-05-12T19:31:33Z",
        "author_association": "MEMBER",
        "body": ">I'd definitely be interested in seeing a reference implementation\r\n\r\nI shared something very rough here: https://github.com/dask/dask/pull/9076\r\n\r\nThat PR doesn't quite present a clear API just yet, but hopefully I can push it there :)",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1125350081/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1125379236",
        "html_url": "https://github.com/dask/dask/issues/8980#issuecomment-1125379236",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/8980",
        "id": 1125379236,
        "node_id": "IC_kwDOAbcwm85DE-yk",
        "user": {
            "login": "douglasdavis",
            "id": 3202090,
            "node_id": "MDQ6VXNlcjMyMDIwOTA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3202090?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/douglasdavis",
            "html_url": "https://github.com/douglasdavis",
            "followers_url": "https://api.github.com/users/douglasdavis/followers",
            "following_url": "https://api.github.com/users/douglasdavis/following{/other_user}",
            "gists_url": "https://api.github.com/users/douglasdavis/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/douglasdavis/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/douglasdavis/subscriptions",
            "organizations_url": "https://api.github.com/users/douglasdavis/orgs",
            "repos_url": "https://api.github.com/users/douglasdavis/repos",
            "events_url": "https://api.github.com/users/douglasdavis/events{/privacy}",
            "received_events_url": "https://api.github.com/users/douglasdavis/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-05-12T20:08:37Z",
        "updated_at": "2022-05-12T20:08:37Z",
        "author_association": "MEMBER",
        "body": "\"Richard (Rick) Zamora\" ***@***.***> writes:\n\n>>I'd definitely be interested in seeing a reference implementation\n>\n> I shared something very rough here: https://github.com/dask/dask/pull/9076\n>\n> That PR doesn't quite present a clear API just yet, but hopefully I can push it there :)\n\nAwesome thanks a lot. I'll give it a study and see how the experience is\ntrying to do something similar in dask-awkward.\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1125379236/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]