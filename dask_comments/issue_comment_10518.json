[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1725694799",
        "html_url": "https://github.com/dask/dask/issues/10518#issuecomment-1725694799",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10518",
        "id": 1725694799,
        "node_id": "IC_kwDOAbcwm85m3ANP",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-09-19T14:15:39Z",
        "updated_at": "2023-09-19T14:15:39Z",
        "author_association": "MEMBER",
        "body": "Thanks for your report. \r\n\r\nBefore I get into this, what you call \"compilation\", i.e. the process of building the \"low level graph\" / initializing all tasks, is what we typically refer to as \"materialization\".\r\n\r\nWith this out of the way, let's look at your `data`. Calling `data.dask` shows the representation of your graph up to this point, layer by layer (roughly every expression that is applied to your collection is represented as a layer).\r\n\r\nYou'll notice the attribute `is_materialized` which indicates whether the graph was already fully built since this is actually done layer by layer. You'll also notice the white vs grey circles.\r\n\r\n![image](https://github.com/dask/dask/assets/8629629/3600e98a-c965-4960-b837-d13e9d373c66)\r\n\r\nThere are a couple of layer types in here that are already materialized. Looking through the code base it appears that for those operations (primarily concatenate and overlap) the \"non-materialized\" representation of the graph is simply not implemented yet. \r\n\r\nIf this is implemented properly, we would indeed just compute whatever is necessary to calculate the desired output key as you are describing.\r\n\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1725694799/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1725707494",
        "html_url": "https://github.com/dask/dask/issues/10518#issuecomment-1725707494",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10518",
        "id": 1725707494,
        "node_id": "IC_kwDOAbcwm85m3DTm",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-09-19T14:22:06Z",
        "updated_at": "2023-09-19T14:22:06Z",
        "author_association": "MEMBER",
        "body": "Apart from the materialization issues, your example is generating a graph of about 4MM tasks. This is larger than what we are typically dealing with and especially if you are adding more layers to this graph, this could quickly grow out of hand. If there is any opportunity to rechunk / use larger chunks, this could help significantly. IIUC your input dataset has chunks of about 50MiB. You may be able to go a little higher here\r\n\r\n\r\n```python\r\nzero = da.zeros((10000,5000,5000,5), dtype='float32', chunks=(1000, 500, 25, 1))\r\n# If the input data is the way it is, you can still rechunk later\r\n# Mind that the new chunks are a multiple of the input, this way the operation is trivial\r\nzero = zero.rechunk((2000, 1000, 25, 1))\r\n# Adjust the overlap as necessary\r\ndata = da.overlap.overlap(zero, depth={0:5, 1:2, 2:2}, boundary=-1)\r\n```",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1725707494/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1725788257",
        "html_url": "https://github.com/dask/dask/issues/10518#issuecomment-1725788257",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10518",
        "id": 1725788257,
        "node_id": "IC_kwDOAbcwm85m3XBh",
        "user": {
            "login": "BrandonSmithJ",
            "id": 1062829,
            "node_id": "MDQ6VXNlcjEwNjI4Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1062829?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/BrandonSmithJ",
            "html_url": "https://github.com/BrandonSmithJ",
            "followers_url": "https://api.github.com/users/BrandonSmithJ/followers",
            "following_url": "https://api.github.com/users/BrandonSmithJ/following{/other_user}",
            "gists_url": "https://api.github.com/users/BrandonSmithJ/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/BrandonSmithJ/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/BrandonSmithJ/subscriptions",
            "organizations_url": "https://api.github.com/users/BrandonSmithJ/orgs",
            "repos_url": "https://api.github.com/users/BrandonSmithJ/repos",
            "events_url": "https://api.github.com/users/BrandonSmithJ/events{/privacy}",
            "received_events_url": "https://api.github.com/users/BrandonSmithJ/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-09-19T14:44:21Z",
        "updated_at": "2023-09-19T14:44:21Z",
        "author_association": "NONE",
        "body": "Thanks for the reply! \r\n\r\nSo to reiterate what you're saying, the materialization does in fact already happen just-in-time, it's only because the non-materialization representation isn't implemented for concatenate/overlap that the current behavior requires those layers to be fully materialized in order to compute any output keys. If/when a non-materialization representation is available for those layers, it should be the case that in the example above, the first block can be computed without actually materializing the other (unnecessary for that block) parts of the low level graph. Did I understand that correctly?\r\n\r\nFor example, [this specific area](https://github.com/dask/dask/blob/216c7c9393d8df1014a911eceb797502999e8a51/dask/layers.py#L147) is where that non-materializing representation would be implemented? And [this pull request](https://github.com/dask/dask/pull/8476) is actually addressing that, except that it hasn't been merged yet. I can bump that pull request, since it seems like it may have slipped through the cracks.\r\n\r\n\r\nSo I guess that answers my main question, thanks! One thing from your reply that I'm unsure of, though: having something like 4MM (or even 400MM) tasks in a graph should only be a problem for the scheduler if you're actually trying to compute that entire graph, right? \r\n\r\nIf instead, we're only doing a small segment of the graph at a time (like in the example above, computing one block at a time) - and assuming the graph has a full non-materialization representation - there really shouldn't be any bottleneck on how large the overall graph can be. The bottleneck is purely at the number of tasks specifically required for the requested output key. Is that correct?",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1725788257/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1725977974",
        "html_url": "https://github.com/dask/dask/issues/10518#issuecomment-1725977974",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10518",
        "id": 1725977974,
        "node_id": "IC_kwDOAbcwm85m4FV2",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-09-19T16:07:19Z",
        "updated_at": "2023-09-20T07:20:47Z",
        "author_association": "MEMBER",
        "body": "> layers, it should be the case that in the example above, the first block can be computed without actually materializing the other (unnecessary for that block) parts of the low level graph. Did I understand that correctly?\r\n\r\nYes, we call this [culling](https://github.com/dask/dask/blob/216c7c9393d8df1014a911eceb797502999e8a51/dask/highlevelgraph.py#L689-L704). We'll basically take the output key you requested and walk our way backwards building the graph. This way, you'll only build and compute what you actually require for your result.\r\n\r\n> For example, [this specific area](https://github.com/dask/dask/blob/216c7c9393d8df1014a911eceb797502999e8a51/dask/layers.py#L147) is where that non-materializing representation would be implemented? And https://github.com/dask/dask/pull/8476 is actually addressing that, except that it hasn't been merged yet. I can bump that pull request, since it seems like it may have slipped through the cracks.\r\n\r\nI'm not familiar with this yet but from a brief glance, yes. \r\n\r\nFor `concatenate`, I believe it is simply not implemented, yet. One would need to implement a `ConcatenateLayer` (It looks like [this](https://github.com/dask/dask/blob/216c7c9393d8df1014a911eceb797502999e8a51/dask/array/core.py#L4313-L4324) is old code that is generating the low level graph eagerly. I don't know how difficult it is to move this into a layer.)\r\n\r\n\r\n---\r\n\r\nFor the sake of transparency, this `HighLevelGraph` / `Layer` is an abstraction we're not entirely satisfied with. For DataFrames, there is a rewrite/experiment happening over in https://github.com/dask-contrib/dask-expr. This does not support arrays yet but it is our intention to add arrays to it, eventually. This will not help you now, I'm just mentioning this in case you are interested.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1725977974/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1731625471",
        "html_url": "https://github.com/dask/dask/issues/10518#issuecomment-1731625471",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10518",
        "id": 1731625471,
        "node_id": "IC_kwDOAbcwm85nNoH_",
        "user": {
            "login": "BrandonSmithJ",
            "id": 1062829,
            "node_id": "MDQ6VXNlcjEwNjI4Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1062829?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/BrandonSmithJ",
            "html_url": "https://github.com/BrandonSmithJ",
            "followers_url": "https://api.github.com/users/BrandonSmithJ/followers",
            "following_url": "https://api.github.com/users/BrandonSmithJ/following{/other_user}",
            "gists_url": "https://api.github.com/users/BrandonSmithJ/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/BrandonSmithJ/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/BrandonSmithJ/subscriptions",
            "organizations_url": "https://api.github.com/users/BrandonSmithJ/orgs",
            "repos_url": "https://api.github.com/users/BrandonSmithJ/repos",
            "events_url": "https://api.github.com/users/BrandonSmithJ/events{/privacy}",
            "received_events_url": "https://api.github.com/users/BrandonSmithJ/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-09-22T15:34:54Z",
        "updated_at": "2023-09-22T18:17:18Z",
        "author_association": "NONE",
        "body": "Unfortunately my application needs to work with arrays rather than DataFrames, but thanks for mentioning it - I'll definitely keep my eye on the progress. \r\n\r\nWith that said, I am somewhat invested in getting a faster subgraph computation like in the example above, and so I'm trying to dig into exactly why this example needs to take so long to compute the first block. In the reference you provided above to culling, one of the first lines of that function is to call `get_all_external_keys`, which is what triggers the materialization of the overlap layer.\r\n\r\nThe problem with that is, when there are millions of external keys for a layer (which seems to commonly be the case for an overlap layer), this takes significantly more time and memory to create and work with than any single key dependency path actually requires (regardless of if the layer is actually materialized, if I understand things correctly). \r\n \r\nI'm having some difficulty understanding exactly why an individual layer needs the entire graph's external keys in order to cull its own dependencies, however. When I trace back the usage of the full external key set, it appears as though each layer is just checking whether each of its dependencies is actually contained in the full graph key set ([here](https://github.com/dask/dask/blob/216c7c9393d8df1014a911eceb797502999e8a51/dask/highlevelgraph.py#L167))...which to me, seems tautologically true.\r\n\r\nI've made some modifications to dask that allow the above example to completely run in < 1 second (essentially removing the time dependency on the size of the graph/data):\r\n\r\n```\r\n0.02 seconds to compile graph\r\nGraph contains 4,268,720 tasks\r\n0.55 seconds to compute the first block\r\n\r\n0.21 seconds to compute the first block\r\n0.05 seconds to compute a different block\r\n0.00 seconds to compile graph\r\nGraph contains 4,268,720 tasks\r\n```\r\n\r\nThis requires removing the calculation of all external keys that I mentioned above, however, which does work for this example - and I think theoretically should never be required for any other situation - but I'm not familiar enough with dask internals to say for sure. Do you (or anyone else) know why the calculation of all external keys is necessary? In what situation(s) would a layer need the external keys of the entire graph in order to cull its own dependencies?  ",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1731625471/reactions",
            "total_count": 2,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 2
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1733802081",
        "html_url": "https://github.com/dask/dask/issues/10518#issuecomment-1733802081",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10518",
        "id": 1733802081,
        "node_id": "IC_kwDOAbcwm85nV7hh",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-09-25T14:16:25Z",
        "updated_at": "2023-09-25T14:16:25Z",
        "author_association": "MEMBER",
        "body": "@rjzamora maybe you got some insights here?",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1733802081/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1733955061",
        "html_url": "https://github.com/dask/dask/issues/10518#issuecomment-1733955061",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10518",
        "id": 1733955061,
        "node_id": "IC_kwDOAbcwm85nWg31",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-09-25T15:28:21Z",
        "updated_at": "2023-09-25T15:28:21Z",
        "author_association": "MEMBER",
        "body": ">In the reference you provided above to culling, one of the first lines of that function is to call get_all_external_keys, which is what triggers the materialization of the overlap layer...  I'm having some difficulty understanding exactly why an individual layer needs the entire graph's external keys in order to cull its own dependencies\r\n\r\nYou have a good eye @BrandonSmithJ - The call to `get_all_external_keys` was meant to be a \"temporary\" thing when we first started shipping `HighLevelGraph` objects from client to scheduler. Before that, we were always culling a fully-materialized graph anyway, so the optimization was written in a way that assumed you could always check if a particular string or tuple was also a key in the graph.  The \"real\" problem came when this assumption began to leak into critical areas of the HLG serialization code.  For example, while \"stringifying\" both input and output keys during the serialization of a specific `Layer`, we would often use the set of all known external keys to tell us *which* tuple objects are actually keys.\r\n\r\nYou are absolutely correct that there is no fundamental reason that we need `get_all_external_keys`. In fact, now that the graph is usually **not** fully materialized when culling is performed, it is quite silly that we are still doing this. After materialization, the scheduler **does** need a full dependency graph for all keys in the optimized graph, but this certainly shouldn't require us to know all possible keys **before** optimization.\r\n\r\nBoth myself and others have proposed changes to this in the past (e.g. https://github.com/dask/dask/issues/9216). However, slightly more-visible problems, like [`HighLevelGraph` serialization](https://github.com/dask/distributed/pull/7564) and [key \"stringification\"](https://github.com/dask/distributed/pull/8083), have always tended to block/delay its prioritization.  The good news is that these other priorities are mostly out of the way now, so it is probably a good time to discuss a path forward (even if `HighLevelGraph` design is ultimately replaced with an expression system).\r\n\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1733955061/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1735828695",
        "html_url": "https://github.com/dask/dask/issues/10518#issuecomment-1735828695",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10518",
        "id": 1735828695,
        "node_id": "IC_kwDOAbcwm85ndqTX",
        "user": {
            "login": "BrandonSmithJ",
            "id": 1062829,
            "node_id": "MDQ6VXNlcjEwNjI4Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1062829?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/BrandonSmithJ",
            "html_url": "https://github.com/BrandonSmithJ",
            "followers_url": "https://api.github.com/users/BrandonSmithJ/followers",
            "following_url": "https://api.github.com/users/BrandonSmithJ/following{/other_user}",
            "gists_url": "https://api.github.com/users/BrandonSmithJ/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/BrandonSmithJ/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/BrandonSmithJ/subscriptions",
            "organizations_url": "https://api.github.com/users/BrandonSmithJ/orgs",
            "repos_url": "https://api.github.com/users/BrandonSmithJ/repos",
            "events_url": "https://api.github.com/users/BrandonSmithJ/events{/privacy}",
            "received_events_url": "https://api.github.com/users/BrandonSmithJ/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-09-26T15:54:11Z",
        "updated_at": "2023-09-26T15:54:11Z",
        "author_association": "NONE",
        "body": "Thanks @rjzamora! The historical usage of it makes sense, and I think that does solidify my understanding on things. \r\n\r\nI cleaned up my patch a bit and created a pull request (#10534) that addresses this issue, and seems to pass all tests (locally, at least). So it appears this might offer a generalized significant improvement in speed when a user is only computing parts of the overall graph. \r\n\r\nHappy to discuss this further - whether it's any other small modifications that should be made, or if the change can't be incorporated for whatever reason.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1735828695/reactions",
            "total_count": 1,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 1,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]