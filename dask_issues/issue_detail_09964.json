{
    "url": "https://api.github.com/repos/dask/dask/issues/9964",
    "repository_url": "https://api.github.com/repos/dask/dask",
    "labels_url": "https://api.github.com/repos/dask/dask/issues/9964/labels{/name}",
    "comments_url": "https://api.github.com/repos/dask/dask/issues/9964/comments",
    "events_url": "https://api.github.com/repos/dask/dask/issues/9964/events",
    "html_url": "https://github.com/dask/dask/issues/9964",
    "id": 1585853083,
    "node_id": "I_kwDOAbcwm85ehjKb",
    "number": 9964,
    "title": "Key collision in dask graph",
    "user": {
        "login": "jochenott",
        "id": 13297654,
        "node_id": "MDQ6VXNlcjEzMjk3NjU0",
        "avatar_url": "https://avatars.githubusercontent.com/u/13297654?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jochenott",
        "html_url": "https://github.com/jochenott",
        "followers_url": "https://api.github.com/users/jochenott/followers",
        "following_url": "https://api.github.com/users/jochenott/following{/other_user}",
        "gists_url": "https://api.github.com/users/jochenott/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/jochenott/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/jochenott/subscriptions",
        "organizations_url": "https://api.github.com/users/jochenott/orgs",
        "repos_url": "https://api.github.com/users/jochenott/repos",
        "events_url": "https://api.github.com/users/jochenott/events{/privacy}",
        "received_events_url": "https://api.github.com/users/jochenott/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 1342304743,
            "node_id": "MDU6TGFiZWwxMzQyMzA0NzQz",
            "url": "https://api.github.com/repos/dask/dask/labels/core",
            "name": "core",
            "color": "000000",
            "default": false,
            "description": ""
        },
        {
            "id": 3468123446,
            "node_id": "LA_kwDOAbcwm87Ot102",
            "url": "https://api.github.com/repos/dask/dask/labels/needs%20attention",
            "name": "needs attention",
            "color": "6d626c",
            "default": false,
            "description": "It's been a while since this was pushed on. Needs attention from the owner or a maintainer."
        },
        {
            "id": 3798450413,
            "node_id": "LA_kwDOAbcwm87iZ8Dt",
            "url": "https://api.github.com/repos/dask/dask/labels/bug",
            "name": "bug",
            "color": "faadaf",
            "default": true,
            "description": "Something is broken"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2023-02-15T13:21:36Z",
    "updated_at": "2024-03-11T01:44:56Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "<!-- Please include a self-contained copy-pastable example that generates the issue if possible.\r\n\r\nPlease be concise with code posted. See guidelines below on how to provide a good bug report:\r\n\r\n- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports\r\n- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve\r\n\r\nBug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.\r\n-->\r\n\r\nWhen building many similar dask graphs that have the same structure, just different input data, it can happen that the default dask optimizations create keys for the dask graph dictionary that are the same for different input data. In essence, this is a hash collision, which (by default) has a relatively large probability.\r\n\r\n\r\n\r\n```python\r\nimport dask.config\r\nfrom dask import delayed\r\nfrom dask.base import collections_to_dsk\r\nfrom dask.bag import from_sequence\r\n\r\n\r\n@delayed\r\ndef first_function_with_a_long_name_that_just_returns_its_argument(arg):\r\n    return arg\r\n\r\n\r\n@delayed\r\ndef second_function_with_a_long_name_that_just_returns_its_argument(arg):\r\n    return arg\r\n\r\n\r\n@delayed\r\ndef third_function_with_a_long_name_that_just_returns_its_argument(arg):\r\n    return arg\r\n\r\n\r\n# see comments below\r\n# dask.config.set({\"optimization.fuse.rename-keys\": False})\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    all_dsk_keys = set()\r\n\r\n    for i in range(1_000):\r\n        print(i)\r\n        d = (\r\n            from_sequence([i])\r\n            .map(third_function_with_a_long_name_that_just_returns_its_argument)\r\n            .map(second_function_with_a_long_name_that_just_returns_its_argument)\r\n            .map(first_function_with_a_long_name_that_just_returns_its_argument)\r\n        )\r\n        dsk = collections_to_dsk([d])\r\n        dsk_keys = set(dsk)\r\n        colliding_keys = all_dsk_keys & dsk_keys\r\n        assert not colliding_keys, f\"Key collision: {colliding_keys}\"\r\n        all_dsk_keys.update(dsk_keys)\r\n```\r\n\r\nthis shows assertion errors like this:\r\n\r\n```\r\n...\r\n155\r\n156\r\nTraceback (most recent call last):\r\n  File \"dask-hash-collision.py\", line 42, in <module>\r\n    assert not colliding_keys, f\"Key collision: {colliding_keys}\"\r\nAssertionError: Key collision: {('second_function_with_a_long_name_that_just_returns-third_function_with_a_long_name_that_just_returns_-first_functio--208', 0)}\r\n```\r\n\r\nThe source of the issue is the default for \"rename-keys\", which truncates the hash part to only 4 hex characters in case the fused key name becomes too long:\r\nhttps://github.com/dask/dask/blob/0890b96be75e46ef2b88c11015761b9a6bd32480/dask/optimization.py#L416\r\nUsing only 4 hex characters of hash makes hash collisions pretty common; it is often enough to use a few dozen graphs.\r\n\r\nUsing the commented-out line `dask.config.set` above works around the issue. Still, I think the default behavior should be fixed, as it makes this issue too likely.\r\n\r\nWe do observe such key collisions in real-world scenarios in distributed, where we would get the wrong result on client side since the scheduler hands out old results of the key that the new computation collided with.\r\n\r\nSide note: using `default_fused_linear_keys_renamer` as \"optimization.fuse.rename-keys\" creates other key collision issues. It seems the `default_fused_linear_keys_renamer` and the `default_fused_key_renamer` have incompatible assumptions about the order of keys in their `keys` argument.\r\n\r\n**Environment**:\r\n\r\n- Dask version: 2023.2.0\r\n- Python version: 3.8\r\n- Operating System: linux (debian)\r\n- Install method (conda, pip, source): pip\r\n",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/dask/dask/issues/9964/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/dask/dask/issues/9964/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}