[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/564887748",
        "html_url": "https://github.com/dask/dask/issues/5644#issuecomment-564887748",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5644",
        "id": 564887748,
        "node_id": "MDEyOklzc3VlQ29tbWVudDU2NDg4Nzc0OA==",
        "user": {
            "login": "simone-codeluppi",
            "id": 861501,
            "node_id": "MDQ6VXNlcjg2MTUwMQ==",
            "avatar_url": "https://avatars.githubusercontent.com/u/861501?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/simone-codeluppi",
            "html_url": "https://github.com/simone-codeluppi",
            "followers_url": "https://api.github.com/users/simone-codeluppi/followers",
            "following_url": "https://api.github.com/users/simone-codeluppi/following{/other_user}",
            "gists_url": "https://api.github.com/users/simone-codeluppi/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/simone-codeluppi/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/simone-codeluppi/subscriptions",
            "organizations_url": "https://api.github.com/users/simone-codeluppi/orgs",
            "repos_url": "https://api.github.com/users/simone-codeluppi/repos",
            "events_url": "https://api.github.com/users/simone-codeluppi/events{/privacy}",
            "received_events_url": "https://api.github.com/users/simone-codeluppi/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2019-12-12T07:37:58Z",
        "updated_at": "2019-12-12T07:37:58Z",
        "author_association": "NONE",
        "body": "So if I understand correctly the `dask.optimization` utilities do not currently works on HighLevelGraphs, correct? I am curious because I would like to fuse some tasks in parallel branches of my processing graph generated using delayed functions to make sure that all the step in a branch will run on the same worker/node.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/564887748/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/564986499",
        "html_url": "https://github.com/dask/dask/issues/5644#issuecomment-564986499",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5644",
        "id": 564986499,
        "node_id": "MDEyOklzc3VlQ29tbWVudDU2NDk4NjQ5OQ==",
        "user": {
            "login": "TomAugspurger",
            "id": 1312546,
            "node_id": "MDQ6VXNlcjEzMTI1NDY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1312546?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/TomAugspurger",
            "html_url": "https://github.com/TomAugspurger",
            "followers_url": "https://api.github.com/users/TomAugspurger/followers",
            "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
            "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
            "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
            "repos_url": "https://api.github.com/users/TomAugspurger/repos",
            "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
            "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2019-12-12T12:27:12Z",
        "updated_at": "2019-12-12T12:27:12Z",
        "author_association": "MEMBER",
        "body": "> dask.optimization utilities do not currently works on HighLevelGraphs, correct?\r\n\r\nNo, they do. See https://github.com/dask/dask/blob/1c39d48b452d857418c854008932fdac2608e121/dask/array/optimization.py#L40-L43 for example.\r\n\r\n> I would like to fuse some tasks in parallel branches of my processing graph generated using delayed functions \r\n\r\nI'm not sure if this is likely to get fused. HighLevelGraphs rely on the structure provided by Dask's collections, and `dask.delayed` has less structure. But it's worth trying out.\r\n\r\nKeep in mind that Dask's low-level fusion in https://github.com/dask/dask/blob/1c39d48b452d857418c854008932fdac2608e121/dask/optimization.py#L401-L411 may also kick in.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/564986499/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/565100315",
        "html_url": "https://github.com/dask/dask/issues/5644#issuecomment-565100315",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5644",
        "id": 565100315,
        "node_id": "MDEyOklzc3VlQ29tbWVudDU2NTEwMDMxNQ==",
        "user": {
            "login": "TomAugspurger",
            "id": 1312546,
            "node_id": "MDQ6VXNlcjEzMTI1NDY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1312546?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/TomAugspurger",
            "html_url": "https://github.com/TomAugspurger",
            "followers_url": "https://api.github.com/users/TomAugspurger/followers",
            "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
            "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
            "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
            "repos_url": "https://api.github.com/users/TomAugspurger/repos",
            "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
            "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2019-12-12T17:16:06Z",
        "updated_at": "2019-12-12T17:16:06Z",
        "author_association": "MEMBER",
        "body": "A slightly more specific optimization is pushing down binary operations and masking on DataFrames read from parquet files into the `filters` argument.\r\n\r\n```python\r\n>>> df = dd.read_parquet(\"data.parquet\")\r\n>>> df[df.A > 1] \r\n```\r\n\r\nWould become something like\r\n\r\n```python\r\n>>> dd.read_parquet(\"data.parquet\", filters=[(\"A\",  \">\", 1\")])\r\n```\r\n\r\nThere are probably lots of complexity, but that might make a good first introduction to this (cc @eriknw)",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/565100315/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/615289591",
        "html_url": "https://github.com/dask/dask/issues/5644#issuecomment-615289591",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5644",
        "id": 615289591,
        "node_id": "MDEyOklzc3VlQ29tbWVudDYxNTI4OTU5MQ==",
        "user": {
            "login": "chenliu0831",
            "id": 1504463,
            "node_id": "MDQ6VXNlcjE1MDQ0NjM=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1504463?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/chenliu0831",
            "html_url": "https://github.com/chenliu0831",
            "followers_url": "https://api.github.com/users/chenliu0831/followers",
            "following_url": "https://api.github.com/users/chenliu0831/following{/other_user}",
            "gists_url": "https://api.github.com/users/chenliu0831/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/chenliu0831/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/chenliu0831/subscriptions",
            "organizations_url": "https://api.github.com/users/chenliu0831/orgs",
            "repos_url": "https://api.github.com/users/chenliu0831/repos",
            "events_url": "https://api.github.com/users/chenliu0831/events{/privacy}",
            "received_events_url": "https://api.github.com/users/chenliu0831/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-04-17T14:53:15Z",
        "updated_at": "2020-04-17T14:53:15Z",
        "author_association": "NONE",
        "body": "Just curious and a quick imagination, does it make sense to compile the graph to some IR in the compiler world and leverage LLVM or other compiler technologies to handle graph optimizations (like convert the graph to SSA form)?",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/615289591/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/639079235",
        "html_url": "https://github.com/dask/dask/issues/5644#issuecomment-639079235",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5644",
        "id": 639079235,
        "node_id": "MDEyOklzc3VlQ29tbWVudDYzOTA3OTIzNQ==",
        "user": {
            "login": "jcrist",
            "id": 2783717,
            "node_id": "MDQ6VXNlcjI3ODM3MTc=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2783717?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jcrist",
            "html_url": "https://github.com/jcrist",
            "followers_url": "https://api.github.com/users/jcrist/followers",
            "following_url": "https://api.github.com/users/jcrist/following{/other_user}",
            "gists_url": "https://api.github.com/users/jcrist/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jcrist/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jcrist/subscriptions",
            "organizations_url": "https://api.github.com/users/jcrist/orgs",
            "repos_url": "https://api.github.com/users/jcrist/repos",
            "events_url": "https://api.github.com/users/jcrist/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jcrist/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-06-04T19:49:51Z",
        "updated_at": "2020-06-04T19:49:51Z",
        "author_association": "MEMBER",
        "body": "> Just curious and a quick imagination, does it make sense to compile the graph to some IR in the compiler world and leverage LLVM or other compiler technologies to handle graph optimizations (like convert the graph to SSA form)?\r\n\r\nNot really, compiler IR is generally lower level than what we describe in dask graphs, the transformations we want to do and the transformations compilers want to do are sufficiently different that we'd get no benefit (AFAICT) from doing so.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/639079235/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/639089674",
        "html_url": "https://github.com/dask/dask/issues/5644#issuecomment-639089674",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5644",
        "id": 639089674,
        "node_id": "MDEyOklzc3VlQ29tbWVudDYzOTA4OTY3NA==",
        "user": {
            "login": "jcrist",
            "id": 2783717,
            "node_id": "MDQ6VXNlcjI3ODM3MTc=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2783717?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jcrist",
            "html_url": "https://github.com/jcrist",
            "followers_url": "https://api.github.com/users/jcrist/followers",
            "following_url": "https://api.github.com/users/jcrist/following{/other_user}",
            "gists_url": "https://api.github.com/users/jcrist/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jcrist/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jcrist/subscriptions",
            "organizations_url": "https://api.github.com/users/jcrist/orgs",
            "repos_url": "https://api.github.com/users/jcrist/repos",
            "events_url": "https://api.github.com/users/jcrist/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jcrist/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-06-04T20:09:43Z",
        "updated_at": "2020-06-04T20:09:43Z",
        "author_association": "MEMBER",
        "body": "Was just helping @jsignell debug an issue that had to do with our optimization passes, and the best solution I could come up with is some change in how we manage collection-specific optimizations.\r\n\r\nCurrently, different collections have different `__dask_optimize__` methods with the following signature:\r\n\r\n```python\r\ndef __dask_optimize__(self, dsk: Mapping, keys: Iterable, **kwargs) -> dict:\r\n    ...\r\n```\r\n\r\nDepending on the call path `dsk` may be either a `HighLevelGraph` or a `dict`. If provided a `HighLevelGraph`, these may do some high-level optimizations, before lowering to a `dict` based graph and doing things like `cull` and `fuse`. See the one for `dask.dataframe` for example:\r\n\r\nhttps://github.com/dask/dask/blob/8eeb0e0194ef0561b4202f42de06c0b7fc0784b9/dask/dataframe/optimize.py#L12-L35\r\n\r\nWhen converting between collections `A` to `B` we usually (but not always) call the optimization function of `A` on the graph to ensure that its optimizations are run, since `B` will no longer track those optimizations.\r\n\r\nThis can cause issues, especially if `fuse` is enabled. For example, say we have 2 `dask.dataframe` objects that share some upstream graph structure:\r\n\r\n```\r\ndf1, df2 = some_shared_upstream_task()\r\na = df1.to_delayed()\r\nb = df2.to_delayed()\r\n```\r\n\r\nIf fusion is enabled, there is a risk that the call to `__dask_optimize__` inside `to_delayed` will fuse out the shared upstream tasks, resulting in duplicated work (see #6232).\r\n\r\nA few possible solutions:\r\n\r\n1. Since many collections share the same low-level graph optimizations - `cull`, and `fuse` - we may only need the high-level optimizations to be class-specific. This currently isn't 100% true - `dask.bag` has some class-specific optimization passes that are implemented on the low-level graphs, but with some work we may be able to change that around. Then `__dask_optimize__` would map `HighLevelGraph -> HighLevelGraph`, and there'd be a consistent low-level optimization pipeline on the merged graph handling the `cull`, `fuse`, etc...\r\n\r\n2. We might instead associate optimization functions with layers in the `HighLevelGraph` instead of with collections. Then the optimizations wouldn't need to run on conversion between collection types, the backing layers could be merged and optimized on compute. I suspect this would be harder to implement than option 1, but may solve some cases not solved that solution.\r\n\r\nThere also might be a simpler thing I didn't think of, a bit in the weeds here.\r\n\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/639089674/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/640729388",
        "html_url": "https://github.com/dask/dask/issues/5644#issuecomment-640729388",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5644",
        "id": 640729388,
        "node_id": "MDEyOklzc3VlQ29tbWVudDY0MDcyOTM4OA==",
        "user": {
            "login": "jsignell",
            "id": 4806877,
            "node_id": "MDQ6VXNlcjQ4MDY4Nzc=",
            "avatar_url": "https://avatars.githubusercontent.com/u/4806877?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jsignell",
            "html_url": "https://github.com/jsignell",
            "followers_url": "https://api.github.com/users/jsignell/followers",
            "following_url": "https://api.github.com/users/jsignell/following{/other_user}",
            "gists_url": "https://api.github.com/users/jsignell/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jsignell/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jsignell/subscriptions",
            "organizations_url": "https://api.github.com/users/jsignell/orgs",
            "repos_url": "https://api.github.com/users/jsignell/repos",
            "events_url": "https://api.github.com/users/jsignell/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jsignell/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-06-08T16:17:13Z",
        "updated_at": "2020-06-08T16:17:13Z",
        "author_association": "MEMBER",
        "body": "Thanks for writing that up Jim. I think option 1 sounds more straightforward and would avoid adding more information to the `HighLevelGraph` object (something that I am newly wary of bloating). ",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/640729388/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/642865368",
        "html_url": "https://github.com/dask/dask/issues/5644#issuecomment-642865368",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5644",
        "id": 642865368,
        "node_id": "MDEyOklzc3VlQ29tbWVudDY0Mjg2NTM2OA==",
        "user": {
            "login": "TomAugspurger",
            "id": 1312546,
            "node_id": "MDQ6VXNlcjEzMTI1NDY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1312546?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/TomAugspurger",
            "html_url": "https://github.com/TomAugspurger",
            "followers_url": "https://api.github.com/users/TomAugspurger/followers",
            "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
            "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
            "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
            "repos_url": "https://api.github.com/users/TomAugspurger/repos",
            "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
            "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-06-11T18:47:59Z",
        "updated_at": "2020-06-11T18:47:59Z",
        "author_association": "MEMBER",
        "body": "In https://github.com/dask/dask/pull/6262 @gforsyth added a CSVSubgraph, which makes the structure of `read_csv` similar to `read_parquet`. We'll now be able to implement an optimization similar to `optimize_read_parquet_getitem`, but for `read_csv` instead. Finding the patterns that can be shared between the two optimizations will be an interesting exercise.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/642865368/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/642932343",
        "html_url": "https://github.com/dask/dask/issues/5644#issuecomment-642932343",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5644",
        "id": 642932343,
        "node_id": "MDEyOklzc3VlQ29tbWVudDY0MjkzMjM0Mw==",
        "user": {
            "login": "mrocklin",
            "id": 306380,
            "node_id": "MDQ6VXNlcjMwNjM4MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/306380?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mrocklin",
            "html_url": "https://github.com/mrocklin",
            "followers_url": "https://api.github.com/users/mrocklin/followers",
            "following_url": "https://api.github.com/users/mrocklin/following{/other_user}",
            "gists_url": "https://api.github.com/users/mrocklin/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mrocklin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mrocklin/subscriptions",
            "organizations_url": "https://api.github.com/users/mrocklin/orgs",
            "repos_url": "https://api.github.com/users/mrocklin/repos",
            "events_url": "https://api.github.com/users/mrocklin/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mrocklin/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-06-11T21:17:11Z",
        "updated_at": "2020-06-11T21:17:11Z",
        "author_association": "MEMBER",
        "body": "> Finding the patterns that can be shared between the two optimizations\nwill be an interesting exercise.\n\n+1\n\n\nOn Thu, Jun 11, 2020 at 11:48 AM Tom Augspurger <notifications@github.com>\nwrote:\n\n> In #6262 <https://github.com/dask/dask/pull/6262> @gforsyth\n> <https://github.com/gforsyth> added a CSVSubgraph, which makes the\n> structure of read_csv similar to read_parquet. We'll now be able to\n> implement an optimization similar to optimize_read_parquet_getitem, but\n> for read_csv instead. Finding the patterns that can be shared between the\n> two optimizations will be an interesting exercise.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dask/dask/issues/5644#issuecomment-642865368>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AACKZTCXZ3PQZKQ3H2YVGHDRWERG5ANCNFSM4JR2TPPA>\n> .\n>\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/642932343/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/798937636",
        "html_url": "https://github.com/dask/dask/issues/5644#issuecomment-798937636",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5644",
        "id": 798937636,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc5ODkzNzYzNg==",
        "user": {
            "login": "nils-braun",
            "id": 6116188,
            "node_id": "MDQ6VXNlcjYxMTYxODg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6116188?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/nils-braun",
            "html_url": "https://github.com/nils-braun",
            "followers_url": "https://api.github.com/users/nils-braun/followers",
            "following_url": "https://api.github.com/users/nils-braun/following{/other_user}",
            "gists_url": "https://api.github.com/users/nils-braun/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/nils-braun/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/nils-braun/subscriptions",
            "organizations_url": "https://api.github.com/users/nils-braun/orgs",
            "repos_url": "https://api.github.com/users/nils-braun/repos",
            "events_url": "https://api.github.com/users/nils-braun/events{/privacy}",
            "received_events_url": "https://api.github.com/users/nils-braun/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-03-14T16:35:34Z",
        "updated_at": "2021-03-14T16:36:01Z",
        "author_association": "CONTRIBUTOR",
        "body": "Recently, @beckernick brought my attention to https://github.com/IntelPython/sdc (in https://github.com/nils-braun/dask-sql/issues/143). This project offers numba optimizations for pandas operations. In my very naive world I would think this (and numba itself) can be used on fused subgraphs to compile the code before distributing it to the workers (so compile it once and run it multiple times) - similar to what @jcrist started in https://github.com/dask/dask/pull/4091 as a first draft (but for all sorts of fused subgraphs). \r\n\r\nI know that this is so far only a very rough draft, but I would imagine it to work similarly to this:\r\n1. While building the highlevel graph using some collection type, like dataframes, we already know the type information due to the _meta. We can store this \"somehow\" (with annotations https://github.com/dask/dask/issues/3783?) in the individual tasks or layers (currently, this is \"lost\" when moving from collections to graphs - or?). This would mean not every task will get a _meta annotation (as we only know the _meta of collections), but at least a few of them. \r\n2. When fusing subgraphs, we use the type annotations from the inputs (if we have it) and create a pre-compiled version of the subgraph function. This can replace the original function in the graph.\r\n3. The compiled function can (hopefully) be executed on the workers using the real inputs. We can always fall back to the non-compiled version, e.g. if the meta type information was wrong.\r\n\r\nI do not have any feeling if the compilation overhead (and implementation work!) is worth the gains, but I just know that many other distributed engines (Spark, Impala, ...) use code generation (so there must be at least anything to gain here...). \r\n\r\nBefore one would go into more details on this, there are a couple of questions to answer:\r\n* is the _meta information enough to pre-compile the fused function?\r\n* how to properly preserve the meta information from the collection to the dask graph during rewriting, optimization, etc.? where should this happen?\r\n* was this already tried (apart from https://github.com/dask/dask/pull/4091)? Or was it deemed infeasible already? (sorry if I just have not found it)\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/798937636/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]