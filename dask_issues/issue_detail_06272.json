{
    "url": "https://api.github.com/repos/dask/dask/issues/6272",
    "repository_url": "https://api.github.com/repos/dask/dask",
    "labels_url": "https://api.github.com/repos/dask/dask/issues/6272/labels{/name}",
    "comments_url": "https://api.github.com/repos/dask/dask/issues/6272/comments",
    "events_url": "https://api.github.com/repos/dask/dask/issues/6272/events",
    "html_url": "https://github.com/dask/dask/issues/6272",
    "id": 628534264,
    "node_id": "MDU6SXNzdWU2Mjg1MzQyNjQ=",
    "number": 6272,
    "title": "Expose intermediate rechunking logic da.reshape",
    "user": {
        "login": "TomAugspurger",
        "id": 1312546,
        "node_id": "MDQ6VXNlcjEzMTI1NDY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1312546?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TomAugspurger",
        "html_url": "https://github.com/TomAugspurger",
        "followers_url": "https://api.github.com/users/TomAugspurger/followers",
        "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
        "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
        "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
        "repos_url": "https://api.github.com/users/TomAugspurger/repos",
        "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
        "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 242862305,
            "node_id": "MDU6TGFiZWwyNDI4NjIzMDU=",
            "url": "https://api.github.com/repos/dask/dask/labels/array",
            "name": "array",
            "color": "006b75",
            "default": false,
            "description": null
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2020-06-01T15:33:53Z",
    "updated_at": "2020-06-29T11:32:47Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "`da.reshape` does some clever tricks to avoid making too large intermediate chunks. Sometimes, however, the user can do better, especially given downstream operations.\r\n\r\nIn this example, we \"read\", reshape, and slice. The nature of the final slice happens to select data from just a single original chunk. But by default there's an intermediate `rechunk-merge` of two original chunks.\r\n\r\n```python\r\n# a has 4 chunks\r\nx = np.arange(2 * 2 * 5).reshape((2, 2, 5))\r\na = da.from_array(x, chunks=(1, 1, 5))\r\na_reshaped = a.reshape((4, 5))\r\n```\r\n\r\n\r\n```python\r\na_reshaped[0].visualize(filename=\"default\", optimize_graph=True)\r\n```\r\n\r\n![default](https://user-images.githubusercontent.com/1312546/83425082-f1a8b500-a3f2-11ea-99ea-a55eb4bd6e23.png)\r\n\r\n\r\nIf the user could specify the intermediate and output chunks, then they can get the desired chunking\r\n\r\n```python\r\na_reshaped = a.reshape((2*2, 5),\r\n                       inchunks=((1, 1), (1, 1), (5,)),\r\n                       outchunks=((1, 1, 1, 1), (5,)))\r\n```\r\n\r\n```python\r\na_reshaped[0].visualize(filename=\"manual\", optimize_graph=True)\r\n```\r\n\r\n![manual](https://user-images.githubusercontent.com/1312546/83425141-0e44ed00-a3f3-11ea-9c99-64c88e8ebe8a.png)\r\n\r\nThe change itself is pretty small\r\n\r\n```diff\r\ndiff --git a/dask/array/core.py b/dask/array/core.py\r\nindex ef8970091..756b72bd5 100644\r\n--- a/dask/array/core.py\r\n+++ b/dask/array/core.py\r\n@@ -1742,12 +1742,12 @@ class Array(DaskMethodsMixin):\r\n         return choose(self, choices)\r\n \r\n     @derived_from(np.ndarray)\r\n-    def reshape(self, *shape):\r\n+    def reshape(self, *shape, inchunks=None, outchunks=None):\r\n         from .reshape import reshape\r\n \r\n         if len(shape) == 1 and not isinstance(shape[0], Number):\r\n             shape = shape[0]\r\n-        return reshape(self, shape)\r\n+        return reshape(self, shape, inchunks=inchunks, outchunks=outchunks)\r\n \r\n     def topk(self, k, axis=-1, split_every=None):\r\n         \"\"\"The top k elements of an array.\r\ndiff --git a/dask/array/reshape.py b/dask/array/reshape.py\r\nindex 85b5ca33c..e00a0a191 100644\r\n--- a/dask/array/reshape.py\r\n+++ b/dask/array/reshape.py\r\n@@ -133,7 +133,7 @@ def contract_tuple(chunks, factor):\r\n     return tuple(out)\r\n \r\n \r\n-def reshape(x, shape):\r\n+def reshape(x, shape, inchunks=None, outchunks=None):\r\n     \"\"\" Reshape array to new shape\r\n \r\n     This is a parallelized version of the ``np.reshape`` function with the\r\n@@ -145,6 +145,23 @@ def reshape(x, shape):\r\n \r\n     .. _`row-major order`: https://en.wikipedia.org/wiki/Row-_and_column-major_order\r\n \r\n+    Parameters\r\n+    ----------\r\n+    shape : tuple\r\n+        The new shape should be compatible with the original shape and should satisfy\r\n+        Dask's additional restrictions. If\r\n+        an integer, then the result will be a 1-D array of that length.\r\n+        One shape dimension can be -1. In this case, the value is\r\n+        inferred from the length of the array and remaining dimensions.\r\n+    inchunks : tuple, optional\r\n+        The chunks to use for an intermediate re-chunked array. By default, the array\r\n+        is rechunked to keep roughly the same chunk sizes.\r\n+    outchunks : tuple, optional\r\n+        The chunks to use for the output array.\r\n+\r\n+    Notes\r\n+    -----\r\n+\r\n     When communication is necessary this algorithm depends on the logic within\r\n     rechunk.  It endeavors to keep chunk sizes roughly the same when possible.\r\n \r\n@@ -192,7 +209,12 @@ def reshape(x, shape):\r\n         return Array(graph, name, chunks, meta=meta)\r\n \r\n     # Logic for how to rechunk\r\n-    inchunks, outchunks = reshape_rechunk(x.shape, shape, x.chunks)\r\n+    if inchunks is None and outchunks is None:\r\n+        inchunks2, outchunks2 = reshape_rechunk(x.shape, shape, x.chunks)\r\n+        if inchunks is None:\r\n+            inchunks = inchunks2\r\n+        if outchunks is None:\r\n+            outchunks = outchunks2\r\n     x2 = x.rechunk(inchunks)\r\n \r\n     # Construct graph\r\n```\r\n\r\nThe primary argument against is perhaps that this perhaps something Dask should be doing automatically. I'm not sure how feasible detecting this optimization is though.\r\n\r\nThis is a workaround that might be solved properly by https://github.com/dask/dask/issues/5544.",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/dask/dask/issues/6272/reactions",
        "total_count": 1,
        "+1": 1,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/dask/dask/issues/6272/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}