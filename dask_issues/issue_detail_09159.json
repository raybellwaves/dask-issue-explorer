{
    "url": "https://api.github.com/repos/dask/dask/issues/9159",
    "repository_url": "https://api.github.com/repos/dask/dask",
    "labels_url": "https://api.github.com/repos/dask/dask/issues/9159/labels{/name}",
    "comments_url": "https://api.github.com/repos/dask/dask/issues/9159/comments",
    "events_url": "https://api.github.com/repos/dask/dask/issues/9159/events",
    "html_url": "https://github.com/dask/dask/issues/9159",
    "id": 1258509309,
    "node_id": "I_kwDOAbcwm85LA1P9",
    "number": 9159,
    "title": "[Discussion] HighLevelGraph Development Roadmap",
    "user": {
        "login": "rjzamora",
        "id": 20461013,
        "node_id": "MDQ6VXNlcjIwNDYxMDEz",
        "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rjzamora",
        "html_url": "https://github.com/rjzamora",
        "followers_url": "https://api.github.com/users/rjzamora/followers",
        "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
        "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
        "organizations_url": "https://api.github.com/users/rjzamora/orgs",
        "repos_url": "https://api.github.com/users/rjzamora/repos",
        "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
        "received_events_url": "https://api.github.com/users/rjzamora/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 2156573524,
            "node_id": "MDU6TGFiZWwyMTU2NTczNTI0",
            "url": "https://api.github.com/repos/dask/dask/labels/highlevelgraph",
            "name": "highlevelgraph",
            "color": "8c24d6",
            "default": false,
            "description": "Issues relating to HighLevelGraphs."
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 3,
    "created_at": "2022-06-02T17:52:29Z",
    "updated_at": "2022-08-30T03:09:05Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "`HighLevelGraph`s (HLGs) are discussed in many places throughout Dask\u2019s GitHub organization, but there is no single place with an up-to-date status and outlook.  This issue should be modified if/when the HLG roadmap changes.\r\n\r\n**Last Update**: 2022/08/29\r\n\r\n## Current status\r\n\r\n`HighlevelGraph` development is currently \u201cfrozen\u201d.\r\n\r\nThe ongoing development of new `highlevelgraph.Layer` classes and/or `HighlevelGraph` optimizations is strongly discouraged. Bug fixes are obviously fine, but expansion of the existing system should be avoided. Dask users and down-stream developers should avoid interactive with `Layer` classes directly.  The motivation for the current development freeze is the fact that there is a consensus that (1) the current design of HLGs is not sufficient for effective graph optimizations, and that (2) HLG Layers are too complicated to implement. \r\n\r\n### Reasons for current pain\r\n\r\n- HLG serialization is convoluted and buggy\r\n- The current API design makes it difficult to implement an effective `Layer` class. For example, it can be challenging to implement `cull` without materializing the subgraph\r\n- The current collection/HighLevelGraph/Layer hierarchy makes it nearly impossible to perform general optimizations. Some important optimizations that are missing or significantly limited:\r\n  - Dask does not track **partition metadata** (like Parquet statistics) to optimize simple queries like `len`, `min`, and `max`.\r\n  - Dask does not support automatic **predicate pushdown** (i.e. Dask will not detect filter operations in the task graph, and use them to re-write IO Layers with `filters=`).\r\n  - Dask does not support automatic **column projection** when the implicit or explicit selection and IO operation are separated by non-trivial operations like merge, shuffle and/or groupby. This limitation often requires the user to explicitly define `read_parquet(..., columns=...)` to reduce memory pressure.\r\n\r\n\r\n## Roadmap\r\n\r\n### 1 - Address HLG-serialization\r\n\r\n**Relevant PRs**:\r\n\r\n- https://github.com/dask/distributed/pull/6028\r\n- https://github.com/dask/dask/pull/8864\r\n\r\nSerialization for client-scheduler communication has been a consistent challenge since the introduction of `highlevelgraph.Layer`. Most of this pain can be resolved by adopting Pickle for HLG serialization.\r\n\r\nThe current plan is to move forward with distributed#6028 and dask#8864, which proposes that we **always** use pickle to send the HLG from the client to scheduler, and therefore remove the problematic `__dask_distributed_pack__` protocol from `HighLevelGraph`/`Layer`.\r\n\r\n\r\n### 2 - Explore alternate designs for current collection/HLG/Layer API\r\n\r\nEven if serialization challenges are addressed by 6028 (and follow-up work), the current collection/HLG/Layer hierarchy and HLG/Layer design will still pose a serious problem for developers. Therefore we probably need to do one of the following:\r\n\r\n- **Option A** - Revise the `HighLevelGraph` and `Layer` classes to simplify the implementation of new `Layer` subclasses and to encapsulate the necessary information for high-level optimizations. This may require some refactoring of the collection APIs to move `meta`/`divisions`/`chunks` ownership into the HLG.\r\n- **Option B** - Redesign the collection APIs to use a high-level-expression (HLE) API instead of HLGs/Layers (see *original* HLE discussion in #7933). One possible variation on an HLE-like redesign is under active exploration (see #9117), but that work is still **very** far from reflecting a clear design proposal. In fact, the final outcome of that work **may** be a recommendation to go with option A.\r\n\r\nRegardless of the specific path we choose, it seems likely that we will want to manage graph-materialization logic and collection metadata in the same place.  Therefore, it may be difficult to avoid significant changes to the DataFrame and Array APIs.\r\n\r\n\r\n#### Possible \"Option A\" Poposal \r\n\r\n**Step 1: Simplify the Layer and HLG-culling APIs** (See: https://github.com/dask/dask/issues/9216)\r\n\r\n- Remove `Mapping` base to simplify culling and make \"accidental\" Layer materialization highly unlikely.\r\n  - The \"new\" Layer should only be materialized by an explicit method (like `Layer.subgraph(keys)`), which should include implicit culling.\r\n- Remove boiler-plate code related to `Mapping` behavior (`keys()`, `__len__`, etc..)\r\n- Remove `Layer.cull` and `HighLevelGraph.cull`.\r\n- **Outcome**: Layer design and maintenance becomes significantly simpler. HLG-based optimizations (besides culling) are not addressed in any way.\r\n\r\n**Step 2: Revise HighLevelGraph/Layer dependency tracking**\r\n\r\n- Extend the `Layer` API to track it's own collection dependencies.\r\n- Add an `output_layer` attribute to `HighLevelGraph`, and make this the primary \"state\" of an HLG\r\n  - `HighLevelGraph.layers` and `HighLevelGraph.dependencies` should simply refer to `HighLevelGraph.output_layer` \r\n- **Outcome**: `Layer` objects track direct *Layer* dependencies by tracking direct *collection* dependencies.\r\n\r\n**Step 3: Move collection metadata into Layer**\r\n\r\n- Move `name`, `meta`, and `divisions` management from the collection object to `Layer`\r\n  - It *may* be best to store and manage this metadata within a new `CollectionMetadata` class.  This may make it easier to modify/expand the kinds of metadata we track at the `Layer` level (e.g. partition statistics).\r\n- **Outcome**: The \"identity\" of a Dask collections becomes synonymous with the HLG's output layer\r\n\r\n**Step 4: Add regeneration mechanism to Layer**\r\n\r\n- Add `creation_info` attribute to `Layer`\r\n  - This attribute should specify the `func`, `args`, and `kwargs` needed to re-create the **collection** associated with the current `Layer`.\r\n  - `Layer` dependencies can be regenerated recursively\r\n\r\n**Step 5: Re-visit HLG optimizations**\r\n\r\n\r\n### 3 - Reach consensus on collection/HLG/Layer design\r\n\r\nAt some point in the medium-term future, it will be necessary to make a decision to pursue option A or option B. If there is no clear reference implementation and/or design document in place for option B, then I suggest we focus on option A (changing the existing HLG/Layer design).  The motivation for making A the \u201cdefault\u201d is an acknowledgment that attacking option B in an incremental way is likely to be more difficult without a detailed plan in place. \r\n\r\n### 4 - Develop *new* roadmap\r\n\r\nAt this point, the existing \u201croadmap\u201d should be obsolete, and ready for replacement.",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/dask/dask/issues/9159/reactions",
        "total_count": 2,
        "+1": 2,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/dask/dask/issues/9159/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}