{
    "url": "https://api.github.com/repos/dask/dask/issues/6410",
    "repository_url": "https://api.github.com/repos/dask/dask",
    "labels_url": "https://api.github.com/repos/dask/dask/issues/6410/labels{/name}",
    "comments_url": "https://api.github.com/repos/dask/dask/issues/6410/comments",
    "events_url": "https://api.github.com/repos/dask/dask/issues/6410/events",
    "html_url": "https://github.com/dask/dask/issues/6410",
    "id": 656461267,
    "node_id": "MDU6SXNzdWU2NTY0NjEyNjc=",
    "number": 6410,
    "title": "Documentation for custom Aggregation does not cover NA edge case",
    "user": {
        "login": "lucventurini",
        "id": 8897821,
        "node_id": "MDQ6VXNlcjg4OTc4MjE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8897821?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/lucventurini",
        "html_url": "https://github.com/lucventurini",
        "followers_url": "https://api.github.com/users/lucventurini/followers",
        "following_url": "https://api.github.com/users/lucventurini/following{/other_user}",
        "gists_url": "https://api.github.com/users/lucventurini/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/lucventurini/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/lucventurini/subscriptions",
        "organizations_url": "https://api.github.com/users/lucventurini/orgs",
        "repos_url": "https://api.github.com/users/lucventurini/repos",
        "events_url": "https://api.github.com/users/lucventurini/events{/privacy}",
        "received_events_url": "https://api.github.com/users/lucventurini/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 242862289,
            "node_id": "MDU6TGFiZWwyNDI4NjIyODk=",
            "url": "https://api.github.com/repos/dask/dask/labels/dataframe",
            "name": "dataframe",
            "color": "fbca04",
            "default": false,
            "description": null
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2020-07-14T09:15:49Z",
    "updated_at": "2021-10-13T05:53:12Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "Example on the Dask documentation:\r\n\r\n```\r\n>>> import itertools as it\r\n>>> collect_list = dd.Aggregation(\r\n...     name=\"collect_list\",\r\n...     chunk=lambda s: s.apply(list),\r\n...     agg=lambda s0: s0.apply(lambda chunks: list(it.chain.from_iterable(chunks))),\r\n... )\r\n>>> df.groupby('g').agg(collect_list)\r\n```\r\n\r\nHowever, if the dataframe contains categories:\r\n\r\n```python\r\n>>> import dask.dataframe as dd; import pandas as pd\r\n>>> import itertools as it\r\n>>> df = pd.DataFrame().assign(index=[0, 0, 1, 1], values=[\"a\", \"a\", \"b\", \"b\"], ex=[1, 2, 3, 4]).astype({\"values\": \"category\"})\r\n>>> ddf = dd.from_pandas(df, chunksize=2)\r\n>>> collect_list = dd.Aggregation(\r\n                     name=\"collect_list\", chunk=lambda s: s.apply(list),\r\n                     agg=lambda s0: s0.apply(lambda chunks: list(it.chain.from_iterable(chunks))))\r\n>>> ddf.groupby([\"index\", \"values\"]).agg(collect_list)\r\nTypeError\r\n[...]\r\nValueError: Metadata inference failed in `_agg_finalize`.\r\n\r\nYou have supplied a custom function and Dask is unable to\r\ndetermine the type of output that that function returns.\r\n\r\nTo resolve this please provide a meta= keyword.\r\nThe docstring of the Dask function you ran should have more information.\r\n\r\nOriginal error is below:\r\n------------------------\r\nTypeError(\"'float' object is not iterable\")\r\n[...]\r\n```\r\n\r\nThis can be solved by having a different aggregation function:\r\n\r\n```\r\n>>> def convert_to_list(c):\r\n    if (c != c).all():   # c != c is a trick to find NaN values\r\n        return [np.nan]\r\n    f = [_ for _ in c if _ == _]  # Again, only select non-NaN values\r\n    f = [_ if isinstance(_, list) else [_] for _ in f]\r\n    return list(it.chain.from_iterable(f))\r\n\r\n>>> collect_list = dd.Aggregation(\r\n     name=\"collect_list\", chunk=lambda s: s.apply(list),\r\n     agg=lambda s0: s0.apply(lambda chunks: internal(chunks)))\r\n>>> ddf.groupby([\"index\", \"values\"]).agg(collect_list).compute()\r\n                  ex\r\nindex values\r\n0     a       [1, 2]\r\n      b        [nan]\r\n1     a        [nan]\r\n      b       [3, 4]\r\n```\r\n\r\n**As a more general note**, this kind of operation (passing the whole list of values per-group to the \"aggregation\" function) is a passage that is sometimes necessary in data analysis, and it would be good in my humble opinion that good examples on how to force Dask to pass the whole list of values to the final aggregation stage would be both easier and more prominent on the documentation.\r\n\r\nAs a user-case, I found this edge-case while trying to calculate the MAD on a column of a grouped dask.DataFrame (using the `scipy.stats.median_absolute_deviation` function). Having to implement a map-reduce version of this standard function is far less optimal than simply passing the list of values to the end-stage (as it happens in pandas in an equivalent scenario).\r\n\r\n**Environment**: \r\n- Dask version: 2.17.2\r\n- Python version: 3.7.6 | Conda\r\n- Operating System:  WSL Ubuntu\r\n- Install method (conda, pip, source): Conda\r\n",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/dask/dask/issues/6410/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/dask/dask/issues/6410/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}