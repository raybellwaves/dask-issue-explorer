[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1396893016",
        "html_url": "https://github.com/dask/dask/issues/9847#issuecomment-1396893016",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9847",
        "id": 1396893016,
        "node_id": "IC_kwDOAbcwm85TQuVY",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-19T12:20:23Z",
        "updated_at": "2023-01-19T12:20:23Z",
        "author_association": "MEMBER",
        "body": "There is a lot to unpack and I might not be addressing everything you're talking about but here are my thoughts\r\n\r\n> 3. To inspect the categorical domains in the GUI, or because for whatever reason they must be known ahead of the graph computation.\r\n\r\nI think we can safely ignore this _use case_. If somebody cares about this, let them call `unique().compute()`\r\n\r\n---\r\n\r\nI'm slightly confused about your use case 1.) and 2.). I'll try to rephrase it a bit from a technological perspective because I believe we are supporting both but require a few computes too much.\r\nIIUC this is about whether or not dask knows categories or not or rather whether we care about a global unified `pd.CategoricalDtype`. For the global knowledge, we'll need to calculate a unique on the entire DF and this needs to block. The dataframe will hold this information in `meta` and this can be reused at a later step.\r\nIf we don't care about a global union and dask doesn't need to know, it can apply a map_partitions lazily. This is what we are currently doing with `astype(\"category\")`.\r\n\r\nI agree that the API of `categorize` vs `astype(\"category\")` is not intuitive. That this is happening behind the scenes is only hinted at in the docs\r\n\r\n> [...] and any unknown categoricals are made known. [...]\r\n\r\nhttps://github.com/dask/dask/blob/253b009bc9f1dc503c6544062bba002ce411b158/dask/dataframe/categorical.py#L80-L88\r\n\r\nI doubt that the ordinary user knows what it means to have \"unknown categoricals\" (that's the case you are referring to as \"local\") less alone what the implication of this is.\r\n\r\n> Add parameters to categorize():\r\n\r\nI think the `topology` argument makes sense but I suggest to call it differently. The term topology is very heavy and complex. Since we already have this concept of unknown_categories, I suggest something like `compute_unknown` or `resolve_unknown`, etc.\r\nInstead of using this argument we could also just expand documentation and point to the difference between `astype(\"category\")` and `categorize` more prominently than what we're doing right now.\r\n\r\n> compute: \"twice\" | \"persisted\" | False, optional\r\n\r\nI think the compute dilemma is generally a problem in dask. I could see us only working around this once we have a much more elaborate version of HLGs but for now there is no easy way out. Another prominent example where this comes up is `set_index`.\r\nTypically, when a compute arg is added it offers boolean values and we could offer the same here as well. However, typically this does not change *what* is being calculate but merely how.\r\n\r\nFor instance an array _compression matrix_ (more or less random example)\r\nhttps://github.com/dask/dask/blob/253b009bc9f1dc503c6544062bba002ce411b158/dask/array/linalg.py#L722-L742\r\n\r\nwill use persist internally if `compute=True` but will not change what is being calculated. Sometimes `compute=True` will also just trigger an actual intermediate compute as categorize does but I'm not aware of an example where compute changes semantics like in the example of `categorize(\"global\", False)` since this would result in a global `CategoricalDtype` but with unknown categories even though `(global, twice | persist)` does just that.\r\n\r\nI'm a bit concerned in your proposal about how the two kwargs are entangled and am concerned that this is not easily accessible; at least not more accessible than a thorough docs page about pros/cons including a couple of \"recipes\".\r\n\r\n---\r\n\r\n> .categorize(\"global\", False) is use case (2) at the beginning of this post, which is currently impossible.\r\n\r\nnit: Inconvenient, of course. Impossible? Well... this code is for a single column only but calculates a global `CategoricalDtype` and casts the partitions **lazily**. The ddf meta does not hold the known categories which is, I believe what you are describing with `(global, False)`\r\n\r\n```python\r\nimport pandas as pd\r\nimport dask.dataframe as dd\r\nddf = dd.from_pandas(pd.DataFrame({'A': range(100)}), npartitions=2)\r\n\r\ndef apply_dtype(part, column, categories):\r\n    return part.astype({column: pd.CategoricalDtype(categories)})\r\n\r\ndef apply_global_category(ddf, column):\r\n    return ddf.map_partitions(\r\n        apply_dtype, \r\n        column=column,\r\n        categories=ddf.A.unique(),\r\n        meta=ddf.astype({column: \"category\"})\r\n    )\r\napply_global_category(ddf, \"A\")\r\n```",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1396893016/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1396917130",
        "html_url": "https://github.com/dask/dask/issues/9847#issuecomment-1396917130",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9847",
        "id": 1396917130,
        "node_id": "IC_kwDOAbcwm85TQ0OK",
        "user": {
            "login": "crusaderky",
            "id": 6213168,
            "node_id": "MDQ6VXNlcjYyMTMxNjg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6213168?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/crusaderky",
            "html_url": "https://github.com/crusaderky",
            "followers_url": "https://api.github.com/users/crusaderky/followers",
            "following_url": "https://api.github.com/users/crusaderky/following{/other_user}",
            "gists_url": "https://api.github.com/users/crusaderky/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/crusaderky/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/crusaderky/subscriptions",
            "organizations_url": "https://api.github.com/users/crusaderky/orgs",
            "repos_url": "https://api.github.com/users/crusaderky/repos",
            "events_url": "https://api.github.com/users/crusaderky/events{/privacy}",
            "received_events_url": "https://api.github.com/users/crusaderky/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-19T12:41:30Z",
        "updated_at": "2023-01-19T12:41:30Z",
        "author_association": "MEMBER",
        "body": "> I think we can safely ignore this use case.\r\n\r\nVery happy to drop this use case then.\r\n\r\n> I'm a bit concerned in your proposal about how the two kwargs are entangled and am concerned that this is not easily accessible; at least not more accessible than a thorough docs page about pros/cons including a couple of \"recipes\".\r\n\r\nMy thought here is that a doc page with \"recipes\" can be easily missed, while a mandatory parameter forces an informed decision. Very happy to change the semantics of the parameter(s) as long as it requires the user to explicitly state which of the 3 use cases (`(global, twice)`, `(global, False)`, or `local`) they want.\r\n\r\n> nit: Inconvenient, of course. Impossible? Well...\r\n\r\nAs in, not something that a data scientist should have to deal with. The code you propose is exactly what should be implemented inside `categorize`.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1396917130/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1397097558",
        "html_url": "https://github.com/dask/dask/issues/9847#issuecomment-1397097558",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9847",
        "id": 1397097558,
        "node_id": "IC_kwDOAbcwm85TRgRW",
        "user": {
            "login": "crusaderky",
            "id": 6213168,
            "node_id": "MDQ6VXNlcjYyMTMxNjg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6213168?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/crusaderky",
            "html_url": "https://github.com/crusaderky",
            "followers_url": "https://api.github.com/users/crusaderky/followers",
            "following_url": "https://api.github.com/users/crusaderky/following{/other_user}",
            "gists_url": "https://api.github.com/users/crusaderky/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/crusaderky/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/crusaderky/subscriptions",
            "organizations_url": "https://api.github.com/users/crusaderky/orgs",
            "repos_url": "https://api.github.com/users/crusaderky/repos",
            "events_url": "https://api.github.com/users/crusaderky/events{/privacy}",
            "received_events_url": "https://api.github.com/users/crusaderky/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-19T14:51:42Z",
        "updated_at": "2023-01-19T14:51:42Z",
        "author_association": "MEMBER",
        "body": "P.S. your code snippet for `(global, False)` is problematic, as it will wholly hold in memory a much larger dataset than necessary. You need to prepend `map_partitions` with `ddf = ddf.astype(\"category\")` to get major RAM savings. This is the same as my discussion above of `.persist().categorize()` vs. `.astype(\"category\").persist().categorize()`.\r\n\r\n...which brings my point home: this is exactly why this kind of algorithm should be something that comes out of the box, and not be left to the final user to code by themselves.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1397097558/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]