{
    "url": "https://api.github.com/repos/dask/dask/issues/9859",
    "repository_url": "https://api.github.com/repos/dask/dask",
    "labels_url": "https://api.github.com/repos/dask/dask/issues/9859/labels{/name}",
    "comments_url": "https://api.github.com/repos/dask/dask/issues/9859/comments",
    "events_url": "https://api.github.com/repos/dask/dask/issues/9859/events",
    "html_url": "https://github.com/dask/dask/issues/9859",
    "id": 1551161706,
    "node_id": "I_kwDOAbcwm85cdNlq",
    "number": 9859,
    "title": "Utility that prints out delayed values when they're computed?",
    "user": {
        "login": "gjoseph92",
        "id": 3309802,
        "node_id": "MDQ6VXNlcjMzMDk4MDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3309802?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gjoseph92",
        "html_url": "https://github.com/gjoseph92",
        "followers_url": "https://api.github.com/users/gjoseph92/followers",
        "following_url": "https://api.github.com/users/gjoseph92/following{/other_user}",
        "gists_url": "https://api.github.com/users/gjoseph92/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/gjoseph92/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/gjoseph92/subscriptions",
        "organizations_url": "https://api.github.com/users/gjoseph92/orgs",
        "repos_url": "https://api.github.com/users/gjoseph92/repos",
        "events_url": "https://api.github.com/users/gjoseph92/events{/privacy}",
        "received_events_url": "https://api.github.com/users/gjoseph92/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 1342304743,
            "node_id": "MDU6TGFiZWwxMzQyMzA0NzQz",
            "url": "https://api.github.com/repos/dask/dask/labels/core",
            "name": "core",
            "color": "000000",
            "default": false,
            "description": ""
        },
        {
            "id": 3468123446,
            "node_id": "LA_kwDOAbcwm87Ot102",
            "url": "https://api.github.com/repos/dask/dask/labels/needs%20attention",
            "name": "needs attention",
            "color": "6d626c",
            "default": false,
            "description": "It's been a while since this was pushed on. Needs attention from the owner or a maintainer."
        },
        {
            "id": 3798450420,
            "node_id": "LA_kwDOAbcwm87iZ8D0",
            "url": "https://api.github.com/repos/dask/dask/labels/feature",
            "name": "feature",
            "color": "b0f0fa",
            "default": false,
            "description": "Something is missing"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 8,
    "created_at": "2023-01-20T16:48:43Z",
    "updated_at": "2024-03-25T01:45:36Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "It's common to see `print(dask_thing.compute())` in the middle of people's code. Print statements are helpful for debugging, and especially with dask, where everything is delayed already, it can be especially helpful to see what an object actually looks like. However, these `compute` calls can enormously slow things down and recompute data unnecessarily, and users may not understand this.\r\n\r\nWhat if we had a utility for making print statements like this that basically deferred the printing/evaluation until a later call of `dask.compute`?\r\n\r\n#### Original code:\r\n```python\r\nQ3 = ddf[\"trip_time\"].quantile(0.75)\r\nprint(f\"Q3 is:  {Q3.compute()}\")  # blocks, computes whole dataframe, prints\r\nupper_bound = Q3 + (1.5 * (Q3 - lower_bound))\r\nprint(f\"Upper bound is:  {upper_bound.compute()}\")  # blocks, recomputes whole dataframe, prints\r\n\r\nddf = ddf.loc[(ddf[\"trip_time\"] >= lower_bound) & (ddf[\"trip_time\"] <= upper_bound)]\r\nddf.to_parquet(...).compute()  # blocks, does actual computation you care about\r\n```\r\n\r\n#### Using new utility:\r\n```python\r\nQ3 = ddf[\"trip_time\"].quantile(0.75)\r\ndask.print(\"Q3 is:  {}\", Q3)  # instant, doesn't print anything yet\r\nupper_bound = Q3 + (1.5 * (Q3 - lower_bound))\r\ndask.print(\"Upper bound is:  {}\", upper_bound)  # instant, doesn't print anything yet\r\n\r\nddf = ddf.loc[(ddf[\"trip_time\"] >= lower_bound) & (ddf[\"trip_time\"] <= upper_bound)]\r\nddf.to_parquet(...).compute()  # blocks, does actual computation you care about.\r\n# first prints \"Q3 is ...\"\r\n# then a little later prints \"Upper bound is ...\"\r\n# then later returns\r\n```\r\n\r\nBasically, `dask.print` / `dask.log` (not sure what to name it) would just push a print statement onto an internal, global queue when you call it, but not actually print anything yet.\r\n\r\nThen each time it's called, `dask.compute` would pull everything off that queue and add it to the list of dask collections to be computed. It would take Futures to each of the print statements, and as soon as the future completed, it would print.",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/dask/dask/issues/9859/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/dask/dask/issues/9859/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}