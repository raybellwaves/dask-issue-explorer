{
    "url": "https://api.github.com/repos/dask/dask/issues/4389",
    "repository_url": "https://api.github.com/repos/dask/dask",
    "labels_url": "https://api.github.com/repos/dask/dask/issues/4389/labels{/name}",
    "comments_url": "https://api.github.com/repos/dask/dask/issues/4389/comments",
    "events_url": "https://api.github.com/repos/dask/dask/issues/4389/events",
    "html_url": "https://github.com/dask/dask/issues/4389",
    "id": 399546289,
    "node_id": "MDU6SXNzdWUzOTk1NDYyODk=",
    "number": 4389,
    "title": "Possible way of allow array repeat argument in da.repeat()",
    "user": {
        "login": "rainwoodman",
        "id": 138060,
        "node_id": "MDQ6VXNlcjEzODA2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/138060?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rainwoodman",
        "html_url": "https://github.com/rainwoodman",
        "followers_url": "https://api.github.com/users/rainwoodman/followers",
        "following_url": "https://api.github.com/users/rainwoodman/following{/other_user}",
        "gists_url": "https://api.github.com/users/rainwoodman/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/rainwoodman/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/rainwoodman/subscriptions",
        "organizations_url": "https://api.github.com/users/rainwoodman/orgs",
        "repos_url": "https://api.github.com/users/rainwoodman/repos",
        "events_url": "https://api.github.com/users/rainwoodman/events{/privacy}",
        "received_events_url": "https://api.github.com/users/rainwoodman/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 242862305,
            "node_id": "MDU6TGFiZWwyNDI4NjIzMDU=",
            "url": "https://api.github.com/repos/dask/dask/labels/array",
            "name": "array",
            "color": "006b75",
            "default": false,
            "description": null
        },
        {
            "id": 3798450416,
            "node_id": "LA_kwDOAbcwm87iZ8Dw",
            "url": "https://api.github.com/repos/dask/dask/labels/p2",
            "name": "p2",
            "color": "ffc133",
            "default": false,
            "description": "Affects more than a few users but doesn't prevent core functions"
        },
        {
            "id": 3798450420,
            "node_id": "LA_kwDOAbcwm87iZ8D0",
            "url": "https://api.github.com/repos/dask/dask/labels/feature",
            "name": "feature",
            "color": "b0f0fa",
            "default": false,
            "description": "Something is missing"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2019-01-15T21:36:45Z",
    "updated_at": "2022-08-12T16:55:06Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "Currently da.repeat only appear to allow scalar inputs as its repeats argument:\r\n\r\n```\r\narr = da.random.uniform(size=(100, 3), chunks=(10, 3))\r\nrepeats = da.arange(len(arr), chunks=10)\r\nda.repeat(arr, repeats, axis=0)\r\n\r\nNotImplementedError: .....\r\n```\r\nThere are two ways of doing this. One is to extend the current concatenate based method to allow for arbitrary repeat values. The basic idea would be first match the chunk size of the repeat array to the source array along the repeating axis, then compute the size of each block by traversing the repeat array, and build the graph that does the actual repeat.\r\n\r\nAnother is to use the map_block function. Here is a potential implementation. I think it essentially builds the same graph as above, but I do worry using the chunks argument of map_blocks in this manner is a bit fragile. \r\n\r\n```\r\ndef repeat_sizes(repeats):\r\n    return tuple(\r\n        da.map_blocks(lambda x: x.sum(dtype='i8').reshape(1),\r\n                      repeats,\r\n                             chunks=(1,),\r\n                             dtype='i8').compute())\r\n\r\ndef repeat(a, repeats, axis=0, sizes=None):\r\n    repeats = da.broadcast_to(repeats, (a.shape[axis], ), chunks=a.chunks[axis])\r\n    repeats = repeats.rechunk(a.chunks[axis])\r\n    if sizes is None:\r\n        sizes = repeat_sizes(repeats)\r\n    \r\n    chunks = list(a.chunks)\r\n    chunks[axis] = sizes\r\n    \r\n    chunks = tuple(chunks)\r\n    \r\n    def rep(x, r):\r\n        r = r.reshape(-1)\r\n        s = numpy.repeat(x, r.reshape(-1), axis=axis)\r\n        #print(x.shape, r, s.shape)\r\n        #print(x.shape, r, s.shape)\r\n        return s\r\n    one = [1] * len(a.shape)\r\n    one[axis] = -1\r\n    repeats = repeats.reshape(one)\r\n    #print(chunks, repeats.shape, repeats.chunks)\r\n    r = da.map_blocks(rep, \r\n                      a, repeats, chunks=chunks,\r\n                      dtype=a.dtype)\r\n    #print(r.chunks)\r\n    assert r.shape[axis] == numpy.sum(sizes)\r\n    return r\r\n\r\n\r\n```\r\n\r\nIf this looks like the right path right I will massage this into a proper PR. I however thought concatenate based method may be more suitable, though coding at that level seems to be out of my reach.\r\n\r\n",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/dask/dask/issues/4389/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/dask/dask/issues/4389/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}