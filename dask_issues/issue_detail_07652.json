{
    "url": "https://api.github.com/repos/dask/dask/issues/7652",
    "repository_url": "https://api.github.com/repos/dask/dask",
    "labels_url": "https://api.github.com/repos/dask/dask/issues/7652/labels{/name}",
    "comments_url": "https://api.github.com/repos/dask/dask/issues/7652/comments",
    "events_url": "https://api.github.com/repos/dask/dask/issues/7652/events",
    "html_url": "https://github.com/dask/dask/issues/7652",
    "id": 890800623,
    "node_id": "MDU6SXNzdWU4OTA4MDA2MjM=",
    "number": 7652,
    "title": "Sparsely blocked/chunked arrays",
    "user": {
        "login": "system123",
        "id": 91509,
        "node_id": "MDQ6VXNlcjkxNTA5",
        "avatar_url": "https://avatars.githubusercontent.com/u/91509?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/system123",
        "html_url": "https://github.com/system123",
        "followers_url": "https://api.github.com/users/system123/followers",
        "following_url": "https://api.github.com/users/system123/following{/other_user}",
        "gists_url": "https://api.github.com/users/system123/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/system123/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/system123/subscriptions",
        "organizations_url": "https://api.github.com/users/system123/orgs",
        "repos_url": "https://api.github.com/users/system123/repos",
        "events_url": "https://api.github.com/users/system123/events{/privacy}",
        "received_events_url": "https://api.github.com/users/system123/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 242862305,
            "node_id": "MDU6TGFiZWwyNDI4NjIzMDU=",
            "url": "https://api.github.com/repos/dask/dask/labels/array",
            "name": "array",
            "color": "006b75",
            "default": false,
            "description": null
        },
        {
            "id": 2156573524,
            "node_id": "MDU6TGFiZWwyMTU2NTczNTI0",
            "url": "https://api.github.com/repos/dask/dask/labels/highlevelgraph",
            "name": "highlevelgraph",
            "color": "8c24d6",
            "default": false,
            "description": "Issues relating to HighLevelGraphs."
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 15,
    "created_at": "2021-05-13T07:19:15Z",
    "updated_at": "2022-08-19T10:50:31Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "I have an application whereby I am manually forming a dask array using `blocks` as each of the chunks in the final array need to go through a specific transform to ensure the correct alignment in the final dask array. Furthermore, not all the chunks in the array which is formed contain useful information, but some are just needed to ensure spatial alignment between their neighboring chunks, thus forming a Dask array with sparse blocks/chunks.\r\n\r\nCurrently I am using masked arrays to mask out entire chunks, however, this is inefficient as those blocks are still included in the computational graph and are still evaluated to some degree. Ultimately it would be nice to have the concept of chunk/block masks which let dask know that the evaluation of any operation on an entire chunk will result in a NaN or empty result and can thus be skipped entirely without additional computation. \r\n\r\nThe application generally has more `empty` blocks/chunks that those with valid data and thus the computational graph grows very large with a lot of unneeded operations, having a way to prevent this would be nice.\r\n\r\nA small example of how I currently handle this:\r\n```\r\nimport numpy as np\r\nimport dask.array as da\r\n\r\narr0 = da.from_array(np.arange(1, 26).reshape(5,5), chunks=(5, 5))\r\narr1 = da.from_array(np.arange(25, 50).reshape(5,5), chunks=(5, 5))\r\n# This chunk is empty/blank/invalid but is needed to align the other chunks\r\narr2 = da.from_array(np.full((5,5), np.nan), chunks=(5, 5)) \r\narr3 = da.from_array(np.arange(75, 100).reshape(5,5), chunks=(5, 5))\r\n\r\na = da.block([[arr0, arr1],[arr2, arr3]])\r\nb = da.ma.masked_invalid(a)\r\nc = b.min().compute()\r\n```\r\n\r\nWhat would be nice to have:\r\n```\r\nimport numpy as np\r\nimport dask.array as da\r\n\r\narr0 = da.from_array(np.arange(1, 26).reshape(5,5), chunks=(5, 5))\r\narr1 = da.from_array(np.arange(25, 50).reshape(5,5), chunks=(5, 5))\r\narr3 = da.from_array(np.arange(75, 100).reshape(5,5), chunks=(5, 5))\r\n\r\na = da.sparse_block([[arr0, arr1],[None, arr3]])\r\nb = a.min().compute()\r\n```",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/dask/dask/issues/7652/reactions",
        "total_count": 2,
        "+1": 2,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/dask/dask/issues/7652/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}