,url,repository_url,labels_url,comments_url,events_url,html_url,id,node_id,number,title,labels,state,locked,assignee,assignees,milestone,n_comments,created_at,updated_at,closed_at,author_association,active_lock_reason,body,closed_by,timeline_url,performed_via_github_app,state_reason,user.login,user.id,user.node_id,user.avatar_url,user.gravatar_id,user.url,user.html_url,user.followers_url,user.following_url,user.gists_url,user.starred_url,user.subscriptions_url,user.organizations_url,user.repos_url,user.events_url,user.received_events_url,user.type,user.site_admin,reactions.url,reactions.total_count,reactions.+1,reactions.-1,reactions.laugh,reactions.hooray,reactions.confused,reactions.heart,reactions.rocket,reactions.eyes,closed_by.login,closed_by.id,closed_by.node_id,closed_by.avatar_url,closed_by.gravatar_id,closed_by.url,closed_by.html_url,closed_by.followers_url,closed_by.following_url,closed_by.gists_url,closed_by.starred_url,closed_by.subscriptions_url,closed_by.organizations_url,closed_by.repos_url,closed_by.events_url,closed_by.received_events_url,closed_by.type,closed_by.site_admin,draft,pull_request.url,pull_request.html_url,pull_request.diff_url,pull_request.patch_url,pull_request.merged_at,assignee.login,assignee.id,assignee.node_id,assignee.avatar_url,assignee.gravatar_id,assignee.url,assignee.html_url,assignee.followers_url,assignee.following_url,assignee.gists_url,assignee.starred_url,assignee.subscriptions_url,assignee.organizations_url,assignee.repos_url,assignee.events_url,assignee.received_events_url,assignee.type,assignee.site_admin
0,https://api.github.com/repos/dask/dask/issues/72,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/72/labels{/name},https://api.github.com/repos/dask/dask/issues/72/comments,https://api.github.com/repos/dask/dask/issues/72/events,https://github.com/dask/dask/issues/72,60959584,MDU6SXNzdWU2MDk1OTU4NA==,72,Create multiple output arrays with map_blocks,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2015-03-13T02:02:57Z,2021-10-11T23:59:07Z,,MEMBER,,"If a user provides a map function that produces multiple outputs, e.g.

``` python
def f(block):
    return block - 1, block + 1
```

Then they should be able to specify that somehow in the call to mapblocks

``` python
a, b = x.map_blocks(f, blockshape=[(10, 10), (10, 10)])
```

and receive two dask `Array` objects that share a common dask graph.
",,https://api.github.com/repos/dask/dask/issues/72/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/72/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1,https://api.github.com/repos/dask/dask/issues/97,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/97/labels{/name},https://api.github.com/repos/dask/dask/issues/97/comments,https://api.github.com/repos/dask/dask/issues/97/events,https://github.com/dask/dask/issues/97,64692056,MDU6SXNzdWU2NDY5MjA1Ng==,97,Idea: deferred errors,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,5,2015-03-27T04:36:37Z,2021-10-12T00:02:29Z,,MEMBER,,"Sometimes, it's nice to have defensive checks to ensure that the input is as you expect. But with dask, you might not want to evaluate these checks eagerly, because doing so might very expensive. Instead, we could have errors raised only when I finally run `dask.compute()`.

We might allow writing something like:

```
da.assert_((x > 0).all(), ValueError, 'x must be positive')
```

The tricky part would be figuring out how to insert an assert statement into the task dependency graph without making a mess of global state.
",,https://api.github.com/repos/dask/dask/issues/97/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/97/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
2,https://api.github.com/repos/dask/dask/issues/731,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/731/labels{/name},https://api.github.com/repos/dask/dask/issues/731/comments,https://api.github.com/repos/dask/dask/issues/731/events,https://github.com/dask/dask/issues/731,107308081,MDU6SXNzdWUxMDczMDgwODE=,731,dask.dataframe quantile fails spectacularly in some edge cases,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,8,2015-09-19T03:45:43Z,2023-04-04T17:33:14Z,,MEMBER,,"```
s = pd.Series([-1, 0, 0, 0, 1, 1])
print(s.median())  # 0.0
print(dd.from_pandas(s, 2).quantile(0.5).compute())  # 1.0
```

This is also true for arbitrarily large repetitions of this data, e.g.,

```
s = pd.Series([-1] * 1000 + [0, 0, 0] * 1000 + [1, 1] * 1000)
# also holds for all different chunk sizes that I tested other than 20
dd.from_pandas(s, 20).quantile(0.5).compute()  # 1.0
```

cc @ogrisel 
",,https://api.github.com/repos/dask/dask/issues/731/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/731/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
3,https://api.github.com/repos/dask/dask/issues/746,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/746/labels{/name},https://api.github.com/repos/dask/dask/issues/746/comments,https://api.github.com/repos/dask/dask/issues/746/events,https://github.com/dask/dask/issues/746,107803943,MDU6SXNzdWUxMDc4MDM5NDM=,746,Add optimizations to dask.array to remap ufunc(data)[key] to ufunc(data[key]),"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,20,2015-09-22T21:12:06Z,2021-10-12T00:02:50Z,,MEMBER,,"This is a reminder to finish up/reboot the aborted PR #410

These optimizations would be _extremely_ useful for xray's integration with dask (both internally and for our users), by allowing us to write transformations on entire dask arrays without any cost in unnecessary IO. Once this is working robustly, I'll be able to delete a pretty significant chunk of code from xray that deals with lazy computation.
",,https://api.github.com/repos/dask/dask/issues/746/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/746/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
4,https://api.github.com/repos/dask/dask/issues/874,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/874/labels{/name},https://api.github.com/repos/dask/dask/issues/874/comments,https://api.github.com/repos/dask/dask/issues/874/events,https://github.com/dask/dask/issues/874,121327475,MDU6SXNzdWUxMjEzMjc0NzU=,874,Scheduler fail case: centering data with dask.array,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,42,2015-12-09T20:07:04Z,2021-10-12T00:00:14Z,,MEMBER,,"A common use case for many modeling problems (e.g., in machine learning or climate science) is to center data by subtracting an average of some kind over a given axis. The dask scheduler currently falls flat on its face when attempting to schedule these types of problems.

Here's a simple example of such a fail case:

``` python
import dask.array as da
x = da.ones((8, 200, 200), chunks=(1, 200, 200))  # e.g., a large stack of image data
mad = abs(x - x.mean(axis=0)).mean()
mad.visualize()
```

![image](https://cloud.githubusercontent.com/assets/1217238/11696975/18d78eb2-9e6c-11e5-8ca1-8741ca2e38a9.png)

The scheduler will keep each of the initial chunks in memory that it uses to compute the mean, because they will be used later to as an argument to `sub`. In contrast, the appropriate way to handle this graph to avoid blowing up memory would be to compute the initial chunks twice.

I know that in principle this could be avoided by using an on-disk cache. But this seems like a waste, because the initial values are often sitting in a file on disk, anyways.

This is a pretty typical use case for dask.array (one of the first things people try with xray), so it's worth seeing if we can come up with a solution that works by default.
",,https://api.github.com/repos/dask/dask/issues/874/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/874/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
5,https://api.github.com/repos/dask/dask/issues/898,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/898/labels{/name},https://api.github.com/repos/dask/dask/issues/898/comments,https://api.github.com/repos/dask/dask/issues/898/events,https://github.com/dask/dask/issues/898,124300714,MDU6SXNzdWUxMjQzMDA3MTQ=,898,Determine accurate index in read_csv with full data read,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,3,2015-12-30T03:48:17Z,2023-04-04T17:36:59Z,,MEMBER,,"`dask.dataframe.read_csv` works by breaking up a text file across byte boundaries (say, every 100MB), seeking to nearby endlines, and then passing off that block of bytes to `pandas.read_csv`.  However, we only read the first bit of the first block at construction time in order to determine dtypes and column names; we don't read the rest of the blocks.  This results in a fast return to the user.

However, this also means that we have no ability to determine index values.  If there is an actual index (say, for a time series) then we can't leverage this.  If there is no index then we don't have the ability to accurately add an increasing index like `1, 2, 3, ...`.  In some cases these are really important.  

So at times it might make sense to suffer the additional pass through the data so that we can collect index values for `divisions`.  Presumably this could be achieved by using `read_csv` normally, and then calling an appropriate `map_partitions` function to determine `(partition.index.min(), partition.index.max())` or whatnot.

This has come up a few times, but most recently in #897
",,https://api.github.com/repos/dask/dask/issues/898/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/898/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
6,https://api.github.com/repos/dask/dask/issues/922,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/922/labels{/name},https://api.github.com/repos/dask/dask/issues/922/comments,https://api.github.com/repos/dask/dask/issues/922/events,https://github.com/dask/dask/issues/922,127282243,MDU6SXNzdWUxMjcyODIyNDM=,922,from_hdf5 function that uses filenames rather than files,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,27,2016-01-18T18:09:15Z,2020-03-11T16:02:26Z,,MEMBER,,"The current approach to load data from HDF5 is to load in an h5py or netcdf4 Dataset object and pass that to `from_array`.  This is efficient, but also includes the file pointer within the dask graph.  This fails if you need to serialize the graph, such as is necessary in distributed computing.

It might be wise to instead create an explicit `da.from_hdf5` function that only stored the filename, datapath, and slice information within the graph.  

It would also be nice if this API was exposed up to `xarray` (cc @shoyer).

cc @rabernat @pwolfram
",,https://api.github.com/repos/dask/dask/issues/922/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/922/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
7,https://api.github.com/repos/dask/dask/issues/955,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/955/labels{/name},https://api.github.com/repos/dask/dask/issues/955/comments,https://api.github.com/repos/dask/dask/issues/955/events,https://github.com/dask/dask/issues/955,131376756,MDU6SXNzdWUxMzEzNzY3NTY=,955,Read_hdf with sorted column,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,8,2016-02-04T15:10:18Z,2016-04-20T05:03:38Z,,MEMBER,,"Often a Pandas-build HDF5 file has a sorted column that we can use to cleanly and efficiently partition the dataset.  We should expose this case through the read_hdf function.

cc @jreback @jcrist 
",,https://api.github.com/repos/dask/dask/issues/955/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/955/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
8,https://api.github.com/repos/dask/dask/issues/1167,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1167/labels{/name},https://api.github.com/repos/dask/dask/issues/1167/comments,https://api.github.com/repos/dask/dask/issues/1167/events,https://github.com/dask/dask/issues/1167,155766249,MDU6SXNzdWUxNTU3NjYyNDk=,1167,Handle fixed format hdf tables with dataframe,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2016-05-19T15:29:37Z,2021-10-12T00:34:05Z,,MEMBER,,"There is a lot of complexity around HDF5 flavors used with Pandas. In particular ""fixed"" format hdf5 files are somewhat opaque and can not be cut easily.  Dask.dataframe currently chokes on these.  

We should do one of the following:
1.  Raise informative error messages
2.  Accept them as single-partition dask.dataframes
3.  Accept them in glob strings as multi-partition dask.dataframes

cc pvanderlinden
",,https://api.github.com/repos/dask/dask/issues/1167/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1167/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
9,https://api.github.com/repos/dask/dask/issues/1233,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1233/labels{/name},https://api.github.com/repos/dask/dask/issues/1233/comments,https://api.github.com/repos/dask/dask/issues/1233/events,https://github.com/dask/dask/issues/1233,158768921,MDU6SXNzdWUxNTg3Njg5MjE=,1233,dd.read_sas(),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,31,2016-06-06T20:36:44Z,2023-04-02T17:12:40Z,,CONTRIBUTOR,,"Would it be possible to get a read_sas method for Dask? Is it much more work than read_csv?
",,https://api.github.com/repos/dask/dask/issues/1233/timeline,,,AlbertDeFusco,43654,MDQ6VXNlcjQzNjU0,https://avatars.githubusercontent.com/u/43654?v=4,,https://api.github.com/users/AlbertDeFusco,https://github.com/AlbertDeFusco,https://api.github.com/users/AlbertDeFusco/followers,https://api.github.com/users/AlbertDeFusco/following{/other_user},https://api.github.com/users/AlbertDeFusco/gists{/gist_id},https://api.github.com/users/AlbertDeFusco/starred{/owner}{/repo},https://api.github.com/users/AlbertDeFusco/subscriptions,https://api.github.com/users/AlbertDeFusco/orgs,https://api.github.com/users/AlbertDeFusco/repos,https://api.github.com/users/AlbertDeFusco/events{/privacy},https://api.github.com/users/AlbertDeFusco/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1233/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
10,https://api.github.com/repos/dask/dask/issues/1259,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1259/labels{/name},https://api.github.com/repos/dask/dask/issues/1259/comments,https://api.github.com/repos/dask/dask/issues/1259/events,https://github.com/dask/dask/issues/1259,159327779,MDU6SXNzdWUxNTkzMjc3Nzk=,1259,Add missing methods to Series,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,23,2016-06-09T04:52:44Z,2024-02-01T14:00:04Z,,MEMBER,,"Pandas methods like `to_timestamp` are trivial to add to dask.dataframe.  We should go through the API and verify that we've implemented everything like this that is more-or-less trivial to do.
",,https://api.github.com/repos/dask/dask/issues/1259/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1259/reactions,0,0,0,0,0,0,0,0,0,jsignell,4806877.0,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
11,https://api.github.com/repos/dask/dask/issues/1288,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1288/labels{/name},https://api.github.com/repos/dask/dask/issues/1288/comments,https://api.github.com/repos/dask/dask/issues/1288/events,https://github.com/dask/dask/issues/1288,160202905,MDU6SXNzdWUxNjAyMDI5MDU=,1288,Approximate algorithms for dask.nunique/dask.drop_duplicates,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,4,2016-06-14T14:55:24Z,2016-06-30T15:35:50Z,,MEMBER,,"Approximate algorithms can be _much_ faster than entirely correct algorithms.  It would be good to implement approximate variants of methods like `nunique` and `drop_duplicates`.  For example, perhaps calling `nunique(approximate=True)` should use something like [Hyper-Log-Log](https://en.wikipedia.org/wiki/HyperLogLog)
",,https://api.github.com/repos/dask/dask/issues/1288/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1288/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
12,https://api.github.com/repos/dask/dask/issues/1296,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1296/labels{/name},https://api.github.com/repos/dask/dask/issues/1296/comments,https://api.github.com/repos/dask/dask/issues/1296/events,https://github.com/dask/dask/issues/1296,160761298,MDU6SXNzdWUxNjA3NjEyOTg=,1296,array.to_hdf5(compute=False) doesn't return delayed value,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,4,2016-06-16T21:07:37Z,2020-07-11T14:51:52Z,,CONTRIBUTOR,,"`array.to_hdf5` accepts a compute keyword implicitly by passing it along to `store` (which handles it correctly), but `array.to_hdf5` does not handle that correctly. It should accept it explicitly and return a single `delayed()` object in that case.
",,https://api.github.com/repos/dask/dask/issues/1296/timeline,,,nirizr,3631703,MDQ6VXNlcjM2MzE3MDM=,https://avatars.githubusercontent.com/u/3631703?v=4,,https://api.github.com/users/nirizr,https://github.com/nirizr,https://api.github.com/users/nirizr/followers,https://api.github.com/users/nirizr/following{/other_user},https://api.github.com/users/nirizr/gists{/gist_id},https://api.github.com/users/nirizr/starred{/owner}{/repo},https://api.github.com/users/nirizr/subscriptions,https://api.github.com/users/nirizr/orgs,https://api.github.com/users/nirizr/repos,https://api.github.com/users/nirizr/events{/privacy},https://api.github.com/users/nirizr/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1296/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
13,https://api.github.com/repos/dask/dask/issues/1340,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1340/labels{/name},https://api.github.com/repos/dask/dask/issues/1340/comments,https://api.github.com/repos/dask/dask/issues/1340/events,https://github.com/dask/dask/issues/1340,162570194,MDU6SXNzdWUxNjI1NzAxOTQ=,1340,to_hdf multiple nodes first node bottleneck should be avoided,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,1,2016-06-27T23:22:55Z,2019-08-08T15:04:47Z,,CONTRIBUTOR,,"when saving to multiple nodes in the same hdf file (which i feel is the best compromise between efficiency and clean output), there's a bottleneck created by all subsequent to_hdf tasks depending on the first.
It might be worth creating a fake ""to_hdf"" node that will not depend on any input for this case.

this assumes PR #1293 is in, which is not the case atm, but i wanted to make sure this is noted somewhere.

For example, with `mode='a' or 'r+'`, there's no need to link anything.
",,https://api.github.com/repos/dask/dask/issues/1340/timeline,,,nirizr,3631703,MDQ6VXNlcjM2MzE3MDM=,https://avatars.githubusercontent.com/u/3631703?v=4,,https://api.github.com/users/nirizr,https://github.com/nirizr,https://api.github.com/users/nirizr/followers,https://api.github.com/users/nirizr/following{/other_user},https://api.github.com/users/nirizr/gists{/gist_id},https://api.github.com/users/nirizr/starred{/owner}{/repo},https://api.github.com/users/nirizr/subscriptions,https://api.github.com/users/nirizr/orgs,https://api.github.com/users/nirizr/repos,https://api.github.com/users/nirizr/events{/privacy},https://api.github.com/users/nirizr/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1340/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
14,https://api.github.com/repos/dask/dask/issues/1353,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1353/labels{/name},https://api.github.com/repos/dask/dask/issues/1353/comments,https://api.github.com/repos/dask/dask/issues/1353/events,https://github.com/dask/dask/issues/1353,163997890,MDU6SXNzdWUxNjM5OTc4OTA=,1353,dd.read_hdf with pattern format can be slow,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,12,2016-07-06T04:51:53Z,2019-08-08T15:10:36Z,,MEMBER,,"A user reports that read_hdf can be a bit slow when using pattern matching because calling fnmatch many times can be slow.  Perhaps there is a faster way to narrow down key-spaces based on group prefix?
",,https://api.github.com/repos/dask/dask/issues/1353/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1353/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
15,https://api.github.com/repos/dask/dask/issues/1408,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1408/labels{/name},https://api.github.com/repos/dask/dask/issues/1408/comments,https://api.github.com/repos/dask/dask/issues/1408/events,https://github.com/dask/dask/issues/1408,167237888,MDU6SXNzdWUxNjcyMzc4ODg=,1408,Rewrite dd.read_hdf,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,22,2016-07-24T15:10:15Z,2019-08-08T15:14:24Z,,MEMBER,,"HDF format is probably the most mature cross-platform format in common use today for pandas-like data.  Dask.dataframe supports this format through `dd.to_hdf` and `dd.read_hdf` functions, which are decently full featured.  

However, as various features have glommed onto `read_hdf` it has become fairly complex, causing significant maintenance burden and additional friction when adding new features.  As we think about naturally supporting intelligent partitioning (see #1407), a new and important feature, we might also consider how `read_hdf` might be rewritten from scratch to improve both the existing situation and ease future development.

It would be nice to now collect both some current frustrations and some long-term desires for dealing with dask.dataframe and HDF files together so that future designs can have these in mind. 

cc @nirizr @alberthdev
",,https://api.github.com/repos/dask/dask/issues/1408/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1408/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
16,https://api.github.com/repos/dask/dask/issues/1438,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1438/labels{/name},https://api.github.com/repos/dask/dask/issues/1438/comments,https://api.github.com/repos/dask/dask/issues/1438/events,https://github.com/dask/dask/issues/1438,169027174,MDU6SXNzdWUxNjkwMjcxNzQ=,1438,dask bag `take` ignores shared dependencies,"[{'id': 242862273, 'node_id': 'MDU6TGFiZWwyNDI4NjIyNzM=', 'url': 'https://api.github.com/repos/dask/dask/labels/bag', 'name': 'bag', 'color': '0052cc', 'default': False, 'description': None}]",open,False,,[],,8,2016-08-03T01:31:04Z,2019-08-08T15:26:54Z,,NONE,,"Normally, `take` seems to intelligently ""propagate"" its way down, so that a `take(1)` doesn't evaluate the entire task graph before . This is super useful for exploring large data sets.

Unfortunately, this doesn't seem to work for ""diamond"" / shared dependencies (like those created with `zip`), where the task graph looks like:

```
     --------
     | Take |
     --------
        /\
      /    \
    /        \
--------  --------
| Task |  | Task |
--------  --------
    \        /
      \    /
        \/
     --------
     | Base |
     --------
```

In this diamond dependency, even a trivial `take(1)` seems to evaluate the entire task graph, even though it should be easy to for `take(1)` to percolate down through the `zip`.

I saw this on Python 3.5 and dask `0.10.2` (both from `conda-forge`).
",,https://api.github.com/repos/dask/dask/issues/1438/timeline,,,alanhdu,1914111,MDQ6VXNlcjE5MTQxMTE=,https://avatars.githubusercontent.com/u/1914111?v=4,,https://api.github.com/users/alanhdu,https://github.com/alanhdu,https://api.github.com/users/alanhdu/followers,https://api.github.com/users/alanhdu/following{/other_user},https://api.github.com/users/alanhdu/gists{/gist_id},https://api.github.com/users/alanhdu/starred{/owner}{/repo},https://api.github.com/users/alanhdu/subscriptions,https://api.github.com/users/alanhdu/orgs,https://api.github.com/users/alanhdu/repos,https://api.github.com/users/alanhdu/events{/privacy},https://api.github.com/users/alanhdu/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1438/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
17,https://api.github.com/repos/dask/dask/issues/1493,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1493/labels{/name},https://api.github.com/repos/dask/dask/issues/1493/comments,https://api.github.com/repos/dask/dask/issues/1493/events,https://github.com/dask/dask/issues/1493,172274379,MDU6SXNzdWUxNzIyNzQzNzk=,1493,Full support for multiindex in dataframes,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,55,2016-08-20T14:50:06Z,2023-10-04T13:05:46Z,,NONE,,"Dask can load a dataframe from a pytables hdf5 file, and pytables already supports a hierarchy tables.  Why not simulate a multiindex (like in pandas) by loading all tables from an hdf5 file into one dask dataframe with nested column indices?
",,https://api.github.com/repos/dask/dask/issues/1493/timeline,,,dirkbike,3711678,MDQ6VXNlcjM3MTE2Nzg=,https://avatars.githubusercontent.com/u/3711678?v=4,,https://api.github.com/users/dirkbike,https://github.com/dirkbike,https://api.github.com/users/dirkbike/followers,https://api.github.com/users/dirkbike/following{/other_user},https://api.github.com/users/dirkbike/gists{/gist_id},https://api.github.com/users/dirkbike/starred{/owner}{/repo},https://api.github.com/users/dirkbike/subscriptions,https://api.github.com/users/dirkbike/orgs,https://api.github.com/users/dirkbike/repos,https://api.github.com/users/dirkbike/events{/privacy},https://api.github.com/users/dirkbike/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1493/reactions,12,12,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
18,https://api.github.com/repos/dask/dask/issues/1519,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1519/labels{/name},https://api.github.com/repos/dask/dask/issues/1519/comments,https://api.github.com/repos/dask/dask/issues/1519/events,https://github.com/dask/dask/issues/1519,174424260,MDU6SXNzdWUxNzQ0MjQyNjA=,1519,with_dependencies method for adding arbitrary dependencies,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,3,2016-09-01T02:46:51Z,2019-08-08T15:35:33Z,,MEMBER,,"e.g., suppose `x` is a dask.array or dataframe that we want to verify is finite:

```
@dask.delayed
def assert_(condition):
    assert condition

x = x.with_dependencies([assert_(da.notnull(x).all())])
```

Under the covers, this would create a new dask object with each task dependent on computing the dependent tasks.

Potentially, this would be quite useful for tools like xarray, so we could defer equality checks until we've built the entire graph. One concern is that this might trigger a fail case for the dask scheduler (#874) when checks inevitably require looking at the entire dataset.

This is a more general solution to #97, inspired by the corresponding design from TensorFlow:
https://www.tensorflow.org/versions/r0.10/api_docs/python/check_ops.html#assert_negative
",,https://api.github.com/repos/dask/dask/issues/1519/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1519/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
19,https://api.github.com/repos/dask/dask/issues/1744,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1744/labels{/name},https://api.github.com/repos/dask/dask/issues/1744/comments,https://api.github.com/repos/dask/dask/issues/1744/events,https://github.com/dask/dask/issues/1744,186648968,MDU6SXNzdWUxODY2NDg5Njg=,1744,Function to determine optimal dtypes for a dask.dataframe,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,8,2016-11-01T21:13:47Z,2021-10-12T00:28:35Z,,MEMBER,,"In many cases we read tabular data from some source modify it, and write it out to another data destination.  In this transfer we have an opportunity to tighten the data representation a bit, for example by changing dtypes or using categoricals.

Often people do this by hand.  It might be nice for us to do some of this work for them based on a single pass through the data.  This might involve finding min/max of all integer columns, the approximate number of unique elements of all object dtype and integer columns, etc. and returning an appropriate dtype dict that we could optionally pass into an `asdtype` method.",,https://api.github.com/repos/dask/dask/issues/1744/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1744/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
20,https://api.github.com/repos/dask/dask/issues/1821,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1821/labels{/name},https://api.github.com/repos/dask/dask/issues/1821/comments,https://api.github.com/repos/dask/dask/issues/1821/events,https://github.com/dask/dask/issues/1821,192627171,MDU6SXNzdWUxOTI2MjcxNzE=,1821,Groupby nunique-approx,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2016-11-30T17:22:03Z,2019-08-08T16:04:51Z,,MEMBER,,"As of #1358 we now have a nice approximate nunique algorithm.  A natural extension of this is to implement `groupby.nunique_approx`.  

@mikegraham do you have thoughts on how this could best be implemented?

cc @jreback ",,https://api.github.com/repos/dask/dask/issues/1821/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1821/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
21,https://api.github.com/repos/dask/dask/issues/1978,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1978/labels{/name},https://api.github.com/repos/dask/dask/issues/1978/comments,https://api.github.com/repos/dask/dask/issues/1978/events,https://github.com/dask/dask/issues/1978,207063700,MDU6SXNzdWUyMDcwNjM3MDA=,1978,Add a memory-efficient LU factorization,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2017-02-12T17:10:36Z,2019-08-08T17:14:03Z,,NONE,,"I think it will be useful to add operations akin to [`scipy.linalg.lu_facto` and `scipy.linalg.lu_solve`](https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.linalg.lu_factor.html).

These produce and use a LU factorisation with a memory footprint of (N*(N + 1)), for a matrix of N by N, as opposed to the current version which produces a factorisation of size 3(N*N).
",,https://api.github.com/repos/dask/dask/issues/1978/timeline,,,demianw,272705,MDQ6VXNlcjI3MjcwNQ==,https://avatars.githubusercontent.com/u/272705?v=4,,https://api.github.com/users/demianw,https://github.com/demianw,https://api.github.com/users/demianw/followers,https://api.github.com/users/demianw/following{/other_user},https://api.github.com/users/demianw/gists{/gist_id},https://api.github.com/users/demianw/starred{/owner}{/repo},https://api.github.com/users/demianw/subscriptions,https://api.github.com/users/demianw/orgs,https://api.github.com/users/demianw/repos,https://api.github.com/users/demianw/events{/privacy},https://api.github.com/users/demianw/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1978/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
22,https://api.github.com/repos/dask/dask/issues/1983,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1983/labels{/name},https://api.github.com/repos/dask/dask/issues/1983/comments,https://api.github.com/repos/dask/dask/issues/1983/events,https://github.com/dask/dask/issues/1983,207634145,MDU6SXNzdWUyMDc2MzQxNDU=,1983,Inferring chunks in from_array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2017-02-14T20:56:34Z,2018-10-23T22:22:39Z,,MEMBER,,"Not sure if this is reasonable, but it might be nice if chunks could optionally be inferred when calling `from_array`. Namely if given something has the `chunks` attribute, try to use it. If not raise some sort of error that it needs to be provided. There are already a few cases where this should work reasonably ok (e.g. Zarr, HDF5).",,https://api.github.com/repos/dask/dask/issues/1983/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1983/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
23,https://api.github.com/repos/dask/dask/issues/1991,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/1991/labels{/name},https://api.github.com/repos/dask/dask/issues/1991/comments,https://api.github.com/repos/dask/dask/issues/1991/events,https://github.com/dask/dask/issues/1991,208520875,MDU6SXNzdWUyMDg1MjA4NzU=,1991,Visualize synopsis of large graphs,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,18,2017-02-17T18:32:33Z,2020-09-18T16:15:33Z,,MEMBER,,"People appreciate our `dot` images, especially when coupled with visualizations like the following (courtesy of Jim)

![](http://jcrist.github.io/images/grid_search_schedule.gif)

Unfortunately these don't scale beyond a few hundred nodes.  Meaningfully visualizing very large graphs is a *hard problem*.  

However, while we can't visualize full dask graphs, we might be able to build synopses graphs and visualize those.  In particular, we may be able to take advantage of Dask's naming scheme to show connections between groups of tasks.  Presumably line widths and node sizes/shapes could be used to fill in some of the dropped information.

Additionally, if we can flesh out a good way to construct and visualize these on the fly then we may be able to get something live running on Bokeh.  This is probably secondary to just visualizing things statically though.

cc @eriknw , who just gave a cool talk/demo about visualizing graphs",,https://api.github.com/repos/dask/dask/issues/1991/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/1991/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
24,https://api.github.com/repos/dask/dask/issues/2034,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2034/labels{/name},https://api.github.com/repos/dask/dask/issues/2034/comments,https://api.github.com/repos/dask/dask/issues/2034/events,https://github.com/dask/dask/issues/2034,211767253,MDU6SXNzdWUyMTE3NjcyNTM=,2034,Dask.arrays adds overheads for BlackScholes bench comparing to Numpy-based function ,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2017-03-03T18:35:14Z,2021-10-12T00:20:58Z,,NONE,,"We've open-sourced the benchmark here: https://github.com/IntelPython/BlackScholes_bench
I also fixed some issues to remove differences which between `bs_erf_dask.py` and `bs_erf_dask_numpy.py` versions which reduced the gap which I showed to you at AnacondaCon.
Though, some difference remains there. Please take a look if you have an explanation and simple path to optimize it.
```
# Intel build of Numpy is used as set by set_python_envs.sh
./run.sh

bs_erf_dask_numpy.py:
Using  Intel-erf-invsqrt  numpy  1.11.2
ERF: Dask-agg-sq: Size: 1024
MOPS: 1.0975617202031693
ERF: Dask-agg-sq: Size: 2048
MOPS: 2.160373246781671
ERF: Dask-agg-sq: Size: 4096
MOPS: 3.877962602697867
ERF: Dask-agg-sq: Size: 8192
MOPS: 6.392508487718868
ERF: Dask-agg-sq: Size: 16384
MOPS: 10.572198107424121
ERF: Dask-agg-sq: Size: 32768
MOPS: 14.918486422827671
ERF: Dask-agg-sq: Size: 65536
MOPS: 19.937007392952143
ERF: Dask-agg-sq: Size: 131072
MOPS: 34.957127243175385
ERF: Dask-agg-sq: Size: 262144
MOPS: 55.59018833939888
ERF: Dask-agg-sq: Size: 524288
MOPS: 65.61944673131615
ERF: Dask-agg-sq: Size: 1048576
MOPS: 95.88951101372575
ERF: Dask-agg-sq: Size: 2097152
MOPS: 113.26209976424786
ERF: Dask-agg-sq: Size: 4194304
MOPS: 149.32191488202923
ERF: Dask-agg-sq: Size: 8388608
MOPS: 146.0329585890649
ERF: Dask-agg-sq: Size: 16777216
MOPS: 156.52372122173202

bs_erf_dask.py:
Using  Intel-erf-invsqrt  numpy  1.11.2
ERF: Dask-sq: Size: 1024
intelpython3/lib/python3.5/site-packages/dask/array/core.py:457: RuntimeWarning: overflow encountered in true_divide
  o = func(*args, **kwargs)
MOPS: 0.1569314351720343
ERF: Dask-sq: Size: 2048
MOPS: 0.31703701235651266
ERF: Dask-sq: Size: 4096
MOPS: 0.6423204626561884
ERF: Dask-sq: Size: 8192
MOPS: 1.2690267681811251
ERF: Dask-sq: Size: 16384
MOPS: 2.247484566707261
ERF: Dask-sq: Size: 32768
MOPS: 4.385553723786909
ERF: Dask-sq: Size: 65536
MOPS: 7.389463396923947
ERF: Dask-sq: Size: 131072
MOPS: 14.642015572025098
ERF: Dask-sq: Size: 262144
MOPS: 26.894927982463447
ERF: Dask-sq: Size: 524288
MOPS: 42.16209875801704
ERF: Dask-sq: Size: 1048576
MOPS: 73.32840063658358
ERF: Dask-sq: Size: 2097152
MOPS: 87.92025592270113
ERF: Dask-sq: Size: 4194304
MOPS: 118.21894916833371
ERF: Dask-sq: Size: 8388608
MOPS: 135.69298033658706
ERF: Dask-sq: Size: 16777216
MOPS: 141.9271284927524
```",,https://api.github.com/repos/dask/dask/issues/2034/timeline,,,anton-malakhov,7475946,MDQ6VXNlcjc0NzU5NDY=,https://avatars.githubusercontent.com/u/7475946?v=4,,https://api.github.com/users/anton-malakhov,https://github.com/anton-malakhov,https://api.github.com/users/anton-malakhov/followers,https://api.github.com/users/anton-malakhov/following{/other_user},https://api.github.com/users/anton-malakhov/gists{/gist_id},https://api.github.com/users/anton-malakhov/starred{/owner}{/repo},https://api.github.com/users/anton-malakhov/subscriptions,https://api.github.com/users/anton-malakhov/orgs,https://api.github.com/users/anton-malakhov/repos,https://api.github.com/users/anton-malakhov/events{/privacy},https://api.github.com/users/anton-malakhov/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2034/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
25,https://api.github.com/repos/dask/dask/issues/2053,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2053/labels{/name},https://api.github.com/repos/dask/dask/issues/2053/comments,https://api.github.com/repos/dask/dask/issues/2053/events,https://github.com/dask/dask/issues/2053,212624693,MDU6SXNzdWUyMTI2MjQ2OTM=,2053,read_csv with wildcards fails on different column orders,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,5,2017-03-08T03:03:07Z,2021-10-12T00:24:05Z,,NONE,,"Hi I finally tracked down this issue after alot of work but if you have 2 (or more) csv files with headers, but the column order of the files is different, read_csv will read the second file as if the columns where in the same order.

I did not know that the order of these columns would be different but `pd.Dataframe.to_csv()` does not guarantee an ordering.

take for example the following 2 files.

    ==> mean-2016.12.11.csv <==
    d,demo,s,market,qtr_hr,ue,000s,w,np,tarp
    2016-12-11,TTLPPL,0,0201,0,4998799.939999982,6.332151999999998,6332.151999999998,5,0.12667344314643691
    2016-12-11,TTLPPL,0,0201,1,4998799.939999982,3.9752799999999993,3975.2799999999993,2,0.07952468687914752
    2016-12-11,TTLPPL,0,0201,2,4998799.939999982,3.2186719999999993,3218.6719999999996,2,0.0643888941072527

    ==> mean-2016.12.18.csv <==
    d,demo,s,market,qtr_hr,w,ue,np,000s,tarp
    2016-12-18,TTLPPL,0,0201,0,1743.1853333333338,4998800.000000004,2,1.7431853333333331,0.034872075964898205
    2016-12-18,TTLPPL,0,0201,1,1952.8600000000004,4998800.000000004,3,1.9528599999999998,0.039066575978234735
    2016-12-18,TTLPPL,0,0201,2,1654.542666666667,4998800.000000004,2,1.6545426666666665,0.033098797044624005

you get the following

    >>> df = dd.read_csv('../data/mean-2016.12.18.csv')
    >>> df.compute().ix[0]
    d         2016-12-18
    demo          TTLPPL
    s                  0
    market           201
    qtr_hr             0
    w            1743.19
    ue        4.9988e+06
    np                 2
    000s         1.74319
    tarp       0.0348721
    Name: 0, dtype: object

in contrast

    >>> df = dd.read_csv('../data/mean-2016.12.1*.csv')
    >>> df.compute().ix[0]

    d	demo	s	market	qtr_hr	ue	000s	w	np	tarp
    0	2016-12-11	TTLPPL	0	201	0	4.998800e+06	6.332152e+00	6332.152	5.000000	0.126673
    0	2016-12-18	TTLPPL	0	201	0	1.743185e+03	4.998800e+06	2.000	1.743185	0.034872",,https://api.github.com/repos/dask/dask/issues/2053/timeline,,,stumitchell,738393,MDQ6VXNlcjczODM5Mw==,https://avatars.githubusercontent.com/u/738393?v=4,,https://api.github.com/users/stumitchell,https://github.com/stumitchell,https://api.github.com/users/stumitchell/followers,https://api.github.com/users/stumitchell/following{/other_user},https://api.github.com/users/stumitchell/gists{/gist_id},https://api.github.com/users/stumitchell/starred{/owner}{/repo},https://api.github.com/users/stumitchell/subscriptions,https://api.github.com/users/stumitchell/orgs,https://api.github.com/users/stumitchell/repos,https://api.github.com/users/stumitchell/events{/privacy},https://api.github.com/users/stumitchell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2053/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
26,https://api.github.com/repos/dask/dask/issues/2103,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2103/labels{/name},https://api.github.com/repos/dask/dask/issues/2103/comments,https://api.github.com/repos/dask/dask/issues/2103/events,https://github.com/dask/dask/issues/2103,215827480,MDU6SXNzdWUyMTU4Mjc0ODA=,2103,Should da ufuncs be lazy or immediate on numpy arrays?,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,8,2017-03-21T17:57:34Z,2021-10-20T12:47:26Z,,MEMBER,,"Currently functions like `da.sin` on a numpy array compute immediately.  However all other cases of `atop` wrap the numpy array into a single-chunk dask.array and compute lazily.  Should we change the immediate behavior of dask.array ufuncs to be lazy?

cc @shoyer @jhamman",,https://api.github.com/repos/dask/dask/issues/2103/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2103/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
27,https://api.github.com/repos/dask/dask/issues/2149,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2149/labels{/name},https://api.github.com/repos/dask/dask/issues/2149/comments,https://api.github.com/repos/dask/dask/issues/2149/events,https://github.com/dask/dask/issues/2149,218536388,MDU6SXNzdWUyMTg1MzYzODg=,2149,Rename pure keyword to deterministic,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 1968982461, 'node_id': 'MDU6TGFiZWwxOTY4OTgyNDYx', 'url': 'https://api.github.com/repos/dask/dask/labels/delayed', 'name': 'delayed', 'color': '4f6edd', 'default': False, 'description': ''}]",open,False,,[],,3,2017-03-31T15:28:24Z,2021-10-12T00:13:34Z,,MEMBER,,"We use the `pure=` keyword on the dask.delayed and dask.distributed interfaces to mean that repeated calls of the same function on the same arguments produce the same result.  This might more precisely be called deterministic behavior than pure.  In particular, some people have set `pure=False` as an excuse to then provide functions that mutate external state and think that they are doing so safely.

We might want to change this name.

cc @jcrist ",,https://api.github.com/repos/dask/dask/issues/2149/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2149/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
28,https://api.github.com/repos/dask/dask/issues/2156,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2156/labels{/name},https://api.github.com/repos/dask/dask/issues/2156/comments,https://api.github.com/repos/dask/dask/issues/2156/events,https://github.com/dask/dask/issues/2156,218655894,MDU6SXNzdWUyMTg2NTU4OTQ=,2156,ENH: Delayed variant of persist (pin?) ,[],open,False,,[],,19,2017-04-01T01:26:49Z,2018-03-19T17:13:01Z,,MEMBER,,"It seems that storing an intermediate result now requires one call `persist` or `cache`, which trigger a computation in the background. Something that would be really nice is delayed caching (pinning?).

To elaborate a bit, pinning would mean that when computation is triggered by other means, the pinned object would be computed once and then persisted on the workers. However noting that the object should be pinned would not result in any computation on its own. Here's a simple example to demonstrate what this might mean.

```python
In [1]: import dask.array as da

In [2]: import numpy as np

In [3]: a = da.from_array(np.arange(6), chunks=(6,))

In [4]: b = a * 2

In [5]: b = b.pin()  # persist this later

In [6]: c = b + 3

In [7]: c.compute()  # compute `c` and persist `b` in the process
Out[7]: array([ 3,  5,  7,  9, 11, 13])

In [8]: b.compute()  # fetch `b`, it was already computed when `c` was
Out[8]: array([ 0,  2,  4,  6,  8, 10])

In [9]: del a, b, c  # free memory, particularly `b` and `c` are needed to free `b`'s memory
```

Not to walk through all of this, but calling `b.pin()` notes that this value should be persisted on the workers once computation is triggered. Though otherwise it is just an annotation in the Dask graph. When we call `c.compute()`, this triggers computation, which will result in computing `b` as well. Once `b` is computed, its result is kept on the workers just as `b.persist()` does. So when we call `b.compute()`, it doesn't really compute anything. It just returns the result that was persisted in memory on the workers. To free the memory attached to `b`, we just release all references to it as we would do with `persist`.",,https://api.github.com/repos/dask/dask/issues/2156/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2156/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
29,https://api.github.com/repos/dask/dask/issues/2201,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2201/labels{/name},https://api.github.com/repos/dask/dask/issues/2201/comments,https://api.github.com/repos/dask/dask/issues/2201/events,https://github.com/dask/dask/issues/2201,221072405,MDU6SXNzdWUyMjEwNzI0MDU=,2201,Set_index should avoid partd on mostly sorted dataframes,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2017-04-11T20:33:23Z,2021-10-12T00:15:24Z,,MEMBER,,"Setting a column as an index currently requires a full shuffle.  This is very expensive.   If the data is already sorted *and* doesn't have any repeated values between partitions, then we avoid this shuffle and instead just use the min/max values of each partition for the divisions.  This still requires a full pass through the data to find min/max values but is much cheaper than performing shuffles.

However, very often data is *mostly sorted* with a bit of out-of-order behavior.  In these cases it would be nice to still use the existing divisions found during the min/max process but just move around those errant records that overlap in each partition to their neighbors.  This would make a common case situation *much* faster.

Also cc @TomAugspurger in case he's bored.  This was reported originally by @shughes-uk",,https://api.github.com/repos/dask/dask/issues/2201/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2201/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
30,https://api.github.com/repos/dask/dask/issues/2225,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2225/labels{/name},https://api.github.com/repos/dask/dask/issues/2225/comments,https://api.github.com/repos/dask/dask/issues/2225/events,https://github.com/dask/dask/issues/2225,221981022,MDU6SXNzdWUyMjE5ODEwMjI=,2225,Optimize tensordot with rechunk,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,28,2017-04-16T00:19:39Z,2021-10-12T02:48:09Z,,MEMBER,,"Dask.array tensordot operations can be made significantly faster by doing an initial rechunk pass, making all axes over which we intend to contract single-chunked.  

For example, if we have the following block-chunked arrays:

```python
import dask.array as da
x = da.random.random((500, 500, 500), chunks=(50, 50, 50))
y = da.random.random((500, 100), chunks=(50, 50))
```

And we want to contract over the 1st and 0th dimensions respectively

```python
da.tensordot(x, y, axes=[1, 0]).visualize()
```

Then we may want to preemptively rechunk so that those axes have only one chunk as follows:

```python
x2 = x.rechunk((..., 500, ...)).persist()
y2 = y.rechunk((500, ...)).persist()
```

We may want to contract other axes while we expand these ones to make sure that we don't produce chunks that are too large (and to ensure that the resulting tensordot chunks are not too large).  In this case though the outputs are small enough even with a 10x increase in size, so we leave the other dimensions as-is.

```python
x2 = x.rechunk((50, 500, 50)).persist()
y2 = y.rechunk((500, 50)).persist()
```

This does incur some communication costs up front, but it will generally save us more communication down the line.

So I think the question here is the following:

*Given the chunks of both arrays and the `axis=` argument, how should we rechunk these arrays prior to the normal tensordot call.  This should both increase the chunksize in the contracted axes to the full extent and possibly reduce the chunksize of the other dimension based on the expected nbytes of out output of the tensordot call.*

Snagged this trick from this talk: https://youtu.be/dcT6c-PrloE?t=1584

cc @jcrist and @shoyer who might find this interesting.  cc @pitrou who did the rechunk logic and might be able to recommend something.",,https://api.github.com/repos/dask/dask/issues/2225/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2225/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
31,https://api.github.com/repos/dask/dask/issues/2244,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2244/labels{/name},https://api.github.com/repos/dask/dask/issues/2244/comments,https://api.github.com/repos/dask/dask/issues/2244/events,https://github.com/dask/dask/issues/2244,223480920,MDU6SXNzdWUyMjM0ODA5MjA=,2244,Stencil operations,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,17,2017-04-21T19:57:00Z,2021-10-12T02:47:58Z,,MEMBER,,"Opening this issue to discuss supporting stencil operations in Dask. Am interested to see a nice wrapper function or functions that do a reasonably good job at wrapping up common case stencil function APIs. Also should work for users interested in adding their own custom stencil operations. Just a few cases and relevant discussions are listed below. As suggested elsewhere by @mrocklin, these might benefit from using `map_overlap` for the implementation.

It may make more sense to hash this out after we have tried to handle a few cases. Then again a good wrapper could really open the door for a lot of cool operations in Dask or with Dask much faster.

cc @rabernat @mrocklin

xref: https://github.com/dask/dask/issues/2241
xref: https://github.com/dask/dask/issues/2147
xref: https://github.com/dask/dask/issues/2132#issuecomment-290107519",,https://api.github.com/repos/dask/dask/issues/2244/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2244/reactions,0,0,0,0,0,0,0,0,0,mrocklin,306380.0,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
32,https://api.github.com/repos/dask/dask/issues/2254,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2254/labels{/name},https://api.github.com/repos/dask/dask/issues/2254/comments,https://api.github.com/repos/dask/dask/issues/2254/events,https://github.com/dask/dask/issues/2254,223994973,MDU6SXNzdWUyMjM5OTQ5NzM=,2254,Asymmetric ghosting,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,9,2017-04-25T01:34:40Z,2019-06-20T20:05:56Z,,MEMBER,,"It would be very helpful if operations like `ghost`, `trim`, and `map_overlap` would support asymmetric ghosting (a.k.a. haloing).

To provide context, many filters have the option to specify the origin of the footprint (where the result will be placed) be somewhere other than its center. In these instances, one needs a larger halo on edges where the origin of the footprint is closest too. However one can get away with a much smaller halo on edges where the origin of the footprint is further from.

As it stands currently, halos must be symmetric meaning that one ends up having a larger halo in all directions if the origin of the footprint deviates from the center. When in reality the size of the block plus halo should be invariant to the origin of the footprint. This results in some unneeded computational inefficiency in these cases. Given common cases take the origin to an extreme (all the way to one end of the footprint), these inefficiencies are not insignificant.

To fix cases like these, I would propose that we allow a `list` to be specified for each dimension in addition to the already standard `int`. We could treat the `int` as a special form of the `list` case where both values in the `list` are the same. One could specify a `list` only on dimensions in need of this asymmetry. This `list` syntax can easily be used in conjuction with the `tuple` or `dict` syntax as well for improved versatility. This would allow for more appropriate halos to be specified in these cases where the footprint origin is not in the center.",,https://api.github.com/repos/dask/dask/issues/2254/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2254/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
33,https://api.github.com/repos/dask/dask/issues/2292,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2292/labels{/name},https://api.github.com/repos/dask/dask/issues/2292/comments,https://api.github.com/repos/dask/dask/issues/2292/events,https://github.com/dask/dask/issues/2292,226083313,MDU6SXNzdWUyMjYwODMzMTM=,2292,Process local variables,[],open,False,,[],,1,2017-05-03T19:02:06Z,2017-05-03T19:30:08Z,,MEMBER,,"Many forms of parallelism have some mechanism of denoting a variable should be constructed on a per thread basis. This typically goes by the name [Thread-local storage]( https://en.wikipedia.org/wiki/Thread-local_storage ) or TLS. These variables are like their global variable analogues except that except that they are global for the thread they exist in. This allows them to be initialized independently per thread and be appropriately tracked as so. By being thread local, these variables are safe equivalents to global variables as one generally doesn't need to worry about locking before using them.

For the most part Dask/Distributed doesn't need things like these or at least doesn't generally need to expose these to the user. Many operations don't necessarily suggest that they are acting in parallel (e.g. addition), but in reality are under the surface. Even operations that do hint they are parallel (e.g. `map_blocks` or `map_overlap`) hide the details of data transfer from the user. Not to mention Dask/Distributed is pretty good at avoiding data transfer. So this is rarely an issue the user needs to think about. Given the data being moved is generally picklable, this just doesn't present a problem in most cases.

However pickling is just not that often a safe thing. In fact many libraries (e.g. `dill`, `cloudpickle`, `tblib`, etc.) are built around the notion that pickling in the core Python library is somehow deficient and it needs to be rectified by allowing something else to be pickled that wouldn't be normally allowed (e.g. closures, tracebacks, etc.). While these different libraries certainly close the gap on what can be pickled safely, inevitably one will want to work with something that doesn't fit nicely in one of these cases (e.g. `h5py` objects).

In cases like these, users certainly have some options. First they can try to keep these non-pickle safe object contained in functions that only take picklable objects and return picklable objects. [1] This avoids exposing these objects to Dask/Distributed. This does solve many use cases. However for other users these don't scale to their demands. Second they can specify how to handle serialization. [2] While this definitely seems like a nice option, we encounter issues with it that are challenging to debug and fix. [3]

Given the current state of things, it seems we could really benefit from a way to specify and represent a process local variable/operation. In the interest of allowing for cleanup, we could require the process local operation to be a single value generator. This way the user can `yield` the value for use and handle cleanup operations after the `yield` (e.g. closing a file).

By allowing for process local variables like this, one can easily reuse the variable in multiple operations and not have to worry about many setup/teardown operations costing on performance. Also one can ensure the variable in question is created on the relevant process only once requested. There is no need to figure out how to transfer this object between processes as each process would have access to a locally defined object. Anything else like accessing a dataset would result in another process local object. To ensure this object could be handled within Dask this could be represented as a Delayed object (potentially special cased). Conversion to a Dask Array should be possible with the same `da.from_delayed` mechanism. Though one may wish to rechunk before proceeding, this is hardly unique to this use of `da.from_delayed`.

<br>

1: https://github.com/dask/dask/issues/922#issuecomment-199085431
2: https://github.com/dask/distributed/issues/604
3: https://github.com/dask/dask/issues/1777",,https://api.github.com/repos/dask/dask/issues/2292/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2292/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
34,https://api.github.com/repos/dask/dask/issues/2299,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2299/labels{/name},https://api.github.com/repos/dask/dask/issues/2299/comments,https://api.github.com/repos/dask/dask/issues/2299/events,https://github.com/dask/dask/issues/2299,226381034,MDU6SXNzdWUyMjYzODEwMzQ=,2299,Key and Task classes,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,7,2017-05-04T19:15:59Z,2021-10-12T02:44:06Z,,MEMBER,,"I think it would be worth considering adding optional light-weight classes to represent keys and tasks in a dask graph. These would complement the existing `dask.core.quote` for literals.

This would allow for much clearer intent when creating dask graphs, and better error messages when things go wrong (e.g., for #2298), because dask could know unambiguously what an object is intended to represent without needing to guess about what it is. For example, if a key is not found, dask could raise an error instead of using it as a literal.

These could be simple `tuple` subclasses, e.g.,
```
class Key(tuple):
  __slots__ = ()
  
  def __new__(cls, *args):
    return tuple.__new__(Key, args)

  def __repr__(self):
    contents = repr(tuple(self))
    if len(self) == 1:
      contents = contents[:-len(',)')] + ')'
    return 'Key{}'.format(contents)
```

The `Task` class could automatically handle `**kwargs` in the proper fashion, e.g., `Task(pd.read_csv, filename, sep='\t')`.

This is more verbose than using Python builtins, but not onerously so. E.g., adapting the [""Custom Graphs"" example](http://dask.pydata.org/en/latest/custom-graphs.html) from the docs:
```python
from dask import Task, Key

...
dsk = {'load-1': Task(load, 'myfile.a.data'),
       'load-2': Task(load, 'myfile.b.data'),
       'load-3': Task(load, 'myfile.c.data'),
       'clean-1': Task(clean, Key('load-1')),
       'clean-2': Task(clean, Key('load-2')),
       'clean-3': Task(clean, Key('load-3')),
       'analyze': Task(analyze, [Key('clean-%d') % i for i in [1, 2, 3]]),
       'store': Task(store, Key('analyze'))}
```

Possibly, we would want a ""strict evaluation"" mode that requires all tasks and keys to be wrapped in the appropriate classes, and switches the default interpretation for everything else to be a literal. Think of this as ""strong typing"" for dask.

I think this would be really valuable for library code, such as the existing dask collections.",,https://api.github.com/repos/dask/dask/issues/2299/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2299/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
35,https://api.github.com/repos/dask/dask/issues/2431,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2431/labels{/name},https://api.github.com/repos/dask/dask/issues/2431/comments,https://api.github.com/repos/dask/dask/issues/2431/events,https://github.com/dask/dask/issues/2431,234263515,MDU6SXNzdWUyMzQyNjM1MTU=,2431,"Swapping getitem and elementwise operations via graph opimization, redux?",[],open,False,,[],,10,2017-06-07T16:10:55Z,2017-06-07T17:26:45Z,,MEMBER,,"@jcrist did some work back in https://github.com/dask/dask/pull/755 on swapping getitem and elementwise operations. We didn't end up merging this work, because we were unable to come up with a solution that worked across the board without slowing down every dask array operations (by forcing broadcasting).

However, this is still a vital optimization for climate/weather data analysis use cases (where arrays are often currently loaded with one chunk/file, as described in https://github.com/pydata/xarray/issues/1440), and would be extremely valuable for xarray (allowing us to remove our legacy system for deferred array computation). It would be great to pursue it in some more limited form.

Any of the following would solve xarray's use cases:

1. Optimization that only works on elementwise operations with a single array argument, e.g., of the form `x + 1`.
2. Optimization that only works on elementwise operations with pre-broadcast arguments. These would need some sort of special indication in the dask graph, likely via some custom API, e.g., `da.swappable_elementwise()`.
3. A new (optional) elementwise operation that always explicitly broadcasts, for cases when optimization is essential and some overhead is acceptable.

The optimization pass itself could also be optional, but we would always want to use it on dask.array objects wrapped with xarray.",,https://api.github.com/repos/dask/dask/issues/2431/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2431/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
36,https://api.github.com/repos/dask/dask/issues/2456,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2456/labels{/name},https://api.github.com/repos/dask/dask/issues/2456/comments,https://api.github.com/repos/dask/dask/issues/2456/events,https://github.com/dask/dask/issues/2456,236117194,MDU6SXNzdWUyMzYxMTcxOTQ=,2456,OOMs on seemingly simple shuffle job: mem usage greatly exceeds --memory-limit,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,34,2017-06-15T08:41:06Z,2022-03-28T18:00:58Z,,NONE,,"# Summary
- I'm struggling to figure out how to avoid OOMs in a seemingly simple shuffle on a ~6gb parquet.snappy dataset using 16 workers, each with 8gb mem, ~4gb memory limit, 1 proc, and 1 thread. I'm not persisting anything, and I'm ok with shuffle tasks spilling to disk as necessary.
- The OOMs cause the job to either fail after a while or complete after a really long while, nondeterministically.
- I decreased task size by increasing task count (128 -> 512), but I still observed OOMs with similar frequency.
- Plotting mem usage over time shows a tight distribution around `--memory-limit` for the first ~1/2 of the job and then large variance for the second ~1/2 of the job, during which time OOMs start happening (plots below).
- I created more headroom for this large variance by decreasing `--memory-limit` (4gb/8gb -> 2gb/8gb) and I did observe many fewer OOMs, but still 1 OOM, and moreover 2gb/8gb impedes our ability to persist data later in this pipeline for an iterative ML algo so this isn't a feasible solution.
- Maybe there's something fishy on the dask side happening here, in particular in the high variance of mem usage above `--memory-limit`? Or maybe I'm just making a dumb user error somewhere that's easy to fix?
- Lmk if I can clarify or distill anything better!

# Setup
- 16 workers (on k8s on ec2), each running in its own docker container with 8gb mem and 1 cpu
- Workers running with ~4gb mem limit, 1 proc, and 1 thread:
  - `DASK_COMPRESSION=zlib dask-worker --nprocs 1 --nthreads 1 --memory-limit=4e9 --no-nanny <scheduler-url>`
- Code looks like:

```py
# Read from parquet (s3)
#   - 238 parts in
#   - ~6.5gb total
#   - Part file sizes vary 10-50mb (see plot below)
ddf_no_index = dd.read_parquet(in_path)

# Pick task/part count for output
num_parts_out = ... # 128 or 512

# Reindex to a column of uniformly distributed uuid5 values with fixed, uniform divisions
#   - npartitions=num_parts_out, via divisions=uniform_divisions[num_parts_out]
ddf_indexed = ddf_no_index.set_index(
    uniformly_distributed_uuid5_column,
    drop=False,
    divisions=uniform_divisions[num_parts_out],
)

# Write to parquet (s3)
#   - 128 or 512 parts out
#   - ~6.6gb total (based on a successful 128-part output)
#   - When 128 parts, output part files vary 54-58mb (see plot below)
#   - When 512 parts, output part files should vary ~10-15mb, but I didn't let the job finish
(ddf_indexed
    .astype(...)
    .drop(ddf_indexed.index.name, axis=1)
    .to_parquet(
        out_path,
        compression='snappy',
        object_encoding=...,
        write_index=True,
    )
)
```

- Data skew looks like:

| input parquet.snappy part file sizes <br> 238 parts | output parquet.snappy part file sizes <br> 128 parts |
|---|---|
| ![fig-20170615t072553509023](https://user-images.githubusercontent.com/627486/27170013-36aae5e8-5161-11e7-97aa-c6f0e1e11564.png) | ![fig-20170615t073618347342](https://user-images.githubusercontent.com/627486/27170455-c870244c-5162-11e7-8214-c12098f77b41.png) |

# Trials
- Rows 12: my starting point was `num_parts_out=128` with `--memory-limit=4e9`, which fails a lot of the time but actually succeeded twice with many OOMs and long runtimes
- Row 3: I increased task count to `num_parts_out=512`, but saw a similar frequency of OOMs and killed the job
- Row 4: I decreased mem limit to `--memory-limit=2e9` but still saw 1 OOM (and thus some amount of repeated work)
- Col ""sys metrics"": check out the change in variance in mem usage partway through the job, after which OOMs start happening
- Col ""task aftermath"": you can see the lost workers, all due to OOMs
- Col ""task counts"": shows the number of shuffle tasks, for reference (~68k)

| params | outcome | task counts | task aftermath | sys metrics |
|---|---|---|---|---|
| 238&nbsp;parts&nbsp;in <br> 128&nbsp;parts&nbsp;out <br> 4g&nbsp;mem&nbsp;limit | 27&nbsp;OOMs <br> 111m <br> success ||| ![datadog 4g 128 2](https://user-images.githubusercontent.com/627486/27168445-86a68b94-515a-11e7-959c-c0c6a6478b12.png) |
| 238&nbsp;parts&nbsp;in <br> 128&nbsp;parts&nbsp;out <br> 4g&nbsp;mem&nbsp;limit | 10&nbsp;OOMs <br> 47m <br> success | ![dask 4g 128](https://user-images.githubusercontent.com/627486/27167974-7228ba72-5158-11e7-8f16-5a9483c14baf.png) | ![tasks 4g 128](https://user-images.githubusercontent.com/627486/27167970-72013f56-5158-11e7-9472-60a16151c8e0.png) | ![datadog 4g 128](https://user-images.githubusercontent.com/627486/27168385-48cd352a-515a-11e7-8d20-69c4cd539cdf.png) |
| 238&nbsp;parts&nbsp;in <br> 512&nbsp;parts&nbsp;out <br> 4g&nbsp;mem&nbsp;limit | >4&nbsp;OOMs <br> gave&nbsp;up&nbsp;early | ![dask 4g 512](https://user-images.githubusercontent.com/627486/27167969-71d81216-5158-11e7-858f-494876a9d6b0.png) | ![blank](https://user-images.githubusercontent.com/627486/27168471-a0b3693a-515a-11e7-8e45-e266fc4dcc00.png) | ![datadog 4g 512](https://user-images.githubusercontent.com/627486/27168326-0f06583a-515a-11e7-8566-059cffd39cac.png) |
| 238&nbsp;parts&nbsp;in <br> 128&nbsp;parts&nbsp;out <br> 2g&nbsp;mem&nbsp;limit | 1&nbsp;OOM <br> 56m <br> success | ![dask 2g 128](https://user-images.githubusercontent.com/627486/27167976-723e4252-5158-11e7-9ae0-7e63b98c4c4e.png) | ![tasks 2g 128](https://user-images.githubusercontent.com/627486/27167977-72410082-5158-11e7-971f-b8769fd30213.png) | ![datadog 2g 128](https://user-images.githubusercontent.com/627486/27168416-645b8b98-515a-11e7-82cf-584f03443263.png) |

# Versions
```sh
$ python --version
Python 3.6.0

$ cat requirements.txt | egrep 'dask|distributed|fastparquet'
git+https://github.com/dask/dask.git@a883f44
git+https://github.com/dask/fastparquet.git@d07d662
distributed==1.16.2
```",,https://api.github.com/repos/dask/dask/issues/2456/timeline,,,jdanbrown,627486,MDQ6VXNlcjYyNzQ4Ng==,https://avatars.githubusercontent.com/u/627486?v=4,,https://api.github.com/users/jdanbrown,https://github.com/jdanbrown,https://api.github.com/users/jdanbrown/followers,https://api.github.com/users/jdanbrown/following{/other_user},https://api.github.com/users/jdanbrown/gists{/gist_id},https://api.github.com/users/jdanbrown/starred{/owner}{/repo},https://api.github.com/users/jdanbrown/subscriptions,https://api.github.com/users/jdanbrown/orgs,https://api.github.com/users/jdanbrown/repos,https://api.github.com/users/jdanbrown/events{/privacy},https://api.github.com/users/jdanbrown/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2456/reactions,3,3,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
37,https://api.github.com/repos/dask/dask/issues/2488,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2488/labels{/name},https://api.github.com/repos/dask/dask/issues/2488/comments,https://api.github.com/repos/dask/dask/issues/2488/events,https://github.com/dask/dask/issues/2488,238396930,MDU6SXNzdWUyMzgzOTY5MzA=,2488,da.store for hdf file or to_hdf fails with distributed scheduler,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,5,2017-06-25T18:23:33Z,2021-10-12T02:39:49Z,,MEMBER,,"h5py File objects do not serialize, so they can only be shared between tasks with the threaded scheduler. da.to_hdf creates an h5py File and then calls store. 
Naturally, this only makes sense if the workers are on the same machine or otherwise have access to the same network file-system. Producing many hdf files from one dataset does not necessarily make much sense for arrays as opposed to dataframes.

dataframe's to_hdf is already fixed in this respect, so presumably some of that logic could be copied here.",,https://api.github.com/repos/dask/dask/issues/2488/timeline,,,martindurant,6042212,MDQ6VXNlcjYwNDIyMTI=,https://avatars.githubusercontent.com/u/6042212?v=4,,https://api.github.com/users/martindurant,https://github.com/martindurant,https://api.github.com/users/martindurant/followers,https://api.github.com/users/martindurant/following{/other_user},https://api.github.com/users/martindurant/gists{/gist_id},https://api.github.com/users/martindurant/starred{/owner}{/repo},https://api.github.com/users/martindurant/subscriptions,https://api.github.com/users/martindurant/orgs,https://api.github.com/users/martindurant/repos,https://api.github.com/users/martindurant/events{/privacy},https://api.github.com/users/martindurant/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2488/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
38,https://api.github.com/repos/dask/dask/issues/2497,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2497/labels{/name},https://api.github.com/repos/dask/dask/issues/2497/comments,https://api.github.com/repos/dask/dask/issues/2497/events,https://github.com/dask/dask/issues/2497,239952323,MDU6SXNzdWUyMzk5NTIzMjM=,2497,Improve dask.array Black Scholes benchmark performance,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,13,2017-07-01T14:26:16Z,2021-10-12T00:21:08Z,,MEMBER,,"Intel has a nice benchmark for dask.array and Black Scholes here: https://github.com/IntelPython/BlackScholes_bench .  We might want to use this as a benchmark to improve scheduler, optimization, and dask.array performance.",,https://api.github.com/repos/dask/dask/issues/2497/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2497/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
39,https://api.github.com/repos/dask/dask/issues/2498,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2498/labels{/name},https://api.github.com/repos/dask/dask/issues/2498/comments,https://api.github.com/repos/dask/dask/issues/2498/events,https://github.com/dask/dask/issues/2498,239964657,MDU6SXNzdWUyMzk5NjQ2NTc=,2498,dask.base's normalize_array hashes the same data to different values,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,13,2017-07-01T18:20:45Z,2021-10-12T02:39:17Z,,NONE,,"https://github.com/dask/dask/blob/0.15.0/dask/base.py#L400

Is there a reason to both hash the ravel'ed data and use strides?  Reading some other issues suggests strides was introduce for memmaps but I think this borks the case where its just a plain np.array.  Also, passing an `order` kwarg to `ravel` makes the same data come out in different ways.

It looks like a recent change introduces an `order` kwarg to the `ravel` method call
Is it necessary for something?  

```python
import pprint

import dask.base
import dask.hashing
import numpy as np


def f(x):
    data = dask.hashing.hash_buffer_hex(x.ravel().view('i1'))
    return (data, x.dtype, x.shape)


data = [[0, 1], [2, 3]]
orders = ('C', 'F')
# arrs have the same data
arrs = [np.array(data, order=order) for order in orders]
# but tokenize differently
pprint.pprint([dask.base.tokenize(arr) for arr in arrs])
# the cause of the difference is passing `order` to ravel and using strides
pprint.pprint([dask.base.normalize_token(arr) for arr in arrs])
# what if we omit the `order` arg to ravel and the use of strides?
pprint.pprint([f(arr) for arr in arrs])
pprint.pprint([np.__version__, dask.__version__])
```
will print
```
['77acec63d80d37fcc8d42d0b4ee467bb', '85fb7b31b123920d0609d087c3d47300']
[('f5c356611bc74f63a6d8068bdb3b807ce19691fb', dtype('int64'), (2, 2), (16, 8)),
 ('f2837ee9691f05f519de044b5aae40589bec6155', dtype('int64'), (2, 2), (8, 16))]
[('f5c356611bc74f63a6d8068bdb3b807ce19691fb', dtype('int64'), (2, 2)),
 ('f5c356611bc74f63a6d8068bdb3b807ce19691fb', dtype('int64'), (2, 2))]
['1.11.3', '0.15.0+16.g24afbd5']
```",,https://api.github.com/repos/dask/dask/issues/2498/timeline,,,dlovell,1074774,MDQ6VXNlcjEwNzQ3NzQ=,https://avatars.githubusercontent.com/u/1074774?v=4,,https://api.github.com/users/dlovell,https://github.com/dlovell,https://api.github.com/users/dlovell/followers,https://api.github.com/users/dlovell/following{/other_user},https://api.github.com/users/dlovell/gists{/gist_id},https://api.github.com/users/dlovell/starred{/owner}{/repo},https://api.github.com/users/dlovell/subscriptions,https://api.github.com/users/dlovell/orgs,https://api.github.com/users/dlovell/repos,https://api.github.com/users/dlovell/events{/privacy},https://api.github.com/users/dlovell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2498/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
40,https://api.github.com/repos/dask/dask/issues/2561,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2561/labels{/name},https://api.github.com/repos/dask/dask/issues/2561/comments,https://api.github.com/repos/dask/dask/issues/2561/events,https://github.com/dask/dask/issues/2561,245773138,MDU6SXNzdWUyNDU3NzMxMzg=,2561,Reshaping trivial dimensions with non-trivial chunks fails,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2017-07-26T16:03:19Z,2019-05-13T14:29:11Z,,MEMBER,,"When trying to use `reshape` on a Dask Array with some trivial (i.e. `0`-length) dimensions and non-trivial chunks (i.e. multiple chunks) along non-trivial dimensions, the `reshape` operation fails. This differs from NumPy in the same situation. It seems to have something to do with how rechunking occurs as a consequence of reshaping. An example is provided in the code snippet below along with environment details.

Code snippet:

<details>

```python
In [1]: import numpy as np

In [2]: import dask.array as da

In [3]: a = np.ones((2, 0, 0))

In [4]: d = da.from_array(a, (1, 0, 0))

In [5]: a.reshape((len(a), -1))
Out[5]: array([], shape=(2, 0), dtype=float64)

In [6]: d.reshape((len(d), -1))
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-6-4a136cd07540> in <module>()
----> 1 d.reshape((len(d), -1))

/zopt/conda2/envs/test/lib/python2.7/site-packages/dask/array/core.pyc in reshape(self, *shape)
   1299         if len(shape) == 1 and not isinstance(shape[0], Number):
   1300             shape = shape[0]
-> 1301         return reshape(self, shape)
   1302 
   1303     @wraps(topk)

/zopt/conda2/envs/test/lib/python2.7/site-packages/dask/array/reshape.pyc in reshape(x, shape)
    178 
    179     # Logic for how to rechunk
--> 180     inchunks, outchunks = reshape_rechunk(x.shape, shape, x.chunks)
    181     x2 = x.rechunk(inchunks)
    182 

/zopt/conda2/envs/test/lib/python2.7/site-packages/dask/array/reshape.pyc in reshape_rechunk(inshape, outshape, inchunks)
     40             while ileft >= 0 and reduce(mul, inshape[ileft:ii + 1]) < dout: # 4 < 64, 4*4 < 64, 4*4*4 == 64
     41                 ileft -= 1
---> 42             if reduce(mul, inshape[ileft:ii + 1]) != dout:
     43                 raise ValueError(""Shapes not compatible"")
     44 

TypeError: reduce() of empty sequence with no initial value
```

</details>

<br>
Environment:
<br>
<br>

<details>

```yaml
name: test
channels:
- conda-forge
- defaults
dependencies:
- appnope=0.1.0=py27_0
- asn1crypto=0.22.0=py27_0
- backports.shutil_get_terminal_size=1.0.0=py27_1
- backports_abc=0.5=py27_0
- bkcharts=0.2=py27_0
- blas=1.1=openblas
- bokeh=0.12.6=py27_0
- ca-certificates=2017.4.17=0
- certifi=2017.4.17=py27_0
- cffi=1.10.0=py27_0
- chardet=3.0.2=py27_1
- click=6.7=py27_0
- cloudpickle=0.3.1=py27_0
- cryptography=1.9=py27_0
- cycler=0.10.0=py27_0
- dask=0.15.1=py27_0
- decorator=4.1.2=py27_0
- distributed=1.18.0=py27_0
- enum34=1.1.6=py27_1
- freetype=2.7=1
- functools32=3.2.3.2=py27_1
- futures=3.0.5=py27_0
- heapdict=1.0.0=py27_0
- idna=2.5=py27_0
- ipaddress=1.0.18=py27_0
- ipython=5.4.1=py27_0
- ipython_genutils=0.2.0=py27_0
- jinja2=2.9.5=py27_0
- libffi=3.2.1=3
- libgfortran=3.0.0=0
- libpng=1.6.28=0
- locket=0.2.0=py27_1
- markupsafe=1.0=py27_0
- matplotlib=2.0.2=np113py27_0
- msgpack-python=0.4.8=py27_0
- ncurses=5.9=10
- numpy=1.13.1=py27_blas_openblas_201
- openblas=0.2.20=1
- openssl=1.0.2l=0
- pandas=0.20.3=py27_1
- partd=0.3.8=py27_0
- pathlib2=2.3.0=py27_0
- pexpect=4.2.1=py27_0
- pickleshare=0.7.3=py27_0
- pip=9.0.1=py27_0
- prompt_toolkit=1.0.14=py27_0
- psutil=5.2.1=py27_0
- ptyprocess=0.5.2=py27_0
- pycparser=2.18=py27_0
- pygments=2.2.0=py27_0
- pyopenssl=16.2.0=py27_0
- pyparsing=2.2.0=py27_0
- pysocks=1.6.7=py27_0
- python=2.7.13=1
- python-dateutil=2.6.1=py27_0
- pytz=2017.2=py27_0
- pyyaml=3.12=py27_1
- readline=6.2=0
- requests=2.18.2=py27_0
- scandir=1.5=py27_1
- setuptools=36.2.2=py27_0
- simplegeneric=0.8.1=py27_0
- singledispatch=3.4.0.3=py27_0
- six=1.10.0=py27_1
- sortedcontainers=1.5.3=py27_0
- sqlite=3.13.0=1
- ssl_match_hostname=3.5.0.1=py27_1
- subprocess32=3.2.7=py27_0
- tblib=1.3.2=py27_0
- tk=8.5.19=1
- toolz=0.8.2=py27_0
- tornado=4.5.1=py27_0
- traitlets=4.3.2=py27_0
- urllib3=1.21.1=py27_1
- wcwidth=0.1.7=py27_0
- wheel=0.29.0=py27_0
- yaml=0.1.6=0
- zict=0.1.2=py27_0
- zlib=1.2.11=0
- pip:
  - backports-abc==0.5
  - backports.shutil-get-terminal-size==1.0.0
  - backports.ssl-match-hostname==3.5.0.1
  - ipython-genutils==0.2.0
  - prompt-toolkit==1.0.14
```

</details>",,https://api.github.com/repos/dask/dask/issues/2561/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2561/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
41,https://api.github.com/repos/dask/dask/issues/2577,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2577/labels{/name},https://api.github.com/repos/dask/dask/issues/2577/comments,https://api.github.com/repos/dask/dask/issues/2577/events,https://github.com/dask/dask/issues/2577,247116399,MDU6SXNzdWUyNDcxMTYzOTk=,2577,Return dependencies in optimization calls,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,4,2017-08-01T15:51:22Z,2021-10-12T01:19:53Z,,MEMBER,,"A non-trivial fraction of our scheduling overhead comes from calculating dependencies of the task graph.  We currently do this redundantly in a few places.  A while ago we changed many of the optimization functions to return both a task graph and the dependencies so that this can be passed along to other optimizations.  However, the full `dd.optimize` or `da.optimize` functions don't do this, they only return the task graph.

I am inclined to change this, so that top-level optimization functions also return dependencies.  This will help us to reduce overhead costs.  However, this also is a break to top-level API and will break user code from some more advanced users and so perhaps warrants some discussion.

cc @shoyer @jcrist ",,https://api.github.com/repos/dask/dask/issues/2577/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2577/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
42,https://api.github.com/repos/dask/dask/issues/2618,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2618/labels{/name},https://api.github.com/repos/dask/dask/issues/2618/comments,https://api.github.com/repos/dask/dask/issues/2618/events,https://github.com/dask/dask/issues/2618,251338352,MDU6SXNzdWUyNTEzMzgzNTI=,2618,Adding eigenvalue and eigenvector computations,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,15,2017-08-18T19:31:18Z,2021-09-10T20:20:38Z,,MEMBER,,"NumPy's [`linalg`]( https://docs.scipy.org/doc/numpy/reference/routines.linalg.html ) includes a variety of eigenvalue and eigenvector functions (e.g. [`eig`, `eigh`, `eigvals`, `eigvalsh`]( https://docs.scipy.org/doc/numpy/reference/routines.linalg.html#matrix-eigenvalues )). Would be nice to include these in Dask Array's `linalg` as well.

This came up on StackOverflow as well. ( https://stackoverflow.com/q/44806395/3877089 )",,https://api.github.com/repos/dask/dask/issues/2618/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2618/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
43,https://api.github.com/repos/dask/dask/issues/2620,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2620/labels{/name},https://api.github.com/repos/dask/dask/issues/2620/comments,https://api.github.com/repos/dask/dask/issues/2620/events,https://github.com/dask/dask/issues/2620,252603298,MDU6SXNzdWUyNTI2MDMyOTg=,2620,Chunked FFTs,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,15,2017-08-24T13:34:13Z,2021-02-16T05:35:10Z,,MEMBER,,"Admittedly this is a bit of a tricky topic, but it would be very helpful if we were able to perform FFTs over axes that have more than one chunk. This could help lighten the memory requirements in some cases and avoid potentially needing to rechunk the data.",,https://api.github.com/repos/dask/dask/issues/2620/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2620/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
44,https://api.github.com/repos/dask/dask/issues/2629,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2629/labels{/name},https://api.github.com/repos/dask/dask/issues/2629/comments,https://api.github.com/repos/dask/dask/issues/2629/events,https://github.com/dask/dask/issues/2629,253049206,MDU6SXNzdWUyNTMwNDkyMDY=,2629,Implementation of scipy.integrate.simps,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,7,2017-08-26T01:00:18Z,2023-03-01T21:27:54Z,,NONE,,"Are there plans to implement `scipy.integrate.simps`? 
It is a pretty useful method that would easily gain from chunking (when integration is done down one axis of a multi-N array).",,https://api.github.com/repos/dask/dask/issues/2629/timeline,,,Joshuaalbert,14807032,MDQ6VXNlcjE0ODA3MDMy,https://avatars.githubusercontent.com/u/14807032?v=4,,https://api.github.com/users/Joshuaalbert,https://github.com/Joshuaalbert,https://api.github.com/users/Joshuaalbert/followers,https://api.github.com/users/Joshuaalbert/following{/other_user},https://api.github.com/users/Joshuaalbert/gists{/gist_id},https://api.github.com/users/Joshuaalbert/starred{/owner}{/repo},https://api.github.com/users/Joshuaalbert/subscriptions,https://api.github.com/users/Joshuaalbert/orgs,https://api.github.com/users/Joshuaalbert/repos,https://api.github.com/users/Joshuaalbert/events{/privacy},https://api.github.com/users/Joshuaalbert/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2629/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
45,https://api.github.com/repos/dask/dask/issues/2648,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2648/labels{/name},https://api.github.com/repos/dask/dask/issues/2648/comments,https://api.github.com/repos/dask/dask/issues/2648/events,https://github.com/dask/dask/issues/2648,254684474,MDU6SXNzdWUyNTQ2ODQ0NzQ=,2648,Optimization of commutable operations,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,8,2017-09-01T16:01:28Z,2021-10-12T00:49:36Z,,MEMBER,,"Some (mathematical) operations are commutable (e.g. `+`). In cases where a commutable operator is found, it would be nice to ""sort"" the arguments in a standard way. Thus if the user writes something like `a + b` at one point and `b + a` at another, these will both be replaced by `a + b` thus computing it only once.

Just for additional context, running the code below results in the comparison being computed twice. Namely `d_a[0] == d_a[1]` is the same as `d_a[1] == d_a[0]`. So it would be better to compute one of them, say `d_a[0] == d_a[1]`, and replace the other one, `d_a[1] == d_a[0]`, with the result of the first computation. By inspecting the graph from this result, we can see the comparison does get computed two different ways instead of taking advantage of commutation.

Code:

<details>

```python
In [1]: import numpy as np

In [2]: import dask.array as da

In [3]: a = np.arange(6).reshape(2, 3)

In [4]: d_a = da.from_array(a, chunks=(1, 3))

In [5]: d_r = (d_a[0] == d_a[1]).astype(int) + (d_a[1] == d_a[0]).astype(int)

In [6]: d_r.visualize()
Out[6]: <IPython.core.display.Image object>
```

</details>

<br>

Graph:

<details>

![mydask](https://user-images.githubusercontent.com/3019665/29977602-f3ffa1fa-8f0b-11e7-90aa-0d26bb14ae38.png)

</details>",,https://api.github.com/repos/dask/dask/issues/2648/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2648/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
46,https://api.github.com/repos/dask/dask/issues/2670,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2670/labels{/name},https://api.github.com/repos/dask/dask/issues/2670/comments,https://api.github.com/repos/dask/dask/issues/2670/events,https://github.com/dask/dask/issues/2670,256336166,MDU6SXNzdWUyNTYzMzYxNjY=,2670,"Irrelevant columns breaking dask groupby vars, but not means (and not in pandas)","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,4,2017-09-08T18:31:21Z,2021-10-12T00:50:43Z,,NONE,,"This is from user Laszlo on Stackoverflow (https://stackoverflow.com/questions/46115779/irrelevant-columns-breaking-dask-groupby-vars-but-not-means-and-not-in-pandas)

Below is the MCVE of the behavior of an up-to-date dask instance on my system, and contrasts the dask error with pandas using the small CSV quoted at the end of this question.

Setup:

```
import numpy as np
import dask.dataframe as dd
df = dd.read_csv('hmda_lar_head_4var.csv',
                 engine='c',
                 usecols=['tract_to_msamd_income','as_of_year','agency_abbr','action_taken_name'],
                 dtype={'tract_to_msamd_income': np.float64,
                        'as_of_year':np.uint16,
                        'agency_abbr':'category',
                        'action_taken_name':'category'
                       })
```
The line that breaks: df.groupby('as_of_year').var().compute()

The error:

```
---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/dataframe/utils.py in raise_on_meta_error(funcname)
    136     try:
--> 137         yield
    138     except Exception as e:


/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/dataframe/core.py in _emulate(func, *args, **kwargs)
   3058     with raise_on_meta_error(funcname(func)):
-> 3059         return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))
   3060 


/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/compatibility.py in apply(func, args, kwargs)
     46         if kwargs:
---> 47             return func(*args, **kwargs)
     48         else:


/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/dataframe/groupby.py in _var_agg(g, levels, ddof)
    210     result /= div
--> 211     result[(n - ddof) == 0] = np.nan
    212     assert isinstance(result, pd.DataFrame)


/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/pandas/core/frame.py in __setitem__(self, key, value)
   2425         elif isinstance(key, DataFrame):
-> 2426             self._setitem_frame(key, value)
   2427         else:


/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/pandas/core/frame.py in _setitem_frame(self, key, value)
   2463         self._check_setitem_copy()
-> 2464         self._where(-key, value, inplace=True)
   2465 


/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/pandas/core/generic.py in _where(self, cond, other, inplace, axis, level, try_cast, raise_on_error)
   4952                 if not is_bool_dtype(dt):
-> 4953                     raise ValueError(msg.format(dtype=dt))
   4954 


ValueError: Boolean array expected for the condition, not float64


During handling of the above exception, another exception occurred:


ValueError                                Traceback (most recent call last)

<ipython-input-154-4d73414200e5> in <module>()
----> 1 df.groupby('as_of_year').var().compute()


/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/dataframe/groupby.py in var(self, ddof, split_every, split_out)
    796                      combine_kwargs={'levels': levels},
    797                      split_every=split_every, split_out=split_out,
--> 798                      split_out_setup=split_out_on_index)
    799 
    800         if isinstance(self.obj, Series):


/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/dataframe/core.py in apply_concat_apply(args, chunk, aggregate, combine, meta, token, chunk_kwargs, aggregate_kwargs, combine_kwargs, split_every, split_out, split_out_setup, split_out_setup_kwargs, **kwargs)
   3010         meta_chunk = _emulate(apply, chunk, args, chunk_kwargs)
   3011         meta = _emulate(apply, aggregate, [_concat([meta_chunk])],
-> 3012                         aggregate_kwargs)
   3013     meta = make_meta(meta)
   3014 


/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/dataframe/core.py in _emulate(func, *args, **kwargs)
   3057     """"""
   3058     with raise_on_meta_error(funcname(func)):
-> 3059         return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))
   3060 
   3061 


/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/contextlib.py in __exit__(self, type, value, traceback)
     75                 value = type()
     76             try:
---> 77                 self.gen.throw(type, value, traceback)
     78                 raise RuntimeError(""generator didn't stop after throw()"")
     79             except StopIteration as exc:


/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/dataframe/utils.py in raise_on_meta_error(funcname)
    148                ).format("" in `{0}`"".format(funcname) if funcname else """",
    149                         repr(e), tb)
--> 150         raise ValueError(msg)
    151 
    152 


ValueError: Metadata inference failed in `apply`.

Original error is below:
------------------------
ValueError('Boolean array expected for the condition, not float64',)

Traceback:
---------
  File ""/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/dataframe/utils.py"", line 137, in raise_on_meta_error
    yield
  File ""/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/dataframe/core.py"", line 3059, in _emulate
    return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))
  File ""/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/compatibility.py"", line 47, in apply
    return func(*args, **kwargs)
  File ""/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/dask/dataframe/groupby.py"", line 211, in _var_agg
    result[(n - ddof) == 0] = np.nan
  File ""/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/pandas/core/frame.py"", line 2426, in __setitem__
    self._setitem_frame(key, value)
  File ""/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/pandas/core/frame.py"", line 2464, in _setitem_frame
    self._where(-key, value, inplace=True)
  File ""/Users/laszlo.sandor/miniconda3/envs/idp/lib/python3.5/site-packages/pandas/core/generic.py"", line 4953, in _where
    raise ValueError(msg.format(dtype=dt))
Compare this with the behavior of the line that produces correct results: df.groupby('as_of_year').mean().compute()

```
If you set things up in supposedly similar pandas:

```
import pandas as pd
df = pd.read_csv('hmda_lar_head_4var.csv',
                 engine='c',
                 usecols=['tract_to_msamd_income','as_of_year','agency_abbr','action_taken_name'],
                 dtype={'tract_to_msamd_income': np.float64,
                        'as_of_year':np.uint16,
                        'agency_abbr':'category',
                        'action_taken_name':'category'
                       })
```
You see that both df.groupby('as_of_year').var() and df.groupby('as_of_year').mean() produce the correct results.

If you load only two columns, one you are grouping by and another that is meaningful to report the variance for, dask has no problem reporting the variance:

```
import numpy as np
import dask.dataframe as dd
df = dd.read_csv('hmda_lar_head_4var.csv',
                 engine='c',
                 usecols=['tract_to_msamd_income','as_of_year'],
                 dtype={'tract_to_msamd_income': np.float64,
                        'as_of_year':np.uint16
                       })
```
This is small comfort, as (I think) you cannot easily specify which columns to calculate groupby methods for, only select ones to report. I.e. some columns can break dask groupby var even if you ask to report only other columns.

Here is the CSV for MCVE:

tract_to_msamd_income,as_of_year,agency_abbr,action_taken_name ""85.02999877929688"",""2007"",""FRS"",""Loan originated"" ""103.12000274658203"",""2007"",""FRS"",""Application withdrawn by applicant"" ""127.87000274658203"",""2007"",""FRS"",""Loan originated"" ""103.12000274658203"",""2007"",""FRS"",""Application denied by financial institution"" ""131.14999389648438"",""2007"",""FRS"",""Loan originated"" ""85.02999877929688"",""2007"",""FRS"",""Application withdrawn by applicant"" ""103.12000274658203"",""2007"",""FRS"",""Application withdrawn by applicant"" ""95.76000213623047"",""2007"",""FRS"",""Loan originated"" ""103.12000274658203"",""2007"",""FRS"",""Application withdrawn by applicant""",,https://api.github.com/repos/dask/dask/issues/2670/timeline,,,Developer4190,27331480,MDQ6VXNlcjI3MzMxNDgw,https://avatars.githubusercontent.com/u/27331480?v=4,,https://api.github.com/users/Developer4190,https://github.com/Developer4190,https://api.github.com/users/Developer4190/followers,https://api.github.com/users/Developer4190/following{/other_user},https://api.github.com/users/Developer4190/gists{/gist_id},https://api.github.com/users/Developer4190/starred{/owner}{/repo},https://api.github.com/users/Developer4190/subscriptions,https://api.github.com/users/Developer4190/orgs,https://api.github.com/users/Developer4190/repos,https://api.github.com/users/Developer4190/events{/privacy},https://api.github.com/users/Developer4190/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2670/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
47,https://api.github.com/repos/dask/dask/issues/2682,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2682/labels{/name},https://api.github.com/repos/dask/dask/issues/2682/comments,https://api.github.com/repos/dask/dask/issues/2682/events,https://github.com/dask/dask/issues/2682,257874977,MDU6SXNzdWUyNTc4NzQ5Nzc=,2682,Add a tests for our tests helpers,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}]",open,False,,[],,4,2017-09-14T22:28:25Z,2024-04-28T07:03:43Z,,MEMBER,,"Dask uses a couple `assert_eq` helpers for easily testing the equality of the result of a computation (a `dask.array` or `dask.dataframe` say) to the expected value (`np.array`, `pd.DataFrame)`. It'd be nice to have some tests for these helpers to ensure they're functioning properly

- array: https://github.com/dask/dask/blob/a1a75a766243f1f84ac1df502de3faf8ce4ebc81/dask/array/utils.py#L62
- dataframe: https://github.com/dask/dask/blob/a1a75a766243f1f84ac1df502de3faf8ce4ebc81/dask/dataframe/utils.py#L553

See https://github.com/dask/dask/pull/2681/files#diff-20d741e3b309789af8da0fbc2663f964 for an example of the kinds of tests we would be good to have.",,https://api.github.com/repos/dask/dask/issues/2682/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2682/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
48,https://api.github.com/repos/dask/dask/issues/2716,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2716/labels{/name},https://api.github.com/repos/dask/dask/issues/2716/comments,https://api.github.com/repos/dask/dask/issues/2716/events,https://github.com/dask/dask/issues/2716,260374213,MDU6SXNzdWUyNjAzNzQyMTM=,2716,Get metadata from the Hive metastore,[],open,False,,[],,14,2017-09-25T18:36:49Z,2021-02-04T21:21:08Z,,MEMBER,,"Many big data deployments keep metadata about their data artifacts in the hive metastore, even if they don't use hive itself.  We've frequently received requests to support this.  I believe that this would involve building a small `dask-hive` Python project that communicated with the Hive metastore through thrift.

cc @mariusvniekerk @martindurant @seibert ",,https://api.github.com/repos/dask/dask/issues/2716/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2716/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
49,https://api.github.com/repos/dask/dask/issues/2721,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2721/labels{/name},https://api.github.com/repos/dask/dask/issues/2721/comments,https://api.github.com/repos/dask/dask/issues/2721/events,https://github.com/dask/dask/issues/2721,260997760,MDU6SXNzdWUyNjA5OTc3NjA=,2721,Add isscalar,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2017-09-27T14:33:40Z,2017-12-05T02:20:25Z,,MEMBER,,Would be nice to have an implementation of [`isscalar`]( https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.isscalar.html ) for Dask Array. Guessing this should be simple enough. Though there might be some corner cases (e.g. 0-D arrays) that might need some extra thought.,,https://api.github.com/repos/dask/dask/issues/2721/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2721/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
50,https://api.github.com/repos/dask/dask/issues/2793,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2793/labels{/name},https://api.github.com/repos/dask/dask/issues/2793/comments,https://api.github.com/repos/dask/dask/issues/2793/events,https://github.com/dask/dask/issues/2793,266665397,MDU6SXNzdWUyNjY2NjUzOTc=,2793,argmin/argmax fail on unknown shape,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2017-10-18T22:40:39Z,2017-10-18T22:50:23Z,,MEMBER,,"If a Dask Array has known shape, `argmin` and `argmax` work fine. If one of the dimensions of the array is unknown, the Dask graph can be constructed fine, but computation fails. It seems this problem is connected to the underlying reduction using the shape from the Dask Array even though some values are not finalized (i.e. `nan`).

An example is shown below and the `conda` environment used to create it in included as well. The example just uses `argmin` for simplicity, but `argmax` can reproduce it just as well.

<details>
<summary>Example:</summary>

```python
In [1]: import dask.array as da

In [2]: a = da.arange(5, chunks=2)

In [3]: da.argmin(a)
Out[3]: dask.array<arg_agg-aggregate, shape=(), dtype=int64, chunksize=()>

In [4]: da.argmin(a).compute()
Out[4]: 0

In [5]: a[a < 2]
Out[5]: dask.array<getitem, shape=(nan,), dtype=int64, chunksize=(nan,)>

In [6]: a[a < 2].compute()
Out[6]: array([0, 1])

In [7]: da.argmin(a[a < 2])
Out[7]: dask.array<arg_agg-aggregate, shape=(), dtype=int64, chunksize=()>

In [8]: da.argmin(a[a < 2]).compute()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-8-cdeeefd60de4> in <module>()
----> 1 da.argmin(a[a < 2]).compute()

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/base.py in compute(self, **kwargs)
     97             Extra keywords to forward to the scheduler ``get`` function.
     98         """"""
---> 99         (result,) = compute(self, traverse=False, **kwargs)
    100         return result
    101 

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/base.py in compute(*args, **kwargs)
    204     dsk = collections_to_dsk(variables, optimize_graph, **kwargs)
    205     keys = [var._keys() for var in variables]
--> 206     results = get(dsk, keys, **kwargs)
    207 
    208     results_iter = iter(results)

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/threaded.py in get(dsk, result, cache, num_workers, **kwargs)
     73     results = get_async(pool.apply_async, len(pool._pool), dsk, result,
     74                         cache=cache, get_id=_thread_get_id,
---> 75                         pack_exception=pack_exception, **kwargs)
     76 
     77     # Cleanup pools associated to dead threads

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    519                         _execute_task(task, data)  # Re-execute locally
    520                     else:
--> 521                         raise_exception(exc, tb)
    522                 res, worker_id = loads(res_info)
    523                 state['cache'][key] = res

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/compatibility.py in reraise(exc, tb)
     58         if exc.__traceback__ is not tb:
     59             raise exc.with_traceback(tb)
---> 60         raise exc
     61 
     62 else:

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    288     try:
    289         task, data = loads(task_info)
--> 290         result = _execute_task(task, data)
    291         id = get_id()
    292         result = dumps((result, id))

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/local.py in _execute_task(arg, cache, dsk)
    269         func, args = arg[0], arg[1:]
    270         args2 = [_execute_task(a, cache) for a in args]
--> 271         return func(*args2)
    272     elif not ishashable(arg):
    273         return arg

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/array/reductions.py in arg_chunk(func, argfunc, x, axis, offset_info)
    486         ind = np.unravel_index(arg.ravel()[0], x.shape)
    487         total_ind = tuple(o + i for (o, i) in zip(offset, ind))
--> 488         arg[:] = np.ravel_multi_index(total_ind, total_shape)
    489     else:
    490         arg += offset_info

TypeError: 'float' object cannot be interpreted as an integer
```

</details>

<br>

<details>
<summary>Environment:</summary>

```yaml
name: test
channels:
- conda-forge
- defaults
dependencies:
- appnope=0.1.0=py36_0
- blas=1.1=openblas
- bokeh=0.12.9=py36_0
- ca-certificates=2017.7.27.1=0
- certifi=2017.7.27.1=py36_0
- click=6.7=py36_0
- cloudpickle=0.4.0=py36_0
- dask=0.15.4=py_0
- dask-core=0.15.4=py_0
- decorator=4.1.2=py36_0
- distributed=1.19.3=py36_0
- heapdict=1.0.0=py36_0
- ipython=6.2.1=py36_0
- ipython_genutils=0.2.0=py36_0
- jedi=0.10.2=py36_0
- jinja2=2.9.6=py36_0
- libgfortran=3.0.0=0
- locket=0.2.0=py36_1
- markupsafe=1.0=py36_0
- msgpack-python=0.4.8=py36_0
- ncurses=5.9=10
- numpy=1.13.3=py36_blas_openblas_200
- openblas=0.2.19=2
- openssl=1.0.2l=0
- pandas=0.20.3=py36_1
- partd=0.3.8=py36_0
- pexpect=4.2.1=py36_0
- pickleshare=0.7.4=py36_0
- pip=9.0.1=py36_0
- prompt_toolkit=1.0.15=py36_0
- psutil=5.3.1=py36_0
- ptyprocess=0.5.2=py36_0
- pygments=2.2.0=py36_0
- python=3.6.3=0
- python-dateutil=2.6.1=py36_0
- pytz=2017.2=py36_0
- pyyaml=3.12=py36_1
- readline=6.2=0
- setuptools=36.6.0=py36_1
- simplegeneric=0.8.1=py36_0
- six=1.11.0=py36_1
- sortedcontainers=1.5.7=py36_0
- sqlite=3.13.0=1
- tblib=1.3.2=py36_0
- tk=8.5.19=2
- toolz=0.8.2=py_2
- tornado=4.5.2=py36_0
- traitlets=4.3.2=py36_0
- wcwidth=0.1.7=py36_0
- wheel=0.30.0=py_1
- xz=5.2.3=0
- yaml=0.1.6=0
- zict=0.1.3=py_0
- zlib=1.2.8=3
```

</details>",,https://api.github.com/repos/dask/dask/issues/2793/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2793/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
51,https://api.github.com/repos/dask/dask/issues/2812,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2812/labels{/name},https://api.github.com/repos/dask/dask/issues/2812/comments,https://api.github.com/repos/dask/dask/issues/2812/events,https://github.com/dask/dask/issues/2812,267794023,MDU6SXNzdWUyNjc3OTQwMjM=,2812,List optional cytoolz dependency,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}]",open,False,,[],,9,2017-10-23T19:47:44Z,2021-10-12T03:31:42Z,,MEMBER,,Would be nice if somehow `cytoolz` was noted as an optional dependency in `setup.py`. Not totally sure the right place to add it though.,,https://api.github.com/repos/dask/dask/issues/2812/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2812/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
52,https://api.github.com/repos/dask/dask/issues/2824,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2824/labels{/name},https://api.github.com/repos/dask/dask/issues/2824/comments,https://api.github.com/repos/dask/dask/issues/2824/events,https://github.com/dask/dask/issues/2824,268747117,MDU6SXNzdWUyNjg3NDcxMTc=,2824,Add axis= keyword to percentile,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,8,2017-10-26T12:50:01Z,2024-01-31T22:09:10Z,,MEMBER,,Originally reported by @ogrisel and @jorisvandenbossche in https://github.com/dask/dask-ml/pull/62#pullrequestreview-71802786,,https://api.github.com/repos/dask/dask/issues/2824/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2824/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
53,https://api.github.com/repos/dask/dask/issues/2829,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2829/labels{/name},https://api.github.com/repos/dask/dask/issues/2829/comments,https://api.github.com/repos/dask/dask/issues/2829/events,https://github.com/dask/dask/issues/2829,268963721,MDU6SXNzdWUyNjg5NjM3MjE=,2829,Add Categorical.from_codes,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2017-10-27T01:49:40Z,2020-02-27T13:46:31Z,,MEMBER,,"I had a need for this today. I think something like

```python
In [74]: categories = ['a', 'b', 'c']

In [75]: codes = da.random.randint(0, 4, size=100, chunks=50)

In [76]: (dd.from_dask_array(codes)
    ...:    .astype('category')
    ...:    .cat.set_categories(np.arange(len(categories)))
    ...:    .cat.rename_categories(categories))
    ...:
    ...:
Out[76]:
Dask Series Structure:
npartitions=2
0     category[known]
50                ...
99                ...
dtype: category
Dask Name: cat, 10 tasks
```

will work (may not be optimal though). The more awkward part is finding where to put that, since dask doesn't have a `Categorical`, so maybe just a top-level function?",,https://api.github.com/repos/dask/dask/issues/2829/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2829/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
54,https://api.github.com/repos/dask/dask/issues/2840,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2840/labels{/name},https://api.github.com/repos/dask/dask/issues/2840/comments,https://api.github.com/repos/dask/dask/issues/2840/events,https://github.com/dask/dask/issues/2840,269440565,MDU6SXNzdWUyNjk0NDA1NjU=,2840,Unexpected sort on binop between Dask.dataframe and pandas.Series,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2017-10-29T21:58:31Z,2017-10-29T23:14:59Z,,MEMBER,,"```python
import numpy as np
import pandas as pd
import dask.dataframe as dd
from dask.dataframe.utils import assert_eq


def test_binop():
    df = pd.DataFrame(np.random.uniform(size=(5, 11))).rename(columns=str)
    ddf = dd.from_pandas(df, 2)

    result = ddf / ddf.mean(0).compute()
    expected = df / df.mean(0)
    assert_eq(result, expected)
```

```python

In [29]: result.columns
Out[29]: Index(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11'], dtype='object')

In [30]: result.compute().columns
Out[30]: Index(['0', '1', '10', '11', '2', '3', '4', '5', '6', '7', '8', '9'], dtype='object')
```",,https://api.github.com/repos/dask/dask/issues/2840/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2840/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
55,https://api.github.com/repos/dask/dask/issues/2851,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2851/labels{/name},https://api.github.com/repos/dask/dask/issues/2851/comments,https://api.github.com/repos/dask/dask/issues/2851/events,https://github.com/dask/dask/issues/2851,270173309,MDU6SXNzdWUyNzAxNzMzMDk=,2851,Using tree reductions with unique,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2017-11-01T02:19:08Z,2018-10-18T19:50:03Z,,MEMBER,,"The current `unique` implementation, while lazy, does not currently leverage tree reductions akin to those used for things like `sum`. These tree reductions allow operations to be computed over each chunk and then reduce small groups of chunks into a smaller group of new chunks that can be further reduced until only one small chunk remains. Through this process it is possible to work with much larger pieces of data. To allow `unique` to work on larger pieces of data, it would be nice to leverage this tree reduction strategy in its implementation.

Currently `unique` makes use of a wrapper function `_unique_internal`, which makes it pretty easy to support `unique` with various optional extra results. This function is well designed for performing more complex reductions by supporting reductions of the other arguments as well. So there shouldn't really be any retuning of `unique` needed for this change.

It is almost possible to implement `unique` using the existing reduction utilities in [`dask.array.reductions`]( https://github.com/dask/dask/blob/b9e3487a963b574f91eb403fdfc0baf1bc97d2eb/dask/array/reductions.py ) except that these functions seem to assume that a reduction results in a chunk with a single element (or one element for a dimension). However `unique` may return an unknown number of elements that could range from one to the length of the data itself. Hence we would need a way to explain that the chunks from each reduction may have a different or indeterminate size. Perhaps another argument to `reduction` and `_tree_reduce` is all that is needed.",,https://api.github.com/repos/dask/dask/issues/2851/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2851/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
56,https://api.github.com/repos/dask/dask/issues/2882,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2882/labels{/name},https://api.github.com/repos/dask/dask/issues/2882/comments,https://api.github.com/repos/dask/dask/issues/2882/events,https://github.com/dask/dask/issues/2882,273259213,MDU6SXNzdWUyNzMyNTkyMTM=,2882,Outer indexing support,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2017-11-12T19:51:44Z,2017-11-18T23:44:11Z,,MEMBER,,"xarray, netCDF4-Python and now zarr (https://github.com/alimanfoo/zarr/pull/172) support a form of ""outer indexing"", where each axis is indexed independently, without broadcasting. See `oindex` in @seberg's draft NEP for details: https://github.com/numpy/numpy/pull/6256.

In dask, we currently support a subset of this behavior, allowing for only at most one list-like indexing. This is almost (but [not always](https://github.com/alimanfoo/zarr/pull/172#issuecomment-340745599)) consistent with NumPy's standard indexing.

It would be nice to have a dedicated indexing method that support outer indexing along multiple dimensions at once. This would allow xarray to remove [some hacks](https://github.com/pydata/xarray/blob/master/xarray/core/indexing.py#L548-L556) it currently has to implement outer indexing in dask, and potentially allow dask array's optimization rules to consolidate repeated outer indexing.",,https://api.github.com/repos/dask/dask/issues/2882/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2882/reactions,4,4,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
57,https://api.github.com/repos/dask/dask/issues/2883,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2883/labels{/name},https://api.github.com/repos/dask/dask/issues/2883/comments,https://api.github.com/repos/dask/dask/issues/2883/events,https://github.com/dask/dask/issues/2883,273261092,MDU6SXNzdWUyNzMyNjEwOTI=,2883,Explicitly handle array indexing types in dask.array.from_array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2017-11-12T20:16:29Z,2017-11-18T23:44:01Z,,MEMBER,,"Over in https://github.com/dask/dask/pull/1776, @laliberte tried to fix a bug resulting from a combination between array optimization and inconsistencies with how different types of wrapped arrays handle indexing.

The immediate issue was fixed by disabling some optimizations. However, I still think it would be a good idea to explicitly indicate the types of indexing allowed by wrapped arrays. This would allow us to optimize more of these cases, and avoid bugs due to unclear behavior (see, e.g., https://github.com/pydata/xarray/pull/1705 for some corresponding clean-up in xarray).

Based on our experience with xarray, there are three main cases that need to be considered:
- ""Basic"" indexing that only supports integers and slices. This is common for simple array types, but probably doesn't need explicit support in dask.
- ""Outer"" indexing (xref https://github.com/dask/dask/issues/2882 for support in dask). This includes netCDF4-Python, h5py (for one list-like indexer) and now zarr (https://github.com/alimanfoo/zarr/pull/172). Any combination of multiple outer and basic indexing calls can be optimized into a single outer indexer.
- ""Vectorized"" or ""Fancy"" indexing of some form. This includes NumPy and zarr, and for dask would be an indication that optimization consolidating indexing calls is probably not feasible.

I see two possible solutions:
- An additional argument of some sort to `from_array` that allows for explicitly indicating that an argument supports a particular form of indexing. This is what was implemented in #1776. However, it requires knowing the type of indexing that will be done on an object before the indexing actually happens, which is not always possible or convenient.
- Some way of passing *multiple* indexable objects to `from_array`, exposing different ways of indexing the same data. For example, `outer_indexable` and `vectorized_indexable` keywords arguments could be used to expose the multiple ways in which a NumPy array or zarr array can be indexed. Dask's indexing routines would be updated to index the appropriate array based on how they were called.

CC @alimanfoo, @fujiisoup ",,https://api.github.com/repos/dask/dask/issues/2883/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2883/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
58,https://api.github.com/repos/dask/dask/issues/2893,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2893/labels{/name},https://api.github.com/repos/dask/dask/issues/2893/comments,https://api.github.com/repos/dask/dask/issues/2893/events,https://github.com/dask/dask/issues/2893,273932739,MDU6SXNzdWUyNzM5MzI3Mzk=,2893,Groupby with a tuple key for the grouper,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,0,2017-11-14T20:31:47Z,2017-11-14T20:31:47Z,,MEMBER,,"xref https://github.com/dask/dask/pull/2892 and https://github.com/pandas-dev/pandas/commit/4c6387520e

Not sure this is worth supporting if it's difficult to implement. If not, then we should raise a better error message.

Here's a failing test:

```python
def test_groupby_tuple_key():
    df = pd.DataFrame({('a', 'b'): [1, 1, 2, 2], 'a': [1, 1, 1, 2],
                       'b': [1, 2, 2, 2], 'c': [1, 1, 1, 1]})
    ddf = dd.from_pandas(df, npartitions=2)

    result = ddf.groupby(('a', 'b')).c.count()
    expected = df.groupby(('a', 'b')).c.count()
    assert_eq(result, expected)

    result = ddf.groupby(['a', 'b']).c.count()
    expected = df.groupby(['a', 'b']).c.count()
    assert_eq(result, expected)
```",,https://api.github.com/repos/dask/dask/issues/2893/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2893/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
59,https://api.github.com/repos/dask/dask/issues/2900,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2900/labels{/name},https://api.github.com/repos/dask/dask/issues/2900/comments,https://api.github.com/repos/dask/dask/issues/2900/events,https://github.com/dask/dask/issues/2900,275109796,MDU6SXNzdWUyNzUxMDk3OTY=,2900,More expressive error message for read_sql_table (when partition is empty),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,7,2017-11-18T21:04:59Z,2021-10-12T03:06:04Z,,NONE,,"If an SQL clause does not return any data - e.g. a view has been written to be non-deterministic (rightly or wrongly!) then Dask gives the following error message. It would be more helpful to be informed that the dataframe for a given partition is empty. That's all, thanks.

---

ValueError: Metadata mismatch found in `from_delayed`.

Partition type: `DataFrame`
+-------------------+--------+----------+
| Column            | Found  | Expected |
+-------------------+--------+----------+
| col_b | object | int64    |
| col_a   | object | int64    |
+-------------------+--------+----------+",,https://api.github.com/repos/dask/dask/issues/2900/timeline,,,morganics,16958906,MDQ6VXNlcjE2OTU4OTA2,https://avatars.githubusercontent.com/u/16958906?v=4,,https://api.github.com/users/morganics,https://github.com/morganics,https://api.github.com/users/morganics/followers,https://api.github.com/users/morganics/following{/other_user},https://api.github.com/users/morganics/gists{/gist_id},https://api.github.com/users/morganics/starred{/owner}{/repo},https://api.github.com/users/morganics/subscriptions,https://api.github.com/users/morganics/orgs,https://api.github.com/users/morganics/repos,https://api.github.com/users/morganics/events{/privacy},https://api.github.com/users/morganics/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2900/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
60,https://api.github.com/repos/dask/dask/issues/2911,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2911/labels{/name},https://api.github.com/repos/dask/dask/issues/2911/comments,https://api.github.com/repos/dask/dask/issues/2911/events,https://github.com/dask/dask/issues/2911,275234478,MDU6SXNzdWUyNzUyMzQ0Nzg=,2911,Checklist of NumPy functions in Dask Array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,15,2017-11-20T04:31:10Z,2022-05-05T18:21:53Z,,MEMBER,,"Below is a rough list of functions in NumPy that may be useful in Dask Array. This has been curated based on what may be manageable in Dask. Sorting operations have been dropped for instance.

* [x] abs
* [x] absolute
* [x] add
* [x] all
* [x] allclose
* [x] amax
* [x] amin
* [x] angle
* [x] any
* [ ] append
* [x] apply_along_axis
* [x] apply_over_axes
* [x] arange
* [x] arccos
* [x] arccosh
* [x] arcsin
* [x] arcsinh
* [x] arctan
* [x] arctan2
* [x] arctanh
* [x] argmax
* [x] argmin
* [x] argwhere
* [x] around
* [ ] array_equal
* [ ] array_equiv
* [ ] array_split
* [x] asanyarray
* [x] asarray
* [ ] asarray_chkfinite
* [ ] asscalar
* [x] atleast_1d
* [x] atleast_2d
* [x] atleast_3d
* [x] average
* [ ] bartlett
* [x] bincount
* [x] bitwise_and
* [x] bitwise_not
* [x] bitwise_or
* [x] bitwise_xor
* [ ] blackman
* [x] block
* [ ] bmat
* [ ] broadcast
* [x] broadcast_arrays
* [x] broadcast_to
* [ ] c_
* [ ] can_cast
* [ ] cast
* [x] cbrt
* [x] ceil
* [x] choose
* [x] clip
* [ ] column_stack
* [x] compress
* [x] concatenate
* [x] conj
* [x] conjugate
* [ ] convolve
* [ ] copy
* [x] copysign
* [x] corrcoef
* [ ] correlate
* [x] cos
* [x] cosh
* [x] count_nonzero
* [x] cov
* [ ] cross
* [x] cumprod
* [x] cumsum
* [x] deg2rad
* [x] degrees
* [ ] delete
* [x] diag
* [ ] diag_indices
* [ ] diag_indices_from
* [ ] diagflat
* [x] diagonal
* [x] diff
* [x] digitize
* [x] divide
* [ ] division
* [x] divmod
* [x] dot
* [ ] dsplit
* [x] dstack
* [x] ediff1d
* [x] einsum
* [x] empty
* [x] empty_like
* [x] equal
* [ ] euler_gamma
* [x] exp
* [x] exp2
* [ ] expand_dims
* [x] expm1
* [x] extract
* [x] eye
* [x] fabs
* [ ] fill_diagonal
* [x] fix
* [x] flatnonzero
* [x] flip
* [x] fliplr
* [x] flipud
* [x] float_power
* [x] floor
* [x] floor_divide
* [x] fmax
* [x] fmin
* [x] fmod
* [x] frexp
* [x] fromfunction
* [x] frompyfunc
* [x] full
* [x] full_like
* [ ] fv
* [ ] geomspace
* [x] gradient
* [x] greater
* [x] greater_equal
* [ ] hamming
* [ ] hanning
* [ ] heaviside
* [x] histogram
* [x] histogram2d
* [x] histogramdd
* [ ] hsplit
* [x] hstack
* [x] hypot
* [x] i0
* [ ] identity
* [x] imag
* [ ] in1d
* [ ] index_exp
* [x] indices
* [ ] inexact
* [ ] inner
* [ ] insert
* [ ] interp
* [ ] intersect1d
* [x] invert
* [ ] ipmt
* [ ] irr
* [x] isclose
* [x] iscomplex
* [ ] iscomplexobj
* [x] isfinite
* [x] isin
* [x] isinf
* [x] isnan
* [ ] isnat
* [x] isneginf
* [x] isposinf
* [x] isreal
* [ ] isrealobj
* [ ] isscalar
* [ ] ix_
* [ ] kaiser
* [ ] kron
* [x] ldexp
* [x] left_shift
* [x] less
* [x] less_equal
* [x] linspace
* [x] log
* [x] log10
* [x] log1p
* [x] log2
* [x] logaddexp
* [x] logaddexp2
* [x] logical_and
* [x] logical_not
* [x] logical_or
* [x] logical_xor
* [ ] logspace
* [ ] mask_indices
* [x] matmul
* [x] max
* [x] maximum
* [x] mean
* [x] meshgrid
* [ ] mgrid
* [x] min
* [x] minimum
* [ ] mirr
* [x] mod
* [x] modf
* [ ] moveaxis
* [x] multiply
* [x] nan_to_num
* [x] nanargmax
* [x] nanargmin
* [x] nancumprod
* [x] nancumsum
* [x] nanmax
* [x] nanmean
* [x] nanmin
* [x] nanprod
* [x] nanstd
* [x] nansum
* [x] nanvar
* [ ] ndim
* [x] negative
* [x] nextafter
* [x] nonzero
* [x] not_equal
* [ ] nper
* [ ] npv
* [ ] ogrid
* [x] ones
* [x] ones_like
* [x] outer
* [ ] packbits
* [x] pad
* [x] piecewise
* [ ] place
* [ ] pmt
* [ ] poly
* [ ] poly1d
* [ ] polyadd
* [ ] polyder
* [ ] polydiv
* [ ] polyfit
* [ ] polyint
* [ ] polymul
* [ ] polynomial
* [ ] polysub
* [ ] polyval
* [ ] positive
* [x] power
* [ ] ppmt
* [x] prod
* [ ] product
* [x] ptp
* [ ] put
* [ ] putmask
* [ ] pv
* [ ] r_
* [x] rad2deg
* [x] radians
* [ ] rate
* [x] ravel
* [ ] ravel_multi_index
* [x] real
* [ ] real_if_close
* [x] reciprocal
* [x] remainder
* [x] repeat
* [ ] require
* [x] reshape
* [ ] resize
* [x] result_type
* [x] right_shift
* [x] roll
* [ ] rollaxis
* [ ] roots
* [x] rot90
* [x] round
* [ ] row_stack
* [ ] select
* [ ] setdiff1d
* [ ] setxor1d
* [ ] shape
* [x] sign
* [x] signbit
* [x] sin
* [x] sinc
* [x] sinh
* [ ] size
* [x] spacing
* [ ] split
* [x] sqrt
* [x] square
* [x] squeeze
* [x] stack
* [x] std
* [x] subtract
* [x] sum
* [x] swapaxes
* [x] take
* [x] tan
* [x] tanh
* [x] tensordot
* [x] tile
* [x] trace
* [x] transpose
* [ ] trapz
* [ ] tri
* [x] tril
* [ ] tril_indices
* [ ] tril_indices_from
* [ ] trim_zeros
* [x] triu
* [ ] triu_indices
* [ ] triu_indices_from
* [x] true_divide
* [x] trunc
* [ ] union1d
* [x] unique
* [ ] unpackbits
* [ ] unravel_index
* [ ] unwrap
* [ ] vander
* [x] var
* [x] vdot
* [ ] vectorize
* [ ] vsplit
* [x] vstack
* [x] where
* [x] zeros
* [x] zeros_like",,https://api.github.com/repos/dask/dask/issues/2911/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2911/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
61,https://api.github.com/repos/dask/dask/issues/2912,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2912/labels{/name},https://api.github.com/repos/dask/dask/issues/2912/comments,https://api.github.com/repos/dask/dask/issues/2912/events,https://github.com/dask/dask/issues/2912,275237225,MDU6SXNzdWUyNzUyMzcyMjU=,2912,dask.array.asarray should recognize dask duck-types,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2017-11-20T04:54:40Z,2018-03-31T00:08:37Z,,MEMBER,,"With master for dask and xarray (with dask duck array support):
```
In [25]: import dask.array as da

In [26]: import xarray

In [27]: dask_obj = da.ones((3, 3), chunks=-1)

In [28]: xarray_obj = xarray.DataArray(x, dims=['x', 'y'])

In [29]: dict(da.asarray(xarray_obj).dask)
Out[29]:
{('array-5ce95599636c17df4c5746fb5f3c220b',
  0,
  0): (<function dask.array.core.getter_inline>, 'array-original-5ce95599636c17df4c5746fb5f3c220b', (slice(0, 3, None),
   slice(0, 3, None))),
 'array-original-5ce95599636c17df4c5746fb5f3c220b': <xarray.DataArray 'wrapped-8015d128b19387281f3d8bd3a663300a' (x: 3, y: 3)>
 dask.array<shape=(3, 3), dtype=float64, chunksize=(3, 3)>
 Dimensions without coordinates: x, y}
```

The dask graph from `asarray()` has an `xarray.DataArray` object in it, with its own nested dask graph. This is pretty messy: `asarray()` should really recognize the dask duck-type and combine the argument's dask graph into its own.",,https://api.github.com/repos/dask/dask/issues/2912/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2912/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
62,https://api.github.com/repos/dask/dask/issues/2913,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2913/labels{/name},https://api.github.com/repos/dask/dask/issues/2913/comments,https://api.github.com/repos/dask/dask/issues/2913/events,https://github.com/dask/dask/issues/2913,275237955,MDU6SXNzdWUyNzUyMzc5NTU=,2913,Dask array arithmetic should defer to unrecognized classes,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2017-11-20T05:01:05Z,2017-11-22T20:21:51Z,,MEMBER,,"This came up my discussion of `__matmul__` with @jakirkham in https://github.com/dask/dask/pull/2909.

Currently, dask array operations attempt to blindly convert everything into a dask arrays. This is great for NumPy arrays and numbers, but probably not a good idea for arbitrary objects.

For example: dask + xarray currently creates an dask object, but xarray + dask creates an xarray object:
```
In [1]: import dask.array as da

In [3]: import xarray

In [2]: x = da.ones((3, 3), chunks=-1)

In [4]: y = xarray.DataArray(x, dims=['x', 'y'])

In [6]: x + y
Out[6]: dask.array<add, shape=(3, 3), dtype=float64, chunksize=(3, 3)>

In [7]: y + x
Out[7]:
<xarray.DataArray 'wrapped-8015d128b19387281f3d8bd3a663300a' (x: 3, y: 3)>
dask.array<shape=(3, 3), dtype=float64, chunksize=(3, 3)>
Dimensions without coordinates: x, y
```
It would be better for dask to defer to xarray in all cases, since xarray knows about dask but dask doesn't know about xarray. This is easiest to do by adding a check for recognized types at the start of every binary operation, e.g.,
```python
def __add__(self, other):
    if not isinstance(other, RECOGNIZED_TYPES):
        return NotImplemented
    return do_add(self, other)
```
As another example, I also wrote a version of this for [`__array_ufunc__`](https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html) using `numpy.lib.mixins.NDArrayOperatorsMixin`.",,https://api.github.com/repos/dask/dask/issues/2913/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2913/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
63,https://api.github.com/repos/dask/dask/issues/2923,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2923/labels{/name},https://api.github.com/repos/dask/dask/issues/2923/comments,https://api.github.com/repos/dask/dask/issues/2923/events,https://github.com/dask/dask/issues/2923,276166644,MDU6SXNzdWUyNzYxNjY2NDQ=,2923,Dask dataframe filesystem committers,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,1,2017-11-22T18:30:15Z,2021-10-12T03:04:27Z,,MEMBER,,"During writing a dask dataframe to an output format all files are created eagerly and run as soon as they can.   This can cause incomplete datasets to be written to the underlying filesystem in case something goes wrong and incomplete datasets being visible to other users of the filesystem whilst the write is in progress.

Hadoop Mapreduce (and other jvm big data tools) deal with this by means of an OutputCommitter.  This changes the write procedure to write to a temporary location and then attempt to do an atomic (or at least close) move of the written parts (on completion of all of them) to their final location.

For blobstore backends (like s3) an approach can be made to write the files but delay their final commit until all parts have been written successfully.  See https://github.com/rdblue/s3committer for a s3 implementation.


",,https://api.github.com/repos/dask/dask/issues/2923/timeline,,,mariusvniekerk,73973,MDQ6VXNlcjczOTcz,https://avatars.githubusercontent.com/u/73973?v=4,,https://api.github.com/users/mariusvniekerk,https://github.com/mariusvniekerk,https://api.github.com/users/mariusvniekerk/followers,https://api.github.com/users/mariusvniekerk/following{/other_user},https://api.github.com/users/mariusvniekerk/gists{/gist_id},https://api.github.com/users/mariusvniekerk/starred{/owner}{/repo},https://api.github.com/users/mariusvniekerk/subscriptions,https://api.github.com/users/mariusvniekerk/orgs,https://api.github.com/users/mariusvniekerk/repos,https://api.github.com/users/mariusvniekerk/events{/privacy},https://api.github.com/users/mariusvniekerk/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2923/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
64,https://api.github.com/repos/dask/dask/issues/2930,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2930/labels{/name},https://api.github.com/repos/dask/dask/issues/2930/comments,https://api.github.com/repos/dask/dask/issues/2930/events,https://github.com/dask/dask/issues/2930,277119584,MDU6SXNzdWUyNzcxMTk1ODQ=,2930,DOC: from_array's use of tokenize,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,2,2017-11-27T18:24:40Z,2021-09-13T21:18:38Z,,MEMBER,,Would be good to document `from_array`'s use of `tokenize` and what that means in terms of calls to `__dask_tokenize__` and `normalize_token`. In particular how do these influence the `name` used in graph construction.,,https://api.github.com/repos/dask/dask/issues/2930/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2930/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
65,https://api.github.com/repos/dask/dask/issues/2933,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2933/labels{/name},https://api.github.com/repos/dask/dask/issues/2933/comments,https://api.github.com/repos/dask/dask/issues/2933/events,https://github.com/dask/dask/issues/2933,277833117,MDU6SXNzdWUyNzc4MzMxMTc=,2933,Configuring specific token hashing algorithm,[],open,False,,[],,6,2017-11-29T17:03:49Z,2018-10-29T19:30:38Z,,MEMBER,,"Would be nice to have a way to force a particular hashing algorithm with Dask via `set_options`. Stealing the code snippet below from @jcrist's [comment]( https://github.com/dask/dask/pull/2377#issuecomment-305232945 ). This is needed for use cases where having reproducible hashes are necessary (e.g. caching, versioning, etc.).

```python
dask.set_options(tokenize_hash='mmh3')  # use mmh3, error if not available
dask.set_options(tokenize_hash=None)   # Use best available hash, default behavior
```",,https://api.github.com/repos/dask/dask/issues/2933/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2933/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
66,https://api.github.com/repos/dask/dask/issues/2939,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2939/labels{/name},https://api.github.com/repos/dask/dask/issues/2939/comments,https://api.github.com/repos/dask/dask/issues/2939/events,https://github.com/dask/dask/issues/2939,278199774,MDU6SXNzdWUyNzgxOTk3NzQ=,2939,Add mgrid/ogrid,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,5,2017-11-30T17:12:17Z,2021-10-12T03:03:52Z,,MEMBER,,Would be nice to have Dask Array implementations of NumPy's [`mgrid`]( https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.mgrid.html ) and [`ogrid`]( https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ogrid.html ). These should be pretty trivial extensions of `meshgrid`. Can also simplify `indices` further using `mgrid`.,,https://api.github.com/repos/dask/dask/issues/2939/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2939/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
67,https://api.github.com/repos/dask/dask/issues/2941,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2941/labels{/name},https://api.github.com/repos/dask/dask/issues/2941/comments,https://api.github.com/repos/dask/dask/issues/2941/events,https://github.com/dask/dask/issues/2941,278265850,MDU6SXNzdWUyNzgyNjU4NTA=,2941,Dataframe.concat generating large numbers of tasks with overlapping time indexed dataframes,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2017-11-30T20:52:25Z,2022-11-23T17:03:48Z,,CONTRIBUTOR,,"When I concat DateTimeIndexed dataframes together, that have overlapping partitions,  dask generates a large number of repartition-merge , repartition-split tasks. With 400 dataframes I have seen it generate 600,000 tasks even when each dataframe only has one partition, I can't reproduce quite the same number using data generated inline, but did get 300k.

I want to establish if this is just a catch of the way concat works and if it is, find a way to mitigate it for my dataset.

Here is the sample of code that generates 320800 tasks from 400 dataframes.

```python
from datetime import datetime, timedelta

import dask.dataframe as dd
import numpy as np
import pandas as pd

one_day = timedelta(days=1)
start = datetime(2017, 1, 1)
end = datetime(2017, 1, 2)
dataframes = []
for i in range(0, 400):
    one_second = 1000000000
    d_range = pd.date_range(start=start, end=start + one_day, freq='{0}ns'.format(one_second + i))
    df = pd.DataFrame(np.random.randn(len(d_range), 1), index=d_range, columns=list('A'))
    df = dd.from_pandas(df, npartitions=1)
    dataframes.append(df)
print(dd.concat(dataframes, interleave_partitions=True))

```",,https://api.github.com/repos/dask/dask/issues/2941/timeline,,,shughes-uk,546891,MDQ6VXNlcjU0Njg5MQ==,https://avatars.githubusercontent.com/u/546891?v=4,,https://api.github.com/users/shughes-uk,https://github.com/shughes-uk,https://api.github.com/users/shughes-uk/followers,https://api.github.com/users/shughes-uk/following{/other_user},https://api.github.com/users/shughes-uk/gists{/gist_id},https://api.github.com/users/shughes-uk/starred{/owner}{/repo},https://api.github.com/users/shughes-uk/subscriptions,https://api.github.com/users/shughes-uk/orgs,https://api.github.com/users/shughes-uk/repos,https://api.github.com/users/shughes-uk/events{/privacy},https://api.github.com/users/shughes-uk/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2941/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
68,https://api.github.com/repos/dask/dask/issues/2946,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2946/labels{/name},https://api.github.com/repos/dask/dask/issues/2946/comments,https://api.github.com/repos/dask/dask/issues/2946/events,https://github.com/dask/dask/issues/2946,278482040,MDU6SXNzdWUyNzg0ODIwNDA=,2946,da.repeat with `repeats` as list NotImplemented,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2017-12-01T14:26:25Z,2018-02-22T21:13:42Z,,NONE,,"Hi,

I was looking to use `da.repeat` as in the [documentation](http://dask.pydata.org/en/latest/array-api.html#dask.array.repeat) `np.repeat(x, [1, 2], axis=0)`, though I get a NotImplementedError.

I looked in the [Checklist](https://github.com/dask/dask/issues/2911) which has repeat as checked - not sure if this takes into account the problem above.

Any suggestions of a neat was of reproducing this function in dask currently?

Thanks",,https://api.github.com/repos/dask/dask/issues/2946/timeline,,,jamesstidard,1797906,MDQ6VXNlcjE3OTc5MDY=,https://avatars.githubusercontent.com/u/1797906?v=4,,https://api.github.com/users/jamesstidard,https://github.com/jamesstidard,https://api.github.com/users/jamesstidard/followers,https://api.github.com/users/jamesstidard/following{/other_user},https://api.github.com/users/jamesstidard/gists{/gist_id},https://api.github.com/users/jamesstidard/starred{/owner}{/repo},https://api.github.com/users/jamesstidard/subscriptions,https://api.github.com/users/jamesstidard/orgs,https://api.github.com/users/jamesstidard/repos,https://api.github.com/users/jamesstidard/events{/privacy},https://api.github.com/users/jamesstidard/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2946/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
69,https://api.github.com/repos/dask/dask/issues/2959,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2959/labels{/name},https://api.github.com/repos/dask/dask/issues/2959/comments,https://api.github.com/repos/dask/dask/issues/2959/events,https://github.com/dask/dask/issues/2959,279106702,MDU6SXNzdWUyNzkxMDY3MDI=,2959,Implementing `item` method for Dask Arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2017-12-04T18:51:29Z,2018-06-17T04:35:11Z,,MEMBER,,"For NumPy Arrays, `item` is a convenience method that returns a scalar from a NumPy array with a single value. If the NumPy array does not have a single value, it errors out. Would be nice to have a similar method for Dask Arrays.",,https://api.github.com/repos/dask/dask/issues/2959/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2959/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
70,https://api.github.com/repos/dask/dask/issues/2961,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2961/labels{/name},https://api.github.com/repos/dask/dask/issues/2961/comments,https://api.github.com/repos/dask/dask/issues/2961/events,https://github.com/dask/dask/issues/2961,279196815,MDU6SXNzdWUyNzkxOTY4MTU=,2961,Dask array getitem scalar vs 0-D array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2017-12-05T00:02:39Z,2018-06-13T20:43:47Z,,MEMBER,,"When indexing a Dask array, it will return a 0-D array instead of a scalar. This differs from NumPy's behavior. Fixing this is straightforward if we are ok leaving 0-D arrays behind.

With a NumPy array, slicing with an empty tuple (e.g. `a[()]`) typically converts a 0-D array to a scalar. Alternatively NumPy scalars can be converted to 0-D arrays by slicing using `Ellipsis` (e.g. `v[...]`). The latter already works correctly with Dask arrays since 0-D arrays are always returned. However the former does not.

<details>
<summary>Example</summary>

```python
In [1]: import numpy as np

In [2]: import dask.array as da

In [3]: a1 = np.zeros((1, 1))

In [4]: d1 = da.from_array(a1, chunks=1)

In [5]: a2 = np.array(0.0)

In [6]: d2 = da.from_array(a2, chunks=1)

In [7]: a1[0, 0]
Out[7]: 0.0

In [8]: d1[0, 0]
Out[8]: dask.array<getitem, shape=(), dtype=float64, chunksize=()>

In [9]: d1[0, 0].compute()
Out[9]: array(0.0)

In [10]: a2[()]
Out[10]: 0.0

In [11]: d2[()]
Out[11]: dask.array<array, shape=(), dtype=float64, chunksize=()>

In [12]: d2[()].compute()
Out[12]: array(0.0)

In [13]: a2[()][...]
Out[13]: array(0.0)

In [14]: d2[()][...]
Out[14]: dask.array<array, shape=(), dtype=float64, chunksize=()>

In [15]: d2[()][...].compute()
Out[15]: array(0.0)
```

</details>

<br>

<details>
<summary>Environment</summary>

```yaml
name: test
channels:
- conda-forge
- defaults
dependencies:
- appnope=0.1.0=py36_0
- blas=1.1=openblas
- bokeh=0.12.11=py36_0
- ca-certificates=2017.11.5=0
- certifi=2017.11.5=py36_0
- click=6.7=py36_0
- cloudpickle=0.4.0=py36_0
- dask=0.16.0=py_0
- dask-core=0.16.0=py_0
- decorator=4.1.2=py36_0
- distributed=1.20.1=py36_0
- heapdict=1.0.0=py36_0
- ipython=6.2.1=py36_0
- ipython_genutils=0.2.0=py36_0
- jedi=0.10.2=py36_0
- jinja2=2.10=py36_0
- libgfortran=3.0.0=0
- locket=0.2.0=py36_1
- markupsafe=1.0=py36_0
- msgpack-python=0.4.8=py36_0
- ncurses=5.9=10
- numpy=1.13.3=py36_blas_openblas_201
- openblas=0.2.20=6
- openssl=1.0.2m=0
- pandas=0.21.0=py36_0
- partd=0.3.8=py36_0
- pexpect=4.3.0=py36_0
- pickleshare=0.7.4=py36_0
- pip=9.0.1=py36_0
- prompt_toolkit=1.0.15=py36_0
- psutil=5.4.0=py36_0
- ptyprocess=0.5.2=py36_0
- pygments=2.2.0=py36_0
- python=3.6.3=1
- python-dateutil=2.6.1=py36_0
- pytz=2017.3=py_2
- pyyaml=3.12=py36_1
- readline=6.2=0
- setuptools=38.2.3=py36_0
- simplegeneric=0.8.1=py36_0
- six=1.11.0=py36_1
- sortedcontainers=1.5.7=py36_0
- sqlite=3.13.0=1
- tblib=1.3.2=py36_0
- tk=8.5.19=2
- toolz=0.8.2=py_2
- tornado=4.5.2=py36_0
- traitlets=4.3.2=py36_0
- wcwidth=0.1.7=py36_0
- wheel=0.30.0=py_1
- xz=5.2.3=0
- yaml=0.1.7=0
- zict=0.1.3=py_0
- zlib=1.2.11=0
```

</details>",,https://api.github.com/repos/dask/dask/issues/2961/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2961/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
71,https://api.github.com/repos/dask/dask/issues/2991,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2991/labels{/name},https://api.github.com/repos/dask/dask/issues/2991/comments,https://api.github.com/repos/dask/dask/issues/2991/events,https://github.com/dask/dask/issues/2991,281425851,MDU6SXNzdWUyODE0MjU4NTE=,2991,read_parquet() does not capture divisions when partitioned,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,11,2017-12-12T15:29:26Z,2021-10-12T04:46:12Z,,NONE,,"Reading a dataframe from parquet fails to load the partitions in order or preserve index divisions, while it works if reading the same dataframe from a globstring

Expected behavior: partitions in the dask frame correspond to ordered partitions of the parquet file, and divisions on the index should be preserved if partitioning and order of partitions does not scramble the index (ie if the partition has the same ordering as the index, is a prefix, etc)

```python
from dask import dataframe as dask_df
import pandas as pd
from datetime import date, timedelta, datetime
import dask
print(dask.__version__) # 0.16.0
import fastparquet
print(fastparquet.__version__) . # 0.1.3

def make_dt(hour):
    return datetime(2017, 1, 1, 0, 0, 0) + timedelta(hours=hour)

def make_part(hours):
    return pd.DataFrame([
        dict(
            hour=h,
            dt=make_dt(h),
            date=make_dt(h).date().strftime('%Y-%m-%d')
        )
        for h in hours
    ]
    ).set_index('hour')

ddf = dask_df.from_pandas(make_part(range(480,520)),npartitions=1)

ddf.to_parquet('partition_play', write_index=True, partition_on=['date'])

back = dask_df.read_parquet('partition_play', index='hour') # hour is actually known as default index

# back will .compute() correctly, but does not know its divisions even though the parquet file has them in the min/max part of the header
# I think this is because the partitions are not stored in order in the _metadata file
back.known_divisions # False

# The glob string will read the partitions in order and preserves the index
back_glob = = dask_df.read_parquet('partition_play/date=*/*.parquet')
back_glob.known_divisions # True

```

If the real issue is just row groups in _metadata not being sorted, I believe this could be addressed by just reordering the partitions in read_parquet before checking for an index, but I'm not too familiar w/ how parquet should work in this case",,https://api.github.com/repos/dask/dask/issues/2991/timeline,,,gorlins,139286,MDQ6VXNlcjEzOTI4Ng==,https://avatars.githubusercontent.com/u/139286?v=4,,https://api.github.com/users/gorlins,https://github.com/gorlins,https://api.github.com/users/gorlins/followers,https://api.github.com/users/gorlins/following{/other_user},https://api.github.com/users/gorlins/gists{/gist_id},https://api.github.com/users/gorlins/starred{/owner}{/repo},https://api.github.com/users/gorlins/subscriptions,https://api.github.com/users/gorlins/orgs,https://api.github.com/users/gorlins/repos,https://api.github.com/users/gorlins/events{/privacy},https://api.github.com/users/gorlins/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2991/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
72,https://api.github.com/repos/dask/dask/issues/2999,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/2999/labels{/name},https://api.github.com/repos/dask/dask/issues/2999/comments,https://api.github.com/repos/dask/dask/issues/2999/events,https://github.com/dask/dask/issues/2999,282156650,MDU6SXNzdWUyODIxNTY2NTA=,2999,Groupby-agg on index with known divisions results in unknown divisions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2017-12-14T16:19:04Z,2021-10-12T04:45:32Z,,NONE,,"I would expect `ddf.groupby(ddf.index).sum()` to have same divisions as `ddf`, but they seem to be unknown. Not sure if this is a desired behaviour or if I'm doing something wrong.
```
In[2]: import pandas as pd
In[3]: import dask.dataframe as dd
In[4]: ddf = dd.from_pandas(pd.DataFrame({'A': [1, 2]}), npartitions=1)
In[5]: ddf.divisions
Out[5]: (0, 1)
In[6]: ddf.groupby(ddf.index).sum().divisions
Out[6]: (None, None)
```
- dask 0.16
- pandas 0.21.1
",,https://api.github.com/repos/dask/dask/issues/2999/timeline,,,michcio1234,16254622,MDQ6VXNlcjE2MjU0NjIy,https://avatars.githubusercontent.com/u/16254622?v=4,,https://api.github.com/users/michcio1234,https://github.com/michcio1234,https://api.github.com/users/michcio1234/followers,https://api.github.com/users/michcio1234/following{/other_user},https://api.github.com/users/michcio1234/gists{/gist_id},https://api.github.com/users/michcio1234/starred{/owner}{/repo},https://api.github.com/users/michcio1234/subscriptions,https://api.github.com/users/michcio1234/orgs,https://api.github.com/users/michcio1234/repos,https://api.github.com/users/michcio1234/events{/privacy},https://api.github.com/users/michcio1234/received_events,User,False,https://api.github.com/repos/dask/dask/issues/2999/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
73,https://api.github.com/repos/dask/dask/issues/3074,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3074/labels{/name},https://api.github.com/repos/dask/dask/issues/3074/comments,https://api.github.com/repos/dask/dask/issues/3074/events,https://github.com/dask/dask/issues/3074,289109956,MDU6SXNzdWUyODkxMDk5NTY=,3074,Multiprocess writes using `to_hdf5`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,21,2018-01-17T01:12:00Z,2021-10-12T04:39:39Z,,MEMBER,,"After seeing @stuartarchibald's [post on gitter]( https://gitter.im/dask/dask?at=5a5cd598290a1f45618f91b3 ), I was a bit curious how `to_hdf5` actually worked and whether it would be viable to call from multiple processes.

Turns out [`to_hdf5` just calls `store` underneath the hood]( https://github.com/dask/dask/blob/0.16.1/dask/array/core.py#L3390 ) while [holding the file open locally]( https://github.com/dask/dask/blob/0.16.1/dask/array/core.py#L3385 ). The biggest issue of course is that the file is held open in write mode on the scheduler (meaning nothing else can write to the HDF5 file without corrupting it). Since the type of locking was not specified and `store` uses a [`threading.Lock` by default]( https://github.com/dask/dask/blob/0.16.1/dask/array/core.py#L837-L840 ), this is also incompatible with the multiprocessing use case (i.e. `threading.Lock` cannot be serialized/locked across processes). IOW the current implementation of `to_hdf5` is not friendly even for locked parallel writes.

That said, it should be feasible to change `to_hdf5`'s behavior to be more friendly for storage from multiple processes (though it will still need to be locked). In this case, it would still create the datasets initially (as it already does), but then would close the file. Instead of passing raw HDF5 Datasets as targets, a wrapper class would need to be used (to allow for pickling). The wrapper class would need to provide a `__setitem__` method that would open the HDF5 file and write to the HDF5 Dataset at the selection specified in a process safe manner (probably with `locket.lock_file`). Ideally it would provide a `__getitem__` method as well. Doing this should allow for HDF5 file to be written to in parallel. This assumes the filesystem is very robust and syncing changes between different nodes.

An alternative to this proposal that would avoid locking would be to have data serialized back to the scheduler, which then writes each piece to the HDF5 file as it arrives. This would avoid the overhead of the previous strategy (and any potential issues locking) by guaranteeing only one process ever opens the HDF5 file and keeps open until everything is written. This strategy would continue to work well for non-parallel use cases with arguably less overhead than is present now. The only thing to do before writing out all results would be to optimize the graphs since `store` would no longer be used.",,https://api.github.com/repos/dask/dask/issues/3074/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3074/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
74,https://api.github.com/repos/dask/dask/issues/3135,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3135/labels{/name},https://api.github.com/repos/dask/dask/issues/3135/comments,https://api.github.com/repos/dask/dask/issues/3135/events,https://github.com/dask/dask/issues/3135,294086865,MDU6SXNzdWUyOTQwODY4NjU=,3135,Unexpected dataframe shuffle for sorted index,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2018-02-03T05:47:27Z,2021-10-12T04:37:01Z,,CONTRIBUTOR,,"Following up on https://stackoverflow.com/questions/48592049/dask-dataframe-groupby-apply-efficiency/48592529 with an example.

Read data w/ a sorted index column and perform a groupby; shouldn't require a shuffle:
```
from uuid import uuid4
import dask.dataframe as dd
from distributed import Client
import numpy as np
import pandas as pd


N = int(1e4); n = 50
uids = sorted(str(uuid4()) for i in range(N))
df = pd.DataFrame({'uid': np.repeat(uids, n), 'x': np.random.random(N * n),
                   'y': np.random.random(N * n)})
df.sort_values(by='uid', inplace=True)
df.to_parquet('/tmp/test.parquet', compression=None)
del df

c = Client('tcp://192.168.1.42:8786')
ddf = dd.read_parquet('/tmp/test.parquet')
ddf = c.persist(ddf.set_index('uid'))
#ddf = c.persist(ddf.repartition(npartitions=100))  # no shuffle if we don't repartition
future = ddf.groupby('uid').apply(sum).compute()
```
<img width=""920"" alt=""screenshot 2018-02-02 21 07 03"" src=""https://user-images.githubusercontent.com/903655/35763436-1a709334-0861-11e8-8067-ee9c9f78509f.png"">
Looks good! But re-running with the repartition uncommented:
<img width=""942"" alt=""screenshot 2018-02-02 21 08 45"" src=""https://user-images.githubusercontent.com/903655/35763440-3ccbd93e-0861-11e8-8578-686391b87c0b.png"">

Based on my reading of the docs it doesn't seem like `repartition` should be so problematic if my index is sorted; am I just misinterpreting or is unexpected behavior?",,https://api.github.com/repos/dask/dask/issues/3135/timeline,,,bnaul,903655,MDQ6VXNlcjkwMzY1NQ==,https://avatars.githubusercontent.com/u/903655?v=4,,https://api.github.com/users/bnaul,https://github.com/bnaul,https://api.github.com/users/bnaul/followers,https://api.github.com/users/bnaul/following{/other_user},https://api.github.com/users/bnaul/gists{/gist_id},https://api.github.com/users/bnaul/starred{/owner}{/repo},https://api.github.com/users/bnaul/subscriptions,https://api.github.com/users/bnaul/orgs,https://api.github.com/users/bnaul/repos,https://api.github.com/users/bnaul/events{/privacy},https://api.github.com/users/bnaul/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3135/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
75,https://api.github.com/repos/dask/dask/issues/3162,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3162/labels{/name},https://api.github.com/repos/dask/dask/issues/3162/comments,https://api.github.com/repos/dask/dask/issues/3162/events,https://github.com/dask/dask/issues/3162,296560849,MDU6SXNzdWUyOTY1NjA4NDk=,3162,Arithmetic operations of dtype arrays raise ValueError,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2018-02-12T23:24:20Z,2019-08-13T14:30:15Z,,CONTRIBUTOR,,"xref pydata/xarray#1883

Object-typed array does not support arithmetic operations,
```python
In [1]: import numpy as np
   ...: import dask.array as da
   ...: 
   ...: x = np.array([True, False, np.nan], dtype=object)
   ...: x / 2
   ...: 
Out[1]: array([0.5, 0.0, nan], dtype=object)

In [2]: dx = da.from_array(x, chunks=[1])
   ...: dx / 2
   ...: 
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-2-0fc254e56c40> in <module>()
      1 dx = da.from_array(x, chunks=[1])
----> 2 dx / 2

~/anaconda3/envs/xarray/lib/python3.6/site-packages/dask/array/core.py in __truediv__(self, other)
   1532 
   1533     def __truediv__(self, other):
-> 1534         return elemwise(operator.truediv, self, other)
   1535 
   1536     def __rtruediv__(self, other):

~/anaconda3/envs/xarray/lib/python3.6/site-packages/dask/array/core.py in elemwise(op, *args, **kwargs)
   2938                 if not is_scalar_for_elemwise(a) else a
   2939                 for a in args]
-> 2940         dt = apply_infer_dtype(op, vals, {}, 'elemwise', suggest_dtype=False)
   2941         need_enforce_dtype = any(not is_scalar_for_elemwise(a) and a.ndim == 0 for a in args)
   2942 

~/anaconda3/envs/xarray/lib/python3.6/site-packages/dask/array/core.py in apply_infer_dtype(func, args, kwargs, funcname, suggest_dtype)
    544         msg = None
    545     if msg is not None:
--> 546         raise ValueError(msg)
    547     return o.dtype
    548 

ValueError: `dtype` inference failed in `elemwise`.

Original error is below:
------------------------
TypeError(""unsupported operand type(s) for /: 'NoneType' and 'int'"",)

Traceback:
---------
  File ""/home/keisukefujii/anaconda3/envs/xarray/lib/python3.6/site-packages/dask/array/core.py"", line 529, in apply_infer_dtype
    o = func(*args, **kwargs)
```

Maybe we need some type castings.",,https://api.github.com/repos/dask/dask/issues/3162/timeline,,,fujiisoup,6815844,MDQ6VXNlcjY4MTU4NDQ=,https://avatars.githubusercontent.com/u/6815844?v=4,,https://api.github.com/users/fujiisoup,https://github.com/fujiisoup,https://api.github.com/users/fujiisoup/followers,https://api.github.com/users/fujiisoup/following{/other_user},https://api.github.com/users/fujiisoup/gists{/gist_id},https://api.github.com/users/fujiisoup/starred{/owner}{/repo},https://api.github.com/users/fujiisoup/subscriptions,https://api.github.com/users/fujiisoup/orgs,https://api.github.com/users/fujiisoup/repos,https://api.github.com/users/fujiisoup/events{/privacy},https://api.github.com/users/fujiisoup/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3162/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
76,https://api.github.com/repos/dask/dask/issues/3194,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3194/labels{/name},https://api.github.com/repos/dask/dask/issues/3194/comments,https://api.github.com/repos/dask/dask/issues/3194/events,https://github.com/dask/dask/issues/3194,299433383,MDU6SXNzdWUyOTk0MzMzODM=,3194,Dask Arrays with unknown length fail on ravel,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,12,2018-02-22T17:06:30Z,2021-03-31T09:07:00Z,,MEMBER,,"Appears that it is not possible to use `ravel` with a Dask Array that has an unknown number of dimensions. Below is one case where a 2-D array with both dimensions as unknown length fails with `ravel`. Though there are a few other such cases like 1-D arrays with unknown length or even 2-D arrays with only one dimension of unknown length.

<details>
<summary>Example:</summary>

```python
In [1]: import dask.array as da

In [2]: a = da.random.random((110, 120), chunks=(11, 12))

In [3]: b = a[a[:, 0] < 0.5, a[1] > 0.6]
/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/array/core.py:2177: UserWarning: Increasing number of chunks by factor of 10
  (nparts / max_parts))

In [4]: b
Out[4]: dask.array<getitem_variadic, shape=(nan, nan), dtype=float64, chunksize=(nan, nan)>

In [5]: b.ravel()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-5-999f388470b7> in <module>()
----> 1 b.ravel()

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/array/core.py in ravel(self)
   1382     def ravel(self):
   1383         from .routines import ravel
-> 1384         return ravel(self)
   1385 
   1386     flatten = ravel

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/array/routines.py in ravel(array)
    832 @wraps(np.ravel)
    833 def ravel(array):
--> 834     return array.reshape((-1,))
    835 
    836 

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/array/core.py in reshape(self, *shape)
   1396         if len(shape) == 1 and not isinstance(shape[0], Number):
   1397             shape = shape[0]
-> 1398         return reshape(self, shape)
   1399 
   1400     def topk(self, k):

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/array/reshape.py in reshape(x, shape)
    156         if len(known_sizes) - len(shape) > 1:
    157             raise ValueError('can only specify one unknown dimension')
--> 158         missing_size = sanitize_index(x.size / reduce(mul, known_sizes, 1))
    159         shape = tuple(missing_size if s == -1 else s for s in shape)
    160 

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/array/slicing.py in sanitize_index(ind)
     57                      _sanitize_index_element(ind.step))
     58     elif isinstance(ind, Number):
---> 59         return _sanitize_index_element(ind)
     60     elif is_dask_collection(ind):
     61         return ind

/zopt/conda2/envs/test/lib/python3.6/site-packages/dask/array/slicing.py in _sanitize_index_element(ind)
     19     """"""Sanitize a one-element index.""""""
     20     if isinstance(ind, Number):
---> 21         ind2 = int(ind)
     22         if ind2 != ind:
     23             raise IndexError(""Bad index.  Must be integer-like: %s"" % ind)

ValueError: cannot convert float NaN to integer
```

</details>

<details>
<summary>Environment:</summary>

```yaml
name: test
channels:
- conda-forge
- defaults
dependencies:
- appnope=0.1.0=py36_0
- blas=1.1=openblas
- bokeh=0.12.13=py36_0
- ca-certificates=2018.1.18=0
- certifi=2018.1.18=py36_0
- click=6.7=py_1
- cloudpickle=0.5.2=py_0
- dask=0.17.0=py_0
- dask-core=0.17.0=py_0
- decorator=4.1.2=py36_0
- distributed=1.21.0=py36_0
- heapdict=1.0.0=py36_0
- ipython=6.2.1=py36_1
- ipython_genutils=0.2.0=py36_0
- jedi=0.11.1=py36_0
- jinja2=2.10=py36_0
- libgfortran=3.0.0=0
- locket=0.2.0=py36_1
- markupsafe=1.0=py36_0
- msgpack-python=0.5.1=py36_0
- ncurses=5.9=10
- numpy=1.14.0=py36_blas_openblas_200
- openblas=0.2.20=7
- openssl=1.0.2n=0
- pandas=0.22.0=py36_0
- parso=0.1.1=py_0
- partd=0.3.8=py36_0
- pexpect=4.4.0=py36_0
- pickleshare=0.7.4=py36_0
- pip=9.0.1=py36_1
- prompt_toolkit=1.0.15=py36_0
- psutil=5.4.0=py36_0
- ptyprocess=0.5.2=py36_0
- pygments=2.2.0=py36_0
- python=3.6.4=0
- python-dateutil=2.6.1=py36_0
- pytz=2018.3=py_0
- pyyaml=3.12=py36_1
- readline=7.0=0
- setuptools=38.5.1=py36_0
- simplegeneric=0.8.1=py36_0
- six=1.11.0=py36_1
- sortedcontainers=1.5.7=py36_0
- sqlite=3.20.1=2
- tblib=1.3.2=py36_0
- tk=8.6.7=0
- toolz=0.8.2=py_2
- tornado=4.5.3=py36_0
- traitlets=4.3.2=py36_0
- wcwidth=0.1.7=py36_0
- wheel=0.30.0=py36_2
- xz=5.2.3=0
- yaml=0.1.7=0
- zict=0.1.3=py_0
- zlib=1.2.11=0
```

</details>

<br>

xref: https://github.com/dask/dask/issues/1839",,https://api.github.com/repos/dask/dask/issues/3194/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3194/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
77,https://api.github.com/repos/dask/dask/issues/3208,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3208/labels{/name},https://api.github.com/repos/dask/dask/issues/3208/comments,https://api.github.com/repos/dask/dask/issues/3208/events,https://github.com/dask/dask/issues/3208,300059696,MDU6SXNzdWUzMDAwNTk2OTY=,3208,Supporting more ufunc methods,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2018-02-25T20:48:25Z,2019-08-08T00:30:25Z,,MEMBER,,"Would be nice if Dask Array's ufunc supported more of the [NumPy methods]( https://docs.scipy.org/doc/numpy-1.14.0/reference/ufuncs.html#methods ). Have listed the methods below and also checked off any that have been completed with links to the corresponding PR.

* [ ] [`ufunc.reduce`]( https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce )
* [ ] [`ufunc.accumulate`]( https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.ufunc.accumulate.html#numpy.ufunc.accumulate )
* [ ] [`ufunc.reduceat`]( https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.ufunc.reduceat.html#numpy.ufunc.reduceat )
* [x] [`ufunc.outer`]( https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.ufunc.outer.html#numpy.ufunc.outer ) ( https://github.com/dask/dask/pull/2345 )

Also below are ones that don't make sense to implement for Dask Arrays with links to reasons why.

* ~~[`ufunc.at`]( https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.ufunc.at.html#numpy.ufunc.at )~~ ( https://github.com/dask/dask/pull/2345#issuecomment-302428475 )",,https://api.github.com/repos/dask/dask/issues/3208/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3208/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
78,https://api.github.com/repos/dask/dask/issues/3245,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3245/labels{/name},https://api.github.com/repos/dask/dask/issues/3245/comments,https://api.github.com/repos/dask/dask/issues/3245/events,https://github.com/dask/dask/issues/3245,302182457,MDU6SXNzdWUzMDIxODI0NTc=,3245,Silencing warnings issued by numpy functions within dask.array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,29,2018-03-05T06:08:49Z,2023-04-18T14:01:56Z,,MEMBER,,"NumPy's NaN-skipping aggregation functions issue warnings when they encounter all NaN slices, e.g.,
```
In [2]: np.nanmean([np.nan])
/Users/shoyer/miniconda3/envs/xarray-py36/bin/ipython:1: RuntimeWarning: Mean of empty slice
  #!/Users/shoyer/miniconda3/envs/xarray-py36/bin/python
Out[2]: nan
```

As far as xarray is concerned, NaN is the right answer for these cases. So we silence these NumPy warnings, which works with NumPy, but unfortunately not with dask.array:
- Functions like `np.nanmean` issue warnings at compute time, outside our `warnings.catch_warnings()` context.
- Sometimes, dask arrays operations end up issuing new warnings (e.g., due to division by 0 when calculating the mean). 

Some possibilities for dealing with this:
1. Issue these irrelevant warnings, which needlessly annoys and distracts users. This is the current status quo.
2. Silence these warnings unilaterally, which could hide bugs in non-xarray code.
3. Rewrite the relevant dask.array functions to optionally call warning silenced version of NumPy functions. This would need to be in dask.array itself to be maintainable, but there isn't a good place in dask.array's API to inject lists of warnings to silence.
5. *Always* silence warnings when computing with dask, under the theory that warnings without good stacklevel identification are not so useful and  these get lost when computing with processes anyways. This seems like wishful thinking.
6. Add some magic to dask where it automatically logs warnings filters that were activated when a lazy function was added to a dask graph, and then restores them with executing the function. This sounds like the cleanest option, but it might have prohibitively large overhead. Possibly we could do this only for functions known to issue warnings, but if we were really careful about this it would be a very long list (e.g., including any numpy function that does division).

xref https://github.com/pydata/xarray/issues/1652",,https://api.github.com/repos/dask/dask/issues/3245/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3245/reactions,10,10,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
79,https://api.github.com/repos/dask/dask/issues/3247,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3247/labels{/name},https://api.github.com/repos/dask/dask/issues/3247/comments,https://api.github.com/repos/dask/dask/issues/3247/events,https://github.com/dask/dask/issues/3247,302478147,MDU6SXNzdWUzMDI0NzgxNDc=,3247,Dask holding on to memory after garbage collection,[],open,False,,[],,35,2018-03-05T21:52:56Z,2020-09-30T09:33:56Z,,CONTRIBUTOR,,"While debugging/profiling our software using dask we noticed that dask seems to hold on to something and it seems to be dependent on number of arrays or chunks maybe. I'm using python 3.6 on OSX and using the `memory_profiler` package for profiling. This doesn't seem to be dependent on platform or python version. I created the below test script after trying a few different things including running the function multiple times or doing things at random, but I think the below gives a good example of what I'm curious about. You can run it by doing `python script.py`.

```python
import sys
from time import time
import gc
import dask
dask.set_options(get=dask.local.get_sync)
from memory_profiler import profile

NUM_VALUES = 10000
CHUNK_SIZE = 4096

@profile
def main():
    import dask.array as da
    #num_values = round(((time() * 100) % 5) * (NUM_VALUES / 2))
    num_values = 10000
    print(""Number of values: {}"".format(num_values))

    v1 = da.arange(num_values, chunks=CHUNK_SIZE)
    v2 = da.arange(num_values, chunks=CHUNK_SIZE)
    arr_x, arr_y = da.meshgrid(v1, v2)
    res = da.compute(arr_x + arr_y)
    del v1, v2, res, arr_x, arr_y
    print(gc.collect())

    v1 = da.arange(num_values + 1, chunks=CHUNK_SIZE)
    v2 = da.arange(num_values + 1, chunks=CHUNK_SIZE)
    v3 = da.arange(num_values + 1, chunks=CHUNK_SIZE)
    arr_x, arr_y = da.meshgrid(v1, v2)
    arr_x2, arr_y2 = da.meshgrid(v2, v3)
    res = da.compute(arr_x + arr_y + arr_x2)
    del v1, v2, res, arr_x, arr_y, v3, arr_x2, arr_y2
    print(gc.collect())

    v1 = da.arange(num_values + 2, chunks=CHUNK_SIZE)
    v2 = da.arange(num_values + 2, chunks=CHUNK_SIZE)
    v3 = da.arange(num_values + 2, chunks=CHUNK_SIZE)
    v4 = da.arange(num_values + 2, chunks=CHUNK_SIZE)
    arr_x, arr_y = da.meshgrid(v1, v2)
    arr_x2, arr_y2 = da.meshgrid(v3, v4)
    res = da.compute(arr_x + arr_y + arr_x2)
    del v1, v2, res, arr_x, arr_y, v3, v4, arr_x2, arr_y2
    print(gc.collect())

    v1 = da.arange(num_values + 3, chunks=CHUNK_SIZE)
    v2 = da.arange(num_values + 3, chunks=CHUNK_SIZE)
    arr_x, arr_y = da.meshgrid(v1, v2)
    arr_x2, arr_y2 = da.meshgrid(v2, v1)
    res = da.compute(arr_x + arr_y + arr_x2)
    del v1, v2, res, arr_x, arr_y, arr_x2, arr_y2
    print(gc.collect())

    v1 = da.arange(num_values, chunks=CHUNK_SIZE)
    v2 = da.arange(num_values, chunks=CHUNK_SIZE)
    arr_x, arr_y = da.meshgrid(v1, v2)
    res = da.compute(arr_x + arr_y)
    del v1, v2, res, arr_x, arr_y
    print(gc.collect())

main()
```

After running you will get something like the following output:

```
Number of values: 10000
126
0
7
0
10
Filename: test_memory_leak.py

Line #    Mem usage    Increment   Line Contents
================================================
    11     40.6 MiB     40.6 MiB   @profile
    12                             def main():
    13     49.7 MiB      9.0 MiB       import dask.array as da
    14                                 #num_values = round(((time() * 100) % 5) * (NUM_VALUES / 2))
    15     49.7 MiB      0.0 MiB       num_values = 10000
    16     49.7 MiB      0.0 MiB       print(""Number of values: {}"".format(num_values))
    17                             
    18     49.7 MiB      0.0 MiB       v1 = da.arange(num_values, chunks=CHUNK_SIZE)
    19     49.7 MiB      0.0 MiB       v2 = da.arange(num_values, chunks=CHUNK_SIZE)
    20     49.7 MiB      0.0 MiB       arr_x, arr_y = da.meshgrid(v1, v2)
    21   1064.4 MiB   1014.6 MiB       res = da.compute(arr_x + arr_y)
    22    301.4 MiB   -762.9 MiB       del v1, v2, res, arr_x, arr_y
    23    301.4 MiB      0.0 MiB       print(gc.collect())
    24                             
    25    301.4 MiB      0.0 MiB       v1 = da.arange(num_values + 1, chunks=CHUNK_SIZE)
    26    301.4 MiB      0.0 MiB       v2 = da.arange(num_values + 1, chunks=CHUNK_SIZE)
    27    301.4 MiB      0.0 MiB       v3 = da.arange(num_values + 1, chunks=CHUNK_SIZE)
    28    301.4 MiB      0.0 MiB       arr_x, arr_y = da.meshgrid(v1, v2)
    29    301.4 MiB      0.0 MiB       arr_x2, arr_y2 = da.meshgrid(v2, v3)
    30   1396.5 MiB   1095.1 MiB       res = da.compute(arr_x + arr_y + arr_x2)
    31    633.4 MiB   -763.1 MiB       del v1, v2, res, arr_x, arr_y, v3, arr_x2, arr_y2
    32    633.4 MiB      0.0 MiB       print(gc.collect())
    33                             
    34    633.4 MiB      0.0 MiB       v1 = da.arange(num_values + 2, chunks=CHUNK_SIZE)
    35    633.4 MiB      0.0 MiB       v2 = da.arange(num_values + 2, chunks=CHUNK_SIZE)
    36    633.4 MiB      0.0 MiB       v3 = da.arange(num_values + 2, chunks=CHUNK_SIZE)
    37    633.4 MiB      0.0 MiB       v4 = da.arange(num_values + 2, chunks=CHUNK_SIZE)
    38    633.4 MiB      0.0 MiB       arr_x, arr_y = da.meshgrid(v1, v2)
    39    633.4 MiB      0.0 MiB       arr_x2, arr_y2 = da.meshgrid(v3, v4)
    40   1590.8 MiB    957.4 MiB       res = da.compute(arr_x + arr_y + arr_x2)
    41    827.5 MiB   -763.2 MiB       del v1, v2, res, arr_x, arr_y, v3, v4, arr_x2, arr_y2
    42    827.5 MiB      0.0 MiB       print(gc.collect())
    43                             
    44    827.5 MiB      0.0 MiB       v1 = da.arange(num_values + 3, chunks=CHUNK_SIZE)
    45    827.5 MiB      0.0 MiB       v2 = da.arange(num_values + 3, chunks=CHUNK_SIZE)
    46    827.5 MiB      0.0 MiB       arr_x, arr_y = da.meshgrid(v1, v2)
    47    827.5 MiB      0.0 MiB       arr_x2, arr_y2 = da.meshgrid(v2, v1)
    48   1591.6 MiB    764.0 MiB       res = da.compute(arr_x + arr_y + arr_x2)
    49    828.2 MiB   -763.4 MiB       del v1, v2, res, arr_x, arr_y, arr_x2, arr_y2
    50    828.2 MiB      0.0 MiB       print(gc.collect())
    51                             
    52    828.2 MiB      0.0 MiB       v1 = da.arange(num_values, chunks=CHUNK_SIZE)
    53    828.2 MiB      0.0 MiB       v2 = da.arange(num_values, chunks=CHUNK_SIZE)
    54    828.2 MiB      0.0 MiB       arr_x, arr_y = da.meshgrid(v1, v2)
    55   1591.2 MiB    763.0 MiB       res = da.compute(arr_x + arr_y)
    56    828.2 MiB   -762.9 MiB       del v1, v2, res, arr_x, arr_y
    57    828.2 MiB      0.0 MiB       print(gc.collect())

```

So I'm not sure if this is intended but seeing as the memory usage is based on the number/size of inputs it seems like something that should have an option for clearing it out. Just looking for some information on what's going on here.",,https://api.github.com/repos/dask/dask/issues/3247/timeline,,,djhoese,1828519,MDQ6VXNlcjE4Mjg1MTk=,https://avatars.githubusercontent.com/u/1828519?v=4,,https://api.github.com/users/djhoese,https://github.com/djhoese,https://api.github.com/users/djhoese/followers,https://api.github.com/users/djhoese/following{/other_user},https://api.github.com/users/djhoese/gists{/gist_id},https://api.github.com/users/djhoese/starred{/owner}{/repo},https://api.github.com/users/djhoese/subscriptions,https://api.github.com/users/djhoese/orgs,https://api.github.com/users/djhoese/repos,https://api.github.com/users/djhoese/events{/privacy},https://api.github.com/users/djhoese/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3247/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
80,https://api.github.com/repos/dask/dask/issues/3250,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3250/labels{/name},https://api.github.com/repos/dask/dask/issues/3250/comments,https://api.github.com/repos/dask/dask/issues/3250/events,https://github.com/dask/dask/issues/3250,302836078,MDU6SXNzdWUzMDI4MzYwNzg=,3250,Dask implementation of discrete sinusoid transformation,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,8,2018-03-06T19:34:42Z,2018-09-02T23:10:58Z,,NONE,,"Although the discrete sine transformation is implemented in [Scipy](https://docs.scipy.org/doc/scipy-0.18.1/reference/tutorial/fftpack.html#discrete-sine-transforms), currently there is no dask implementation. 
Could this be something to be added to the dask API?",,https://api.github.com/repos/dask/dask/issues/3250/timeline,,,roxyboy,8934026,MDQ6VXNlcjg5MzQwMjY=,https://avatars.githubusercontent.com/u/8934026?v=4,,https://api.github.com/users/roxyboy,https://github.com/roxyboy,https://api.github.com/users/roxyboy/followers,https://api.github.com/users/roxyboy/following{/other_user},https://api.github.com/users/roxyboy/gists{/gist_id},https://api.github.com/users/roxyboy/starred{/owner}{/repo},https://api.github.com/users/roxyboy/subscriptions,https://api.github.com/users/roxyboy/orgs,https://api.github.com/users/roxyboy/repos,https://api.github.com/users/roxyboy/events{/privacy},https://api.github.com/users/roxyboy/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3250/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
81,https://api.github.com/repos/dask/dask/issues/3255,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3255/labels{/name},https://api.github.com/repos/dask/dask/issues/3255/comments,https://api.github.com/repos/dask/dask/issues/3255/events,https://github.com/dask/dask/issues/3255,303557707,MDU6SXNzdWUzMDM1NTc3MDc=,3255,Safely pass a file-like object to dask store,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,65,2018-03-08T17:07:35Z,2021-10-12T04:03:02Z,,CONTRIBUTOR,,"As requested by @jakirkham I'm creating a github issue for this. I started this conversation on gitter and was about to make a SO question but have posted it here instead.

I have a custom array-like object that wraps a file-like object and I pass this custom object to Dask's `store` function to save a dask array. You can see an earlier implementation of that class [here][1] but it shouldn't matter for this question. So the issue I'm having is how to pass a file-like object as a target and have it explicitly closed. In normal execution the file seems to be closed after dask computes everything, in my unit tests with python's `unittest` the file seems to get closed before dask computes when I call it like this:

    with MyFileObject(...) as my_file:
        return da.store(my_data, my_file, compute=False)
    ...
    result.compute()  # compute the above delayed

I then decided to try using `dask.delayed` around a function that opens the file, runs store, then closes the file. But then I realized that `delayed` will compute my dask array before passing it to my function, defeating the purpose of using `da.store` for storing chunks.

So my question is, is there any way to use `da.store` with a file-like object, explicitly close that file-like object, and get the benefits of `da.store` storing individual chunks?

  [1]: https://stackoverflow.com/questions/49090399/thread-safe-rasterio-writes-from-dask-array-store
",,https://api.github.com/repos/dask/dask/issues/3255/timeline,,,djhoese,1828519,MDQ6VXNlcjE4Mjg1MTk=,https://avatars.githubusercontent.com/u/1828519?v=4,,https://api.github.com/users/djhoese,https://github.com/djhoese,https://api.github.com/users/djhoese/followers,https://api.github.com/users/djhoese/following{/other_user},https://api.github.com/users/djhoese/gists{/gist_id},https://api.github.com/users/djhoese/starred{/owner}{/repo},https://api.github.com/users/djhoese/subscriptions,https://api.github.com/users/djhoese/orgs,https://api.github.com/users/djhoese/repos,https://api.github.com/users/djhoese/events{/privacy},https://api.github.com/users/djhoese/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3255/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
82,https://api.github.com/repos/dask/dask/issues/3277,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3277/labels{/name},https://api.github.com/repos/dask/dask/issues/3277/comments,https://api.github.com/repos/dask/dask/issues/3277/events,https://github.com/dask/dask/issues/3277,304516916,MDU6SXNzdWUzMDQ1MTY5MTY=,3277,Improve dask.array.fft's error messages,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2018-03-12T19:54:11Z,2018-10-24T18:36:01Z,,MEMBER,,Currently the error messages (particularly for 2-D and N-D) Dask Array FFT functions don't really match up to their NumPy counterparts either in terms of type or error message. Would be good if we could bring these into better alignment.,,https://api.github.com/repos/dask/dask/issues/3277/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3277/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
83,https://api.github.com/repos/dask/dask/issues/3278,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3278/labels{/name},https://api.github.com/repos/dask/dask/issues/3278/comments,https://api.github.com/repos/dask/dask/issues/3278/events,https://github.com/dask/dask/issues/3278,304532483,MDU6SXNzdWUzMDQ1MzI0ODM=,3278,Support arbitrary kwargs in dask.array.fft,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2018-03-12T20:43:05Z,2018-03-13T01:06:39Z,,MEMBER,,"Would be nice if the wrapper/wrapped functions in `dask.array.fft` supported arbitrary kwargs. That way implementation specific arguments could be passed on to the underlying FFT function.

Might be a little work if we wish to validate these arguments during graph construction. Alternatively we can just trust the user and raise at runtime if errors like this occur.",,https://api.github.com/repos/dask/dask/issues/3278/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3278/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
84,https://api.github.com/repos/dask/dask/issues/3280,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3280/labels{/name},https://api.github.com/repos/dask/dask/issues/3280/comments,https://api.github.com/repos/dask/dask/issues/3280/events,https://github.com/dask/dask/issues/3280,304593144,MDU6SXNzdWUzMDQ1OTMxNDQ=,3280,Support norm in dask.array.fft,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2018-03-13T01:06:16Z,2018-03-13T01:06:16Z,,MEMBER,,"The NumPy FFT functions optionally take a [`norm` argument]( https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.fft.html#normalization ). Would be good if the Dask Array functions also optionally took that argument and only passed it on if it was not `None` (the default). This because it is easier to support other functions that don't take `norm` if we don't require that argument. Alternatively, this might be best addressed as arbitrary keyword argument as proposed in issue ( https://github.com/dask/dask/issues/3278 ).",,https://api.github.com/repos/dask/dask/issues/3280/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3280/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
85,https://api.github.com/repos/dask/dask/issues/3281,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3281/labels{/name},https://api.github.com/repos/dask/dask/issues/3281/comments,https://api.github.com/repos/dask/dask/issues/3281/events,https://github.com/dask/dask/issues/3281,304639079,MDU6SXNzdWUzMDQ2MzkwNzk=,3281,Explore wrapping Intel's mkl_fft,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2018-03-13T06:08:17Z,2018-08-06T18:49:02Z,,MEMBER,,"Intel made an [`mkl_fft`]( https://github.com/IntelPython/mkl_fft ) library, which follows the NumPy API. As such it would be an easy thing to wrap with Dask Arrays' [`fft_wrap`]( http://dask.pydata.org/en/latest/array-api.html#dask.array.fft.fft_wrap ) function. Thus generating Dask Array friendly FFT functions that would leverage MKL for the computation in chunks. Would be interesting to write these and compare how they perform against other implementations (e.g. NumPy, SciPy, pyFFTW, etc.).",,https://api.github.com/repos/dask/dask/issues/3281/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3281/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
86,https://api.github.com/repos/dask/dask/issues/3302,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3302/labels{/name},https://api.github.com/repos/dask/dask/issues/3302/comments,https://api.github.com/repos/dask/dask/issues/3302/events,https://github.com/dask/dask/issues/3302,306613782,MDU6SXNzdWUzMDY2MTM3ODI=,3302,Method to make uniformly chunked Dask Arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2018-03-19T20:04:07Z,2018-05-02T16:27:50Z,,MEMBER,,"In the process of applying some operations on Dask Arrays, chunk sizes can become a bit heterogeneous. However storage applications tend to prefer more homogeneous chunk sizes. While it is possible to the store a Dask Array to a storage format with different chunk sizes, this typically comes at a penalty of needing locking. Certainly one can rechunk the Dask Array manually. However it would be nice to have a method for Dask Arrays, which has some better ideas as to what sort of rechunking will come with low penalty. This method can then determine some reasonable homogeneous chunk size and rechunk the Dask Array using them.",,https://api.github.com/repos/dask/dask/issues/3302/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3302/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
87,https://api.github.com/repos/dask/dask/issues/3329,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3329/labels{/name},https://api.github.com/repos/dask/dask/issues/3329/comments,https://api.github.com/repos/dask/dask/issues/3329/events,https://github.com/dask/dask/issues/3329,308396255,MDU6SXNzdWUzMDgzOTYyNTU=,3329,Override optimization strategy of Dask Collection instance,[],open,False,,[],,1,2018-03-25T23:23:52Z,2018-03-25T23:30:04Z,,MEMBER,,"There is a lot of functionality built into Dask for optimizing Dask Collections and handling this differently per Dask Collection type. Also it is pretty easy to override the optimization strategy globally (even for small blocks of code). However it's not clear to me (though it may exist), how one goes about specializing the optimization of particular instances. Some forms of optimization may be poor for a type overall. However if one knows a particular instance will benefit from a particular optimization in the future, it would be nice to have a way to hook that into the instance so it can be triggered when optimizations occur.",,https://api.github.com/repos/dask/dask/issues/3329/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3329/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
88,https://api.github.com/repos/dask/dask/issues/3355,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3355/labels{/name},https://api.github.com/repos/dask/dask/issues/3355/comments,https://api.github.com/repos/dask/dask/issues/3355/events,https://github.com/dask/dask/issues/3355,309863105,MDU6SXNzdWUzMDk4NjMxMDU=,3355,Support arrays with unknown lengths in broadcast_arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2018-03-29T18:46:05Z,2018-04-19T13:28:05Z,,MEMBER,,"Not totally sure how to approach this ATM. So just leaving an issue here to discuss and see if it is possible somehow.

Would be good if `broadcast_arrays` could support Dask Arrays with some unknown lengths (e.g. `nan` chunks).",,https://api.github.com/repos/dask/dask/issues/3355/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3355/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
89,https://api.github.com/repos/dask/dask/issues/3377,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3377/labels{/name},https://api.github.com/repos/dask/dask/issues/3377/comments,https://api.github.com/repos/dask/dask/issues/3377/events,https://github.com/dask/dask/issues/3377,311682754,MDU6SXNzdWUzMTE2ODI3NTQ=,3377,Option to compute several moments at once,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,7,2018-04-05T16:30:56Z,2021-10-12T05:50:42Z,,MEMBER,,"When doing basic statistics on a Dask Array, it is not uncommon to want to compute a few moments (or really cumulants) at the same time. For instance, one normally doesn't just want the mean, but also the variance (or standard deviation) and maybe even the skew. This means that a few moments need to be computed. Instead of constructing a graph for each of the moments need and combining them together afterwards, it would be nice to just state the range of moment orders that are needed and have a 1-D Dask Array returned with these moments in order.",,https://api.github.com/repos/dask/dask/issues/3377/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3377/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
90,https://api.github.com/repos/dask/dask/issues/3403,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3403/labels{/name},https://api.github.com/repos/dask/dask/issues/3403/comments,https://api.github.com/repos/dask/dask/issues/3403/events,https://github.com/dask/dask/issues/3403,314194270,MDU6SXNzdWUzMTQxOTQyNzA=,3403,Multiply reduces partitions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2018-04-13T17:43:21Z,2018-10-24T19:17:05Z,,NONE,,"I have a pandas dataframe that looks like this 

index  type  value1 value2
 0          a         .5        .6
 1          b         .25      .2
 2          c         .25       .2

Then a dask dataframe that looks like this

index  type  value1  value2
 0          a         8          9
 1          a         7          6
 2          b         2          10
 3          b         4          5
 4          c         2           7
 5          c         1           6

desired output

index   value1  value2
 a           4          5.4
 a           3.5       3.6
 b           0.5       2
 b           1          1
 c           0.5        1.4
 c           0.25      1.2

I want to set the type of both dataframes to the index then do dask_df.mul(pandas_df) so the values in the pandas dataframe are multiplied across all the matching row types in the dask dataframe. This gives me the result that I want but after the multiply the partitions in my dask dataframe are reduced from 124 to 2 and then any operations after the the multiply fail due to a memory error. I'm just wondering if there is a way to stop this repartition or another approach I can take to give the desired output without and wouldn't repartition.",,https://api.github.com/repos/dask/dask/issues/3403/timeline,,,ckaz02,10520677,MDQ6VXNlcjEwNTIwNjc3,https://avatars.githubusercontent.com/u/10520677?v=4,,https://api.github.com/users/ckaz02,https://github.com/ckaz02,https://api.github.com/users/ckaz02/followers,https://api.github.com/users/ckaz02/following{/other_user},https://api.github.com/users/ckaz02/gists{/gist_id},https://api.github.com/users/ckaz02/starred{/owner}{/repo},https://api.github.com/users/ckaz02/subscriptions,https://api.github.com/users/ckaz02/orgs,https://api.github.com/users/ckaz02/repos,https://api.github.com/users/ckaz02/events{/privacy},https://api.github.com/users/ckaz02/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3403/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
91,https://api.github.com/repos/dask/dask/issues/3406,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3406/labels{/name},https://api.github.com/repos/dask/dask/issues/3406/comments,https://api.github.com/repos/dask/dask/issues/3406/events,https://github.com/dask/dask/issues/3406,314422165,MDU6SXNzdWUzMTQ0MjIxNjU=,3406,Slice by 0-dimensional np.array,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2018-04-15T14:51:19Z,2021-10-24T22:40:39Z,,MEMBER,,"As of the current git head:
```
>>>> a = da.arange(2, chunks=2)
>>>> idx = np.array(0)
>>>> a[idx]

---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
<ipython-input-4-013759abffed> in <module>()
      3 a = da.arange(2, chunks=2)
      4 idx = np.array(0)
----> 5 a[idx]

~/anaconda3/lib/python3.6/site-packages/dask/array/core.py in __getitem__(self, index)
   1306 
   1307         out = 'getitem-' + tokenize(self, index2)
-> 1308         dsk, chunks = slice_array(out, self.name, self.chunks, index2)
   1309 
   1310         dsk2 = sharedict.merge(self.dask, (out, dsk))

~/anaconda3/lib/python3.6/site-packages/dask/array/slicing.py in slice_array(out_name, in_name, blockdims, index)
    155 
    156     # Pass down to next function
--> 157     dsk_out, bd_out = slice_with_newaxes(out_name, in_name, blockdims, index)
    158 
    159     bd_out = tuple(map(tuple, bd_out))

~/anaconda3/lib/python3.6/site-packages/dask/array/slicing.py in slice_with_newaxes(out_name, in_name, blockdims, index)
    177 
    178     # Pass down and do work
--> 179     dsk, blockdims2 = slice_wrap_lists(out_name, in_name, blockdims, index2)
    180 
    181     if where_none:

~/anaconda3/lib/python3.6/site-packages/dask/array/slicing.py in slice_wrap_lists(out_name, in_name, blockdims, index)
    232     # No lists, hooray! just use slice_slices_and_integers
    233     if not where_list:
--> 234         return slice_slices_and_integers(out_name, in_name, blockdims, index)
    235 
    236     # Replace all lists with full slices  [3, 1, 0] -> slice(None, None, None)

~/anaconda3/lib/python3.6/site-packages/dask/array/slicing.py in slice_slices_and_integers(out_name, in_name, blockdims, index)
    279             raise ValueError(""Arrays chunk sizes are unknown: %s"", shape)
    280 
--> 281     assert all(isinstance(ind, (slice, Integral)) for ind in index)
    282     assert len(index) == len(blockdims)
    283 
```
",,https://api.github.com/repos/dask/dask/issues/3406/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3406/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
92,https://api.github.com/repos/dask/dask/issues/3411,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3411/labels{/name},https://api.github.com/repos/dask/dask/issues/3411/comments,https://api.github.com/repos/dask/dask/issues/3411/events,https://github.com/dask/dask/issues/3411,314794657,MDU6SXNzdWUzMTQ3OTQ2NTc=,3411,Dataframe loc slicing can break divisions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2018-04-16T19:54:01Z,2018-06-18T13:35:50Z,,NONE,,"I think there are a number of edge cases where slicing a dataframe on the index with known divisions is not handled correctly:

```python
from dask import dataframe as dask_df
import pandas as pd

df = pd.DataFrame({'a':range(10, 15)}).set_index('a')
two_parts = dask_df.from_pandas(df, npartitions=2)
print(two_parts.divisions)  # (10, 13, 14)

# Slicing seems to treat divisions accurately
print(two_parts[11:13].divisions)  # (11, 13, 13)
print(two_parts[0:20].divisions)  # (10, 13, 14)

one_part = dask_df.from_pandas(df, npartitions=1)
print(one_part.divisions)  # (10, 14)
print(one_part[11:12].divisions)  # (11, 12)
print(one_part[:12].divisions)  # (10, 12)

# Except when slicing 1 partition, beyond range of index on that side
print(one_part[0:20].divisions)  # (0, 20) Should be (10, 14)
print(two_parts[0:12].divisions)  # (0, 12) Should be (10, 12)
print(two_parts[12:20].divisions)  # (12, 13, 14) works
print(two_parts[13:20].divisions)  # (13, 20) whoops!

# Out of index range stuff gives weird divisions, ideally should have 0 partitions
print(two_parts[20:].divisions)  # (20, 14)

```

The case where the slice bounds are used for the final devisions when there is only one partition impacted by the slice appears to be the fault of `_LocIndexer._loc_slice` with some hard to read logic that distinguishes between slice bounds of `None` and whether there is more than one partition impacted (`if stop == start`), etc.  I would think it should always take `max(slice.start, first_division)` and `min(slice.end, last_division)` when `known_divisions==True`.

For a slice where no partitions should be returned, I'm not sure what the desired result should be.  As is it will 'work' but be suboptimal because it needs to compute an entire partition unnecessarily, while all that is needed is an empty dataframe corresponding to meta (if that's desired at all, ie it could be elided on a concatenation).",,https://api.github.com/repos/dask/dask/issues/3411/timeline,,,gorlins,139286,MDQ6VXNlcjEzOTI4Ng==,https://avatars.githubusercontent.com/u/139286?v=4,,https://api.github.com/users/gorlins,https://github.com/gorlins,https://api.github.com/users/gorlins/followers,https://api.github.com/users/gorlins/following{/other_user},https://api.github.com/users/gorlins/gists{/gist_id},https://api.github.com/users/gorlins/starred{/owner}{/repo},https://api.github.com/users/gorlins/subscriptions,https://api.github.com/users/gorlins/orgs,https://api.github.com/users/gorlins/repos,https://api.github.com/users/gorlins/events{/privacy},https://api.github.com/users/gorlins/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3411/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
93,https://api.github.com/repos/dask/dask/issues/3422,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3422/labels{/name},https://api.github.com/repos/dask/dask/issues/3422/comments,https://api.github.com/repos/dask/dask/issues/3422/events,https://github.com/dask/dask/issues/3422,315902153,MDU6SXNzdWUzMTU5MDIxNTM=,3422,Slices not fused in some cases,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2018-04-19T14:26:35Z,2021-10-12T05:42:21Z,,MEMBER,,"Someone reported this to me in a side-channel.  Reproducing here.

Reproducer:

```python
class A(object):
    dtype = np.dtype('float64')
    shape = (10,)

a = da.asarray(A())

print 'RECHUNK'
print '======='
pprint.pprint(dask.base.collections_to_dsk([a.rechunk(7)]),width=200)

print
print 'RECHUNK + ASTYPE'
print '================'
pprint.pprint(dask.base.collections_to_dsk([a.rechunk(7).astype('float32')]),width=200)
```

Leads to nice slice fusion here:

```
RECHUNK
=======
{'array-original-55fab0853cc9e527a51bf1324d69e099': <__main__.A object at 0x7fcca4f07690>,
 ('rechunk-merge-0e470de06bd3289659423047c743cc68', 0): ('rechunk-split-rechunk-merge-0e470de06bd3289659423047c743cc68', 0),
 ('rechunk-merge-0e470de06bd3289659423047c743cc68', 1): ('rechunk-split-rechunk-merge-0e470de06bd3289659423047c743cc68', 1),
 ('rechunk-split-rechunk-merge-0e470de06bd3289659423047c743cc68', 0): (<function getter at 0x7fcca5783cf8>, 'array-original-55fab0853cc9e527a51bf1324d69e099', (slice(0, 7, None),)),
 ('rechunk-split-rechunk-merge-0e470de06bd3289659423047c743cc68', 1): (<function getter at 0x7fcca5783cf8>, 'array-original-55fab0853cc9e527a51bf1324d69e099', (slice(7, 10, None),))}
```

but no fusing here -- note the continued existence of `slice(0, 10, None)`:

```
RECHUNK + ASTYPE
================
{'array-original-55fab0853cc9e527a51bf1324d69e099': <__main__.A object at 0x7fcca4f07690>,
 ('astype-f6cb2b1e26daa58e45573bd2b2c9885e', 0): ('rechunk-merge-rechunk-split-astype-f6cb2b1e26daa58e45573bd2b2c9885e', 0),
 ('astype-f6cb2b1e26daa58e45573bd2b2c9885e', 1): ('rechunk-merge-rechunk-split-astype-f6cb2b1e26daa58e45573bd2b2c9885e', 1),
 ('rechunk-merge-rechunk-split-astype-f6cb2b1e26daa58e45573bd2b2c9885e', 0): (<built-in function apply>,
                                                                              <function astype at 0x7fcca6ac0f50>,
                                                                              [(<built-in function getitem>,
                                                                                (<function getter_inline at 0x7fcca5783e60>,
                                                                                 'array-original-55fab0853cc9e527a51bf1324d69e099',
                                                                                 (slice(0, 10, None),)),
                                                                                (slice(0, 7, None),))],
                                                                              {'astype_dtype': dtype('float32')}),
 ('rechunk-merge-rechunk-split-astype-f6cb2b1e26daa58e45573bd2b2c9885e', 1): (<built-in function apply>,
                                                                              <function astype at 0x7fcca6ac0f50>,
                                                                              [(<built-in function getitem>,
                                                                                (<function getter_inline at 0x7fcca5783e60>,
                                                                                 'array-original-55fab0853cc9e527a51bf1324d69e099',
                                                                                 (slice(0, 10, None),)),
                                                                                (slice(7, 10, None),))],
                                                                              {'astype_dtype': dtype('float32')})}
```",,https://api.github.com/repos/dask/dask/issues/3422/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3422/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
94,https://api.github.com/repos/dask/dask/issues/3431,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3431/labels{/name},https://api.github.com/repos/dask/dask/issues/3431/comments,https://api.github.com/repos/dask/dask/issues/3431/events,https://github.com/dask/dask/issues/3431,316921885,MDU6SXNzdWUzMTY5MjE4ODU=,3431,Merge on CategoricalIndex fails with KeyError,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2018-04-23T18:08:05Z,2021-10-12T05:34:52Z,,MEMBER,,"I'm trying to set up the merge of two dataframes with a `CategoricalIndex` but am getting a confusing traceback (see below). I could track down the issue to the [align_partitions](https://github.com/dask/dask/blob/196c9b0d2656fb544945018bb68ce6ebce5c0870/dask/dataframe/multi.py#L75) function and eventually to the repartition of the dataframe itself. This is where I surrendered and I'd be glad for some help.

Here is an example where the Error is raised if more than one partition is used (same can be reproduced if, e.g. `from_delayed` is used)

Disclaimer: I'm running on the pandas master

```
import dask.dataframe as dd
import pandas as pd
from dask import delayed

df = pd.DataFrame({
    'data': [1, 2, 3, 4],
    'index': ['A', 'A', 'B', 'B']
})

ddf = dd.from_pandas(df, npartitions=1).set_index('index').categorize()
res1 = ddf.merge(ddf, left_index=True, right_index=True).compute()

ddf = dd.from_pandas(df, npartitions=2).set_index('index').categorize()
res2 = ddf.merge(ddf, left_index=True, right_index=True).compute()

dd.utils.assert_eq(res1, res2)
```

Traceback


```
Traceback (most recent call last):
  File ""/workspace/pandas/pandas/core/indexes/base.py"", line 4174, in get_slice_bound
    return self._searchsorted_monotonic(label, side)
  File ""/workspace/pandas/pandas/core/indexes/base.py"", line 4124, in _searchsorted_monotonic
    return self.searchsorted(label, side=side)
  File ""/workspace/pandas/pandas/util/_decorators.py"", line 177, in wrapper
    return func(*args, **kwargs)
  File ""/workspace/pandas/pandas/core/base.py"", line 1215, in searchsorted
    return self.values.searchsorted(value, side=side, sorter=sorter)
  File ""/workspace/pandas/pandas/util/_decorators.py"", line 177, in wrapper
    return func(*args, **kwargs)
  File ""/workspace/pandas/pandas/core/arrays/categorical.py"", line 1292, in searchsorted
    raise ValueError(""Categorical not ordered\nyou can use ""
ValueError: Categorical not ordered
you can use .as_ordered() to change the Categorical to an ordered one

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""tests/integrationtests/Untitled-1.py"", line 25, in <module>
    result_delayed = ddf.merge(ddf, left_index=True, right_index=True).compute()
  File ""/workspace/dask/dask/base.py"", line 155, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/workspace/dask/dask/base.py"", line 404, in compute
    results = get(dsk, keys, **kwargs)
  File ""/workspace/dask/dask/threaded.py"", line 75, in get
    pack_exception=pack_exception, **kwargs)
  File ""/workspace/dask/dask/local.py"", line 521, in get_async
    raise_exception(exc, tb)
  File ""/workspace/dask/dask/compatibility.py"", line 67, in reraise
    raise exc
  File ""/workspace/dask/dask/local.py"", line 290, in execute_task
    result = _execute_task(task, data)
  File ""/workspace/dask/dask/local.py"", line 271, in _execute_task
    return func(*args2)
  File ""/workspace/dask/dask/dataframe/methods.py"", line 81, in boundary_slice
    result = getattr(df, kind)[start:stop]
  File ""/workspace/pandas/pandas/core/indexing.py"", line 1375, in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
  File ""/workspace/pandas/pandas/core/indexing.py"", line 1797, in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
  File ""/workspace/pandas/pandas/core/indexing.py"", line 1408, in _get_slice_axis
    slice_obj.step, kind=self.name)
  File ""/workspace/pandas/pandas/core/indexes/base.py"", line 4040, in slice_indexer
    kind=kind)
  File ""/workspace/pandas/pandas/core/indexes/base.py"", line 4247, in slice_locs
    end_slice = self.get_slice_bound(end, 'right', kind)
  File ""/workspace/pandas/pandas/core/indexes/base.py"", line 4177, in get_slice_bound
    raise err
  File ""/workspace/pandas/pandas/core/indexes/base.py"", line 4171, in get_slice_bound
    slc = self._get_loc_only_exact_matches(label)
  File ""/workspace/pandas/pandas/core/indexes/base.py"", line 4140, in _get_loc_only_exact_matches
    return self.get_loc(key)
  File ""/workspace/pandas/pandas/core/indexes/category.py"", line 442, in get_loc
    return self._engine.get_loc(codes)
  File ""pandas/_libs/index.pyx"", line 139, in pandas._libs.index.IndexEngine.get_loc
  File ""pandas/_libs/index.pyx"", line 156, in pandas._libs.index.IndexEngine.get_loc
  File ""pandas/_libs/index.pyx"", line 176, in pandas._libs.index.IndexEngine._get_loc_duplicates
KeyError: 1
```",,https://api.github.com/repos/dask/dask/issues/3431/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3431/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
95,https://api.github.com/repos/dask/dask/issues/3437,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3437/labels{/name},https://api.github.com/repos/dask/dask/issues/3437/comments,https://api.github.com/repos/dask/dask/issues/3437/events,https://github.com/dask/dask/issues/3437,317258972,MDU6SXNzdWUzMTcyNTg5NzI=,3437,Improving map_blocks/map_overlap,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2018-04-24T14:42:50Z,2018-06-12T00:15:04Z,,MEMBER,,"Currently the `map_blocks`/`map_overlap` interfaces provide one main way to pass arguments and keyword arguments that is a variadic `**kwargs` argument. However if one has keyword arguments that overlap with those that `map_blocks`/`map_overlap` take, then one is either not able to pass them or has to write a shim function to map the arguments to something that won't conflict. With variadic arguments, one can pass them along to `map_blocks` (not to `map_overlap`), but they may or may not work. In the case of `map_overlap`, variadic arguments are simply unsupported.

This could be fixed by adding two arguments to `map_blocks`/`map_overlap`. Namely `func_args` and `func_kwargs`. These would be regular arguments taking a sequence and a mapping respectively. Also these would not be treated as non-Dask collection arguments. In the implementation detail, these would be unpacked in the function call. This would avoid confusion caused by trying to have these arguments live alongside arguments to `map_blocks`/`map_overlap`. Longer term, the old strategy of passing arguments could be deprecated and dropped by 1.0.

xref: https://github.com/dask/dask/issues/3263
xref: https://github.com/dask/dask/issues/3081",,https://api.github.com/repos/dask/dask/issues/3437/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3437/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
96,https://api.github.com/repos/dask/dask/issues/3481,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3481/labels{/name},https://api.github.com/repos/dask/dask/issues/3481/comments,https://api.github.com/repos/dask/dask/issues/3481/events,https://github.com/dask/dask/issues/3481,321327136,MDU6SXNzdWUzMjEzMjcxMzY=,3481,Newly enabled tests in test_groupby fail.,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2018-05-08T20:02:20Z,2021-10-12T05:32:13Z,,CONTRIBUTOR,,"The tests enabled by PR #3480 contain some that fail. These are

```
    pdf = pd.DataFrame({'x': [0, 1, 2, 3, 4, 6, 7, 8, 9, 10],
                        'y': list('abcbabbcda')})
    ddf = dd.from_pandas(pdf, 3)

    gp = pdf.groupby('y')['x']
    dp = ddf.groupby('y')['x']
    assert isinstance(dp.obj, dd.Series)
```

and

```
    gp = pdf.groupby(pdf.y)['x']
    dp = ddf.groupby(ddf.y)['x']
    assert isinstance(dp.obj, dd.Series)
```",,https://api.github.com/repos/dask/dask/issues/3481/timeline,,,joergdietrich,1462921,MDQ6VXNlcjE0NjI5MjE=,https://avatars.githubusercontent.com/u/1462921?v=4,,https://api.github.com/users/joergdietrich,https://github.com/joergdietrich,https://api.github.com/users/joergdietrich/followers,https://api.github.com/users/joergdietrich/following{/other_user},https://api.github.com/users/joergdietrich/gists{/gist_id},https://api.github.com/users/joergdietrich/starred{/owner}{/repo},https://api.github.com/users/joergdietrich/subscriptions,https://api.github.com/users/joergdietrich/orgs,https://api.github.com/users/joergdietrich/repos,https://api.github.com/users/joergdietrich/events{/privacy},https://api.github.com/users/joergdietrich/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3481/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
97,https://api.github.com/repos/dask/dask/issues/3487,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3487/labels{/name},https://api.github.com/repos/dask/dask/issues/3487/comments,https://api.github.com/repos/dask/dask/issues/3487/events,https://github.com/dask/dask/issues/3487,322005830,MDU6SXNzdWUzMjIwMDU4MzA=,3487,Storing multiple files of data,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,11,2018-05-10T17:01:30Z,2021-10-12T05:30:28Z,,MEMBER,,"Thinking about this primarily in terms of Dask Arrays (after discussion with a colleague), but maybe this applies elsewhere as well.

A typical use case we encounter is a user has a directory full of files (usually TIFFs, but sometimes other things). They would like to load this data into a single Dask Array, which they would like to perform some operations on. At the end of this, they would like to spit out another directory of files (again usually TIFFs, but sometimes other things).

The current recommendation with loading is a user can call functions wrapped with `delayed` and convert those into arrays using known metadata, which they can then run `stack` and `concatenate` to their hearts content. A nice example of this procedure is in issue ( https://github.com/dask/dask/issues/672 ). Though hopefully these days users just use [`block`]( http://dask.pydata.org/en/latest/array-api.html#dask.array.block ). There are some things like [`dask-imread`]( https://github.com/dask-image/dask-imread ) that do this for users. When it finally comes to storing data, the user is encouraged to use [`store`]( http://dask.pydata.org/en/latest/array-api.html#dask.array.store ), which works fine for things that support a NumPy-like interface.

However when it comes to storing Dask Arrays, there are only a handful of things that could store a large array via a NumPy-like interface in the way that Dask would like to. If the storage format you have in mind (normally determined by what else it needs to be used with) does not fit this interface, you're stuck. In particular some cases are better resolved by writing out a bunch of small files (in our case TIFFs work well). Certainly one could home brew a NumPy-like interface that allows this, but this seems unnecessary since the chunks that Dask Array already operates on are perfect candidates for being mapped one-to-one to files on disk. With such a mapping one is also guaranteed parallel writes, which is desirable combination with Dask. In fact users are already hacking things like `map_blocks` to get this behavior (even though that is not their intend use).

So how could we make this better for users. One thought would be an operation to convert Dask Array chunks into proper Dask Arrays as envisioned in issue ( https://github.com/dask/dask/issues/3274 ). This would allow one to use `store` semantics with chunks and individual files. Though there would still be some home brewing to use the NumPy API for each chunk. Not to mention users would need to come up with a naming scheme. Another thought would be to simply implement an improved `map_blocks` interface for this intent called `store_blocks`. This would handle optimization of a Dask Array and take a function that performs the storage operation. The function could take a `block_id`/`chunk_id` parameter to help with file naming. There may be other options I have not thought of that would work as well. Feedback welcome. :)",,https://api.github.com/repos/dask/dask/issues/3487/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3487/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
98,https://api.github.com/repos/dask/dask/issues/3514,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3514/labels{/name},https://api.github.com/repos/dask/dask/issues/3514/comments,https://api.github.com/repos/dask/dask/issues/3514/events,https://github.com/dask/dask/issues/3514,324621533,MDU6SXNzdWUzMjQ2MjE1MzM=,3514,Very large dask arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,23,2018-05-19T11:03:46Z,2021-10-12T05:27:41Z,,MEMBER,,"When dealing with very large datasets sometimes the task graph handling becomes a bottleneck.  What are some ways in which this can be addressed medium-to-long term.

As an example consider a petabyte array cut into gigabyte chunks.  This means that each elementwise operation on the array generates a million new tasks.  If each task takes up something like 1ms of overhead, then each operation generates around 16 minutes of overhead on the client and scheduler (assuming distributed for the time being).  If we're doing operations with a hundred or so operations then we're waiting a day or two with just overhead.

How can we address this situation?

1.  **Reduce per-task overhead**:  1ms today is actually fairly pessimistic, we're closer to 200-300us, but this requires some effort on our part to ensure that all tasks are cheaply serializable.  This means no dynamic functions, or anything that strictly requires cloudpickle or generates a nontrivial amount of data in serialized form.
2.  **Fuse tasks**: Currently when we do `2 * x + 1` both the `2 * ` and `+ 1` operations generate a million tasks.  This hurts both when we construct the dask arrays, and when we send them to the scheduler.  Ideally we would pre-fuse operations like these, so that we only ever generated one million tasks that did both the `2 *` and `+ 1`.  This requires that the things we operate on at first to behave differently than dask.arrays as they are currently designed.  We need some sort of higher-level array construct.  This might either be a fully symbolic array (simliar to SymPy) or it might be a modification to dask.array to support [atop fusion](https://github.com/dask/dask/issues/2538).
3.  **Overlap overhead with computation**: the 16 minutes of overhead might not be that big of a deal if the computation itself is large.  In this case it's mostly a UX problem as people feel concerned that their computation hasn't started yet.  If we're able to break apart the graph into reasonable chunks then we might be able to stream the graph to the scheduler in pieces.  Doing this cheaply and reliably is likely to be very hard though.
4.  **Use much larger tasks**: Everything becomes easier if we make our tasks larger.  Memory and compute power continues to grow.  ",,https://api.github.com/repos/dask/dask/issues/3514/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3514/reactions,4,4,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
99,https://api.github.com/repos/dask/dask/issues/3523,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3523/labels{/name},https://api.github.com/repos/dask/dask/issues/3523/comments,https://api.github.com/repos/dask/dask/issues/3523/events,https://github.com/dask/dask/issues/3523,325637844,MDU6SXNzdWUzMjU2Mzc4NDQ=,3523,dask.get apparent inconsistencies and possible bug,[],open,False,,[],,8,2018-05-23T10:08:57Z,2018-05-30T14:03:03Z,,NONE,,"I found some apparent inconsistencies and a possible bug with dask.get. See minimal example below (outputs captured with dask 0.17.5).

**Specifically:**

1. Example 5 seems like inconsistent behaviour compared to Examples 3 and 4.
2. I see no reason why Example 7 should throw a KeyError compared to Example 6.

In general, I'm pretty confused as to when Dask will choose to interpolate string literals with the output of other keys in the graph and when it won't. The docs also don't specify how exactly Dask will process a graph. Rules that I've assembled by reading the docs and experimenting seem to be:

1. Strings are replaced by the output of keys with the same name.
2. There is interpolation inside tuples if the first element is a function. Examples 3-5 show inconsistent behaviour here though.
3. Other literals are not interpolated. However, Example 7 raises a KeyError.

Does the above describe the (intended) rules accurately?

```python
import dask

# Example 1
dsk = {'a': 1, 'b': 'a'}
print(dask.get(dsk, 'b'))
# Out: 1 --> OK, 'a' is interpolated to 1

# Example 2
dsk = {'a': 1, 'b': ('a', ) }
print(dask.get(dsk, 'b'))
# Out: ('a', ) --> OK, so no interpolation of 'a' here

# Example 3
dsk = {'a': 1, 'b': (tuple, ['a']) }
print(dask.get(dsk, 'b'))
# Out: ('a', ) --> OK, so this interpolates 'a' to 1

# Example 4
dsk = {'a': 1, 'b': (tuple, [['a']])}
print(dask.get(dsk, 'b'))
# Out: ([1],) --> OK, so still interpolating 'a' to 1

# Example 5
dsk = {'a': 1, 'b': (tuple, {'a'})}
print(dask.get(dsk, 'b'))
# Out: ('a',) --> Confused, why is this not interpolating 'a'?

# Example 6
dsk = {'a': 1, 'b': {'a': 'c'} }
print(dask.get(dsk, 'b'))
# Out: {'a': 'c'} --> OK, so no interpolation of 'a' here

# Example 7
dsk = {'a': 1, 'b': {'c': 'a'}}
print(dask.get(dsk, 'b'))
# KeyError --> I would expect no interpolation here, but throws KeyError.
```

CC @floriango @zgornel",,https://api.github.com/repos/dask/dask/issues/3523/timeline,,,lsorber,4543654,MDQ6VXNlcjQ1NDM2NTQ=,https://avatars.githubusercontent.com/u/4543654?v=4,,https://api.github.com/users/lsorber,https://github.com/lsorber,https://api.github.com/users/lsorber/followers,https://api.github.com/users/lsorber/following{/other_user},https://api.github.com/users/lsorber/gists{/gist_id},https://api.github.com/users/lsorber/starred{/owner}{/repo},https://api.github.com/users/lsorber/subscriptions,https://api.github.com/users/lsorber/orgs,https://api.github.com/users/lsorber/repos,https://api.github.com/users/lsorber/events{/privacy},https://api.github.com/users/lsorber/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3523/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
100,https://api.github.com/repos/dask/dask/issues/3527,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3527/labels{/name},https://api.github.com/repos/dask/dask/issues/3527/comments,https://api.github.com/repos/dask/dask/issues/3527/events,https://github.com/dask/dask/issues/3527,326178812,MDU6SXNzdWUzMjYxNzg4MTI=,3527,Suggestion: Series.agg,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,6,2018-05-24T15:38:24Z,2020-09-25T20:08:19Z,,NONE,,"Pandas allows multiple aggregations on a Series with a single `agg` method.

```python
s = Series(np.arange(10))
s.agg(['min', 'max'])
=> 
min    0
max    9
dtype: int64
```

I don't see a way to currently compute aggregates on a dask Series in a single pass, and it seems this could be useful to that end.",,https://api.github.com/repos/dask/dask/issues/3527/timeline,,,wcbeard,379413,MDQ6VXNlcjM3OTQxMw==,https://avatars.githubusercontent.com/u/379413?v=4,,https://api.github.com/users/wcbeard,https://github.com/wcbeard,https://api.github.com/users/wcbeard/followers,https://api.github.com/users/wcbeard/following{/other_user},https://api.github.com/users/wcbeard/gists{/gist_id},https://api.github.com/users/wcbeard/starred{/owner}{/repo},https://api.github.com/users/wcbeard/subscriptions,https://api.github.com/users/wcbeard/orgs,https://api.github.com/users/wcbeard/repos,https://api.github.com/users/wcbeard/events{/privacy},https://api.github.com/users/wcbeard/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3527/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
101,https://api.github.com/repos/dask/dask/issues/3530,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3530/labels{/name},https://api.github.com/repos/dask/dask/issues/3530/comments,https://api.github.com/repos/dask/dask/issues/3530/events,https://github.com/dask/dask/issues/3530,326234335,MDU6SXNzdWUzMjYyMzQzMzU=,3530,Memory leak with Numpy arrays and the threaded scheduler,[],open,False,,[],,56,2018-05-24T18:14:06Z,2021-12-09T14:54:33Z,,MEMBER,,"This example leaks around 500MB of memory on my machine when using the threaded scheduler, and almost no memory when using the single-threaded scheduler:

```python
import dask.array as da
x = da.ones((2e4, 2e4), chunks=(2e4, 100))
y = x.rechunk((100, 2e4))
z = y.rechunk((2e4, 100))

import psutil
proc = psutil.Process()

from distributed.utils import format_bytes
print(format_bytes(proc.memory_info().rss))
# 80MB

from dask.diagnostics import ProgressBar
ProgressBar().register()

# z.sum().compute(scheduler='single-threaded')  # This doesn't cause problems
z.sum().compute(scheduler='threads')  # This leaks around 500MB of memory

print(format_bytes(proc.memory_info().rss))
# 500-600MB
```

[Notebook](https://gist.github.com/a32b2ba79dc51ff6f0632104ac23ae40)

This doesn't happen when I run it with the single-threaded scheduler.  

Calling `gc.collect()` doesn't help.  Allocating a new large numpy array afterwards also doesn't take up the leaked memory,  the number just climbs.  Looking at the objects that Python knows about shows that there isn't much around:

```python
from pympler import muppy
all_objects = muppy.get_objects()

from pympler import summary
sum1 = summary.summarize(all_objects)
summary.print_(sum1)                          
```

```
                                      types |   # objects |   total size
=========================================== | =========== | ============
                                <class 'str |       60517 |      8.75 MB
                               <class 'dict |       11991 |      5.30 MB
                               <class 'code |       19697 |      2.72 MB
                               <class 'type |        2228 |      2.24 MB
                              <class 'tuple |       16142 |      1.04 MB
                                <class 'set |        2285 |    858.84 KB
                               <class 'list |        7284 |    738.09 KB
                            <class 'weakref |        4412 |    344.69 KB
                        <class 'abc.ABCMeta |         261 |    263.54 KB
                        function (__init__) |        1378 |    183.02 KB
  <class 'traitlets.traitlets.MetaHasTraits |         180 |    175.45 KB
                 <class 'wrapper_descriptor |        2240 |    175.00 KB
                                <class 'int |        5584 |    168.92 KB
                  <class 'getset_descriptor |        2389 |    167.98 KB
            <class 'collections.OrderedDict |         292 |    141.00 KB
```

The local schedulers don't have any persistent state.  My next step is to reproduce with the standard concurrent.futures module, but I thought I'd put this up early in case people have suggestions.

cc @shoyer @pitrou @njsmith",,https://api.github.com/repos/dask/dask/issues/3530/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3530/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
102,https://api.github.com/repos/dask/dask/issues/3535,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3535/labels{/name},https://api.github.com/repos/dask/dask/issues/3535/comments,https://api.github.com/repos/dask/dask/issues/3535/events,https://github.com/dask/dask/issues/3535,326575178,MDU6SXNzdWUzMjY1NzUxNzg=,3535,possible optimization for slice / concatenate operations over contiguous chunks,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2018-05-25T15:44:41Z,2018-06-08T15:00:00Z,,MEMBER,,"Dask's [`array.roll`](https://github.com/dask/dask/blob/4020cb97a1d356d0b05c9c9b5c96f1aa277f3bf9/dask/array/routines.py#L875-L920) function shifts the positions of array elements along an axis, wrapping around the edge of the array. This operation is very important for many numerical calculations. It does this by slicing the array and then calling `concatenate` to piece it back together in the new order.

Xarray's [`roll` method](http://xarray.pydata.org/en/stable/generated/xarray.DataArray.roll.html) basically [re-implements](https://github.com/pydata/xarray/blob/master/xarray/core/variable.py#L985-L1003) the same logic. In [xgcm](http://xgcm.readthedocs.io/en/latest/), we we also do something similar, but possibly using more complex topological connections between elements of the array than the simple periodicity assumed by `roll`. I am motivated to raise this issue here because of scalability challenges related to xgcm on very large datasets.

I think there is an opportunity for optimization of these operations in the **special case where the roll occurs over a contiguous chunk**. (In practice, this is often the case.) Consider the following example.

```python
import numpy as np
import dask.array as dsa

nt = 2
nx = 500
data = dsa.random.random(size=(nt, nx), chunks=(1, nx))
dsa.roll(data, 1, axis=-1).visualize()
```
![image](https://user-images.githubusercontent.com/1197350/40553065-8f80d2aa-600f-11e8-9d14-8ec40ea46a8f.png)

It is instructive to re-implement our own roll function the way dask does it to see that it works the same:

```python
def roll_with_dask(array, split_point):
    left = array[..., :split_point]
    right = array[..., split_point:]
    return dsa.concatenate([right, left], axis=-1)
roll_with_dask(data, 1).visualize()
```
![image](https://user-images.githubusercontent.com/1197350/40553059-862b2412-600f-11e8-83ae-fc6bdd2f45a9.png)

Now I implement the same function in numpy and apply it with map blocks:
```python
def roll_with_numpy(array, split_point):
    left = array[..., :split_point]
    right = array[..., split_point:]
    return np.concatenate([right, left], axis=-1)
data.map_blocks(roll_with_numpy, 1).visualize()
```
![image](https://user-images.githubusercontent.com/1197350/40553157-ce6241d4-600f-11e8-8753-029274ff8039.png)

These two give the same answer:
```python
np.testing.assert_allclose(
    data.map_blocks(roll_with_numpy, 1),
    roll_with_dask(data, 1)
)
```

But the `map_blocks` version has fewer chunks and consequently is much more efficient. Furthermore, no rechunking is required down the line if we want to combine this rolled array with other non-rolled array (e.g. when taking a finite difference). These things make a big difference when working with very large arrays.

To generalize this example, it seems that all slice and concat operations over contiguous chunks should be able to be accomplished at the numpy level. Is this something that could conceivably be detected at the optimization stage and in-lined?",,https://api.github.com/repos/dask/dask/issues/3535/timeline,,,rabernat,1197350,MDQ6VXNlcjExOTczNTA=,https://avatars.githubusercontent.com/u/1197350?v=4,,https://api.github.com/users/rabernat,https://github.com/rabernat,https://api.github.com/users/rabernat/followers,https://api.github.com/users/rabernat/following{/other_user},https://api.github.com/users/rabernat/gists{/gist_id},https://api.github.com/users/rabernat/starred{/owner}{/repo},https://api.github.com/users/rabernat/subscriptions,https://api.github.com/users/rabernat/orgs,https://api.github.com/users/rabernat/repos,https://api.github.com/users/rabernat/events{/privacy},https://api.github.com/users/rabernat/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3535/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
103,https://api.github.com/repos/dask/dask/issues/3542,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3542/labels{/name},https://api.github.com/repos/dask/dask/issues/3542/comments,https://api.github.com/repos/dask/dask/issues/3542/events,https://github.com/dask/dask/issues/3542,327572550,MDU6SXNzdWUzMjc1NzI1NTA=,3542,Allowing optional chunks argument in asarray,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2018-05-30T04:44:36Z,2018-10-24T19:23:28Z,,MEMBER,,"Thinking about this in the context of converting NumPy arrays (or NumPy-like arrays) to Dask Arrays while still nicely handling the Dask Array case.

It would be nice for [`asarray`]( http://dask.pydata.org/en/latest/array-api.html#dask.array.asarray ) to take an optional `chunks` argument (default `None`). This could be used to set a chunking for a NumPy array, but maybe leave a Dask Array untouched (or possibly rechunked). My thoughts are mixed on this at this stage. Happy to hear other thoughts.

cc @jni",,https://api.github.com/repos/dask/dask/issues/3542/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3542/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
104,https://api.github.com/repos/dask/dask/issues/3545,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3545/labels{/name},https://api.github.com/repos/dask/dask/issues/3545/comments,https://api.github.com/repos/dask/dask/issues/3545/events,https://github.com/dask/dask/issues/3545,327800140,MDU6SXNzdWUzMjc4MDAxNDA=,3545,Bag items silently disappear when mapped function errors,"[{'id': 242862273, 'node_id': 'MDU6TGFiZWwyNDI4NjIyNzM=', 'url': 'https://api.github.com/repos/dask/dask/labels/bag', 'name': 'bag', 'color': '0052cc', 'default': False, 'description': None}]",open,False,,[],,7,2018-05-30T16:10:23Z,2021-10-12T04:57:15Z,,NONE,,"When mapping a function over a bag, items from the `dask.bag` would silently disappear when the result of a function mapped over the bag would raise a `StopIteration` error. This is inconsistent with the usual behavior of Dask which is to propagate the error upwards, and caused some mild debugging headaches.

**Here's a small example of this while trying to discretize price information over a dataset:**
```python
>>> from dask import bag
>>> bins = [10, 40, 100, 1000]
>>> discretize = lambda price: next(i for i, v in enumerate(bins) if v > price)

>>> db = bag.from_sequence([12.49, 22.19, 39.99, 49.00, 50.55, 220.00, 1000.00])
>>> len(db.compute())
7
>>> len(db.map(discretize).compute())  # notice how length changes
6
>>> discretize(1000)
StopIteration Traceback
```",,https://api.github.com/repos/dask/dask/issues/3545/timeline,,,luizberti,1904278,MDQ6VXNlcjE5MDQyNzg=,https://avatars.githubusercontent.com/u/1904278?v=4,,https://api.github.com/users/luizberti,https://github.com/luizberti,https://api.github.com/users/luizberti/followers,https://api.github.com/users/luizberti/following{/other_user},https://api.github.com/users/luizberti/gists{/gist_id},https://api.github.com/users/luizberti/starred{/owner}{/repo},https://api.github.com/users/luizberti/subscriptions,https://api.github.com/users/luizberti/orgs,https://api.github.com/users/luizberti/repos,https://api.github.com/users/luizberti/events{/privacy},https://api.github.com/users/luizberti/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3545/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
105,https://api.github.com/repos/dask/dask/issues/3546,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3546/labels{/name},https://api.github.com/repos/dask/dask/issues/3546/comments,https://api.github.com/repos/dask/dask/issues/3546/events,https://github.com/dask/dask/issues/3546,327821705,MDU6SXNzdWUzMjc4MjE3MDU=,3546,Better error message when using single-machine schedulers to compute a graph with distributed Future,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,3,2018-05-30T17:12:17Z,2021-10-12T04:48:55Z,,MEMBER,,"This was a confusing error. We were persisting a dask array with a a distributed Client active, and then (unknowingly) using the threaded scheduler to do the compute.

Is there any hope of detecting this, and raising a better error message?

```python
In [19]: import dask.array as da

In [20]: from distributed import Client

In [21]: import dask

In [22]: client = Client()

In [23]: X, = dask.persist(da.random.uniform(size=(10, 10), chunks=5))

In [24]: X.compute(scheduler='threads')
```

```pytb
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-23-ae77d51b34af> in <module>()
----> 1 X.compute(scheduler='threads')

~/sandbox/dask/dask/base.py in compute(self, **kwargs)
    154         dask.base.compute
    155         """"""
--> 156         (result,) = compute(self, traverse=False, **kwargs)
    157         return result
    158

~/sandbox/dask/dask/base.py in compute(*args, **kwargs)
    399     postcomputes = [x.__dask_postcompute__() for x in collections]
    400     results = schedule(dsk, keys, **kwargs)
--> 401     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    402
    403

~/sandbox/dask/dask/base.py in <listcomp>(.0)
    399     postcomputes = [x.__dask_postcompute__() for x in collections]
    400     results = schedule(dsk, keys, **kwargs)
--> 401     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    402
    403

~/sandbox/dask/dask/array/core.py in finalize(results)
    986     while isinstance(results2, (tuple, list)):
    987         if len(results2) > 1:
--> 988             return concatenate3(results)
    989         else:
    990             results2 = results2[0]

~/sandbox/dask/dask/array/core.py in concatenate3(arrays)
   3363     if not ndim:
   3364         return arrays
-> 3365     chunks = chunks_from_arrays(arrays)
   3366     shape = tuple(map(sum, chunks))
   3367

~/sandbox/dask/dask/array/core.py in chunks_from_arrays(arrays)
   3189
   3190     while isinstance(arrays, (list, tuple)):
-> 3191         result.append(tuple([shape(deepfirst(a))[dim] for a in arrays]))
   3192         arrays = arrays[0]
   3193         dim += 1

~/sandbox/dask/dask/array/core.py in <listcomp>(.0)
   3189
   3190     while isinstance(arrays, (list, tuple)):
-> 3191         result.append(tuple([shape(deepfirst(a))[dim] for a in arrays]))
   3192         arrays = arrays[0]
   3193         dim += 1

IndexError: tuple index out of range


```",,https://api.github.com/repos/dask/dask/issues/3546/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3546/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
106,https://api.github.com/repos/dask/dask/issues/3547,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3547/labels{/name},https://api.github.com/repos/dask/dask/issues/3547/comments,https://api.github.com/repos/dask/dask/issues/3547/events,https://github.com/dask/dask/issues/3547,327866776,MDU6SXNzdWUzMjc4NjY3NzY=,3547,Supporting lists of functions in map_blocks/map_overlap,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2018-05-30T19:25:46Z,2019-04-30T19:18:46Z,,MEMBER,,"Would be nice for function composition to be able to provide a list of functions that will be applied in order in a single `map_blocks` or `map_overlap` operation. This is useful for reducing overhead involved with `map_overlap` in particular, but would be nice to use with `map_blocks` as well.

cc @jni @mrocklin",,https://api.github.com/repos/dask/dask/issues/3547/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3547/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
107,https://api.github.com/repos/dask/dask/issues/3551,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3551/labels{/name},https://api.github.com/repos/dask/dask/issues/3551/comments,https://api.github.com/repos/dask/dask/issues/3551/events,https://github.com/dask/dask/issues/3551,328683605,MDU6SXNzdWUzMjg2ODM2MDU=,3551,Apply optimizer functions to dask collections,[],open,False,,[],,6,2018-06-01T22:55:45Z,2018-06-14T13:54:05Z,,MEMBER,,"I find myself very, very frequently needing to optimize the graph of a dask array and then put it back into the dask array itself. This is a boring and laborious work, which could be eased with a couple of straightforward changes:

1. Change the dask collection interface to specify that a collection that defines ``__dask_graph__`` must also specify a ``copy(dsk=None)`` method. When it's invoked with dsk not None, the method creates a copy of the collection with a replaced dask graph.
2. Create a new module dask.collection.optimization which defines cull, fuse, inline, inline_functions:
```
from ... import optimization as oz
def cull(coll):
    dsk, dependencies = oz.cull(coll.__dask_graph__(), coll.__dask_keys__())
    return coll.copy(dsk=dsk), dependencies
```
Alternatively, one could modify the current cull, etc. functions to dynamically detect if the first argument is a dask collection - but I find it a bit more convoluted.",,https://api.github.com/repos/dask/dask/issues/3551/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3551/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
108,https://api.github.com/repos/dask/dask/issues/3557,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3557/labels{/name},https://api.github.com/repos/dask/dask/issues/3557/comments,https://api.github.com/repos/dask/dask/issues/3557/events,https://github.com/dask/dask/issues/3557,329250565,MDU6SXNzdWUzMjkyNTA1NjU=,3557,Simplify graph of single-chunk reductions,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2018-06-04T23:26:00Z,2019-04-29T11:11:47Z,,MEMBER,,"Whenever a reduction operates on a single chunk, it needlessly creates two nodes:
```
>>> dict(da.arange(2, chunks=2).sum().dask)
{
    ('sum-aggregate-ec0e68db6f32b6093d94c7b17d2bfe45',): (<toolz.functoolz.Compose at 0x7fd7d00962e8>, ('sum-880c178b66ab4131ea200c3a6dbf37a3', 0))
    ('sum-880c178b66ab4131ea200c3a6dbf37a3', 0): (<function dask.compatibility.apply(func, args, kwargs=None)>, functools.partial(<function sum at 0x7fd7f0307b70>, dtype=dtype('int64')), [('arange-9478255fa17899194839c85832cf613a', 0)], {'axis': (0,), 'keepdims': True}),
    ('arange-9478255fa17899194839c85832cf613a', 0): (<function dask.array.chunk.arange(start, stop, step, length, dtype)>, 0, 2, 1, 2, dtype('int64')),
}
```
This should be changed so that:
1. if the chunk and aggregate kernel are the same, instead of ``aggregate(chunk(..., keepdims=True), keepdims=False)`` we should just call ``chunk(..., keepdims=False)``
2. if the chunk and aggregate kernel differ, they should be compose'd into a single node.",,https://api.github.com/repos/dask/dask/issues/3557/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3557/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
109,https://api.github.com/repos/dask/dask/issues/3576,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3576/labels{/name},https://api.github.com/repos/dask/dask/issues/3576/comments,https://api.github.com/repos/dask/dask/issues/3576/events,https://github.com/dask/dask/issues/3576,330427580,MDU6SXNzdWUzMzA0Mjc1ODA=,3576,Supporting `full_matrices` argument with Dask's `svd`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,7,2018-06-07T20:40:33Z,2021-02-25T06:41:20Z,,MEMBER,,"Ran into an issue where NumPy's `svd` and Dask's `svd` would provide different shaped arrays. An example of this behavior is included below with details about the environment used to reproduce it.

<details>
<summary>Example:</summary>

```python
In [1]: import numpy as np

In [2]: import dask.array as da

In [3]: m, n = 20, 10

In [4]: a = np.random.rand(m, n)

In [5]: d_a = da.from_array(a, chunks=(3, n), name='A')

In [6]: d_u, d_s, d_vt = da.linalg.svd(d_a)

In [7]: u, s, vt = np.linalg.svd(a)

In [8]: assert d_u.shape == u.shape
---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
<ipython-input-8-dffa2c855847> in <module>()
----> 1 assert d_u.shape == u.shape

AssertionError: 

In [9]: d_u.shape
Out[9]: (20, 10)

In [10]: u.shape
Out[10]: (20, 20)
```

</details>

<br>

<details>
<summary>Environment:</summary>

```yaml
name: test
channels:
  - conda-forge
  - defaults
dependencies:
  - appnope=0.1.0=py36_0
  - backcall=0.1.0=py_0
  - blas=1.1=openblas
  - bokeh=0.12.16=py36_0
  - ca-certificates=2018.4.16=0
  - certifi=2018.4.16=py36_0
  - click=6.7=py_1
  - cloudpickle=0.5.3=py_0
  - cycler=0.10.0=py36_0
  - cytoolz=0.9.0.1=py36_0
  - dask=0.17.5=py_0
  - dask-core=0.17.5=py_0
  - decorator=4.3.0=py_0
  - distributed=1.21.8=py36_0
  - freetype=2.8.1=0
  - graphviz=2.38.0=7
  - heapdict=1.0.0=py36_0
  - ipython=6.4.0=py36_0
  - ipython_genutils=0.2.0=py36_0
  - jedi=0.12.0=py36_0
  - jinja2=2.10=py36_0
  - jpeg=9b=2
  - kiwisolver=1.0.1=py36_1
  - libgfortran=3.0.0=0
  - libpng=1.6.34=0
  - libtiff=4.0.9=0
  - locket=0.2.0=py36_1
  - markupsafe=1.0=py36_0
  - matplotlib=2.2.2=py36_1
  - msgpack-python=0.5.6=py36h2d50403_2
  - ncurses=5.9=10
  - numpy=1.14.3=py36_blas_openblas_200
  - openblas=0.2.20=8
  - openssl=1.0.2o=0
  - packaging=17.1=py_0
  - pandas=0.23.0=py36_1
  - parso=0.2.1=py_0
  - partd=0.3.8=py36_0
  - pexpect=4.6.0=py36_0
  - pickleshare=0.7.4=py36_0
  - prompt_toolkit=1.0.15=py36_0
  - psutil=5.4.5=py36_0
  - ptyprocess=0.5.2=py36_0
  - pygments=2.2.0=py36_0
  - pyparsing=2.2.0=py36_0
  - python=3.6.5=1
  - python-dateutil=2.7.3=py_0
  - python-graphviz=0.8.3=py36_0
  - pytz=2018.4=py_0
  - pyyaml=3.12=py36_1
  - readline=7.0=0
  - setuptools=39.2.0=py36_0
  - simplegeneric=0.8.1=py36_0
  - six=1.11.0=py36_1
  - sortedcontainers=2.0.2=py36_0
  - sqlite=3.20.1=2
  - tblib=1.3.2=py36_0
  - tk=8.6.7=0
  - toolz=0.9.0=py_0
  - tornado=5.0.2=py36_0
  - traitlets=4.3.2=py36_0
  - wcwidth=0.1.7=py36_0
  - xz=5.2.3=0
  - yaml=0.1.7=0
  - zict=0.1.3=py_0
  - zlib=1.2.11=h470a237_3
```

</details>",,https://api.github.com/repos/dask/dask/issues/3576/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3576/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
110,https://api.github.com/repos/dask/dask/issues/3587,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3587/labels{/name},https://api.github.com/repos/dask/dask/issues/3587/comments,https://api.github.com/repos/dask/dask/issues/3587/events,https://github.com/dask/dask/issues/3587,331007078,MDU6SXNzdWUzMzEwMDcwNzg=,3587,Convention for automatic rechunking,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,10,2018-06-10T22:12:52Z,2018-06-18T13:36:34Z,,MEMBER,,"There are a few operations where we can (and possibly should) meaningfully rechunk arrays for users:

1.  atop operations that include outer products, like tensordot
2.  linear algebra operations like qr and svd
3.  fft, where we need active dimensions to have a single chunk
4.  apply_gufunc, where we need core dimensions to have a single chunk
5.  from_array ?
6.  ...

In all of these cases we generally want to make a few dimensions have as few chunks as possible (often one) and then sometimes make other dimensions as large as possible while respecting chunk size memory limits, while still enabling some parallelism.  This can strongly affect performance.

For some operations like `fft` we currently raise informative errors that encourage users to do the right thing.  For other operations like `atop` we don't necessarily want to err, but do want to encourage users to do the right thing.  We might choose to do some of this automatically.  If so, we should do it consistently across all operations in order to avoid API diversity.

I'll propose a `rechunk=` keyword with the following semantics:

1. `rechunk=False` does no rechunking.
2.  `rechunk=True` tells the operation to do whatever it wants to perform automatic rechunking
3.  `rechunk='10MB'` or other string tells the operation to do whatever it wants to perform automatic rechunking, targetting chunk sizes of 10MB.  Otherwise we default to `dask.config.get('array.chunk-size')` as is done now.

I'll also suggest that we leave it to the operations whether or not they choose to do automatic rechunking.",,https://api.github.com/repos/dask/dask/issues/3587/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3587/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
111,https://api.github.com/repos/dask/dask/issues/3590,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3590/labels{/name},https://api.github.com/repos/dask/dask/issues/3590/comments,https://api.github.com/repos/dask/dask/issues/3590/events,https://github.com/dask/dask/issues/3590,331282857,MDU6SXNzdWUzMzEyODI4NTc=,3590,Automatically coerce map_blocks results to correct dimension,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,38,2018-06-11T17:37:33Z,2019-04-04T22:36:50Z,,NONE,,"I have a Dask array of 120 HD images built from a stack of delayed objects:
```
dask.array<stack, shape=(120, 1080, 1920), dtype=uint16, chunksize=(1, 1080, 1920)>
```
and I am trying to apply a function, which returns an int64, to each image using map_blocks:
```
floc_proxy = dsa.map_blocks(calc_floc_proxy, delayed_frame_array, d1, d2, n, dtype='i8', drop_axis=[1,2])
floc_proxy
dask.array<calc_floc_proxy, shape=(120,), dtype=int64, chunksize=(1,)>
```
when I do floc_proxy.compute(), it runs through all the calculations for each image just fine, but fails at the very end with the following error:
```
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-102-4aab0a1a8291> in <module>()
----> 1 floc_proxy.compute()

/opt/conda/lib/python3.6/site-packages/dask/base.py in compute(self, **kwargs)
    153         dask.base.compute
    154         """"""
--> 155         (result,) = compute(self, traverse=False, **kwargs)
    156         return result
    157 

/opt/conda/lib/python3.6/site-packages/dask/base.py in compute(*args, **kwargs)
    405     results_iter = iter(results)
    406     return tuple(a if f is None else f(next(results_iter), *a)
--> 407                  for f, a in postcomputes)
    408 
    409 

/opt/conda/lib/python3.6/site-packages/dask/base.py in <genexpr>(.0)
    405     results_iter = iter(results)
    406     return tuple(a if f is None else f(next(results_iter), *a)
--> 407                  for f, a in postcomputes)
    408 
    409 

/opt/conda/lib/python3.6/site-packages/dask/array/core.py in finalize(results)
    991     while isinstance(results2, (tuple, list)):
    992         if len(results2) > 1:
--> 993             return concatenate3(results)
    994         else:
    995             results2 = results2[0]

/opt/conda/lib/python3.6/site-packages/dask/array/core.py in concatenate3(arrays)
   3355     if not ndim:
   3356         return arrays
-> 3357     chunks = chunks_from_arrays(arrays)
   3358     shape = tuple(map(sum, chunks))
   3359 

/opt/conda/lib/python3.6/site-packages/dask/array/core.py in chunks_from_arrays(arrays)
   3181 
   3182     while isinstance(arrays, (list, tuple)):
-> 3183         result.append(tuple([shape(deepfirst(a))[dim] for a in arrays]))
   3184         arrays = arrays[0]
   3185         dim += 1

/opt/conda/lib/python3.6/site-packages/dask/array/core.py in <listcomp>(.0)
   3181 
   3182     while isinstance(arrays, (list, tuple)):
-> 3183         result.append(tuple([shape(deepfirst(a))[dim] for a in arrays]))
   3184         arrays = arrays[0]
   3185         dim += 1

IndexError: tuple index out of range
```
Any ideas what I'm doing wrong? Could this be a bug?
",,https://api.github.com/repos/dask/dask/issues/3590/timeline,,,tjcrone,5667194,MDQ6VXNlcjU2NjcxOTQ=,https://avatars.githubusercontent.com/u/5667194?v=4,,https://api.github.com/users/tjcrone,https://github.com/tjcrone,https://api.github.com/users/tjcrone/followers,https://api.github.com/users/tjcrone/following{/other_user},https://api.github.com/users/tjcrone/gists{/gist_id},https://api.github.com/users/tjcrone/starred{/owner}{/repo},https://api.github.com/users/tjcrone/subscriptions,https://api.github.com/users/tjcrone/orgs,https://api.github.com/users/tjcrone/repos,https://api.github.com/users/tjcrone/events{/privacy},https://api.github.com/users/tjcrone/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3590/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
112,https://api.github.com/repos/dask/dask/issues/3608,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3608/labels{/name},https://api.github.com/repos/dask/dask/issues/3608/comments,https://api.github.com/repos/dask/dask/issues/3608/events,https://github.com/dask/dask/issues/3608,332082491,MDU6SXNzdWUzMzIwODI0OTE=,3608,Querying number of threads and/or processes used from dask.config,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,3,2018-06-13T17:00:53Z,2018-06-27T06:01:26Z,,MEMBER,,Would be nice if there was a way to inspect `dask.config` and get the number of threads being used and the number of processes used (likely as to different values). The latter is particularly helpful when trying to determine if pickling comes into the picture.,,https://api.github.com/repos/dask/dask/issues/3608/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3608/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
113,https://api.github.com/repos/dask/dask/issues/3612,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3612/labels{/name},https://api.github.com/repos/dask/dask/issues/3612/comments,https://api.github.com/repos/dask/dask/issues/3612/events,https://github.com/dask/dask/issues/3612,332458061,MDU6SXNzdWUzMzI0NTgwNjE=,3612,Option to specify symmetry in atop results,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2018-06-14T15:41:03Z,2018-06-18T13:38:26Z,,MEMBER,,"A common situation that comes up with arrays is an operation applied to them may be symmetric. In these cases, we should be able to roughly half the number of tasks generated (or better for higher order symmetries), which is a pretty nice speedup. Examples of this include computation of the [Covariance matrix]( https://en.wikipedia.org/wiki/Covariance ), [Gramian matrix]( https://en.wikipedia.org/wiki/Gramian_matrix ), [BLAS `syrk`]( http://cvxopt.org/userguide/blas.html#cvxopt.blas.syrk ), [BLAS `herk`]( http://cvxopt.org/userguide/blas.html#cvxopt.blas.herk ), etc. Would be nice if there was a way to inform `atop` that such an operation will be symmetric over some indices or some sets of indices so the graph can reuse tasks from one part of the array for other parts that will be the same (combined with a chunk local transpose).",,https://api.github.com/repos/dask/dask/issues/3612/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3612/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
114,https://api.github.com/repos/dask/dask/issues/3630,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3630/labels{/name},https://api.github.com/repos/dask/dask/issues/3630/comments,https://api.github.com/repos/dask/dask/issues/3630/events,https://github.com/dask/dask/pull/3630,333034668,MDExOlB1bGxSZXF1ZXN0MTk1MzYxMDA5,3630,Add item method to Dask Array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,17,2018-06-17T04:34:34Z,2022-03-10T17:12:30Z,,MEMBER,,"Fixes https://github.com/dask/dask/issues/2959

Adds an `item` method for Dask Arrays equivalent to [NumPy ndarray's `item` method]( https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.ndarray.item.html ).

- [x] Tests added / passed
- [x] Passes `flake8 dask`
",,https://api.github.com/repos/dask/dask/issues/3630/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3630/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/3630,https://github.com/dask/dask/pull/3630,https://github.com/dask/dask/pull/3630.diff,https://github.com/dask/dask/pull/3630.patch,,,,,,,,,,,,,,,,,,,
115,https://api.github.com/repos/dask/dask/issues/3641,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3641/labels{/name},https://api.github.com/repos/dask/dask/issues/3641/comments,https://api.github.com/repos/dask/dask/issues/3641/events,https://github.com/dask/dask/issues/3641,333797279,MDU6SXNzdWUzMzM3OTcyNzk=,3641,Investigate using da.pad in da.overlap,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,"[{'login': 'jakirkham', 'id': 3019665, 'node_id': 'MDQ6VXNlcjMwMTk2NjU=', 'avatar_url': 'https://avatars.githubusercontent.com/u/3019665?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/jakirkham', 'html_url': 'https://github.com/jakirkham', 'followers_url': 'https://api.github.com/users/jakirkham/followers', 'following_url': 'https://api.github.com/users/jakirkham/following{/other_user}', 'gists_url': 'https://api.github.com/users/jakirkham/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/jakirkham/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/jakirkham/subscriptions', 'organizations_url': 'https://api.github.com/users/jakirkham/orgs', 'repos_url': 'https://api.github.com/users/jakirkham/repos', 'events_url': 'https://api.github.com/users/jakirkham/events{/privacy}', 'received_events_url': 'https://api.github.com/users/jakirkham/received_events', 'type': 'User', 'site_admin': False}]",,27,2018-06-19T18:57:09Z,2019-06-25T15:56:44Z,,MEMBER,,"The `da.overlap` module was written to handle `map_overlap` and all of its intricacies. It provides some support for adding padding to edge chunks. Though it only supports a few modes of padding, but not nearly as many as `da.pad` supports. Given that `da.pad` now exists, it makes sense to just use this for performing padding in `da.overlap` to provide these same options to `map_overlap`. Also should help simplify some of the code in `da.overlap`.",,https://api.github.com/repos/dask/dask/issues/3641/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3641/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,jakirkham,3019665.0,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False
116,https://api.github.com/repos/dask/dask/issues/3650,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3650/labels{/name},https://api.github.com/repos/dask/dask/issues/3650/comments,https://api.github.com/repos/dask/dask/issues/3650/events,https://github.com/dask/dask/issues/3650,334369325,MDU6SXNzdWUzMzQzNjkzMjU=,3650,Performance issue on `compute` with reshaped arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,9,2018-06-21T07:24:42Z,2020-09-01T22:41:55Z,,CONTRIBUTOR,,"I ran into a performance issue with related to reshaped dask arrays while using xarray (https://github.com/pydata/xarray/issues/2241). I opened an issue there, but I think this is actually more of a dask issue. Here is some example code which demonstrates the slow down
```python
>>> a = da.random.random((64, 64, 64), (8,8,-1))
>>> b = a.reshape((64**2, 64))
>>> %timeit b[0].compute()
3.2 ms  13 s per loop (mean  std. dev. of 7 runs, 100 loops each)
>>> %timeit a[0,0].compute()
628 s  13.8 s per loop (mean  std. dev. of 7 runs, 1000 loops each)
```
`b[0]` and `a[0,0]` should in principle refer to the same data, but the reshaped values take almost 4 times as long to compute. 

Edit:

This is on dask 0.17.1",,https://api.github.com/repos/dask/dask/issues/3650/timeline,,,nbren12,1386642,MDQ6VXNlcjEzODY2NDI=,https://avatars.githubusercontent.com/u/1386642?v=4,,https://api.github.com/users/nbren12,https://github.com/nbren12,https://api.github.com/users/nbren12/followers,https://api.github.com/users/nbren12/following{/other_user},https://api.github.com/users/nbren12/gists{/gist_id},https://api.github.com/users/nbren12/starred{/owner}{/repo},https://api.github.com/users/nbren12/subscriptions,https://api.github.com/users/nbren12/orgs,https://api.github.com/users/nbren12/repos,https://api.github.com/users/nbren12/events{/privacy},https://api.github.com/users/nbren12/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3650/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
117,https://api.github.com/repos/dask/dask/issues/3657,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3657/labels{/name},https://api.github.com/repos/dask/dask/issues/3657/comments,https://api.github.com/repos/dask/dask/issues/3657/events,https://github.com/dask/dask/issues/3657,334751664,MDU6SXNzdWUzMzQ3NTE2NjQ=,3657,Add NumPy's kron for Dask Arrays,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,36,2018-06-22T05:35:54Z,2020-05-27T15:19:22Z,,MEMBER,,Would be nice to have a Dask Array implementation of [NumPy's `kron`]( https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.kron.html ). A generalization of outer products for two tensors.,,https://api.github.com/repos/dask/dask/issues/3657/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3657/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
118,https://api.github.com/repos/dask/dask/issues/3663,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3663/labels{/name},https://api.github.com/repos/dask/dask/issues/3663/comments,https://api.github.com/repos/dask/dask/issues/3663/events,https://github.com/dask/dask/issues/3663,335228256,MDU6SXNzdWUzMzUyMjgyNTY=,3663,Add NumPy's new take_along_axis,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,21,2018-06-25T00:50:07Z,2024-04-26T15:33:12Z,,MEMBER,,Would be nice to have a Dask Array implementation of the new NumPy function [`take_along_axis`]( http://www.numpy.org/devdocs/reference/generated/numpy.take_along_axis.html ).,,https://api.github.com/repos/dask/dask/issues/3663/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3663/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
119,https://api.github.com/repos/dask/dask/issues/3664,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3664/labels{/name},https://api.github.com/repos/dask/dask/issues/3664/comments,https://api.github.com/repos/dask/dask/issues/3664/events,https://github.com/dask/dask/issues/3664,335228300,MDU6SXNzdWUzMzUyMjgzMDA=,3664,Add NumPy's new put_along_axis,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,0,2018-06-25T00:50:37Z,2019-06-13T20:25:35Z,,MEMBER,,Would be nice to have a Dask Array implementation of the new NumPy function [`put_along_axis`]( http://www.numpy.org/devdocs/reference/generated/numpy.put_along_axis.html ).,,https://api.github.com/repos/dask/dask/issues/3664/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3664/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
120,https://api.github.com/repos/dask/dask/issues/3665,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3665/labels{/name},https://api.github.com/repos/dask/dask/issues/3665/comments,https://api.github.com/repos/dask/dask/issues/3665/events,https://github.com/dask/dask/issues/3665,335394600,MDU6SXNzdWUzMzUzOTQ2MDA=,3665,Dataframe Resample could resample some data before concatenating,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,0,2018-06-25T12:55:32Z,2018-06-25T12:55:32Z,,MEMBER,,"Dask.dataframe resampling operations proceed in two steps:

1.  Collect partitions together, including some potential overlap
2.  Perform the normal Pandas resampling operation

This works fine.  However, when we're using resample to downsample intelligently (which seems to be a common case) then step 1 might collect *a lot* of data onto single machines before any downsampling occurs.  It might be possible to downsample *some* data, move around some boundaries, downsample those as well, and then concat all of the smaller pieces of data together.",,https://api.github.com/repos/dask/dask/issues/3665/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3665/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
121,https://api.github.com/repos/dask/dask/issues/3671,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3671/labels{/name},https://api.github.com/repos/dask/dask/issues/3671/comments,https://api.github.com/repos/dask/dask/issues/3671/events,https://github.com/dask/dask/issues/3671,335904087,MDU6SXNzdWUzMzU5MDQwODc=,3671,dask array map_overlap large memory use,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2018-06-26T16:38:56Z,2018-11-16T17:49:58Z,,CONTRIBUTOR,,"I have some very large datasets containing stacks of images, and I'm trying to do some type of processing on each image. Having both the stack and the images across several chunks is very useful for the processing I'm doing.

`map_overlap` is therefore the obvious choice, but I've been having some memory issues when using it. Doing the equivalent processing using `map_blocks` uses about 2.1 GB of memory during the processing, while `map_overlap` uses more than 30 GB (I had to cancel the computation before running out of memory).

`map_blocks` version:

```python
import numpy as np
import dask.array as da
from dask.diagnostics import ProgressBar

def remove_dead_pixels(data):
    dead_pixels = data == 0
    output_data = np.roll(data, shift=1, axis=-2) * dead_pixels
    return output_data

data = da.random.randint(0, 100000, size=(500, 500, 300, 300), chunks=(10, 10, 30, 30))

temp_data = da.map_blocks(
        remove_dead_pixels, data, dtype=data.dtype, chunks=data.chunks)

temp_data_mean = temp_data.mean(axis=(0, 1))

with ProgressBar():
    temp_data_mean_computed = temp_data_mean.compute()

# Uses about 2.1 GB memory
```

`map_overlap` version:

```python
import numpy as np
import dask.array as da
from dask.diagnostics import ProgressBar

def remove_dead_pixels(data):
    dead_pixels = data == 0
    output_data = np.roll(data, shift=1, axis=-2) * dead_pixels
    return output_data

data = da.random.randint(0, 100000, size=(500, 500, 300, 300), chunks=(10, 10, 30, 30))

temp_data = da.map_overlap(
        func=remove_dead_pixels, x=data, depth=(0, 0, 1, 1),
        dtype=data.dtype, chunks=data.chunks)

temp_data_mean = temp_data.mean(axis=(0, 1))

with ProgressBar():
    temp_data_mean_computed = temp_data_mean.compute()

# Uses more than 30+ GB memory
```

Dask version: current master branch
Numpy version: 1.14.5

",,https://api.github.com/repos/dask/dask/issues/3671/timeline,,,magnunor,1690979,MDQ6VXNlcjE2OTA5Nzk=,https://avatars.githubusercontent.com/u/1690979?v=4,,https://api.github.com/users/magnunor,https://github.com/magnunor,https://api.github.com/users/magnunor/followers,https://api.github.com/users/magnunor/following{/other_user},https://api.github.com/users/magnunor/gists{/gist_id},https://api.github.com/users/magnunor/starred{/owner}{/repo},https://api.github.com/users/magnunor/subscriptions,https://api.github.com/users/magnunor/orgs,https://api.github.com/users/magnunor/repos,https://api.github.com/users/magnunor/events{/privacy},https://api.github.com/users/magnunor/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3671/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
122,https://api.github.com/repos/dask/dask/issues/3674,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3674/labels{/name},https://api.github.com/repos/dask/dask/issues/3674/comments,https://api.github.com/repos/dask/dask/issues/3674/events,https://github.com/dask/dask/issues/3674,336018272,MDU6SXNzdWUzMzYwMTgyNzI=,3674,inplace modification to `compute()` output changes original input.,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2018-06-26T22:47:59Z,2018-07-14T13:01:00Z,,CONTRIBUTOR,,"In dask 0.18.1, the return value of `compute()` can be a view to the original data. When the result of `compute()` is modified in-place for post-processing, the behavior is surprising, as the original data is tainted as well.

```
def test_return_no_views():
    import dask.array as da
    import numpy
    a = numpy.ones(10)
    d = da.from_array(a, chunks=10)

    r = d.compute()
    r[3:4] = 2
    assert (a == 1).all() # fails because a is modified as well.
```

On the other hand, if any operations were performed during the construction of d, then inplace modification of the result of `compute()` won't affect the original input `a`. This asymmetric behavior is somewhat inconsistent.

If a view is highly desired (for performance) then consider marking the result of compute() read-only when a view to the original data is returned, to provide some numpy level protection against accidental overwriting the original data.



",,https://api.github.com/repos/dask/dask/issues/3674/timeline,,,rainwoodman,138060,MDQ6VXNlcjEzODA2MA==,https://avatars.githubusercontent.com/u/138060?v=4,,https://api.github.com/users/rainwoodman,https://github.com/rainwoodman,https://api.github.com/users/rainwoodman/followers,https://api.github.com/users/rainwoodman/following{/other_user},https://api.github.com/users/rainwoodman/gists{/gist_id},https://api.github.com/users/rainwoodman/starred{/owner}{/repo},https://api.github.com/users/rainwoodman/subscriptions,https://api.github.com/users/rainwoodman/orgs,https://api.github.com/users/rainwoodman/repos,https://api.github.com/users/rainwoodman/events{/privacy},https://api.github.com/users/rainwoodman/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3674/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
123,https://api.github.com/repos/dask/dask/issues/3682,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3682/labels{/name},https://api.github.com/repos/dask/dask/issues/3682/comments,https://api.github.com/repos/dask/dask/issues/3682/events,https://github.com/dask/dask/issues/3682,336636972,MDU6SXNzdWUzMzY2MzY5NzI=,3682,Support dask arrays in keywords in map_blocks,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2018-06-28T14:06:53Z,2018-06-29T15:21:59Z,,MEMBER,,"Currently we only check `*args` for dask arrays, and convert anything in keyword arguments to concrete objects when they are passed into the user defined function.  We might consider also looking into the keyword arguments for dask arrays

```python
In [1]: import dask.array as da

In [2]: def f(x):
   ...:     print(x.shape)
   ...:     return x
   ...: 

In [3]: x = da.ones((10, 10), chunks=(5, 5))

In [4]: da.map_blocks(f, x, dtype=x.dtype).compute()
(5, 5)
(5, 5)
(5, 5)
(5, 5)
Out[4]: 
array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]])

In [5]: da.map_blocks(f, x=x, dtype=x.dtype).compute()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-5-0ef3a9dd6003> in <module>()
----> 1 da.map_blocks(f, x=x, dtype=x.dtype).compute()

~/workspace/dask/dask/array/core.py in map_blocks(func, *args, **kwargs)
    696     numblocks = {a.name: a.numblocks for a in arrs}
    697     arginds = list(concat(argpairs))
--> 698     out_ind = tuple(range(max(a.ndim for a in arrs)))[::-1]
    699 
    700     try:

ValueError: max() arg is an empty sequence
```

My only concern is that people might be relying on this behavior.

cc @jakirkham @stuartarchibald ",,https://api.github.com/repos/dask/dask/issues/3682/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3682/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
124,https://api.github.com/repos/dask/dask/issues/3688,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3688/labels{/name},https://api.github.com/repos/dask/dask/issues/3688/comments,https://api.github.com/repos/dask/dask/issues/3688/events,https://github.com/dask/dask/issues/3688,337034147,MDU6SXNzdWUzMzcwMzQxNDc=,3688,Dask Collections API compatibility,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}]",open,False,,[],,14,2018-06-29T15:05:08Z,2021-01-25T00:04:47Z,,MEMBER,,"[This gist](https://gist.github.com/b9c20a55c996c68d0437e70459345f09) parses the function signatures of dask's and pandas' dataframes. It produces two outputs

1. [Matching](https://docs.google.com/spreadsheets/d/1SD7AzJRxi6Dx8tblinIK52kNtiZnm0sv8yZOMxhLYMA/edit?usp=sharing)
    Parameters present in both implementations. These could be check for places where the default value or docstring doesn't match. Filter by `check_sig` and `check_doc`. 
2. [Differing](https://docs.google.com/spreadsheets/d/1qwUjS-LK4xV5EVjyh-vm15gKgw2xqfXUIGWmsEBAYms/edit?usp=sharing)
   Parameters where one is not present in the other. We would care about parameters that are not present in dask.

For example, here's a list of methods where the default values differ between dask and pandas:

method | parameter | pandas_value | dask_value
-- | -- | -- | --
min | skipna | skipna=True | skipna=None
idxmax | axis | axis=None | axis=0
where | other | other=nan | other=nan
nsmallest | n | n=5 | n
nsmallest | columns | columns=None | columns
drop | labels | labels | labels=None
std | skipna | skipna=True | skipna=None
max | skipna | skipna=True | skipna=None
sum | skipna | skipna=True | skipna=None
mask | other | other=nan | other=nan
prod | skipna | skipna=True | skipna=None
all | axis | axis=None | axis=0
idxmin | axis | axis=None | axis=0
nlargest | n | n=5 | n
nlargest | columns | columns=None | columns
eval | inplace | inplace=None | inplace=False
count | axis | axis=None | axis=0
any | axis | axis=None | axis=0
mean | skipna | skipna=True | skipna=None
corr | min_periods | min_periods=None | min_periods=1
var | skipna | skipna=True | skipna=None


Some questions:

1. Would this help guide a sprint?
2. If so, what other things should we inspect / highlight?",,https://api.github.com/repos/dask/dask/issues/3688/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3688/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
125,https://api.github.com/repos/dask/dask/issues/3693,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3693/labels{/name},https://api.github.com/repos/dask/dask/issues/3693/comments,https://api.github.com/repos/dask/dask/issues/3693/events,https://github.com/dask/dask/issues/3693,337234874,MDU6SXNzdWUzMzcyMzQ4NzQ=,3693,Python 3.7 breakpoint() usage,[],open,False,,[],,3,2018-06-30T18:43:32Z,2018-07-09T13:18:40Z,,CONTRIBUTOR,,"More of a discussion prompt than anything else: the [new](https://www.python.org/dev/peps/pep-0553/) `breakpoint()` functionality got me thinking about how it might be used to facilitate debugging dask workflows. For local dask code it's maybe easy enough already to switch to the synchronous scheduler and use pdb directly, but for distributed code especially it can be quite cumbersome. Maybe something in the vein of [launching IPython](http://distributed.readthedocs.io/en/latest/ipython.html#launch-ipython-within-dask-workers) could be called on breakpoint and block until debugging is finished?",,https://api.github.com/repos/dask/dask/issues/3693/timeline,,,bnaul,903655,MDQ6VXNlcjkwMzY1NQ==,https://avatars.githubusercontent.com/u/903655?v=4,,https://api.github.com/users/bnaul,https://github.com/bnaul,https://api.github.com/users/bnaul/followers,https://api.github.com/users/bnaul/following{/other_user},https://api.github.com/users/bnaul/gists{/gist_id},https://api.github.com/users/bnaul/starred{/owner}{/repo},https://api.github.com/users/bnaul/subscriptions,https://api.github.com/users/bnaul/orgs,https://api.github.com/users/bnaul/repos,https://api.github.com/users/bnaul/events{/privacy},https://api.github.com/users/bnaul/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3693/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
126,https://api.github.com/repos/dask/dask/issues/3699,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3699/labels{/name},https://api.github.com/repos/dask/dask/issues/3699/comments,https://api.github.com/repos/dask/dask/issues/3699/events,https://github.com/dask/dask/issues/3699,337294553,MDU6SXNzdWUzMzcyOTQ1NTM=,3699,Recurse in tsqr with unknown chunks,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2018-07-01T14:19:43Z,2021-10-12T06:08:11Z,,MEMBER,,"I suspect that we will often want to use tsqr with unknown chunk sizes, which occur whenever someone converts a dask dataframe into a dask array (dataframes don't maintain chunk sizes).   Currently we don't recurse in these situations.  Maybe we should though.  

A few options:

1.  We do know the chunk size in the columns dimension.  We also have an understanding of what an OK chunk size is in `dask.config.get('array.chunk-size')`.  Is this sufficient?
2.  We might just recurse every 10 or 100 chunks or so, regardless of size",,https://api.github.com/repos/dask/dask/issues/3699/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3699/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
127,https://api.github.com/repos/dask/dask/issues/3714,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3714/labels{/name},https://api.github.com/repos/dask/dask/issues/3714/comments,https://api.github.com/repos/dask/dask/issues/3714/events,https://github.com/dask/dask/issues/3714,338153379,MDU6SXNzdWUzMzgxNTMzNzk=,3714,repartition dask  dataframe according to frequency doesn't match pandas known frequencies,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2018-07-04T07:04:56Z,2019-04-30T16:13:00Z,,NONE,,"When repartitioning a dask  dataframe with a date index according to a certain frequency it does not match the partition made with a pandas Grouper object.

example: 
```python
import pandas as pd
nums= [f'{i:02},' for i in range(9)]
dates = pd.date_range('2018-07-01', periods=9, freq='1d')
df = pd.DataFrame({'dates':dates, 'nums': nums}).set_index('dates')
```
when grouping it with a weekly frequency until thursday:
```python
grouper = pd.Grouper(level='dates', freq='W-THU')
df.groupby(grouper).agg({'nums':'sum'})
```
you get the following result
<details>


|            | nums                  |
|------------|-----------------------|
| dates      |                       |
| 2018-07-05 | 00,01,02,03,04,       |
| 2018-07-12 | 05,06,07,08, |

</details>



however when you repartition a dask dataframe according to the same frequency
and print them you get different partitions. 
```python
import dask.dataframe as dd
ddf = dd.from_pandas(df, npartitions=1).repartition(freq='W-THU')

for i in range(ddf.npartitions):
    print(ddf.get_partition(i).compute())
```
<details>

|            | nums |
|------------|------|
| dates      |      |
| 2018-07-01 | 00,  |
| 2018-07-02 | 01,  |
| 2018-07-03 | 02,  |
| 2018-07-04 | 03,  |

|            | nums |
|------------|------|
| dates      |      |
| 2018-07-05 | 04,  |
| 2018-07-06 | 05,  |
| 2018-07-07 | 06,  |
| 2018-07-08 | 07,  |
| 2018-07-09 | 08,  |

</details>
and thus resulting in faulty calculations if i do the following:

```python 
grouper = pd.Grouper(level='dates', freq='W-THU')
ddf.map_partitions(lambda df:df.groupby(grouper).agg({'nums':'sum'}), meta={'nums':str}).compute()
``` 
<details>

|            | nums         |
|------------|--------------|
| dates      |              |
| 2018-07-05 | 00,01,02,03, |
| 2018-07-05 | 04,          |
| 2018-07-12 | 05,06,07,08, |

</details>
EDIT:
Python 3.6.5 :: Anaconda, Inc.
dask Version: 0.18.0
pandas Version: 0.23.0",,https://api.github.com/repos/dask/dask/issues/3714/timeline,,,finete,34818222,MDQ6VXNlcjM0ODE4MjIy,https://avatars.githubusercontent.com/u/34818222?v=4,,https://api.github.com/users/finete,https://github.com/finete,https://api.github.com/users/finete/followers,https://api.github.com/users/finete/following{/other_user},https://api.github.com/users/finete/gists{/gist_id},https://api.github.com/users/finete/starred{/owner}{/repo},https://api.github.com/users/finete/subscriptions,https://api.github.com/users/finete/orgs,https://api.github.com/users/finete/repos,https://api.github.com/users/finete/events{/privacy},https://api.github.com/users/finete/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3714/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
128,https://api.github.com/repos/dask/dask/issues/3727,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3727/labels{/name},https://api.github.com/repos/dask/dask/issues/3727/comments,https://api.github.com/repos/dask/dask/issues/3727/events,https://github.com/dask/dask/issues/3727,338667012,MDU6SXNzdWUzMzg2NjcwMTI=,3727,apply_along_axis infers output shape improperly,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2018-07-05T17:42:49Z,2019-04-30T15:40:22Z,,MEMBER,,"My environment:
Python: 3.6.6 |Anaconda custom (64-bit)
Dask: 0.18.1

This fails:
```python
import dask.array as da
def testfun(v):
    return v[0] + v[1]
dar = da.random.randint(0,1, size=(2,2), chunks=('auto'))
da.apply_along_axis(testfun, 0, dar)
```

```pytb
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-2-43967c9b007c> in <module>
      3     return v[0] + v[1]
      4 dar = da.random.randint(0,1, size=(2,2), chunks=('auto'))
----> 5 da.apply_along_axis(testfun, 0, dar)

~/sandbox/dask/dask/array/routines.py in apply_along_axis(func1d, axis, arr, *args, **kwargs)
    321     # Test out some data with the function.
    322     test_data = np.ones((1,), dtype=arr.dtype)
--> 323     test_result = np.array(func1d(test_data, *args, **kwargs))
    324
    325     # Rechunk so that func1d is applied over the full axis.

<ipython-input-2-43967c9b007c> in testfun(v)
      1 import dask.array as da
      2 def testfun(v):
----> 3     return v[0] + v[1]
      4 dar = da.random.randint(0,1, size=(2,2), chunks=('auto'))
      5 da.apply_along_axis(testfun, 0, dar)

IndexError: index 1 is out of bounds for axis 0 with size 1
```

The reason why is because of [this line](https://github.com/dask/dask/blob/36e235d7074f01830dd79a24fd656f4cda9e2c81/dask/array/routines.py#L324) in `apply_along_axis`, where the function arg in `apply_along_axis` is applied to non-representative test data (`np.ones((1,))`) for estimating output dimensionality and dtype.

At the least, the properties of the output being inferred here (shape and dtype) should be specifiable as kwargs to `apply_along_axis` so the user can dodge having them inferred. 

If these properties are going to be inferred, the sample data fed into the test function should at least match the size (and probably the dtype) of the vectors the user wants to feed `apply_along_axis` .

If I have the time I can study how this is done for comparable functions (`map_blocks` comes to mind) and submit a PR, but I may not have the time soon. ",,https://api.github.com/repos/dask/dask/issues/3727/timeline,,,d-v-b,3805136,MDQ6VXNlcjM4MDUxMzY=,https://avatars.githubusercontent.com/u/3805136?v=4,,https://api.github.com/users/d-v-b,https://github.com/d-v-b,https://api.github.com/users/d-v-b/followers,https://api.github.com/users/d-v-b/following{/other_user},https://api.github.com/users/d-v-b/gists{/gist_id},https://api.github.com/users/d-v-b/starred{/owner}{/repo},https://api.github.com/users/d-v-b/subscriptions,https://api.github.com/users/d-v-b/orgs,https://api.github.com/users/d-v-b/repos,https://api.github.com/users/d-v-b/events{/privacy},https://api.github.com/users/d-v-b/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3727/reactions,0,0,0,0,0,0,0,0,0,mrocklin,306380.0,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
129,https://api.github.com/repos/dask/dask/issues/3734,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3734/labels{/name},https://api.github.com/repos/dask/dask/issues/3734/comments,https://api.github.com/repos/dask/dask/issues/3734/events,https://github.com/dask/dask/issues/3734,339077543,MDU6SXNzdWUzMzkwNzc1NDM=,3734,Benchmark ORC reader,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}]",open,False,,[],,7,2018-07-06T21:33:57Z,2021-10-12T18:18:31Z,,MEMBER,,"With #3284, we can now read ORC files into dask dataframes. It would be good/interesting to benchmark this implementation and see if there are any easy gains we're missing (this was never done). This would ideally be done at two levels:

- Pandas/Arrow (are we getting the bandwidth we'd expect from the ORC c++ reader)
- Dask (are we getting parallelism, is our overhead low)

We'd need to use some other system (spark, hive, etc...) to generate test files, as no python writer exists.",,https://api.github.com/repos/dask/dask/issues/3734/timeline,,,jcrist,2783717,MDQ6VXNlcjI3ODM3MTc=,https://avatars.githubusercontent.com/u/2783717?v=4,,https://api.github.com/users/jcrist,https://github.com/jcrist,https://api.github.com/users/jcrist/followers,https://api.github.com/users/jcrist/following{/other_user},https://api.github.com/users/jcrist/gists{/gist_id},https://api.github.com/users/jcrist/starred{/owner}{/repo},https://api.github.com/users/jcrist/subscriptions,https://api.github.com/users/jcrist/orgs,https://api.github.com/users/jcrist/repos,https://api.github.com/users/jcrist/events{/privacy},https://api.github.com/users/jcrist/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3734/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
130,https://api.github.com/repos/dask/dask/issues/3753,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3753/labels{/name},https://api.github.com/repos/dask/dask/issues/3753/comments,https://api.github.com/repos/dask/dask/issues/3753/events,https://github.com/dask/dask/issues/3753,341134066,MDU6SXNzdWUzNDExMzQwNjY=,3753,Custom aggregate functions removing index labels on output,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2018-07-13T19:28:34Z,2019-04-30T19:07:51Z,,CONTRIBUTOR,,"Minimal example, based on 

https://stackoverflow.com/questions/46080171/constructing-mode-and-corresponding-count-functions-using-custom-aggregation-fun/46082075#46082075

```python
import pandas as pd
import dask.dataframe as dd


def chunk(s):
    return s.value_counts()


def agg(s):
    return s.apply(lambda s: s.groupby(level=-1).sum())


def finalize(s):
    level = list(range(s.index.nlevels - 1))
    return (
        s.groupby(level=level)
            .apply(lambda s: s.reset_index(level=level, drop=True).idxmax()))

mode = dd.Aggregation('mode', chunk, agg, finalize)

df = pd.DataFrame({
    'col0': [0, 1, 1, 2, 3] * 10,
    'col1': [4, 5, 5, 6, 7] * 10,
    'g0': [0, 0, 0, 1, 1] * 10,
    'g1': [0, 0, 0, 1, 1] * 10,
})
ddf = dd.from_pandas(df, npartitions=3)
res = ddf.groupby(['g0', 'g1']).agg({'col0':mode, 'col1':mode})
res.compute()
```
The output is
```
		col0	col1
0	0	1	5
1	1	2	6
```
Mind the missing index labels. Due to the missing labels, if you change the last line to

```python
res.reset_index().compute()
```

You'll get the following stack trace:

```python-traceback
ValueError                                Traceback (most recent call last)
<ipython-input-10-ffe69b3913d9> in <module>()
     29 ddf = dd.from_pandas(df, npartitions=3)
     30 res = ddf.groupby(['g0', 'g1']).agg({'col0':mode, 'col1':mode})
---> 31 res.reset_index().compute()

~/store_markdown/venv/lib/python3.6/site-packages/dask/base.py in compute(self, **kwargs)
    154         dask.base.compute
    155         """"""
--> 156         (result,) = compute(self, traverse=False, **kwargs)
    157         return result
    158 

~/store_markdown/venv/lib/python3.6/site-packages/dask/base.py in compute(*args, **kwargs)
    400     keys = [x.__dask_keys__() for x in collections]
    401     postcomputes = [x.__dask_postcompute__() for x in collections]
--> 402     results = schedule(dsk, keys, **kwargs)
    403     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    404 

~/store_markdown/venv/lib/python3.6/site-packages/dask/threaded.py in get(dsk, result, cache, num_workers, **kwargs)
     73     results = get_async(pool.apply_async, len(pool._pool), dsk, result,
     74                         cache=cache, get_id=_thread_get_id,
---> 75                         pack_exception=pack_exception, **kwargs)
     76 
     77     # Cleanup pools associated to dead threads

~/store_markdown/venv/lib/python3.6/site-packages/dask/local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    519                         _execute_task(task, data)  # Re-execute locally
    520                     else:
--> 521                         raise_exception(exc, tb)
    522                 res, worker_id = loads(res_info)
    523                 state['cache'][key] = res

~/store_markdown/venv/lib/python3.6/site-packages/dask/compatibility.py in reraise(exc, tb)
     67         if exc.__traceback__ is not tb:
     68             raise exc.with_traceback(tb)
---> 69         raise exc
     70 
     71 else:

~/store_markdown/venv/lib/python3.6/site-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    288     try:
    289         task, data = loads(task_info)
--> 290         result = _execute_task(task, data)
    291         id = get_id()
    292         result = dumps((result, id))

~/store_markdown/venv/lib/python3.6/site-packages/dask/local.py in _execute_task(arg, cache, dsk)
    269         func, args = arg[0], arg[1:]
    270         args2 = [_execute_task(a, cache) for a in args]
--> 271         return func(*args2)
    272     elif not ishashable(arg):
    273         return arg

~/store_markdown/venv/lib/python3.6/site-packages/dask/dataframe/core.py in apply_and_enforce(func, args, kwargs, meta)
   3561             if not np.array_equal(np.nan_to_num(meta.columns),
   3562                                   np.nan_to_num(df.columns)):
-> 3563                 raise ValueError(""The columns in the computed data do not match""
   3564                                  "" the columns in the provided metadata"")
   3565             else:

ValueError: The columns in the computed data do not match the columns in the provided metadata
```",,https://api.github.com/repos/dask/dask/issues/3753/timeline,,,cjalmeida,704920,MDQ6VXNlcjcwNDkyMA==,https://avatars.githubusercontent.com/u/704920?v=4,,https://api.github.com/users/cjalmeida,https://github.com/cjalmeida,https://api.github.com/users/cjalmeida/followers,https://api.github.com/users/cjalmeida/following{/other_user},https://api.github.com/users/cjalmeida/gists{/gist_id},https://api.github.com/users/cjalmeida/starred{/owner}{/repo},https://api.github.com/users/cjalmeida/subscriptions,https://api.github.com/users/cjalmeida/orgs,https://api.github.com/users/cjalmeida/repos,https://api.github.com/users/cjalmeida/events{/privacy},https://api.github.com/users/cjalmeida/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3753/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
131,https://api.github.com/repos/dask/dask/issues/3783,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3783/labels{/name},https://api.github.com/repos/dask/dask/issues/3783/comments,https://api.github.com/repos/dask/dask/issues/3783/events,https://github.com/dask/dask/issues/3783,342709347,MDU6SXNzdWUzNDI3MDkzNDc=,3783,Support Task Annotations within the graph,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,30,2018-07-19T12:34:36Z,2019-05-01T08:36:29Z,,MEMBER,,"I think this issue has some relation to https://github.com/dask/distributed/issues/2127, where @kkraus14 wants to run certain tasks on CPU/GPU workers. I've also wanted to run tasks on specific workers, or require resources to be exclusive for certain tasks.

Currently, these task dependencies must be specified as additional arguments to `compute`/`persist` etc. rather than at the point of actual construction -- embedding resource/worker dependencies in the graph is not currently possible.

To support this,  how about adding a `TaskAnnotation` type? This can be a namedtuple, itself containing nested tuples representing key-value pairs. e.g.

```python
annot = TaskAnnotation(an=(('resource', ('GPU': '1'), ('worker', 'alice')))
```

dask array graphs tend to have the following structure:

```python
dsk = {
    (tsk_name, 0) : (fn, arg1, arg2, ..., argn),
    (tsk_name, 1) : (fn, arg1, arg2, ..., argn),
}
```

How about embedding annotations within value tuples?

```python
dsk = {
    (tsk_name, 0) : (fn, arg1, arg2, ..., argn, annotation1),
    (tsk_name, 1) : (fn, arg1, arg2, ..., argn, annotation2),
}
```

If the scheduler discovers an annotation in the tuple, it could remove it from the argument list and attempt to satisfy the requested constraints. In the above example, annotations are placed at the end of the tuple, but the location could be arbitrary and multiple annotations are possible. Alternatively, it might be better to put them at the start.

I realise the above example is somewhat specific to dask arrays (I'm not too familiar with the dataframe and bag collections) so there may be issues I'm not seeing.

One problem I can immediately identify would be modifying existing graph construction functions to support the above annotations (atop/top support is probably the first place to look).",,https://api.github.com/repos/dask/dask/issues/3783/timeline,,,sjperkins,3530212,MDQ6VXNlcjM1MzAyMTI=,https://avatars.githubusercontent.com/u/3530212?v=4,,https://api.github.com/users/sjperkins,https://github.com/sjperkins,https://api.github.com/users/sjperkins/followers,https://api.github.com/users/sjperkins/following{/other_user},https://api.github.com/users/sjperkins/gists{/gist_id},https://api.github.com/users/sjperkins/starred{/owner}{/repo},https://api.github.com/users/sjperkins/subscriptions,https://api.github.com/users/sjperkins/orgs,https://api.github.com/users/sjperkins/repos,https://api.github.com/users/sjperkins/events{/privacy},https://api.github.com/users/sjperkins/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3783/reactions,3,2,0,0,0,0,0,1,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
132,https://api.github.com/repos/dask/dask/issues/3785,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3785/labels{/name},https://api.github.com/repos/dask/dask/issues/3785/comments,https://api.github.com/repos/dask/dask/issues/3785/events,https://github.com/dask/dask/issues/3785,342876052,MDU6SXNzdWUzNDI4NzYwNTI=,3785,Proposal: Add generic support for exploratory workflows,"[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,4,2018-07-19T20:23:54Z,2022-02-04T14:55:06Z,,NONE,,"__Proposal: Add generic support for exploratory workflows__


In big data pipelines, various variants of a specific operator may be
considered. For instance, the variants are related to a data cleaning
strategy or a parameter of a learning algorithm. We refer to such
pipelines as exploratory workflows, as it is not know apriori which
operator variants shall be considered. Choosing an inappropriate
variant, however, may render the result of the workflow useless, so that
computational resources may be wasted.

The [linked proposal](https://github.com/bielefem/MDF-Proposal/blob/master/proposal.md) describes a way to handle such
exploratory workflows more efficiently.
",,https://api.github.com/repos/dask/dask/issues/3785/timeline,,,bielefem,9322230,MDQ6VXNlcjkzMjIyMzA=,https://avatars.githubusercontent.com/u/9322230?v=4,,https://api.github.com/users/bielefem,https://github.com/bielefem,https://api.github.com/users/bielefem/followers,https://api.github.com/users/bielefem/following{/other_user},https://api.github.com/users/bielefem/gists{/gist_id},https://api.github.com/users/bielefem/starred{/owner}{/repo},https://api.github.com/users/bielefem/subscriptions,https://api.github.com/users/bielefem/orgs,https://api.github.com/users/bielefem/repos,https://api.github.com/users/bielefem/events{/privacy},https://api.github.com/users/bielefem/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3785/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
133,https://api.github.com/repos/dask/dask/issues/3802,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3802/labels{/name},https://api.github.com/repos/dask/dask/issues/3802/comments,https://api.github.com/repos/dask/dask/issues/3802/events,https://github.com/dask/dask/issues/3802,343411798,MDU6SXNzdWUzNDM0MTE3OTg=,3802,"Change configuration names for optimizations, arrays, etc..","[{'id': 1012929478, 'node_id': 'MDU6TGFiZWwxMDEyOTI5NDc4', 'url': 'https://api.github.com/repos/dask/dask/labels/config', 'name': 'config', 'color': '1586c0', 'default': False, 'description': ''}]",open,False,,"[{'login': 'jcrist', 'id': 2783717, 'node_id': 'MDQ6VXNlcjI3ODM3MTc=', 'avatar_url': 'https://avatars.githubusercontent.com/u/2783717?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/jcrist', 'html_url': 'https://github.com/jcrist', 'followers_url': 'https://api.github.com/users/jcrist/followers', 'following_url': 'https://api.github.com/users/jcrist/following{/other_user}', 'gists_url': 'https://api.github.com/users/jcrist/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/jcrist/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/jcrist/subscriptions', 'organizations_url': 'https://api.github.com/users/jcrist/orgs', 'repos_url': 'https://api.github.com/users/jcrist/repos', 'events_url': 'https://api.github.com/users/jcrist/events{/privacy}', 'received_events_url': 'https://api.github.com/users/jcrist/received_events', 'type': 'User', 'site_admin': False}]",,3,2018-07-22T14:47:49Z,2019-08-02T19:10:30Z,,MEMBER,,"There are a variety of options available in the opimizations and collections that were previously handled by `dask.set_options`, but are now under `dask.config.set` like `fuse_ave_width` and `array_plugins`.  Do we want to change these names and place them into a configuraiton namespace like `optimization.fuse.width` and `array.plugins` ?  ",,https://api.github.com/repos/dask/dask/issues/3802/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3802/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,jcrist,2783717.0,MDQ6VXNlcjI3ODM3MTc=,https://avatars.githubusercontent.com/u/2783717?v=4,,https://api.github.com/users/jcrist,https://github.com/jcrist,https://api.github.com/users/jcrist/followers,https://api.github.com/users/jcrist/following{/other_user},https://api.github.com/users/jcrist/gists{/gist_id},https://api.github.com/users/jcrist/starred{/owner}{/repo},https://api.github.com/users/jcrist/subscriptions,https://api.github.com/users/jcrist/orgs,https://api.github.com/users/jcrist/repos,https://api.github.com/users/jcrist/events{/privacy},https://api.github.com/users/jcrist/received_events,User,False
134,https://api.github.com/repos/dask/dask/issues/3814,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3814/labels{/name},https://api.github.com/repos/dask/dask/issues/3814/comments,https://api.github.com/repos/dask/dask/issues/3814/events,https://github.com/dask/dask/issues/3814,344762650,MDU6SXNzdWUzNDQ3NjI2NTA=,3814,[trivial] [doc] Scheduler doc improvements,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,1,2018-07-26T09:20:44Z,2019-04-30T16:14:03Z,,MEMBER,,"http://dask.pydata.org/en/latest/scheduler-overview.html needs some improvements after the recent change from get= to scheduler=.

1. What is the comprehensive list of choices for scheduler=? Namely, if I want to use threaded scheduler, is it ""threads"", ""threaded"", or...?
2. ``Additionally, each scheduler may take a few extra keywords specific to that scheduler. `` need to add a link to the actual API definitions that define such keywords.
3. get -> scheduler: 
```
Using the get keyword in the compute method:

>>> x.sum().compute(scheduler='processes')
```

https://distributed.readthedocs.io/en/latest/client.html#dask is also improvable:
1. It says how I can stop a client from registering itself as the default dask scheduler, but it does not say anything about how I can actually use it explicitly after I do that. ``scheduler='distributed', pool=client)``? ``scheduler=client``? something else?
2. Does the ``num_workers`` parameter have any effect?",,https://api.github.com/repos/dask/dask/issues/3814/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3814/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
135,https://api.github.com/repos/dask/dask/issues/3815,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3815/labels{/name},https://api.github.com/repos/dask/dask/issues/3815/comments,https://api.github.com/repos/dask/dask/issues/3815/events,https://github.com/dask/dask/issues/3815,344773894,MDU6SXNzdWUzNDQ3NzM4OTQ=,3815,[new feature] crash test dummy scheduler for unit tests,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,2,2018-07-26T09:52:16Z,2019-04-30T16:10:05Z,,MEMBER,,"I've been spending quite a lot of time recently debugging the dask distributed scheduler being unexpectedly invoked in the middle of defining the dask.array graph, both by xarray and by my own application code. If the distributed client and scheduler are on opposite ends of a high-latency network, this can easily compound into hours of overhead in some cases. Another, worse situation that I'm fighting against is when the dask graph definition is performed inside a process pool - a dire necessity for particularly large graphs. In this case, an accidental invocation of the threaded scheduler from inside the subprocess will cause a random and complete deadlock of the Python interpreter, and an inexperienced developer will never figure out what's going on.

To debug this, so far I have been starting a distributed scheduler without workers and watched for my code getting stuck when it accidentally tries submitting stuff to it. This approach however is impractical when writing unit tests.
I'd like to propose writing a new scheduler, ``crash`` (I'm open to suggestions for a better name), that raises Exception as soon as anybody tries computing anything with it.

Mock up:
```
import dask
from dask.array.utils import assert_eq

dask.config.set(scheduler='crash')


def test1():
    # graph definition. scheduler='crash' verifies parts of the graph are not
    # silently computed under the hood
    a = dask.array.arange(4, chunks=2)
    # internally invokes compute(scheduler='sync')
    assert_eq(a, dask.array.from_array([0, 1,2, 3], chunks]=2)
```",,https://api.github.com/repos/dask/dask/issues/3815/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3815/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
136,https://api.github.com/repos/dask/dask/issues/3824,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3824/labels{/name},https://api.github.com/repos/dask/dask/issues/3824/comments,https://api.github.com/repos/dask/dask/issues/3824/events,https://github.com/dask/dask/issues/3824,345227530,MDU6SXNzdWUzNDUyMjc1MzA=,3824,Chaining slicing one dask array with another dask array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,5,2018-07-27T13:32:25Z,2020-04-30T13:46:57Z,,NONE,,"I don't seem to be able to chain multiple slices of one dask array with another (without realising the intermediate result):

```python
d = da.from_array(np.arange(16), chunks=-1)
e = da.from_array(np.arange(16) + 10, chunks=-1)
f = d[e > 15]
f
dask.array<getitem, shape=(nan,), dtype=int64, chunksize=(nan,)>
g = da.from_array(np.arange(6), chunks=-1)
f[g > 4]
```

```python-traceback
ValueError                                Traceback (most recent call last)
<ipython-input-12-4212770cc0ff> in <module>()
----> 1 f[g > 4]

~/miniconda3/envs/scitools_dev/lib/python3.6/site-packages/dask/array/core.py in __getitem__(self, index)
   1375             self, index2 = slice_with_int_dask_array(self, index2)
   1376         if any(isinstance(i, Array) and i.dtype == bool for i in index2):
-> 1377             self, index2 = slice_with_bool_dask_array(self, index2)
   1378 
   1379         if all(isinstance(i, slice) and i == slice(None) for i in index2):

~/miniconda3/envs/scitools_dev/lib/python3.6/site-packages/dask/array/slicing.py in slice_with_bool_dask_array(x, index)
    989 
    990     if len(index) == 1 and index[0].ndim == x.ndim:
--> 991         y = elemwise(getitem, x, *index, dtype=x.dtype)
    992         name = 'getitem-' + tokenize(x, index)
    993         dsk = {(name, i): k for i, k in enumerate(core.flatten(y.__dask_keys__()))}

~/miniconda3/envs/scitools_dev/lib/python3.6/site-packages/dask/array/core.py in elemwise(op, *args, **kwargs)
   3430     shapes = [getattr(arg, 'shape', ()) for arg in args]
   3431     shapes = [s if isinstance(s, Iterable) else () for s in shapes]
-> 3432     out_ndim = len(broadcast_shapes(*shapes))   # Raises ValueError if dimensions mismatch
   3433     expr_inds = tuple(range(out_ndim))[::-1]
   3434 

~/miniconda3/envs/scitools_dev/lib/python3.6/site-packages/dask/array/core.py in broadcast_shapes(*shapes)
   3402         if any(i not in [-1, 0, 1, dim] and not np.isnan(i) for i in sizes):
   3403             raise ValueError(""operands could not be broadcast together with ""
-> 3404                              ""shapes {0}"".format(' '.join(map(str, shapes))))
   3405         out.append(dim)
   3406     return tuple(reversed(out))

ValueError: operands could not be broadcast together with shapes (nan,) (6,)
```

It looks like the chunks of the intermediate result aren't being calculated (correctly?), which is preventing following operations.

Is there a way to achieve this indexing in dask?

As per the suggestion in #3096, I tried reproducing the indexing using `map_blocks` but that also didn't work:

```python
fmb = da.map_blocks(lambda d, e: d[e > 15], chunks=(3,))
```
```python-traceback
ValueError                                Traceback (most recent call last)
<ipython-input-30-7b39e2419a05> in <module>()
----> 1 fmb = da.map_blocks(lambda d, e: d[e > 15], chunks=(3,))

~/miniconda3/envs/scitools_dev/lib/python3.6/site-packages/dask/array/core.py in map_blocks(func, *args, **kwargs)
    709     numblocks = {a.name: a.numblocks for a in arrs}
    710     arginds = list(concat(argpairs))
--> 711     out_ind = tuple(range(max(a.ndim for a in arrs)))[::-1]
    712 
    713     if has_keyword(func, 'block_id'):

ValueError: max() arg is an empty sequence
```

I'm using dask v0.18.2.

Note: my underlying use-case is chaining multiple lazy array operations on large Iris cubes.",,https://api.github.com/repos/dask/dask/issues/3824/timeline,,,DPeterK,3473068,MDQ6VXNlcjM0NzMwNjg=,https://avatars.githubusercontent.com/u/3473068?v=4,,https://api.github.com/users/DPeterK,https://github.com/DPeterK,https://api.github.com/users/DPeterK/followers,https://api.github.com/users/DPeterK/following{/other_user},https://api.github.com/users/DPeterK/gists{/gist_id},https://api.github.com/users/DPeterK/starred{/owner}{/repo},https://api.github.com/users/DPeterK/subscriptions,https://api.github.com/users/DPeterK/orgs,https://api.github.com/users/DPeterK/repos,https://api.github.com/users/DPeterK/events{/privacy},https://api.github.com/users/DPeterK/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3824/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
137,https://api.github.com/repos/dask/dask/issues/3832,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3832/labels{/name},https://api.github.com/repos/dask/dask/issues/3832/comments,https://api.github.com/repos/dask/dask/issues/3832/events,https://github.com/dask/dask/issues/3832,346363055,MDU6SXNzdWUzNDYzNjMwNTU=,3832,Reentrant versions of dask.utils.SerializableLock and distributed.Lock,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,6,2018-07-31T21:21:46Z,2019-04-30T20:00:15Z,,MEMBER,,"I'm pretty sure to get distributed writes working properly in xarray (https://github.com/pydata/xarray/pull/2261) we will need reentrant versions of `dask.utils.SerializableLock` and `distributed.Lock`, i.e., which can be acquired multiple times by the same thread like [`threading.RLock`](https://docs.python.org/3.7/library/threading.html#rlock-objects). These could potentially be useful for other projects using dask as well.

Contemplating how to write these is hurting my head a little bit. In principle, we could just make a forked version of `SerializableLock` that uses `RLock` internally, but for `distributed.Lock` it's less clear.

Ideally, we could do this with composition, e.g., by writing `ReentrantLock(distributed.Lock(...))` to make a reentrant distributed lock. Does anyone have any idea what that would look like?",,https://api.github.com/repos/dask/dask/issues/3832/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3832/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
138,https://api.github.com/repos/dask/dask/issues/3842,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3842/labels{/name},https://api.github.com/repos/dask/dask/issues/3842/comments,https://api.github.com/repos/dask/dask/issues/3842/events,https://github.com/dask/dask/issues/3842,347074081,MDU6SXNzdWUzNDcwNzQwODE=,3842,Saving to parquet with partition_on results in loss of divisions when reading it back to dataframe.,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,4,2018-08-02T15:56:23Z,2021-10-12T07:26:16Z,,NONE,,"
# TLDR
When I save a Dask dataframe to parquet using partition on a certain collumn and then I read those parquet files into a dataframe the divisions are lost. This doesn't happen with every dataframe, for example if the collumn I'm using for the partitioning (let's call it 'Categoricals') is ordered then this problem won't happen. Below I'll leave an example where the problem happens and one where it doesn't.

# Imports


```python
import numpy as np
import pandas as pd
import dask.dataframe as dd
from fastparquet import ParquetFile
```

    /usr/lib/python3.5/importlib/_bootstrap.py:222: RuntimeWarning: numpy.dtype size changed, may indicate binary incompatibility. Expected 96, got 88
      return f(*args, **kwds)
    /usr/lib/python3.5/importlib/_bootstrap.py:222: RuntimeWarning: numpy.dtype size changed, may indicate binary incompatibility. Expected 96, got 88
      return f(*args, **kwds)


# Example where divisions are known

Here I created a dummy dataframe where the column by which we partition ('Categoricals') is ordered, as can be seen the divisions are known after loading the parquet file.


```python
def generate_df(size):
    df = pd.Series(np.arange(0, size), name='unique').to_frame()

    df['dates'] = pd.date_range('2015-01-01', periods=size, freq='1min', name='dates')
    df['ints'] = np.linspace(0, 100, size, endpoint=False, dtype=int)
    df['floats'] = df['ints'].astype(float)
    df['constants'] = 42
    df['uniques'] = df['unique'].astype(str)

    # nanints is ints with first 10% entries set to nan
    df['nanints'] = df['ints']
    df.loc[df.index < int(size / 10), 'nanints'] = np.nan

    # generate categorical column with 4 distinct values
    categoricals = []
    for value in ['a', 'b', 'c', 'd']:
        categoricals += [value] * int(size / 4)
    df['categoricals'] = categoricals
    df['nancategoricals'] = df['categoricals'].replace('d', np.nan)

    return df
```


```python
df = generate_df(16)
```


```python
df = df.set_index('dates')
df = dd.from_pandas(df, npartitions=3)
```


```python
df.head(16, npartitions=-1)
```


</style>
<table border=""1"" class=""dataframe"">
  <thead>
    <tr style=""text-align: right;"">
      <th></th>
      <th>unique</th>
      <th>ints</th>
      <th>floats</th>
      <th>constants</th>
      <th>uniques</th>
      <th>nanints</th>
      <th>categoricals</th>
      <th>nancategoricals</th>
    </tr>
    <tr>
      <th>dates</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2015-01-01 00:00:00</th>
      <td>0</td>
      <td>0</td>
      <td>0.0</td>
      <td>42</td>
      <td>0</td>
      <td>NaN</td>
      <td>a</td>
      <td>a</td>
    </tr>
    <tr>
      <th>2015-01-01 00:01:00</th>
      <td>1</td>
      <td>6</td>
      <td>6.0</td>
      <td>42</td>
      <td>1</td>
      <td>6.0</td>
      <td>a</td>
      <td>a</td>
    </tr>
    <tr>
      <th>2015-01-01 00:02:00</th>
      <td>2</td>
      <td>12</td>
      <td>12.0</td>
      <td>42</td>
      <td>2</td>
      <td>12.0</td>
      <td>a</td>
      <td>a</td>
    </tr>
    <tr>
      <th>2015-01-01 00:03:00</th>
      <td>3</td>
      <td>18</td>
      <td>18.0</td>
      <td>42</td>
      <td>3</td>
      <td>18.0</td>
      <td>a</td>
      <td>a</td>
    </tr>
    <tr>
      <th>2015-01-01 00:04:00</th>
      <td>4</td>
      <td>25</td>
      <td>25.0</td>
      <td>42</td>
      <td>4</td>
      <td>25.0</td>
      <td>b</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2015-01-01 00:05:00</th>
      <td>5</td>
      <td>31</td>
      <td>31.0</td>
      <td>42</td>
      <td>5</td>
      <td>31.0</td>
      <td>b</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2015-01-01 00:06:00</th>
      <td>6</td>
      <td>37</td>
      <td>37.0</td>
      <td>42</td>
      <td>6</td>
      <td>37.0</td>
      <td>b</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2015-01-01 00:07:00</th>
      <td>7</td>
      <td>43</td>
      <td>43.0</td>
      <td>42</td>
      <td>7</td>
      <td>43.0</td>
      <td>b</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2015-01-01 00:08:00</th>
      <td>8</td>
      <td>50</td>
      <td>50.0</td>
      <td>42</td>
      <td>8</td>
      <td>50.0</td>
      <td>c</td>
      <td>c</td>
    </tr>
    <tr>
      <th>2015-01-01 00:09:00</th>
      <td>9</td>
      <td>56</td>
      <td>56.0</td>
      <td>42</td>
      <td>9</td>
      <td>56.0</td>
      <td>c</td>
      <td>c</td>
    </tr>
    <tr>
      <th>2015-01-01 00:10:00</th>
      <td>10</td>
      <td>62</td>
      <td>62.0</td>
      <td>42</td>
      <td>10</td>
      <td>62.0</td>
      <td>c</td>
      <td>c</td>
    </tr>
    <tr>
      <th>2015-01-01 00:11:00</th>
      <td>11</td>
      <td>68</td>
      <td>68.0</td>
      <td>42</td>
      <td>11</td>
      <td>68.0</td>
      <td>c</td>
      <td>c</td>
    </tr>
    <tr>
      <th>2015-01-01 00:12:00</th>
      <td>12</td>
      <td>75</td>
      <td>75.0</td>
      <td>42</td>
      <td>12</td>
      <td>75.0</td>
      <td>d</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2015-01-01 00:13:00</th>
      <td>13</td>
      <td>81</td>
      <td>81.0</td>
      <td>42</td>
      <td>13</td>
      <td>81.0</td>
      <td>d</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2015-01-01 00:14:00</th>
      <td>14</td>
      <td>87</td>
      <td>87.0</td>
      <td>42</td>
      <td>14</td>
      <td>87.0</td>
      <td>d</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2015-01-01 00:15:00</th>
      <td>15</td>
      <td>93</td>
      <td>93.0</td>
      <td>42</td>
      <td>15</td>
      <td>93.0</td>
      <td>d</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




```python
df.divisions 
```




    (Timestamp('2015-01-01 00:00:00'),
     Timestamp('2015-01-01 00:06:00'),
     Timestamp('2015-01-01 00:12:00'),
     Timestamp('2015-01-01 00:15:00'))




```python
df.to_parquet('./data_new', engine='fastparquet', partition_on=['categoricals'])

```

    /home/felgueira/.local/lib/python3.5/site-packages/fastparquet/writer.py:407: FutureWarning: Method .valid will be removed in a future version. Use .dropna instead.
      out = data.valid()  # better, data[data.notnull()], from above ?



```python
pq_f = ParquetFile('./data_new')

```


```python
df = dd.read_parquet(pq_f)

```


```python
df.divisions

```




    (Timestamp('2015-01-01 00:00:00'),
     Timestamp('2015-01-01 00:04:00'),
     Timestamp('2015-01-01 00:06:00'),
     Timestamp('2015-01-01 00:08:00'),
     Timestamp('2015-01-01 00:12:00'),
     Timestamp('2015-01-01 00:15:00'))



# Example where divisions are not known

Here I created a dummy dataframe where the column by which we partition ('Categoricals') is not ordered because of an ""outlier"", as can be seen the divisions are not known after loading the parquet file.


```python
def generate_df(size):
    df = pd.Series(np.arange(0, size), name='unique').to_frame()

    df['dates'] = pd.date_range('2015-01-01', periods=size, freq='1min', name='dates')
    df['ints'] = np.linspace(0, 100, size, endpoint=False, dtype=int)
    df['floats'] = df['ints'].astype(float)
    df['constants'] = 42
    df['uniques'] = df['unique'].astype(str)

    # nanints is ints with first 10% entries set to nan
    df['nanints'] = df['ints']
    df.loc[df.index < int(size / 10), 'nanints'] = np.nan

    # generate categorical column with 4 distinct values
    categoricals = []
    for value in ['a', 'b', 'c', 'd']:
        categoricals += [value] * int(size / 4)
    categoricals[10] = 'b'
    df['categoricals'] = categoricals
    df['nancategoricals'] = df['categoricals'].replace('d', np.nan)

    return df
```


```python
df = generate_df(16)
```


```python
df = df.set_index('dates')
df = dd.from_pandas(df, npartitions=3)
```


```python
df.head(16, npartitions=-1)
```




<table border=""1"" class=""dataframe"">
  <thead>
    <tr style=""text-align: right;"">
      <th></th>
      <th>unique</th>
      <th>ints</th>
      <th>floats</th>
      <th>constants</th>
      <th>uniques</th>
      <th>nanints</th>
      <th>categoricals</th>
      <th>nancategoricals</th>
    </tr>
    <tr>
      <th>dates</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2015-01-01 00:00:00</th>
      <td>0</td>
      <td>0</td>
      <td>0.0</td>
      <td>42</td>
      <td>0</td>
      <td>NaN</td>
      <td>a</td>
      <td>a</td>
    </tr>
    <tr>
      <th>2015-01-01 00:01:00</th>
      <td>1</td>
      <td>6</td>
      <td>6.0</td>
      <td>42</td>
      <td>1</td>
      <td>6.0</td>
      <td>a</td>
      <td>a</td>
    </tr>
    <tr>
      <th>2015-01-01 00:02:00</th>
      <td>2</td>
      <td>12</td>
      <td>12.0</td>
      <td>42</td>
      <td>2</td>
      <td>12.0</td>
      <td>a</td>
      <td>a</td>
    </tr>
    <tr>
      <th>2015-01-01 00:03:00</th>
      <td>3</td>
      <td>18</td>
      <td>18.0</td>
      <td>42</td>
      <td>3</td>
      <td>18.0</td>
      <td>a</td>
      <td>a</td>
    </tr>
    <tr>
      <th>2015-01-01 00:04:00</th>
      <td>4</td>
      <td>25</td>
      <td>25.0</td>
      <td>42</td>
      <td>4</td>
      <td>25.0</td>
      <td>b</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2015-01-01 00:05:00</th>
      <td>5</td>
      <td>31</td>
      <td>31.0</td>
      <td>42</td>
      <td>5</td>
      <td>31.0</td>
      <td>b</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2015-01-01 00:06:00</th>
      <td>6</td>
      <td>37</td>
      <td>37.0</td>
      <td>42</td>
      <td>6</td>
      <td>37.0</td>
      <td>b</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2015-01-01 00:07:00</th>
      <td>7</td>
      <td>43</td>
      <td>43.0</td>
      <td>42</td>
      <td>7</td>
      <td>43.0</td>
      <td>b</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2015-01-01 00:08:00</th>
      <td>8</td>
      <td>50</td>
      <td>50.0</td>
      <td>42</td>
      <td>8</td>
      <td>50.0</td>
      <td>c</td>
      <td>c</td>
    </tr>
    <tr>
      <th>2015-01-01 00:09:00</th>
      <td>9</td>
      <td>56</td>
      <td>56.0</td>
      <td>42</td>
      <td>9</td>
      <td>56.0</td>
      <td>c</td>
      <td>c</td>
    </tr>
    <tr>
      <th>2015-01-01 00:10:00</th>
      <td>10</td>
      <td>62</td>
      <td>62.0</td>
      <td>42</td>
      <td>10</td>
      <td>62.0</td>
      <td>b</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2015-01-01 00:11:00</th>
      <td>11</td>
      <td>68</td>
      <td>68.0</td>
      <td>42</td>
      <td>11</td>
      <td>68.0</td>
      <td>c</td>
      <td>c</td>
    </tr>
    <tr>
      <th>2015-01-01 00:12:00</th>
      <td>12</td>
      <td>75</td>
      <td>75.0</td>
      <td>42</td>
      <td>12</td>
      <td>75.0</td>
      <td>d</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2015-01-01 00:13:00</th>
      <td>13</td>
      <td>81</td>
      <td>81.0</td>
      <td>42</td>
      <td>13</td>
      <td>81.0</td>
      <td>d</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2015-01-01 00:14:00</th>
      <td>14</td>
      <td>87</td>
      <td>87.0</td>
      <td>42</td>
      <td>14</td>
      <td>87.0</td>
      <td>d</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2015-01-01 00:15:00</th>
      <td>15</td>
      <td>93</td>
      <td>93.0</td>
      <td>42</td>
      <td>15</td>
      <td>93.0</td>
      <td>d</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




```python
df.divisions 
```




    (Timestamp('2015-01-01 00:00:00'),
     Timestamp('2015-01-01 00:06:00'),
     Timestamp('2015-01-01 00:12:00'),
     Timestamp('2015-01-01 00:15:00'))




```python
df.to_parquet('./data_new', engine='fastparquet', partition_on=['categoricals'])

```

    /home/felgueira/.local/lib/python3.5/site-packages/fastparquet/writer.py:407: FutureWarning: Method .valid will be removed in a future version. Use .dropna instead.
      out = data.valid()  # better, data[data.notnull()], from above ?



```python
pq_f = ParquetFile('./data_new')

```


```python
df = dd.read_parquet(pq_f)

```


```python
df.divisions

```




    (None, None, None, None, None, None)

",,https://api.github.com/repos/dask/dask/issues/3842/timeline,,,TSFelg,38079600,MDQ6VXNlcjM4MDc5NjAw,https://avatars.githubusercontent.com/u/38079600?v=4,,https://api.github.com/users/TSFelg,https://github.com/TSFelg,https://api.github.com/users/TSFelg/followers,https://api.github.com/users/TSFelg/following{/other_user},https://api.github.com/users/TSFelg/gists{/gist_id},https://api.github.com/users/TSFelg/starred{/owner}{/repo},https://api.github.com/users/TSFelg/subscriptions,https://api.github.com/users/TSFelg/orgs,https://api.github.com/users/TSFelg/repos,https://api.github.com/users/TSFelg/events{/privacy},https://api.github.com/users/TSFelg/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3842/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
139,https://api.github.com/repos/dask/dask/issues/3864,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3864/labels{/name},https://api.github.com/repos/dask/dask/issues/3864/comments,https://api.github.com/repos/dask/dask/issues/3864/events,https://github.com/dask/dask/issues/3864,349088950,MDU6SXNzdWUzNDkwODg5NTA=,3864,Support for array chunking 'strategies',"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,4,2018-08-09T11:32:50Z,2021-10-12T04:23:01Z,,NONE,,"I have an approach to this working for myself but I am raising it as I have a suspicion I am not the only one who might find this useful:

I am currently using dask to write data parallel versions of several custom algorithms, which is making heavy use of `map_blocks` over custom numba functions usually dropping and adding axes along the way.  Something that has come up quite a few times through this is the need to rechunk with a specific strategy, usually one of ""ensure chunks don't break up a specific axis"" or ""ensure chunks are contiguous when unravelled"".

I currently have (slightly hackish) solutions that work for me, but I wonder if there is scope for dask supporting certain chunking strategies more formally, perhaps extending the current 'auto' keyword to allowing hinting of the desirable chunking strategy?  This might have knock on benefits for the discussion about rechunking going on in #3587.

I would be open to helping develop this if there was appetite for it.",,https://api.github.com/repos/dask/dask/issues/3864/timeline,,,ptooley,32297355,MDQ6VXNlcjMyMjk3MzU1,https://avatars.githubusercontent.com/u/32297355?v=4,,https://api.github.com/users/ptooley,https://github.com/ptooley,https://api.github.com/users/ptooley/followers,https://api.github.com/users/ptooley/following{/other_user},https://api.github.com/users/ptooley/gists{/gist_id},https://api.github.com/users/ptooley/starred{/owner}{/repo},https://api.github.com/users/ptooley/subscriptions,https://api.github.com/users/ptooley/orgs,https://api.github.com/users/ptooley/repos,https://api.github.com/users/ptooley/events{/privacy},https://api.github.com/users/ptooley/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3864/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
140,https://api.github.com/repos/dask/dask/issues/3889,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3889/labels{/name},https://api.github.com/repos/dask/dask/issues/3889/comments,https://api.github.com/repos/dask/dask/issues/3889/events,https://github.com/dask/dask/issues/3889,352110440,MDU6SXNzdWUzNTIxMTA0NDA=,3889,Should dask-mpi section be marked as not necessary in the docs?,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,2,2018-08-20T12:19:46Z,2021-10-12T07:07:51Z,,MEMBER,,"See http://dask.pydata.org/en/latest/setup/hpc.html#using-mpi. 

While working on and with [dask-jobqueue](https://dask-jobqueue.readthedocs.io/en/latest/), in particular on doc issues (See [#118](https://github.com/dask/dask-jobqueue/pull/118)), I stumble on the question of dask-jobqueue for batch processing. I believe this is OK and will work in many cases (I've already used it this way), but it won't in some others where dask-mpi would be appropriate. See the part of the doc I'm working on:

>While dask-jobqueue can perfectly be used to submit batch processing, it is
better suited to interactive processing, using tools like ipython or jupyter
notebooks. Batch processing with dask-jobqueue can be tricky in some cases
depending on how your cluster is configured and which resources and queues you
have access to: scheduler might hang on for a long time before having some
connected workers, and you could end up with less computing power than you
expected. Another good solution for batch processing on HPC system using dask
is the `dask-mpi <http://dask.pydata.org/en/latest/setup/hpc.html#using-mpi>`_
command.

Maybe we should clarify this between us and also in Dask docs?

cc @jhamman ",,https://api.github.com/repos/dask/dask/issues/3889/timeline,,,guillaumeeb,17138587,MDQ6VXNlcjE3MTM4NTg3,https://avatars.githubusercontent.com/u/17138587?v=4,,https://api.github.com/users/guillaumeeb,https://github.com/guillaumeeb,https://api.github.com/users/guillaumeeb/followers,https://api.github.com/users/guillaumeeb/following{/other_user},https://api.github.com/users/guillaumeeb/gists{/gist_id},https://api.github.com/users/guillaumeeb/starred{/owner}{/repo},https://api.github.com/users/guillaumeeb/subscriptions,https://api.github.com/users/guillaumeeb/orgs,https://api.github.com/users/guillaumeeb/repos,https://api.github.com/users/guillaumeeb/events{/privacy},https://api.github.com/users/guillaumeeb/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3889/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
141,https://api.github.com/repos/dask/dask/issues/3913,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3913/labels{/name},https://api.github.com/repos/dask/dask/issues/3913/comments,https://api.github.com/repos/dask/dask/issues/3913/events,https://github.com/dask/dask/issues/3913,354907643,MDU6SXNzdWUzNTQ5MDc2NDM=,3913,Error nicely on malformed config yaml files,"[{'id': 1012929478, 'node_id': 'MDU6TGFiZWwxMDEyOTI5NDc4', 'url': 'https://api.github.com/repos/dask/dask/labels/config', 'name': 'config', 'color': '1586c0', 'default': False, 'description': ''}]",open,False,,[],,4,2018-08-28T21:17:27Z,2019-04-30T15:43:58Z,,NONE,,"This may be misdirected, but wanted to provide feedback on the new centralized config system. I recently implemented the latest version of dask and distributed. After doing so, I typed `import distributed` and got:
```
yaml.parser.ParserError: expected '<document start>', but found '<scalar>'
  in ""<unicode string>"", line 2, column 1:
    keys=root
    ^
```
I usually interpret these sorts of errors as some stale version of a dependency. I spent a while trying to confirm that dependencies were installed correctly.
In the end, I was caught because the new centralized config file parser was picking up some defunct, ill-defined yaml file with this:
```
[loggers]
keys=root
```

This was not at all clear from the error I got initially. I don't see any other reports like this, so maybe mine is a corner case. If not, then dask may want to add a check for valid yaml files before it tries to parse them.",,https://api.github.com/repos/dask/dask/issues/3913/timeline,,,caseyjlaw,1878317,MDQ6VXNlcjE4NzgzMTc=,https://avatars.githubusercontent.com/u/1878317?v=4,,https://api.github.com/users/caseyjlaw,https://github.com/caseyjlaw,https://api.github.com/users/caseyjlaw/followers,https://api.github.com/users/caseyjlaw/following{/other_user},https://api.github.com/users/caseyjlaw/gists{/gist_id},https://api.github.com/users/caseyjlaw/starred{/owner}{/repo},https://api.github.com/users/caseyjlaw/subscriptions,https://api.github.com/users/caseyjlaw/orgs,https://api.github.com/users/caseyjlaw/repos,https://api.github.com/users/caseyjlaw/events{/privacy},https://api.github.com/users/caseyjlaw/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3913/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
142,https://api.github.com/repos/dask/dask/issues/3929,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3929/labels{/name},https://api.github.com/repos/dask/dask/issues/3929/comments,https://api.github.com/repos/dask/dask/issues/3929/events,https://github.com/dask/dask/issues/3929,356153887,MDU6SXNzdWUzNTYxNTM4ODc=,3929,Multinomial bug,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,5,2018-09-01T00:09:02Z,2019-07-04T13:31:42Z,,NONE,,"I'm using python 3.7, numpy 1.16.0.dev0+591880b built with mkl, and dask 0.19.0.

```
import dask
import dask.array as da 
import numpy as np

N = 10
dp = da.random.random(3, chunks=1)
dp = dp / dp.sum()
dx = da.random.multinomial(1, dp, N, chunks=2)
```

```
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""/usr/lib/python3.7/site-packages/dask/array/random.py"", line 295, in multinomial
    extra_chunks=((len(pvals),),))
  File ""/usr/lib/python3.7/site-packages/dask/array/random.py"", line 73, in _wrap
    size = broadcast_shapes(*shapes)
  File ""/usr/lib/python3.7/site-packages/dask/array/core.py"", line 3428, in broadcast_shapes
    ""shapes {0}"".format(' '.join(map(str, shapes))))
ValueError: operands could not be broadcast together with shapes (3,) (10,)
```

The numpy code excutes as expected.
```
p = dp.compute() 
x = np.random.multinomial(1, p, N)
```
Feeding in `p` instead of `dp` causes the same error.
",,https://api.github.com/repos/dask/dask/issues/3929/timeline,,,deasmhumhna,3468977,MDQ6VXNlcjM0Njg5Nzc=,https://avatars.githubusercontent.com/u/3468977?v=4,,https://api.github.com/users/deasmhumhna,https://github.com/deasmhumhna,https://api.github.com/users/deasmhumhna/followers,https://api.github.com/users/deasmhumhna/following{/other_user},https://api.github.com/users/deasmhumhna/gists{/gist_id},https://api.github.com/users/deasmhumhna/starred{/owner}{/repo},https://api.github.com/users/deasmhumhna/subscriptions,https://api.github.com/users/deasmhumhna/orgs,https://api.github.com/users/deasmhumhna/repos,https://api.github.com/users/deasmhumhna/events{/privacy},https://api.github.com/users/deasmhumhna/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3929/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
143,https://api.github.com/repos/dask/dask/issues/3962,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3962/labels{/name},https://api.github.com/repos/dask/dask/issues/3962/comments,https://api.github.com/repos/dask/dask/issues/3962/events,https://github.com/dask/dask/issues/3962,358062747,MDU6SXNzdWUzNTgwNjI3NDc=,3962,[feature] da.linalg.norm does not support SVD-based norms stacks of matrices,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2018-09-07T13:15:36Z,2018-09-29T20:14:35Z,,CONTRIBUTOR,,"For reference: da.linalg.norm for the moment does not support SVD based norms on 2D slices of ndimensional arrays, i.e. stacks of matrices as np.linalg.norm _does_ support. 
From issue #3895, which was resolved by PR #3933 :

> Except for the SVD-based norms on slices of ND arrays. I see that np.linalg itself only supports operating on the last two dimensions of ND-arrays for the svd here: > https://docs.scipy.org/doc/numpy/reference/routines.linalg.html#linear-algebra-on-several-matrices-at-once, although np.linalg.norm handles this somehow.
This means we can either create some application of map_blocks/apply_along_axes on the existing da.linalg.svr (or the underlying da.linalg.tsqr) in this case for norm, or extend one of these to operate on the last 2 dimensions of an N-D array, or to take an axis argument, respectively replicating or superseding the stacked linalg computation functionality of numpy.

I guess matching numpy functionality and operate on the last two dimensions would be the best, as introducing a full axis argument for svd/tsqr would just hide away an underlying transpose.",,https://api.github.com/repos/dask/dask/issues/3962/timeline,,,TAdeJong,6816964,MDQ6VXNlcjY4MTY5NjQ=,https://avatars.githubusercontent.com/u/6816964?v=4,,https://api.github.com/users/TAdeJong,https://github.com/TAdeJong,https://api.github.com/users/TAdeJong/followers,https://api.github.com/users/TAdeJong/following{/other_user},https://api.github.com/users/TAdeJong/gists{/gist_id},https://api.github.com/users/TAdeJong/starred{/owner}{/repo},https://api.github.com/users/TAdeJong/subscriptions,https://api.github.com/users/TAdeJong/orgs,https://api.github.com/users/TAdeJong/repos,https://api.github.com/users/TAdeJong/events{/privacy},https://api.github.com/users/TAdeJong/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3962/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
144,https://api.github.com/repos/dask/dask/issues/3973,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3973/labels{/name},https://api.github.com/repos/dask/dask/issues/3973/comments,https://api.github.com/repos/dask/dask/issues/3973/events,https://github.com/dask/dask/issues/3973,359031507,MDU6SXNzdWUzNTkwMzE1MDc=,3973,Inconsistent behaviour when using map_partitions with DataFrames as arguments,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2018-09-11T12:47:50Z,2021-10-12T07:00:56Z,,NONE,,"When trying to use map_partitions and passing GeoDataFrames as an argument I run into inconsistent behaviour of DASK when the DASK DataFrame is created from delayed. When passing raw DataFrame it throws error about unknown divisions, when first scattering this DataFrame and only then passing It as an argument everything works as (un)expected. Sorry for the long description, but I spent quite a long time trying to figure out what went wrong after DASK upgrade (from 0.17)

```
import pandas as pd
import numpy as np

import geopandas as gpd
from dask import dataframe as dd
from distributed import Client
from shapely.geometry import Point
from dask import delayed

def find_fids(df, gdf_harbours):   #, gdf_anchorage, gdf_faculty, gdf_berths, gdf_buoy):
    print(""This is partition with {} points"".format(len(df.index)))
    m_df = df[['lat', 'lon', 'port_id', 'anch_id', 'fac_id', 'berth_id', 'boy_id']]
    m_df = m_df.reset_index()
    m_df.loc[:,'port_id'] = 1
    m_df = m_df.set_index('index')
    print(""Finished partition"")
    return m_df[['port_id', 'anch_id', 'fac_id', 'berth_id', 'boy_id']]

def rnp(length):
    data_pos = (np.random.rand(length,2)-0.5)*90
    data_id = -np.ones((length,5))
    data = np.concatenate((data_pos, data_id), axis=1)
    return pd.DataFrame(data = data, columns=['lat', 'lon', 'port_id', 'anch_id', 'fac_id', 'berth_id', 'boy_id'])

def get_fdf():
    lazy_dataframes=[]
    for i in range(10000):
        ndf = delayed(rnp)(1000)
        lazy_dataframes.append(ndf)
    ddf = dd.from_delayed(lazy_dataframes, meta=lazy_dataframes[0].compute())
    ldf = ddf.copy()
    ddf = ddf.append(ldf)
    return ddf

client = Client('127.0.0.1:8786', processes=True)

length = 10000
data_pos = (np.random.rand(length,2)-0.5)*90
z = list(map(Point, data_pos))
harbours = gpd.GeoDataFrame({'116': list(np.ones((length, 1))), 'geometry': z}, crs={'init': 'epsg:4326'})

sharbours = client.scatter(harbours)
ddf = client.persist(get_fdf())
ddf[['port_id', 'anch_id', 'fac_id', 'berth_id', 'boy_id']] = ddf.map_partitions(
            find_fids, sharbours, meta=pd.DataFrame({'port_id':[-1], 'anch_id':[-1], 'fac_id':[-1], 
                                                                'berth_id':[-1], 'boy_id':[-1]}))
df = ddf.compute()
```
Works fine. However if I the last part will be only  

```
ddf = client.persist(get_fdf())
ddf[['port_id', 'anch_id', 'fac_id', 'berth_id', 'boy_id']] = ddf.map_partitions(
            find_fids, harbours, meta=pd.DataFrame({'port_id':[-1], 'anch_id':[-1], 'fac_id':[-1], 
                                                                'berth_id':[-1], 'boy_id':[-1]}))
df = ddf.compute()

```
then I receive the following error

```
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-30-5088b0035b38> in <module>()
      1 ddf[['port_id', 'anch_id', 'fac_id', 'berth_id', 'boy_id']] = ddf.map_partitions(
      2             find_fids, harbours, meta=pd.DataFrame({'port_id':[-1], 'anch_id':[-1], 'fac_id':[-1], 
----> 3                                                                 'berth_id':[-1], 'boy_id':[-1]}))
      4 df = ddf.compute()

/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/dataframe/core.py in map_partitions(self, func, *args, **kwargs)
    579         >>> ddf.map_partitions(func).clear_divisions()  # doctest: +SKIP
    580         """"""
--> 581         return map_partitions(func, self, *args, **kwargs)
    582 
    583     @insert_meta_param_description(pad=12)

/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/dataframe/core.py in map_partitions(func, *args, **kwargs)
   3614     from .multi import _maybe_align_partitions
   3615     args = _maybe_from_pandas(args)
-> 3616     args = _maybe_align_partitions(args)
   3617 
   3618     if meta is no_default:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/dataframe/multi.py in _maybe_align_partitions(args)
    145     divisions = dfs[0].divisions
    146     if not all(df.divisions == divisions for df in dfs):
--> 147         dfs2 = iter(align_partitions(*dfs)[0])
    148         return [a if not isinstance(a, _Frame) else next(dfs2) for a in args]
    149     return args

/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/dataframe/multi.py in align_partitions(*dfs)
    101         raise ValueError(""dfs contains no DataFrame and Series"")
    102     if not all(df.known_divisions for df in dfs1):
--> 103         raise ValueError(""Not all divisions are known, can't align ""
    104                          ""partitions. Please use `set_index` ""
    105                          ""to set the index."")

ValueError: Not all divisions are known, can't align partitions. Please use `set_index` to set the index.
```

If I try to set index (adding) the following line

`ddf = client.persist(ddf.reset_index().set_index('index'))`
it takes forever and when killed gives the following trace

```
---------------------------------------------------------------------------
KeyboardInterrupt                         Traceback (most recent call last)
<ipython-input-12-2911203558a9> in <module>()
----> 1 ddf = client.persist(ddf.reset_index().set_index('index'))

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/client.py in persist(self, collections, optimize_graph, workers, allow_other_workers, resources, retries, priority, fifo_timeout, actors, **kwargs)
   2469                                          user_priority=priority,
   2470                                          fifo_timeout=fifo_timeout,
-> 2471                                          actors=actors)
   2472 
   2473         postpersists = [c.__dask_postpersist__() for c in collections]

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/client.py in _graph_to_futures(self, dsk, keys, restrictions, loose_restrictions, priority, user_priority, resources, retries, fifo_timeout, actors)
   2109                 dsk = dask.optimization.inline(dsk, keys=values)
   2110 
-> 2111             d = {k: unpack_remotedata(v, byte_keys=True) for k, v in dsk.items()}
   2112             extra_futures = set.union(*[v[1] for v in d.values()]) if d else set()
   2113             extra_keys = {tokey(future.key) for future in extra_futures}

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/client.py in <dictcomp>(.0)
   2109                 dsk = dask.optimization.inline(dsk, keys=values)
   2110 
-> 2111             d = {k: unpack_remotedata(v, byte_keys=True) for k, v in dsk.items()}
   2112             extra_futures = set.union(*[v[1] for v in d.values()]) if d else set()
   2113             extra_keys = {tokey(future.key) for future in extra_futures}

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    173     if myset is None:
    174         myset = set()
--> 175         out = unpack_remotedata(o, byte_keys, myset)
    176         return out, myset
    177 

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in <listcomp>(.0)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in <listcomp>(.0)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in <listcomp>(.0)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in <listcomp>(.0)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in <listcomp>(.0)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    176         return out, myset
    177 
--> 178     typ = type(o)
    179 
    180     if typ in collection_types:
```

if done without _persist_, i.e.
`ddf = ddf.reset_index().set_index('index')`
then it got stack on map_partitions with **unscattered** geodataframe and when killed produce the following trace:
```

---------------------------------------------------------------------------
KeyboardInterrupt                         Traceback (most recent call last)
<ipython-input-14-5088b0035b38> in <module>()
      2             find_fids, harbours, meta=pd.DataFrame({'port_id':[-1], 'anch_id':[-1], 'fac_id':[-1], 
      3                                                                 'berth_id':[-1], 'boy_id':[-1]}))
----> 4 df = ddf.compute()

/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/base.py in compute(self, **kwargs)
    154         dask.base.compute
    155         """"""
--> 156         (result,) = compute(self, traverse=False, **kwargs)
    157         return result
    158 

/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/base.py in compute(*args, **kwargs)
    393     keys = [x.__dask_keys__() for x in collections]
    394     postcomputes = [x.__dask_postcompute__() for x in collections]
--> 395     results = schedule(dsk, keys, **kwargs)
    396     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    397 

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/client.py in get(self, dsk, keys, restrictions, loose_restrictions, resources, sync, asynchronous, direct, retries, priority, fifo_timeout, **kwargs)
   2202                                          fifo_timeout=fifo_timeout,
   2203                                          retries=retries,
-> 2204                                          user_priority=priority,
   2205                                          )
   2206         packed = pack_data(keys, futures)

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/client.py in _graph_to_futures(self, dsk, keys, restrictions, loose_restrictions, priority, user_priority, resources, retries, fifo_timeout, actors)
   2107                       and k not in keyset}
   2108             if values:
-> 2109                 dsk = dask.optimization.inline(dsk, keys=values)
   2110 
   2111             d = {k: unpack_remotedata(v, byte_keys=True) for k, v in dsk.items()}

/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/optimization.py in inline(dsk, keys, inline_constants, dependencies)
    249     if dependencies is None:
    250         dependencies = {k: get_dependencies(dsk, k)
--> 251                         for k in dsk}
    252 
    253     if inline_constants:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/optimization.py in <dictcomp>(.0)
    249     if dependencies is None:
    250         dependencies = {k: get_dependencies(dsk, k)
--> 251                         for k in dsk}
    252 
    253     if inline_constants:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/core.py in get_dependencies(dsk, key, task, as_list)
    199         new_work = []
    200         for w in work:
--> 201             typ = type(w)
    202             if typ is tuple and w and callable(w[0]):  # istask(w)
    203                 new_work += w[1:]

KeyboardInterrupt: 
```
I run with **scattered** geodataframe, then it got stack on map_partitions, consumes all the memory (in real life example) and when killed produce the following trace:

```
---------------------------------------------------------------------------
KeyboardInterrupt                         Traceback (most recent call last)
<ipython-input-12-9df5c63458da> in <module>()
      2             find_fids, sharbours, meta=pd.DataFrame({'port_id':[-1], 'anch_id':[-1], 'fac_id':[-1], 
      3                                                                 'berth_id':[-1], 'boy_id':[-1]}))
----> 4 df = ddf.compute()

/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/base.py in compute(self, **kwargs)
    154         dask.base.compute
    155         """"""
--> 156         (result,) = compute(self, traverse=False, **kwargs)
    157         return result
    158 

/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/base.py in compute(*args, **kwargs)
    393     keys = [x.__dask_keys__() for x in collections]
    394     postcomputes = [x.__dask_postcompute__() for x in collections]
--> 395     results = schedule(dsk, keys, **kwargs)
    396     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    397 

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/client.py in get(self, dsk, keys, restrictions, loose_restrictions, resources, sync, asynchronous, direct, retries, priority, fifo_timeout, **kwargs)
   2202                                          fifo_timeout=fifo_timeout,
   2203                                          retries=retries,
-> 2204                                          user_priority=priority,
   2205                                          )
   2206         packed = pack_data(keys, futures)

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/client.py in _graph_to_futures(self, dsk, keys, restrictions, loose_restrictions, priority, user_priority, resources, retries, fifo_timeout, actors)
   2109                 dsk = dask.optimization.inline(dsk, keys=values)
   2110 
-> 2111             d = {k: unpack_remotedata(v, byte_keys=True) for k, v in dsk.items()}
   2112             extra_futures = set.union(*[v[1] for v in d.values()]) if d else set()
   2113             extra_keys = {tokey(future.key) for future in extra_futures}

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/client.py in <dictcomp>(.0)
   2109                 dsk = dask.optimization.inline(dsk, keys=values)
   2110 
-> 2111             d = {k: unpack_remotedata(v, byte_keys=True) for k, v in dsk.items()}
   2112             extra_futures = set.union(*[v[1] for v in d.values()]) if d else set()
   2113             extra_keys = {tokey(future.key) for future in extra_futures}

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    173     if myset is None:
    174         myset = set()
--> 175         out = unpack_remotedata(o, byte_keys, myset)
    176         return out, myset
    177 

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in <listcomp>(.0)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in <listcomp>(.0)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in <listcomp>(.0)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in <listcomp>(.0)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in <listcomp>(.0)
    181         if not o:
    182             return o
--> 183         outs = [unpack_remotedata(item, byte_keys, myset) for item in o]
    184         return type(o)(outs)
    185     elif typ is dict:

/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/utils_comm.py in unpack_remotedata(o, byte_keys, myset)
    176         return out, myset
    177 
--> 178     typ = type(o)
    179 
    180     if typ in collection_types:

KeyboardInterrupt: 
```",,https://api.github.com/repos/dask/dask/issues/3973/timeline,,,avnovikov,15693459,MDQ6VXNlcjE1NjkzNDU5,https://avatars.githubusercontent.com/u/15693459?v=4,,https://api.github.com/users/avnovikov,https://github.com/avnovikov,https://api.github.com/users/avnovikov/followers,https://api.github.com/users/avnovikov/following{/other_user},https://api.github.com/users/avnovikov/gists{/gist_id},https://api.github.com/users/avnovikov/starred{/owner}{/repo},https://api.github.com/users/avnovikov/subscriptions,https://api.github.com/users/avnovikov/orgs,https://api.github.com/users/avnovikov/repos,https://api.github.com/users/avnovikov/events{/privacy},https://api.github.com/users/avnovikov/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3973/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
145,https://api.github.com/repos/dask/dask/issues/3976,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3976/labels{/name},https://api.github.com/repos/dask/dask/issues/3976/comments,https://api.github.com/repos/dask/dask/issues/3976/events,https://github.com/dask/dask/issues/3976,359336553,MDU6SXNzdWUzNTkzMzY1NTM=,3976,Inconsistent behaviour when calculating sizeof GeoDataFrame and GeoSeries,[],open,False,,[],,5,2018-09-12T06:43:28Z,2018-10-22T21:09:52Z,,NONE,,"As found in discussion in 
https://github.com/dask/dask/issues/3972#issuecomment-420384065 and probably the root cause of https://github.com/dask/dask/issues/3972

```
AttributeError: 'GeometryArray' object has no attribute 'nbytes'
distributed.sizeof - WARNING - Sizeof calculation failed.  Defaulting to 1MB
Traceback (most recent call last):
  File ""/anaconda3/envs/mariquant/lib/python3.6/site-packages/distributed/sizeof.py"", line 16, in safe_sizeof
    return sizeof(obj)
  File ""/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/utils.py"", line 415, in __call__
    return meth(arg)
  File ""/anaconda3/envs/mariquant/lib/python3.6/site-packages/dask/sizeof.py"", line 63, in sizeof_pandas_series
    p = int(s.memory_usage(index=True))
  File ""/anaconda3/envs/mariquant/lib/python3.6/site-packages/pandas/core/series.py"", line 3503, in memory_usage
    v = super(Series, self).memory_usage(deep=deep)
  File ""/anaconda3/envs/mariquant/lib/python3.6/site-packages/pandas/core/base.py"", line 1143, in memory_usage
    v = self.values.nbytes
```

However GeoDataFrame size seems to be calculated correctly. Looking at the code of distributed/sizeof.py the only suspicious line is `p = int(s.memory_usage(index=True))`, however

```
type(anchorage_buffer)
Out[55]:
geopandas.geoseries.GeoSeries
In [57]:
anchorage_buffer.memory_usage(index=True)
I am densified (external_values, 20353 elements)
I am densified (external_values, 20353 elements)
Out[57]:
325648
```
Unfortunately I can't trace the origin of this error.

This issue seems to be most GeoPandas related and as such I posted a companion issue [#819](https://github.com/geopandas/geopandas/issues/819)",,https://api.github.com/repos/dask/dask/issues/3976/timeline,,,avnovikov,15693459,MDQ6VXNlcjE1NjkzNDU5,https://avatars.githubusercontent.com/u/15693459?v=4,,https://api.github.com/users/avnovikov,https://github.com/avnovikov,https://api.github.com/users/avnovikov/followers,https://api.github.com/users/avnovikov/following{/other_user},https://api.github.com/users/avnovikov/gists{/gist_id},https://api.github.com/users/avnovikov/starred{/owner}{/repo},https://api.github.com/users/avnovikov/subscriptions,https://api.github.com/users/avnovikov/orgs,https://api.github.com/users/avnovikov/repos,https://api.github.com/users/avnovikov/events{/privacy},https://api.github.com/users/avnovikov/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3976/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
146,https://api.github.com/repos/dask/dask/issues/3987,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/3987/labels{/name},https://api.github.com/repos/dask/dask/issues/3987/comments,https://api.github.com/repos/dask/dask/issues/3987/events,https://github.com/dask/dask/issues/3987,360754005,MDU6SXNzdWUzNjA3NTQwMDU=,3987,Improve the implementation of dask.array.block,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,12,2018-09-17T07:42:17Z,2018-10-22T21:21:47Z,,MEMBER,,"https://github.com/dask/dask/blob/14b4c3848516a0f03bcf1b40e3f1f7475131497c/dask/array/core.py#L2899

I recently rewrote what will likely be numpy's new implementation of `block`. @eric-wieser suggested an enhancement which should make it really trivial for dask to piggy back off the results and use it in it's implementation.

https://github.com/numpy/numpy/pull/11971#issuecomment-421910996

The first time I tried to use dask.block, it was really slow, so I had to write my own. I think this might help it since it avoid calls to concatenate all together.

Not sure about unknown dimensions.",,https://api.github.com/repos/dask/dask/issues/3987/timeline,,,hmaarrfk,90008,MDQ6VXNlcjkwMDA4,https://avatars.githubusercontent.com/u/90008?v=4,,https://api.github.com/users/hmaarrfk,https://github.com/hmaarrfk,https://api.github.com/users/hmaarrfk/followers,https://api.github.com/users/hmaarrfk/following{/other_user},https://api.github.com/users/hmaarrfk/gists{/gist_id},https://api.github.com/users/hmaarrfk/starred{/owner}{/repo},https://api.github.com/users/hmaarrfk/subscriptions,https://api.github.com/users/hmaarrfk/orgs,https://api.github.com/users/hmaarrfk/repos,https://api.github.com/users/hmaarrfk/events{/privacy},https://api.github.com/users/hmaarrfk/received_events,User,False,https://api.github.com/repos/dask/dask/issues/3987/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
147,https://api.github.com/repos/dask/dask/issues/4001,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4001/labels{/name},https://api.github.com/repos/dask/dask/issues/4001/comments,https://api.github.com/repos/dask/dask/issues/4001/events,https://github.com/dask/dask/issues/4001,362468408,MDU6SXNzdWUzNjI0Njg0MDg=,4001,groupby aggregation does not scale well with amount of groups,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,15,2018-09-21T06:13:47Z,2020-06-22T12:29:46Z,,NONE,,"It seems that there is performance bug when doing grouping. Time and memory consumed by dask does not seems to scale well with number of output rows.
Please find below script to produce example data, replace `N` to produce bigger input data.
```py
import pandas as pd
import numpy as np

def randChar(f, numGrp, N) :
   things = [f%x for x in range(numGrp)]
   return [things[x] for x in np.random.choice(numGrp, N)]

def randFloat(numGrp, N) :
   things = [round(100*np.random.random(),4) for x in range(numGrp)]
   return [things[x] for x in np.random.choice(numGrp, N)]

N = int(1e7)
K = 100
x = pd.DataFrame({
  'id1' : randChar(""id%03d"", K, N),       # large groups (char)
  'id2' : randChar(""id%03d"", K, N),       # large groups (char)
  'id3' : randChar(""id%010d"", N//K, N),   # small groups (char)
  'id4' : np.random.choice(K, N),         # large groups (int)
  'id5' : np.random.choice(K, N),         # large groups (int)
  'id6' : np.random.choice(N//K, N),      # small groups (int)
  'v1' :  np.random.choice(5, N),         # int in range [1,5]
  'v2' :  np.random.choice(5, N),         # int in range [1,5]
  'v3' :  randFloat(100,N)                # numeric e.g. 23.5749
})
x.to_csv(""example.csv"", encoding='utf-8', index=False)
```
And following code to perform grouping.
```py
import os
import gc
import timeit
import pandas as pd
import dask as dk
import dask.dataframe as dd

print(pd.__version__)
print(dk.__version__)

x = dd.read_csv(""example.csv"", na_filter=False).persist()
print(len(x))

gc.collect()
t_start = timeit.default_timer()
ans = x.groupby(['id1']).agg({'v1':'sum'}).compute()
t = timeit.default_timer() - t_start
print(len(ans))
print(t)
del ans

gc.collect()
t_start = timeit.default_timer()
ans = x.groupby(['id3']).agg({'v1':'sum', 'v3':'mean'}).compute()
t = timeit.default_timer() - t_start
print(len(ans))
print(t)
del ans
```

Running on python 3.6.5, pandas 0.23.4, dask 0.19.2.
Single machine 20 CPU, 125 GB memory.

For input 1e7 rows
output 100 rows, timing: 0.4032 s
output 1e5 rows, timing: 2.1272 s

For input 1e8 rows
output 100 rows, timing: 3.2559 s
output 1e6 rows, timing: 149.8847 s

Additionally I checked alternative approach, instead of `.compute` to use `Client` and `.persist`(adding `print(len(.))` to ensure persist has kicked in). In both cases time was not acceptable (see table below, units are seconds).

| in_rows|groups | compute()|  persist()|
|-------:|:------|---------:|----------:|
|   1e+07|fewer  |     0.395|      0.425|
|   1e+07|more   |     2.124|      2.145|
|   1e+08|fewer  |     3.239|      3.420|
|   1e+08|more   |   148.211|    148.043|
|   1e+09|fewer  |        NA|    848.911|
|   1e+09|more   |        NA|   5364.569|
",,https://api.github.com/repos/dask/dask/issues/4001/timeline,,,jangorecki,3627377,MDQ6VXNlcjM2MjczNzc=,https://avatars.githubusercontent.com/u/3627377?v=4,,https://api.github.com/users/jangorecki,https://github.com/jangorecki,https://api.github.com/users/jangorecki/followers,https://api.github.com/users/jangorecki/following{/other_user},https://api.github.com/users/jangorecki/gists{/gist_id},https://api.github.com/users/jangorecki/starred{/owner}{/repo},https://api.github.com/users/jangorecki/subscriptions,https://api.github.com/users/jangorecki/orgs,https://api.github.com/users/jangorecki/repos,https://api.github.com/users/jangorecki/events{/privacy},https://api.github.com/users/jangorecki/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4001/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
148,https://api.github.com/repos/dask/dask/issues/4040,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4040/labels{/name},https://api.github.com/repos/dask/dask/issues/4040/comments,https://api.github.com/repos/dask/dask/issues/4040/events,https://github.com/dask/dask/issues/4040,365633657,MDU6SXNzdWUzNjU2MzM2NTc=,4040,Calling multiple cupy functions in multiple CPU threads results in poor performance,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,10,2018-10-01T20:39:59Z,2022-03-22T07:05:27Z,,MEMBER,,"Given the following computation:

```python
import dask.array as da
import cupy
import dask
import numpy as np

arrays = [da.from_delayed(dask.delayed(cupy.random.random)((5000, 5000)), shape=(5000, 5000),  dtype='float32')  
          for _ in range(100)]
x = da.concatenate(arrays)
```

This is faster when run in one CPU thread instead of many

```python
da.sin(x).sum().compute(scheduler='single-threaded')  # 350ms
da.sin(x).sum().compute(scheduler='threading')  # 150ms
```

This isn't super-surprising.  We're probably over-saturating some resource on the GPU that wasn't designed for concurrency.  That being said, I'm curious what the best way to handle operations like this is.  I *do* have a few GPUs on this box, and probably each of these tasks is too small to saturate one of them.

@seibert @sklam I'd be curious to get your take on handling performance here.  Can you recommend reading that explains how I should think about concurrency on top of these things?",,https://api.github.com/repos/dask/dask/issues/4040/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4040/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
149,https://api.github.com/repos/dask/dask/issues/4148,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4148/labels{/name},https://api.github.com/repos/dask/dask/issues/4148/comments,https://api.github.com/repos/dask/dask/issues/4148/events,https://github.com/dask/dask/issues/4148,375188106,MDU6SXNzdWUzNzUxODgxMDY=,4148,Implementing Dask Array apply_blocks function,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2018-10-29T19:52:17Z,2021-07-20T18:01:04Z,,MEMBER,,"Would be nice to have a `da.apply_blocks` function that allows some stateful [UDF]( https://en.wikipedia.org/wiki/User-defined_function ) to be supplied that is assumed to not return a result. From the Dask side this could be treated as returning a `Delayed` value allowing the computation to be run as needed. This is handy for things like storing different chunks to different files (e.g. TIFFs, PNGs, CSVs, etc.) or printing something (e.g. mean of each chunk).

cc @d-v-b",,https://api.github.com/repos/dask/dask/issues/4148/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4148/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
150,https://api.github.com/repos/dask/dask/issues/4149,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4149/labels{/name},https://api.github.com/repos/dask/dask/issues/4149/comments,https://api.github.com/repos/dask/dask/issues/4149/events,https://github.com/dask/dask/issues/4149,375189819,MDU6SXNzdWUzNzUxODk4MTk=,4149,Allow UDF style array storage with store-like function,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,11,2018-10-29T19:56:31Z,2021-10-12T08:03:05Z,,MEMBER,,"It is repeatedly mentioned to us that `__setitem__` style `da.store` function doesn't work well for a majority of user cases as this means they need to open a file object and put in the graph. This then can fail for a variety of reasons like it is not safe to pickle, send across process boundaries, etc. Would be nice to have a form of `store` that takes a UDF that can handle all the file open/close logic as well as writing out the chunk.

cc @djhoese",,https://api.github.com/repos/dask/dask/issues/4149/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4149/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
151,https://api.github.com/repos/dask/dask/issues/4154,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4154/labels{/name},https://api.github.com/repos/dask/dask/issues/4154/comments,https://api.github.com/repos/dask/dask/issues/4154/events,https://github.com/dask/dask/issues/4154,375316856,MDU6SXNzdWUzNzUzMTY4NTY=,4154,feature request `da.overlapped_from_array` to avoid memory copy when overlapping an array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,8,2018-10-30T04:31:23Z,2019-04-30T16:44:54Z,,MEMBER,,"Would the a addition of a method `da.overlapped_from_array` be appropriate. 

In this method, under the applicable circumstances, an overlapped array is created from a single memory view into an existing numpy array. This would solve the `da.from_array`, `da.overlapped` issue whereby a fully new array is created when overlapping regions.

I think this kind of stuff would really help people ease into dask. It would definitely help the scikit-image community which probably has most of their code written for a single CPU.

Anyway, this isn't a bottlekneck for me now, but I just wanted to put it out there since it seems like overlapping computations is gaining more attention.

cc. @jakirkham 
",,https://api.github.com/repos/dask/dask/issues/4154/timeline,,,hmaarrfk,90008,MDQ6VXNlcjkwMDA4,https://avatars.githubusercontent.com/u/90008?v=4,,https://api.github.com/users/hmaarrfk,https://github.com/hmaarrfk,https://api.github.com/users/hmaarrfk/followers,https://api.github.com/users/hmaarrfk/following{/other_user},https://api.github.com/users/hmaarrfk/gists{/gist_id},https://api.github.com/users/hmaarrfk/starred{/owner}{/repo},https://api.github.com/users/hmaarrfk/subscriptions,https://api.github.com/users/hmaarrfk/orgs,https://api.github.com/users/hmaarrfk/repos,https://api.github.com/users/hmaarrfk/events{/privacy},https://api.github.com/users/hmaarrfk/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4154/reactions,0,0,0,0,0,0,0,0,0,hmaarrfk,90008.0,MDQ6VXNlcjkwMDA4,https://avatars.githubusercontent.com/u/90008?v=4,,https://api.github.com/users/hmaarrfk,https://github.com/hmaarrfk,https://api.github.com/users/hmaarrfk/followers,https://api.github.com/users/hmaarrfk/following{/other_user},https://api.github.com/users/hmaarrfk/gists{/gist_id},https://api.github.com/users/hmaarrfk/starred{/owner}{/repo},https://api.github.com/users/hmaarrfk/subscriptions,https://api.github.com/users/hmaarrfk/orgs,https://api.github.com/users/hmaarrfk/repos,https://api.github.com/users/hmaarrfk/events{/privacy},https://api.github.com/users/hmaarrfk/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
152,https://api.github.com/repos/dask/dask/issues/4155,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4155/labels{/name},https://api.github.com/repos/dask/dask/issues/4155/comments,https://api.github.com/repos/dask/dask/issues/4155/events,https://github.com/dask/dask/issues/4155,375331874,MDU6SXNzdWUzNzUzMzE4NzQ=,4155,Feature Request: Dataframe reindex support,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,6,2018-10-30T05:54:22Z,2020-05-19T11:00:17Z,,NONE,,"Dask dataframes are missing the ""reindex"" function.  Would be great to support it, as it's a useful primitive for time series analysis.  I think limiting the support to just sorted Int64Index or DateTimeIndex is sufficient.",,https://api.github.com/repos/dask/dask/issues/4155/timeline,,,johngu,7248239,MDQ6VXNlcjcyNDgyMzk=,https://avatars.githubusercontent.com/u/7248239?v=4,,https://api.github.com/users/johngu,https://github.com/johngu,https://api.github.com/users/johngu/followers,https://api.github.com/users/johngu/following{/other_user},https://api.github.com/users/johngu/gists{/gist_id},https://api.github.com/users/johngu/starred{/owner}{/repo},https://api.github.com/users/johngu/subscriptions,https://api.github.com/users/johngu/orgs,https://api.github.com/users/johngu/repos,https://api.github.com/users/johngu/events{/privacy},https://api.github.com/users/johngu/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4155/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
153,https://api.github.com/repos/dask/dask/issues/4156,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4156/labels{/name},https://api.github.com/repos/dask/dask/issues/4156/comments,https://api.github.com/repos/dask/dask/issues/4156/events,https://github.com/dask/dask/issues/4156,375502666,MDU6SXNzdWUzNzU1MDI2NjY=,4156,Handling Dask Arrays with vindex,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2018-10-30T13:57:17Z,2020-05-22T16:44:58Z,,MEMBER,,Currently the `vindex` function has not been updated to support Dask Arrays of integers. Though `__getitem__` has been. ( https://github.com/dask/dask/pull/3407 ) Would be good to extend this support to `vindex`.,,https://api.github.com/repos/dask/dask/issues/4156/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4156/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
154,https://api.github.com/repos/dask/dask/issues/4157,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4157/labels{/name},https://api.github.com/repos/dask/dask/issues/4157/comments,https://api.github.com/repos/dask/dask/issues/4157/events,https://github.com/dask/dask/issues/4157,375504387,MDU6SXNzdWUzNzU1MDQzODc=,4157,Slicing with multiple Dask Arrays of integers,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2018-10-30T14:00:33Z,2021-10-12T08:07:10Z,,MEMBER,,"Currently it is not supported to use multiple Dask Arrays of integers to slice an array with (as seen below). Some work was done on this front in PR ( https://github.com/dask/dask/pull/3210 ).

```python
In [1]: import dask.array as da

In [2]: a = da.random.random((10, 10), chunks=3)

In [3]: a[a.nonzero()]
---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
<ipython-input-3-45db60e0cc61> in <module>()
----> 1 a[a.nonzero()]

~/Developer/PyCharmCE/dask/dask/array/core.py in __getitem__(self, index)
   1240 
   1241         if any(isinstance(i, Array) and i.dtype.kind in 'iu' for i in index2):
-> 1242             self, index2 = slice_with_int_dask_array(self, index2)
   1243         if any(isinstance(i, Array) and i.dtype == bool for i in index2):
   1244             self, index2 = slice_with_bool_dask_array(self, index2)

~/Developer/PyCharmCE/dask/dask/array/slicing.py in slice_with_int_dask_array(x, index)
    892     ]
    893     if sum(fancy_indexes) > 1:
--> 894         raise NotImplementedError(""Don't yet support nd fancy indexing)"")
    895 
    896     out_index = []

NotImplementedError: Don't yet support nd fancy indexing)
```",,https://api.github.com/repos/dask/dask/issues/4157/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4157/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
155,https://api.github.com/repos/dask/dask/issues/4169,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4169/labels{/name},https://api.github.com/repos/dask/dask/issues/4169/comments,https://api.github.com/repos/dask/dask/issues/4169/events,https://github.com/dask/dask/issues/4169,376834611,MDU6SXNzdWUzNzY4MzQ2MTE=,4169,Better hashing strategy with NumPy arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,11,2018-11-02T14:33:42Z,2021-03-24T13:15:58Z,,MEMBER,,"It seems the current hashing strategy of hashing all NumPy array contents has bitten a few users and is generally felt as surprising. Given the number of times `da.asarray` ends up being called to ensure constraints are met, this can be quite surprising for users. Would suggest that we either change the default hashing behavior or just turn it off.

As an initial suggestion about how we can change it, would try using `id` on the NumPy array to inform its hash. This is probably unique enough for most cases and we can be pretty sure that cases where that key shows up the NumPy array still exists in our graph.

Thoughts?",,https://api.github.com/repos/dask/dask/issues/4169/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4169/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
156,https://api.github.com/repos/dask/dask/issues/4170,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4170/labels{/name},https://api.github.com/repos/dask/dask/issues/4170/comments,https://api.github.com/repos/dask/dask/issues/4170/events,https://github.com/dask/dask/issues/4170,377075262,MDU6SXNzdWUzNzcwNzUyNjI=,4170, Implement Dask equivalent of pandas.io.json.json_normalize,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,16,2018-11-03T17:24:32Z,2023-02-11T21:26:26Z,,NONE,,"pandas has a useful function to flatten json files into a DataFrame structure : https://pandas.pydata.org/pandas-docs/stable/generated/pandas.io.json.json_normalize.html

Would be nice to have this feature in Dask as well. I use Dask but am not a heavy power-user, I tried to implement this using map_partitions but got stuck in creating an appropriate meta parameter. 

It should hopefully be easy to recreate this: https://www.kaggle.com/jboysen/quick-tutorial-flatten-nested-json-in-pandas# in Dask.",,https://api.github.com/repos/dask/dask/issues/4170/timeline,,,nsadeh,15837587,MDQ6VXNlcjE1ODM3NTg3,https://avatars.githubusercontent.com/u/15837587?v=4,,https://api.github.com/users/nsadeh,https://github.com/nsadeh,https://api.github.com/users/nsadeh/followers,https://api.github.com/users/nsadeh/following{/other_user},https://api.github.com/users/nsadeh/gists{/gist_id},https://api.github.com/users/nsadeh/starred{/owner}{/repo},https://api.github.com/users/nsadeh/subscriptions,https://api.github.com/users/nsadeh/orgs,https://api.github.com/users/nsadeh/repos,https://api.github.com/users/nsadeh/events{/privacy},https://api.github.com/users/nsadeh/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4170/reactions,15,15,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
157,https://api.github.com/repos/dask/dask/issues/4173,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4173/labels{/name},https://api.github.com/repos/dask/dask/issues/4173/comments,https://api.github.com/repos/dask/dask/issues/4173/events,https://github.com/dask/dask/issues/4173,377220905,MDU6SXNzdWUzNzcyMjA5MDU=,4173,Optimizing out zero-width chunks,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,9,2018-11-05T01:35:48Z,2021-10-12T08:07:51Z,,MEMBER,,One potentially nice optimization would be to drop zero-width chunks. This would eliminate dependencies on other parts of the graph that are not used. Thinking about this mainly in the context of arrays and dataframes.,,https://api.github.com/repos/dask/dask/issues/4173/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4173/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
158,https://api.github.com/repos/dask/dask/issues/4184,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4184/labels{/name},https://api.github.com/repos/dask/dask/issues/4184/comments,https://api.github.com/repos/dask/dask/issues/4184/events,https://github.com/dask/dask/issues/4184,378461292,MDU6SXNzdWUzNzg0NjEyOTI=,4184,Add ewm pandas method to dask,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,15,2018-11-07T20:43:39Z,2021-06-04T13:19:56Z,,NONE,,"Hey guys,

would it be possible to add the [ewm](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.ewm.html) method to the dask dataframe API?

Cheers,
",,https://api.github.com/repos/dask/dask/issues/4184/timeline,,,sfrodrigues,15358467,MDQ6VXNlcjE1MzU4NDY3,https://avatars.githubusercontent.com/u/15358467?v=4,,https://api.github.com/users/sfrodrigues,https://github.com/sfrodrigues,https://api.github.com/users/sfrodrigues/followers,https://api.github.com/users/sfrodrigues/following{/other_user},https://api.github.com/users/sfrodrigues/gists{/gist_id},https://api.github.com/users/sfrodrigues/starred{/owner}{/repo},https://api.github.com/users/sfrodrigues/subscriptions,https://api.github.com/users/sfrodrigues/orgs,https://api.github.com/users/sfrodrigues/repos,https://api.github.com/users/sfrodrigues/events{/privacy},https://api.github.com/users/sfrodrigues/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4184/reactions,7,7,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
159,https://api.github.com/repos/dask/dask/issues/4226,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4226/labels{/name},https://api.github.com/repos/dask/dask/issues/4226/comments,https://api.github.com/repos/dask/dask/issues/4226/events,https://github.com/dask/dask/issues/4226,382093595,MDU6SXNzdWUzODIwOTM1OTU=,4226,error while assigning label encoded values to column in dask dataframe,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,6,2018-11-19T07:48:44Z,2021-10-12T07:58:40Z,,NONE,,"
0
down vote
favorite
I am facing error in label encoding features. To generate my case(Originally, i have imported a csv file in dask dataframe and after cleaning, it is left with 28 columns), I have created dask dataframe like below:

```
import dask
import dask.dataframe as dd
from dask_ml.preprocessing import LabelEncoder

country = np.random.choice(['US','UK','IN'],1700000)
df = pd.DataFrame({'A':country,'B':range(1700000)})
ddf = dd.from_pandas(df,npartitions=2,sort=False)
```
Then I tried to label encode categorical columns like below :

```
le = LabelEncoder()
ddf = ddf.assign(A=dd.from_dask_array(le.fit_transform(ddf['A'])))
```
which threw following error :

```
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-106-480a5e12886a> in <module>()
     10 type(le.fit_transform(ddf['A']))
     11 #ddf['A'] = dd.from_array(le.fit_transform(ddf['A']))
---> 12 ddf = ddf.assign(A=dd.from_dask_array(le.fit_transform(ddf['A'])))

/opt/conda/lib/python3.6/site-packages/dask/dataframe/core.py in assign(self, **kwargs)
   2698         # Figure out columns of the output
   2699         df2 = self._meta.assign(**_extract_meta(kwargs))
-> 2700         return elemwise(methods.assign, self, *pairs, meta=df2)
   2701 
   2702     @derived_from(pd.DataFrame, ua_args=['index'])

/opt/conda/lib/python3.6/site-packages/dask/dataframe/core.py in elemwise(op, *args, **kwargs)
   3277 
   3278     from .multi import _maybe_align_partitions
-> 3279     args = _maybe_align_partitions(args)
   3280     dasks = [arg for arg in args if isinstance(arg, (_Frame, Scalar, Array))]
   3281     dfs = [df for df in dasks if isinstance(df, _Frame)]

/opt/conda/lib/python3.6/site-packages/dask/dataframe/multi.py in _maybe_align_partitions(args)
    145     divisions = dfs[0].divisions
    146     if not all(df.divisions == divisions for df in dfs):
--> 147         dfs2 = iter(align_partitions(*dfs)[0])
    148         return [a if not isinstance(a, _Frame) else next(dfs2) for a in args]
    149     return args

/opt/conda/lib/python3.6/site-packages/dask/dataframe/multi.py in align_partitions(*dfs)
    101         raise ValueError(""dfs contains no DataFrame and Series"")
    102     if not all(df.known_divisions for df in dfs1):
--> 103         raise ValueError(""Not all divisions are known, can't align ""
    104                          ""partitions. Please use `set_index` ""
    105                          ""to set the index."")
```
",,https://api.github.com/repos/dask/dask/issues/4226/timeline,,,BParesh89,10656618,MDQ6VXNlcjEwNjU2NjE4,https://avatars.githubusercontent.com/u/10656618?v=4,,https://api.github.com/users/BParesh89,https://github.com/BParesh89,https://api.github.com/users/BParesh89/followers,https://api.github.com/users/BParesh89/following{/other_user},https://api.github.com/users/BParesh89/gists{/gist_id},https://api.github.com/users/BParesh89/starred{/owner}{/repo},https://api.github.com/users/BParesh89/subscriptions,https://api.github.com/users/BParesh89/orgs,https://api.github.com/users/BParesh89/repos,https://api.github.com/users/BParesh89/events{/privacy},https://api.github.com/users/BParesh89/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4226/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
160,https://api.github.com/repos/dask/dask/issues/4227,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4227/labels{/name},https://api.github.com/repos/dask/dask/issues/4227/comments,https://api.github.com/repos/dask/dask/issues/4227/events,https://github.com/dask/dask/issues/4227,382289063,MDU6SXNzdWUzODIyODkwNjM=,4227,How can one do lazily evaluated Series.isin,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,7,2018-11-19T16:18:02Z,2022-02-10T22:25:26Z,,NONE,,"Hi, sorry to be asking here instead of SO but I am not sure if someone is actively looking at SO since I haven't received any response yet.

I am facing an issue relative to splitting my data based on a specific column. I haven't figured out what is the proposed way of splitting your data while honouring a group based on column so I invoked `train_test_split` on the `.unique()` of a column and then I want to use the results to filter my original dataframe using `Series.isin`. the problem is that is in doesn't work on lazily results. This mean that in order to compute the input to isin the whole graph that I haven't computed so far will need to be calculated. I am wondering am I understanding this correctly? does that mean that at this point my pipeline will need to execute the whole graph to get to the unique list and then in the end of my pipeline where I export data to disk the whole graph will be computed again? Does dask have a way to no repeat the computations that overlap with the computations needed for the unique?

Again sorry for posting here, any help is very appreciated :) ",,https://api.github.com/repos/dask/dask/issues/4227/timeline,,,PGryllos,2640804,MDQ6VXNlcjI2NDA4MDQ=,https://avatars.githubusercontent.com/u/2640804?v=4,,https://api.github.com/users/PGryllos,https://github.com/PGryllos,https://api.github.com/users/PGryllos/followers,https://api.github.com/users/PGryllos/following{/other_user},https://api.github.com/users/PGryllos/gists{/gist_id},https://api.github.com/users/PGryllos/starred{/owner}{/repo},https://api.github.com/users/PGryllos/subscriptions,https://api.github.com/users/PGryllos/orgs,https://api.github.com/users/PGryllos/repos,https://api.github.com/users/PGryllos/events{/privacy},https://api.github.com/users/PGryllos/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4227/reactions,0,0,0,0,0,0,0,0,0,PGryllos,2640804.0,MDQ6VXNlcjI2NDA4MDQ=,https://avatars.githubusercontent.com/u/2640804?v=4,,https://api.github.com/users/PGryllos,https://github.com/PGryllos,https://api.github.com/users/PGryllos/followers,https://api.github.com/users/PGryllos/following{/other_user},https://api.github.com/users/PGryllos/gists{/gist_id},https://api.github.com/users/PGryllos/starred{/owner}{/repo},https://api.github.com/users/PGryllos/subscriptions,https://api.github.com/users/PGryllos/orgs,https://api.github.com/users/PGryllos/repos,https://api.github.com/users/PGryllos/events{/privacy},https://api.github.com/users/PGryllos/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
161,https://api.github.com/repos/dask/dask/issues/4252,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4252/labels{/name},https://api.github.com/repos/dask/dask/issues/4252/comments,https://api.github.com/repos/dask/dask/issues/4252/events,https://github.com/dask/dask/issues/4252,384953353,MDU6SXNzdWUzODQ5NTMzNTM=,4252,Simplifying da.map_overlap's boundary padding,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2018-11-27T19:36:31Z,2019-06-21T07:51:44Z,,MEMBER,,"Currently `da.map_overlap` supports edge paddings of different kinds along different dimensions. This complicates things like [using `da.pad` within `da.map_overlap`]( https://github.com/dask/dask/issues/3641 ).

AFAIK there are no use cases for different edge paddings on different dimensions. The closest thing that I know of is to pad some dimensions and not others (i.e. having different depths per dimension), which can still be cast in terms of having the same padding for all dimensions (just some are trivial). Given this, I'd like to propose deprecating [`boundary` arguments]( http://docs.dask.org/en/latest/array-overlap.html#dask.array.map_overlap ) that are anything other than simple values (e.g. padding mode or constant for all dimensions).",,https://api.github.com/repos/dask/dask/issues/4252/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4252/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
162,https://api.github.com/repos/dask/dask/issues/4253,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4253/labels{/name},https://api.github.com/repos/dask/dask/issues/4253/comments,https://api.github.com/repos/dask/dask/issues/4253/events,https://github.com/dask/dask/issues/4253,384958335,MDU6SXNzdWUzODQ5NTgzMzU=,4253,Helm dask notes seem to have a typo in setting the environment variable,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,16,2018-11-27T19:50:08Z,2021-10-12T07:50:12Z,,NONE,,"I followed the guide at: http://docs.dask.org/en/latest/setup/kubernetes-helm.html

Running `helm install stable/dask` instructs me to run:
![image](https://user-images.githubusercontent.com/674200/49107365-cf762a00-f285-11e8-9924-d7b003af308b.png)

to set the right env variables. Note that the variable is called `DASK_SCHEDULER` while dask seems to look for `DASK_SCHEDULER_ADDRESS`, so 
![image](https://user-images.githubusercontent.com/674200/49107414-f3d20680-f285-11e8-944f-234b80b7b652.png)
was not working for me unless I fixed that.
",,https://api.github.com/repos/dask/dask/issues/4253/timeline,,,twiecki,674200,MDQ6VXNlcjY3NDIwMA==,https://avatars.githubusercontent.com/u/674200?v=4,,https://api.github.com/users/twiecki,https://github.com/twiecki,https://api.github.com/users/twiecki/followers,https://api.github.com/users/twiecki/following{/other_user},https://api.github.com/users/twiecki/gists{/gist_id},https://api.github.com/users/twiecki/starred{/owner}{/repo},https://api.github.com/users/twiecki/subscriptions,https://api.github.com/users/twiecki/orgs,https://api.github.com/users/twiecki/repos,https://api.github.com/users/twiecki/events{/privacy},https://api.github.com/users/twiecki/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4253/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
163,https://api.github.com/repos/dask/dask/issues/4275,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4275/labels{/name},https://api.github.com/repos/dask/dask/issues/4275/comments,https://api.github.com/repos/dask/dask/issues/4275/events,https://github.com/dask/dask/issues/4275,388380730,MDU6SXNzdWUzODgzODA3MzA=,4275,Better educate users when hashing/tokenizing large numpy arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,7,2018-12-06T20:16:38Z,2021-10-19T01:51:19Z,,NONE,,"At the monthly community meeting we discussed that new users of dask may be surprised by slowdowns when passing large arrays to numpy without name=False. 

This has been discussed previously at #4169 where solving the issue via configuration was proposed, and there seemed to be some consensus at the meeting that this was viable. Discussion about how to implement that should probably take place on that issue.

However, configuration options are no good if users do not know about them, and at present there is not much indication to a naive user passing large numpy arrays that they're working against the grain, other than a slowdown in code, which can be substantial (as shown by the benchmark below). 

Although adding warnings to the introductory docs was rejected (as this issue only affects a particular subset of users), we agreed that a dynamic warning message that pointed users to relevant documentation (possibly dask.array best practices?) when input arrays were expected to take a long time to hash would be very useful. 

If dask/distributed#2400 is implemented, then this warning could also be shown there. 

The benchmark below shows a pathological use-case which I personally encountered as a result of a bodge to force pandas to store images or image-stacks inside dataframe columns. It would be nice if the dynamic check were robust to such cases, but even a simple check that the number of elements in the input array does not exceed a threshold would be better than the current situation. 

```python
import numpy as np
import dask.array as da
from dask.distributed import Client

client = Client()

# normal use-case, shows some slowdown
def create_test_for_3d_array(x, y, z):
    arr = np.random.rand(x, y, z)
    def with_hashing():
        arr_da = da.from_array(arr, chunks=(x // 100, -1, -1))
    def without_hashing():
        arr_da = da.from_array(arr, chunks=(x // 100, -1, -1), name=False)
    return (with_hashing, without_hashing)

# my unusual use-case, pathological
def create_test_for_nested_object_array(x, y, z):
    # pre-allocate object array 
    arr = np.full(x, None)
    # assign using broadcasting and list to force a 1d object array of 2d arrays
    arr[:] = list(np.random.rand(x, y, z))
    def with_hashing():
        arr_da = da.from_array(arr, chunks=(x // 100,))
    def without_hashing():
        arr_da = da.from_array(arr, chunks=(x // 100,), name=False)
    return (with_hashing, without_hashing)

(with_hashing_3d, without_hashing_3d) = create_test_for_3d_array(100000, 28, 28)
# smaller size for obj because otherwise the code does not complete in reasonable time
(with_hashing_obj, without_hashing_obj) = create_test_for_nested_object_array(10000, 5, 5)

# in the ipython repl
# for 100_000, 28, 28
%timeit with_hashing_3d()
# 552 ms  946 s per loop (mean  std. dev. of 7 runs, 1 loop each)
%timeit without_hashing_3d()
# 269 s  1.06 s per loop (mean  std. dev. of 7 runs, 1000 loops each)

# for 10_000, 5, 5
%timeit with_hashing_obj()
# 2.05 s  11.5 ms per loop (mean  std. dev. of 7 runs, 1 loop each)
%timeit without_hashing_obj()
# 207 s  524 ns per loop (mean  std. dev. of 7 runs, 1000 loops each)
```

",,https://api.github.com/repos/dask/dask/issues/4275/timeline,,,qwitwa,2302478,MDQ6VXNlcjIzMDI0Nzg=,https://avatars.githubusercontent.com/u/2302478?v=4,,https://api.github.com/users/qwitwa,https://github.com/qwitwa,https://api.github.com/users/qwitwa/followers,https://api.github.com/users/qwitwa/following{/other_user},https://api.github.com/users/qwitwa/gists{/gist_id},https://api.github.com/users/qwitwa/starred{/owner}{/repo},https://api.github.com/users/qwitwa/subscriptions,https://api.github.com/users/qwitwa/orgs,https://api.github.com/users/qwitwa/repos,https://api.github.com/users/qwitwa/events{/privacy},https://api.github.com/users/qwitwa/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4275/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
164,https://api.github.com/repos/dask/dask/issues/4310,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4310/labels{/name},https://api.github.com/repos/dask/dask/issues/4310/comments,https://api.github.com/repos/dask/dask/issues/4310/events,https://github.com/dask/dask/issues/4310,391960799,MDU6SXNzdWUzOTE5NjA3OTk=,4310,Intermediate tasks computed before needed,"[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}]",open,False,,[],,2,2018-12-18T01:39:02Z,2021-10-12T07:40:30Z,,MEMBER,,"Borrowed from https://github.com/dask/dask/pull/3588#issuecomment-400400569

Basically Dask appears to load all of the intermediate chunks in memory well before they are used. In some workloads this can exhaust the available memory and crash the workers. Would be good to adjust the task priority to take this into account.

![Dynamic Dask Task Graph]( https://user-images.githubusercontent.com/1312546/41929408-86414b60-793d-11e8-85f9-11404114145f.gif )",,https://api.github.com/repos/dask/dask/issues/4310/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4310/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
165,https://api.github.com/repos/dask/dask/issues/4344,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4344/labels{/name},https://api.github.com/repos/dask/dask/issues/4344/comments,https://api.github.com/repos/dask/dask/issues/4344/events,https://github.com/dask/dask/issues/4344,394975257,MDU6SXNzdWUzOTQ5NzUyNTc=,4344,Dask slow in simple benchmark,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2018-12-31T12:42:39Z,2021-10-12T07:38:46Z,,NONE,,"So this is in the category ""I'm not sure I should open a bug"", as it might be me being new to dask and not understanding why this operation is slow.

See https://gist.github.com/andaag/207fcdc6965b86b7085406221279e4c2

## With pandas:
```
df3['test2'] = df3['salary'].apply(f)
```
Runtime 22 seconds.

## With dask:
```
%%time
dfn['test'] = dfn['salary'].apply(f, meta=('x', 'f8'))
dfn.compute()
```
Runtime 36 seconds - ok, it's a fairly small sample, but that seems like huge overhead for the extra threads we're adding... Lets try with a custom parallel function that tears the array apart, runs parallel tasks then puts it back together again to rule that out.

## With custom parallel function:
```
%%time
df3['test'] = parallel(df3['salary'], f, n_jobs=n_jobs)
```
Runtime 4.7 seconds. What's going on here?


If dask is slow in this case due to the overhead of parallelization my custom function should not be faster.

This experiment is run inside of https://hub.docker.com/r/andaag/aibox_cuda9, which is built from https://github.com/andaag/aibox. (Which is huge due to deep learning libraries and cuda.. sorry)",,https://api.github.com/repos/dask/dask/issues/4344/timeline,,,andaag,826023,MDQ6VXNlcjgyNjAyMw==,https://avatars.githubusercontent.com/u/826023?v=4,,https://api.github.com/users/andaag,https://github.com/andaag,https://api.github.com/users/andaag/followers,https://api.github.com/users/andaag/following{/other_user},https://api.github.com/users/andaag/gists{/gist_id},https://api.github.com/users/andaag/starred{/owner}{/repo},https://api.github.com/users/andaag/subscriptions,https://api.github.com/users/andaag/orgs,https://api.github.com/users/andaag/repos,https://api.github.com/users/andaag/events{/privacy},https://api.github.com/users/andaag/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4344/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
166,https://api.github.com/repos/dask/dask/issues/4349,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4349/labels{/name},https://api.github.com/repos/dask/dask/issues/4349/comments,https://api.github.com/repos/dask/dask/issues/4349/events,https://github.com/dask/dask/issues/4349,395414160,MDU6SXNzdWUzOTU0MTQxNjA=,4349,TypeError with `store` and distributed scheduler,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,2,2019-01-02T23:28:26Z,2021-10-12T07:37:55Z,,CONTRIBUTOR,,"Here is a stack trace:

```
Traceback (most recent call last):
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/distributed/protocol/pickle.py"", line 38, in dumps
    result = pickle.dumps(x, protocol=pickle.HIGHEST_PROTOCOL)
TypeError: can't pickle _thread.lock objects

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/pdb.py"", line 1667, in main
    pdb._runscript(mainpyfile)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/pdb.py"", line 1548, in _runscript
    self.run(statement)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/bdb.py"", line 434, in run
    exec(cmd, globals, locals)
  File ""<string>"", line 1, in <module>
  File ""/global/project/projectdirs/m3127/lightcones/hod/SAM_GP18.py"", line 114, in <module>
    main()
  File ""/global/project/projectdirs/m3127/lightcones/hod/SAM_GP18.py"", line 108, in main
    [column], dataset='ELG-SAM_GP18', header=None)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/nbodykit/base/catalog.py"", line 640, in save
    array.store(_ColumnWrapper(bb), regions=(slice(offset, offset + len(array)),))
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/dask/array/core.py"", line 1131, in store
    r = store([self], [target], **kwargs)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/dask/array/core.py"", line 866, in store
    result.compute(**kwargs)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/dask/base.py"", line 156, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/dask/base.py"", line 397, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/distributed/client.py"", line 2306, in get
    actors=actors,
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/distributed/client.py"", line 2249, in _graph_to_futures
    'tasks': valmap(dumps_task, dsk3),
  File ""cytoolz/dicttoolz.pyx"", line 165, in cytoolz.dicttoolz.valmap
  File ""cytoolz/dicttoolz.pyx"", line 190, in cytoolz.dicttoolz.valmap
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/distributed/worker.py"", line 2765, in dumps_task
    'args': warn_dumps(task[1:])}
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/distributed/worker.py"", line 2774, in warn_dumps
    b = dumps(obj)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/distributed/protocol/pickle.py"", line 51, in dumps
    return cloudpickle.dumps(x, protocol=pickle.HIGHEST_PROTOCOL)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/cloudpickle/cloudpickle.py"", line 931, in dumps
    cp.dump(obj)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/site-packages/cloudpickle/cloudpickle.py"", line 284, in dump
    return Pickler.dump(self, obj)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/pickle.py"", line 409, in dump
    self.save(obj)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/pickle.py"", line 476, in save
    f(self, obj) # Call unbound method with explicit self
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/pickle.py"", line 751, in save_tuple
    save(element)
  File ""/global/homes/y/yfeng1/.conda/envs/bccp/lib/python3.6/pickle.py"", line 496, in save
    rv = reduce(self.proto)
TypeError: can't pickle _thread.lock objects
```

The full line that triggered this error was:

```
              with ff.create(dataset, dtype, size, Nfile) as bb:

                    # ensure only the first dimension is chunked
                    # because bigfile only support writing with slices in first dimension.
                    rechunk = dict([(ind, -1) for ind in range(1, array.ndim)])
                    array = array.rechunk(rechunk)

                    # lock=False to avoid dask from pickling the lock with the object.
                    array.store(_ColumnWrapper(bb), regions=(slice(offset, offset + len(array)),))
```

If I add `lock=False` to the argument there is no longer such error. Some digging in the stack frames I realized with the default value of lock=True, a `_thread.lock` object is created for the target object to ensure no two workers attempt to write at the same time.

This form of locking is dubious in a cluster environment. Even if implemented correctly (e.g. a lock via the scheduler), the very wide lock also means the entire IO operation will be serialized, and severely limit the IO throughput. These caveats are not stated in the documentation of dask.Array.store.

Furthermore, when locking is disabled, it is difficult to find a storage backend that correctly implements non-overlapping concurrent write operations of arbitrary striding. Even if one exists, it can hardly be efficient. It is much easier to find some that works properly for a contiguous striding (as simple as POSIX files). It may be beneficial to have a way to inform some guarantee on the kind of strides the `store` function triggers on the target object. In the example above, I used rechunk to rechunk the array; but currently there is no guarantee store will not decide to write the array in sequence of `[:, 0]`, `[:, 1]`, ...
",,https://api.github.com/repos/dask/dask/issues/4349/timeline,,,rainwoodman,138060,MDQ6VXNlcjEzODA2MA==,https://avatars.githubusercontent.com/u/138060?v=4,,https://api.github.com/users/rainwoodman,https://github.com/rainwoodman,https://api.github.com/users/rainwoodman/followers,https://api.github.com/users/rainwoodman/following{/other_user},https://api.github.com/users/rainwoodman/gists{/gist_id},https://api.github.com/users/rainwoodman/starred{/owner}{/repo},https://api.github.com/users/rainwoodman/subscriptions,https://api.github.com/users/rainwoodman/orgs,https://api.github.com/users/rainwoodman/repos,https://api.github.com/users/rainwoodman/events{/privacy},https://api.github.com/users/rainwoodman/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4349/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
167,https://api.github.com/repos/dask/dask/issues/4360,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4360/labels{/name},https://api.github.com/repos/dask/dask/issues/4360/comments,https://api.github.com/repos/dask/dask/issues/4360/events,https://github.com/dask/dask/issues/4360,397241599,MDU6SXNzdWUzOTcyNDE1OTk=,4360,RecursionError when adding many computed columns to a DataFrame,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2019-01-09T07:18:45Z,2021-10-12T07:37:30Z,,NONE,,"Dask version: 1.0.0

The following code creates a DataFrame and then adds many computed columns to it

```
import dask.dataframe as dd
import pandas as pd
import random
import itertools
import string
import dask.dataframe as dd
random.seed(10)

bigrams = [''.join(b) for b in itertools.combinations_with_replacement(string.ascii_letters, 2)]
data = dd.from_pandas(
    pd.DataFrame(
        {
            'word': [''.join(random.choices(string.ascii_letters,k=4)) for _ in range(100)]
        }
    ), 
    npartitions=8
    )
for bigram in bigrams:
    col_name = f'has_bigram_{bigram}'
    data[col_name] = data['word'].apply(lambda w: bigram in w, meta=(col_name, bool))

data.compute()
```

When it's the time to compute the results, a RecursionError is raised.

I found two ways to work around this issue. The first one is to reduce the number of added columns. On my machine, if I keep the # of added columns below ~600, I don't see this error. Obviously, this isn't a good way to deal with the problem.

The second option is to `persist` the data once in a while:

```
count = 0
K = 500
for bigram in tqdm.tqdm_notebook(bigrams):
    col_name = f'has_bigram_{bigram}'
    data[col_name] = data['word'].apply(lambda w: bigram in w, meta=(col_name, bool))
    count += 1
    if count > K:
        data = data.persist()
        count = 0
if count:
    data.persist()
```


",,https://api.github.com/repos/dask/dask/issues/4360/timeline,,,bgbg,506547,MDQ6VXNlcjUwNjU0Nw==,https://avatars.githubusercontent.com/u/506547?v=4,,https://api.github.com/users/bgbg,https://github.com/bgbg,https://api.github.com/users/bgbg/followers,https://api.github.com/users/bgbg/following{/other_user},https://api.github.com/users/bgbg/gists{/gist_id},https://api.github.com/users/bgbg/starred{/owner}{/repo},https://api.github.com/users/bgbg/subscriptions,https://api.github.com/users/bgbg/orgs,https://api.github.com/users/bgbg/repos,https://api.github.com/users/bgbg/events{/privacy},https://api.github.com/users/bgbg/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4360/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
168,https://api.github.com/repos/dask/dask/issues/4368,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4368/labels{/name},https://api.github.com/repos/dask/dask/issues/4368/comments,https://api.github.com/repos/dask/dask/issues/4368/events,https://github.com/dask/dask/issues/4368,397835425,MDU6SXNzdWUzOTc4MzU0MjU=,4368,Sort dask array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,9,2019-01-10T13:41:00Z,2019-06-24T15:02:34Z,,CONTRIBUTOR,,"Unless I missed it, there is no way to sort or argsort dask arrays, is it a current work in progress ?
",,https://api.github.com/repos/dask/dask/issues/4368/timeline,,,Pierre-Bartet,24455641,MDQ6VXNlcjI0NDU1NjQx,https://avatars.githubusercontent.com/u/24455641?v=4,,https://api.github.com/users/Pierre-Bartet,https://github.com/Pierre-Bartet,https://api.github.com/users/Pierre-Bartet/followers,https://api.github.com/users/Pierre-Bartet/following{/other_user},https://api.github.com/users/Pierre-Bartet/gists{/gist_id},https://api.github.com/users/Pierre-Bartet/starred{/owner}{/repo},https://api.github.com/users/Pierre-Bartet/subscriptions,https://api.github.com/users/Pierre-Bartet/orgs,https://api.github.com/users/Pierre-Bartet/repos,https://api.github.com/users/Pierre-Bartet/events{/privacy},https://api.github.com/users/Pierre-Bartet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4368/reactions,11,11,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
169,https://api.github.com/repos/dask/dask/issues/4386,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4386/labels{/name},https://api.github.com/repos/dask/dask/issues/4386/comments,https://api.github.com/repos/dask/dask/issues/4386/events,https://github.com/dask/dask/issues/4386,399212646,MDU6SXNzdWUzOTkyMTI2NDY=,4386,Issue when pass filtered dask DataFrame to sklearn.metrics mean_absolute_error,[],open,False,,[],,5,2019-01-15T07:02:33Z,2019-01-18T17:06:11Z,,NONE,,"issue when pass filtered dask DataFrame to sklearn.metrccs
when use delayed, the result is not correct
see the following minimal example 
```
import dask
import sklearn
print(dask.__version__) # 1.0.0
print(sklearn.__version__) # 0.20.2
from sklearn.metrics import mean_absolute_error
import pandas as pd
import dask.dataframe as dd
s1 = pd.DataFrame({""y1"": [1,2,3,4,5,6,7,8,9,10]})
s2 = pd.DataFrame({""y2"": [4,5,6,7,8,9,10,11,12,13]})
s3 = pd.DataFrame({""y3"": [0,0,0,1,1,0,0,1,1,1]})
d1 = dd.from_pandas(s1, npartitions=3)
d2 = dd.from_pandas(s2, npartitions=2)
d3 = dd.from_pandas(s3, npartitions=5)
from dask import delayed
d=d1.merge(d2,how='inner',left_index=True,right_index=True).merge(d3,how='inner',left_index=True,right_index=True)
p=d[d['y3']==1]
task=delayed(mean_absolute_error)(p['y1'],p['y2'])
print(task.compute()) # return 0.0 which is wrong
print(mean_absolute_error(p['y1'],p['y2'])) # return 3.0
```",,https://api.github.com/repos/dask/dask/issues/4386/timeline,,,quickpanda,9373761,MDQ6VXNlcjkzNzM3NjE=,https://avatars.githubusercontent.com/u/9373761?v=4,,https://api.github.com/users/quickpanda,https://github.com/quickpanda,https://api.github.com/users/quickpanda/followers,https://api.github.com/users/quickpanda/following{/other_user},https://api.github.com/users/quickpanda/gists{/gist_id},https://api.github.com/users/quickpanda/starred{/owner}{/repo},https://api.github.com/users/quickpanda/subscriptions,https://api.github.com/users/quickpanda/orgs,https://api.github.com/users/quickpanda/repos,https://api.github.com/users/quickpanda/events{/privacy},https://api.github.com/users/quickpanda/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4386/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
170,https://api.github.com/repos/dask/dask/issues/4389,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4389/labels{/name},https://api.github.com/repos/dask/dask/issues/4389/comments,https://api.github.com/repos/dask/dask/issues/4389/events,https://github.com/dask/dask/issues/4389,399546289,MDU6SXNzdWUzOTk1NDYyODk=,4389,Possible way of allow array repeat argument in da.repeat(),"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798450416, 'node_id': 'LA_kwDOAbcwm87iZ8Dw', 'url': 'https://api.github.com/repos/dask/dask/labels/p2', 'name': 'p2', 'color': 'ffc133', 'default': False, 'description': ""Affects more than a few users but doesn't prevent core functions""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,2,2019-01-15T21:36:45Z,2022-08-12T16:55:06Z,,CONTRIBUTOR,,"Currently da.repeat only appear to allow scalar inputs as its repeats argument:

```
arr = da.random.uniform(size=(100, 3), chunks=(10, 3))
repeats = da.arange(len(arr), chunks=10)
da.repeat(arr, repeats, axis=0)

NotImplementedError: .....
```
There are two ways of doing this. One is to extend the current concatenate based method to allow for arbitrary repeat values. The basic idea would be first match the chunk size of the repeat array to the source array along the repeating axis, then compute the size of each block by traversing the repeat array, and build the graph that does the actual repeat.

Another is to use the map_block function. Here is a potential implementation. I think it essentially builds the same graph as above, but I do worry using the chunks argument of map_blocks in this manner is a bit fragile. 

```
def repeat_sizes(repeats):
    return tuple(
        da.map_blocks(lambda x: x.sum(dtype='i8').reshape(1),
                      repeats,
                             chunks=(1,),
                             dtype='i8').compute())

def repeat(a, repeats, axis=0, sizes=None):
    repeats = da.broadcast_to(repeats, (a.shape[axis], ), chunks=a.chunks[axis])
    repeats = repeats.rechunk(a.chunks[axis])
    if sizes is None:
        sizes = repeat_sizes(repeats)
    
    chunks = list(a.chunks)
    chunks[axis] = sizes
    
    chunks = tuple(chunks)
    
    def rep(x, r):
        r = r.reshape(-1)
        s = numpy.repeat(x, r.reshape(-1), axis=axis)
        #print(x.shape, r, s.shape)
        #print(x.shape, r, s.shape)
        return s
    one = [1] * len(a.shape)
    one[axis] = -1
    repeats = repeats.reshape(one)
    #print(chunks, repeats.shape, repeats.chunks)
    r = da.map_blocks(rep, 
                      a, repeats, chunks=chunks,
                      dtype=a.dtype)
    #print(r.chunks)
    assert r.shape[axis] == numpy.sum(sizes)
    return r


```

If this looks like the right path right I will massage this into a proper PR. I however thought concatenate based method may be more suitable, though coding at that level seems to be out of my reach.

",,https://api.github.com/repos/dask/dask/issues/4389/timeline,,,rainwoodman,138060,MDQ6VXNlcjEzODA2MA==,https://avatars.githubusercontent.com/u/138060?v=4,,https://api.github.com/users/rainwoodman,https://github.com/rainwoodman,https://api.github.com/users/rainwoodman/followers,https://api.github.com/users/rainwoodman/following{/other_user},https://api.github.com/users/rainwoodman/gists{/gist_id},https://api.github.com/users/rainwoodman/starred{/owner}{/repo},https://api.github.com/users/rainwoodman/subscriptions,https://api.github.com/users/rainwoodman/orgs,https://api.github.com/users/rainwoodman/repos,https://api.github.com/users/rainwoodman/events{/privacy},https://api.github.com/users/rainwoodman/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4389/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
171,https://api.github.com/repos/dask/dask/issues/4449,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4449/labels{/name},https://api.github.com/repos/dask/dask/issues/4449/comments,https://api.github.com/repos/dask/dask/issues/4449/events,https://github.com/dask/dask/issues/4449,405750722,MDU6SXNzdWU0MDU3NTA3MjI=,4449,Sizeof fails on GeoDataFrame when passing kwarg to map_partitions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,9,2019-02-01T15:32:02Z,2019-04-30T15:11:09Z,,NONE,,"Almost definitely related to #3972 and #3976, but I'm not too sure since the technical details there are above me.

I found this bug when passing a GeoDataFrame as a keyword argument to `dataframe.map_partitions`. Interestingly enough, this only happened **after I updated to Dask 1.1 from Dask 0.17**. I suspect this is related to the changes in https://github.com/dask/dask/pull/3998

Weirdly enough, Dask seems to manage Dataframes containing shapely objects just fine, but once a GeoDataFrame is passed, Dask is unable to determine its `sizeof` and fails.

Here's a reproducible example with two cases:
- Case 1: Make a Pandas DF with a Shapely geometry column, convert to Dask DF and pass to **map_partitions** to buffer geometries. Specify `geometry` as `str` in the meta.
- Case 2: Same, but use **map_partitions** with a different function that takes a polygon GeoDataFrame and keeps only the point inside the polygon.

```python
df = pd.DataFrame({
    'id': [0, 1],
    'geometry': [Point(0,0), Point(2,2)]
})
ddf = dd.from_pandas(df, npartitions=2).copy()

# CASE 1
## This works fine
def buffer_points(d):
    gdf = gpd.GeoDataFrame(d)
    gdf['geometry'] = gdf.buffer(0.1)
    return gdf

ddf.map_partitions(
    buffer_points,
    meta=[('id', str), ('geometry', str)]
).compute()

# CASE 2
def intersect_points(d, other_gdf):
    gdf = gpd.GeoDataFrame(d)
    sjoin = gpd.sjoin(gdf, other_gdf, op='within')
    sjoin.rename(index=str, columns={'id_left': 'id'}, inplace=True)
    
    return sjoin[['id', 'geometry']]

p1_buffered = gpd.GeoDataFrame({
    'id': [0],
    'geometry': [Point(0,0).buffer(0.1)]
})

# Only Pandas works fine
print(intersect_points(df, p1_buffered))

# Using Dask fails
ddf.map_partitions(
    intersect_points,
    other_gdf=p1_buffered,
    meta=[('id', str), ('geometry', str)]
)

# Error is `ValueError: 'values' must be a NumPy array.`
```

This issue is easy to work around (just pass a Pandas' (not GeoPandas') DF as kwarg and convert to GeoPandas inside the **map_partitions** function), but it may help to solve #3972 and #3976 or other users.

The full stack trace is:

<details>

```
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-79-a27b715cad40> in <module>
      2     intersect_points,
      3     other_gdf=p1_buffered,
----> 4     meta=[('id', str), ('geometry', str)]
      5 )

/usr/local/lib/python3.6/site-packages/dask/dataframe/core.py in map_partitions(self, func, *args, **kwargs)
    558         >>> ddf.map_partitions(func).clear_divisions()  # doctest: +SKIP
    559         """"""
--> 560         return map_partitions(func, self, *args, **kwargs)
    561 
    562     @insert_meta_param_description(pad=12)

/usr/local/lib/python3.6/site-packages/dask/dataframe/core.py in map_partitions(func, *args, **kwargs)
   3705 
   3706     # Normalize keyword arguments
-> 3707     kwargs2 = {k: normalize_arg(v) for k, v in kwargs.items()}
   3708 
   3709     assert callable(func)

/usr/local/lib/python3.6/site-packages/dask/dataframe/core.py in <dictcomp>(.0)
   3705 
   3706     # Normalize keyword arguments
-> 3707     kwargs2 = {k: normalize_arg(v) for k, v in kwargs.items()}
   3708 
   3709     assert callable(func)

/usr/local/lib/python3.6/site-packages/dask/array/core.py in normalize_arg(x)
    301     elif isinstance(x, str) and re.match(r'_\d+', x):
    302         return delayed(x)
--> 303     elif sizeof(x) > 1e6:
    304         return delayed(x)
    305     else:

/usr/local/lib/python3.6/site-packages/dask/utils.py in __call__(self, arg, *args, **kwargs)
    411         """"""
    412         meth = self.dispatch(type(arg))
--> 413         return meth(arg, *args, **kwargs)
    414 
    415     @property

/usr/local/lib/python3.6/site-packages/dask/sizeof.py in sizeof_default(o)
     18 @sizeof.register(object)
     19 def sizeof_default(o):
---> 20     return getsizeof(o)
     21 
     22 

/usr/local/lib/python3.6/site-packages/pandas/core/base.py in __sizeof__(self)
    115         """"""
    116         if hasattr(self, 'memory_usage'):
--> 117             mem = self.memory_usage(deep=True)
    118             if not is_scalar(mem):
    119                 mem = mem.sum()

/usr/local/lib/python3.6/site-packages/pandas/core/frame.py in memory_usage(self, index, deep)
   2584         """"""
   2585         result = Series([c.memory_usage(index=False, deep=deep)
-> 2586                          for col, c in self.iteritems()], index=self.columns)
   2587         if index:
   2588             result = Series(self.index.memory_usage(deep=deep),

/usr/local/lib/python3.6/site-packages/pandas/core/frame.py in <listcomp>(.0)
   2584         """"""
   2585         result = Series([c.memory_usage(index=False, deep=deep)
-> 2586                          for col, c in self.iteritems()], index=self.columns)
   2587         if index:
   2588             result = Series(self.index.memory_usage(deep=deep),

/usr/local/lib/python3.6/site-packages/pandas/core/series.py in memory_usage(self, index, deep)
   3911         212
   3912         """"""
-> 3913         v = super(Series, self).memory_usage(deep=deep)
   3914         if index:
   3915             v += self.index.memory_usage(deep=deep)

/usr/local/lib/python3.6/site-packages/pandas/core/base.py in memory_usage(self, deep)
   1408         v = self.array.nbytes
   1409         if deep and is_object_dtype(self) and not PYPY:
-> 1410             v += lib.memory_usage_of_objects(self.array)
   1411         return v
   1412 

pandas/_libs/lib.pyx in pandas._libs.lib.memory_usage_of_objects()

/usr/local/lib/python3.6/site-packages/pandas/core/arrays/numpy_.py in __getitem__(self, item)
    224         result = self._ndarray[item]
    225         if not lib.is_scalar(result):
--> 226             result = type(self)(result)
    227         return result
    228 

/usr/local/lib/python3.6/site-packages/pandas/core/arrays/numpy_.py in __init__(self, values, copy)
    129             values = values._ndarray
    130         if not isinstance(values, np.ndarray):
--> 131             raise ValueError(""'values' must be a NumPy array."")
    132 
    133         if values.ndim != 1:

ValueError: 'values' must be a NumPy array.
```",,https://api.github.com/repos/dask/dask/issues/4449/timeline,,,arredond,19406854,MDQ6VXNlcjE5NDA2ODU0,https://avatars.githubusercontent.com/u/19406854?v=4,,https://api.github.com/users/arredond,https://github.com/arredond,https://api.github.com/users/arredond/followers,https://api.github.com/users/arredond/following{/other_user},https://api.github.com/users/arredond/gists{/gist_id},https://api.github.com/users/arredond/starred{/owner}{/repo},https://api.github.com/users/arredond/subscriptions,https://api.github.com/users/arredond/orgs,https://api.github.com/users/arredond/repos,https://api.github.com/users/arredond/events{/privacy},https://api.github.com/users/arredond/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4449/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
172,https://api.github.com/repos/dask/dask/issues/4457,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4457/labels{/name},https://api.github.com/repos/dask/dask/issues/4457/comments,https://api.github.com/repos/dask/dask/issues/4457/events,https://github.com/dask/dask/issues/4457,406105408,MDU6SXNzdWU0MDYxMDU0MDg=,4457,Reshuffling large amount of parquet files blows up worker memory,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,6,2019-02-03T16:33:24Z,2019-04-30T15:09:39Z,,NONE,,"I have a large dataset split up to around 400k different parquet files.
I want to reshuffle to group data by a specific column.

Lets say schema is (all columns are text):
username, first name, last name, location

And files are grouped by last name (i have a file with data for each last name) - file size ranges between 5K and 5M.

Now I need to group files by location (do bulk operations on each location)
Since the entire dataset doesn't fit in the shared memory of all my machines in the cluster (I have about 40GB shared amongst ~10 workers) - i thought processing chunks of files, reshuffle them and write intermediate results partitioned based on the 'location' column - creating multiple partitions for each column value.
Then go through each location, and repartition them to have better fitting files (less files, not too large)

But the problem is that after a few chunks the memory in the workers starts to fill up (causing workers to slow down) until eventual freeze.

My code looks like this:
```
def fdata_read(path, file_data):
    df = pd.read_parquet(path)
    df['first_name'] = file_data.first_name
    df['last_name'] = file_data.last_name
    return df
    
def process_chunk(file_iterator, n=100):
    file_data = itertools.islice(file_iterator, n)
    if not file_data:
        return None
    df = dd.from_delayed([delayed(fdata_read)(file_data) for file_data in file_list])
    df = df.apply(lambda x: pd.Series({
        'location': x.full_location.split('_')[0].lower(), 
        'hash': x.hash[:8],
        'first_name': x.first_name,
        'last_name': x.last_name,
    }), axis=1, meta={'location': 'object', 'hash': 'object', 'first_name': 'object', 'last_name': 'object})

    
    df = df.set_index('location', drop=False)
    d = df.to_parquet('s3://my_bucket/result', partition_on=[location'], compute=False)
    return d

while True:
   f = process_chunk(file_iterator)
   if not f: break
   f.compute()
```",,https://api.github.com/repos/dask/dask/issues/4457/timeline,,,talz,538365,MDQ6VXNlcjUzODM2NQ==,https://avatars.githubusercontent.com/u/538365?v=4,,https://api.github.com/users/talz,https://github.com/talz,https://api.github.com/users/talz/followers,https://api.github.com/users/talz/following{/other_user},https://api.github.com/users/talz/gists{/gist_id},https://api.github.com/users/talz/starred{/owner}{/repo},https://api.github.com/users/talz/subscriptions,https://api.github.com/users/talz/orgs,https://api.github.com/users/talz/repos,https://api.github.com/users/talz/events{/privacy},https://api.github.com/users/talz/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4457/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
173,https://api.github.com/repos/dask/dask/issues/4471,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4471/labels{/name},https://api.github.com/repos/dask/dask/issues/4471/comments,https://api.github.com/repos/dask/dask/issues/4471/events,https://github.com/dask/dask/issues/4471,408310533,MDU6SXNzdWU0MDgzMTA1MzM=,4471,Create architecture diagram for the distributed system,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,6,2019-02-08T20:24:53Z,2021-08-11T13:32:03Z,,MEMBER,,"Currently our best architecture diagrams are the following:

![](http://docs.dask.org/en/latest/_images/collections-schedulers.png)

![](http://matthewrocklin.com/slides/images/network.svg)

It would be nice to refresh these diagrams so that they can be more easily used
in documentation and presentations.  In particular it would be useful to make
clear the following points:

1.  Dask networks are composed of three pieces
    1.  A centralized scheduler, which manages workers
    2.  Many workers, which do the computation, hold onto results, and
        communicate results to each other.
    3.  One or multiple clients, from which users interact from Jupyter
        notebooks or scripts and submit work to the scheduler for execution on
        the workers

2.  Dask can be deployed on many different cluster technologies including
    -  Hadoop/Spark clusters running YARN
    -  HPC clusters running job managers like SLURM, SGE, PBS, LSF, or others
       common in academic and scientific labs
    -  Kubernetes clusters, either on the cloud or on premises

    I feel that these base technologies are typically represented as the bottom layer of a set of blocks

3.  The user, in their Jupyter notebook uses normal Python code that looks like
    Pandas, Scikit-Learn, or other common PyData libraries.

    Dask then breaks up these big data computations into many smaller
    computations that actually use the Pandas, Scikit-Learn, and other
    libraries, submits them to the scheduler, and runs them on the workers,
    giving the user the experience of big data with familiar libraries.

4.  Dask can also extend far beyond traditional MapReduce/Spark style
    comptutations, and can execute much more complex algorithms, such as are
    often needed in modern problems today extending beyond typical database
    queries.

This is a complex story that we'll need to tell both in static images, but also
possibly in animations, slide transitions, or even short videos.

I'm writing this issue mostly to point people with some design experience.  Anyone would be welcome to help out here.",,https://api.github.com/repos/dask/dask/issues/4471/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4471/reactions,1,0,0,0,0,0,1,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
174,https://api.github.com/repos/dask/dask/issues/4544,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4544/labels{/name},https://api.github.com/repos/dask/dask/issues/4544/comments,https://api.github.com/repos/dask/dask/issues/4544/events,https://github.com/dask/dask/issues/4544,417432260,MDU6SXNzdWU0MTc0MzIyNjA=,4544,Handling `da.histogram` when `range` is not specified,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2019-03-05T18:16:03Z,2021-05-28T07:45:51Z,,MEMBER,,Currently `da.histogram` is unable to handle the case where `range` is not specified or for that matter when `range` consists of lazy values. It would be nice for `da.histogram` to handle this case by simply using the min/max of the data as the default `range` (as is done in `np.histogram`). Further it would be good if `da.histogram` avoided (accidentally) computing lazy values used for the `range`.,,https://api.github.com/repos/dask/dask/issues/4544/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4544/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
175,https://api.github.com/repos/dask/dask/issues/4555,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4555/labels{/name},https://api.github.com/repos/dask/dask/issues/4555/comments,https://api.github.com/repos/dask/dask/issues/4555/events,https://github.com/dask/dask/issues/4555,417909870,MDU6SXNzdWU0MTc5MDk4NzA=,4555,Support bytes chunksize in dd.from_pandas,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,6,2019-03-06T16:57:21Z,2019-04-01T16:58:14Z,,MEMBER,,"Currently when people convert a pandas dataframe into a dask dataframe they use the from_pandas function

```python
df = pd.DataFrame(...)
ddf = dd.from_pandas(df, npartitions=10)
```

It would be convenient to make the `npartitions=` choice for them

```python
ddf = dd.from_pandas(df)
```

We could do this by looking at `dask.sizeof.sizeof(df)` to get an estiamte of the size of the dataframe, and then dividing that number by some ideal chunk size (perhaps `128 MiB` to start out with).

Additionally, as a step towards this, we might support a string input to the `chunksize=` keyword

```python
ddf = dd.from_pandas(df, chunksize=""128 MiB"")
```

This would use the sizeof trick above, and then assign npartitions approrpiately.

Note that this is somewhat different than the current use of chunksize, which refers to number of rows",,https://api.github.com/repos/dask/dask/issues/4555/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4555/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
176,https://api.github.com/repos/dask/dask/issues/4626,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4626/labels{/name},https://api.github.com/repos/dask/dask/issues/4626/comments,https://api.github.com/repos/dask/dask/issues/4626/events,https://github.com/dask/dask/issues/4626,424447567,MDU6SXNzdWU0MjQ0NDc1Njc=,4626,Add method to optimize collection and return HighLevelGraph,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,4,2019-03-23T01:12:23Z,2021-10-12T08:43:43Z,,MEMBER,,"It appears that when using `__dask_optimize__` it returns raw dicts. However the expectation has become `HighLevelGraph`s should be used instead. To meet that expectation, it would be nice if the `__dask_optimize__` functions also met this need. Here's an example with `Delayed` below, but can see similar things with the other collections.

<details>
<summary>Example:</summary>

```python
In [1]: from dask.delayed import Delayed, delayed                               

In [2]: d = delayed(sum)([2])                                                   

In [3]: Delayed.__dask_optimize__(d.__dask_graph__(), d.__dask_keys__())        
Out[3]: 
{'sum-aa5d6384-422a-4372-ada2-9753cf8efe31': (<function sum(iterable, start=0, /)>,
  [2])}
```

</details>

<br>

<details>
<summary>Environment:</summary>

```yaml
name: dask
channels:
  - conda-forge
  - defaults
dependencies:
  - appnope=0.1.0=py37_1000
  - backcall=0.1.0=py_0
  - blas=2.4=openblas
  - bokeh=1.0.4=py37_1000
  - bzip2=1.0.6=h1de35cc_1002
  - ca-certificates=2019.3.9=hecc5488_0
  - certifi=2019.3.9=py37_0
  - click=7.0=py_0
  - cloudpickle=0.8.0=py_0
  - cytoolz=0.9.0.1=py37h470a237_1
  - dask=1.1.4=py_0
  - dask-core=1.1.4=py_0
  - decorator=4.4.0=py_0
  - distributed=1.26.0=py37_1
  - freetype=2.10.0=h24853df_0
  - heapdict=1.0.0=py37_1000
  - ipython=7.4.0=py37h24bf2e0_0
  - ipython_genutils=0.2.0=py_1
  - jedi=0.13.3=py37_0
  - jinja2=2.10=py_1
  - jpeg=9c=h1de35cc_1001
  - libblas=3.8.0=4_openblas
  - libcblas=3.8.0=4_openblas
  - libcxx=4.0.1=h579ed51_0
  - libcxxabi=4.0.1=hebd6815_0
  - libffi=3.2.1=h6de7cb9_1006
  - libgfortran=3.0.1=0
  - liblapack=3.8.0=4_openblas
  - liblapacke=3.8.0=4_openblas
  - libpng=1.6.36=ha441bb4_1000
  - libtiff=4.0.10=h79f4b77_1001
  - locket=0.2.0=py_2
  - markupsafe=1.1.1=py37h1de35cc_0
  - msgpack-python=0.6.1=py37h04f5b5a_0
  - ncurses=6.1=h0a44026_1002
  - numpy=1.16.2=py37hbb3c62a_1
  - olefile=0.46=py_0
  - openblas=0.3.5=h436c29b_1001
  - openssl=1.1.1b=h01d97ff_2
  - packaging=19.0=py_0
  - pandas=0.24.2=py37h0a44026_0
  - parso=0.3.4=py_0
  - partd=0.3.9=py_0
  - pexpect=4.6.0=py37_1000
  - pickleshare=0.7.5=py37_1000
  - pillow=5.4.1=py37hbddbef0_1000
  - pip=19.0.3=py37_0
  - prompt_toolkit=2.0.9=py_0
  - psutil=5.6.1=py37h1de35cc_0
  - ptyprocess=0.6.0=py37_1000
  - pygments=2.3.1=py_0
  - pyparsing=2.3.1=py_0
  - python=3.7.2=hbdd33cc_0
  - python-dateutil=2.8.0=py_0
  - pytz=2018.9=py_0
  - pyyaml=5.1=py37h1de35cc_0
  - readline=7.0=hcfe32e1_1001
  - scipy=1.2.1=py37hbd7caa9_1
  - setuptools=40.8.0=py37_0
  - six=1.12.0=py37_1000
  - sortedcontainers=2.1.0=py_0
  - sqlite=3.26.0=h1765d9f_1001
  - tblib=1.3.2=py_1
  - tk=8.6.9=ha441bb4_1000
  - toolz=0.9.0=py_1
  - tornado=6.0.1=py37h1de35cc_0
  - traitlets=4.3.2=py37_1000
  - wcwidth=0.1.7=py_1
  - wheel=0.33.1=py37_0
  - xz=5.2.4=h1de35cc_1001
  - yaml=0.1.7=h1de35cc_1001
  - zict=0.1.4=py_0
  - zlib=1.2.11=h1de35cc_1004
```

</details>",,https://api.github.com/repos/dask/dask/issues/4626/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4626/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
177,https://api.github.com/repos/dask/dask/issues/4630,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4630/labels{/name},https://api.github.com/repos/dask/dask/issues/4630/comments,https://api.github.com/repos/dask/dask/issues/4630/events,https://github.com/dask/dask/issues/4630,424945678,MDU6SXNzdWU0MjQ5NDU2Nzg=,4630,Forget history and task overhead investigation,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,22,2019-03-25T14:52:19Z,2021-10-12T08:15:19Z,,MEMBER,,"Another issue about dask performance and optimization, slightly related to #107.

I frequently end up creating dask graphs with 1M+ tasks. Graphs this big cause the scheduler to start to choke. One idea I have had to mitigate this is to call `.persist()` on some intermediate results. I would  essentially like to save some results in the memory of my dask cluster, and then do further computations on this data.

However, the problem is that `.persist()` doesn't seem to reduce the number of tasks in the scheduler's memory. Even though the data I need are all memory on the worker nodes, I can't erase the expensive task history.

Specifically I would like to do something like this
```python
raw_data = load_data_from_storage(...)
intermediate_result = big_function_that_creates_lots_of_tasks(raw_data)
intermediate_result.persist(forget=True)
# intermediate result now only has 1 task per chunk
final_result = downstream_function(intermediate_result)
```

An alternative way to phrase this is that I would like to use the dask cluster as an in-memory distributed storage object, so perhaps there is a different way to achieve the same result.",,https://api.github.com/repos/dask/dask/issues/4630/timeline,,,rabernat,1197350,MDQ6VXNlcjExOTczNTA=,https://avatars.githubusercontent.com/u/1197350?v=4,,https://api.github.com/users/rabernat,https://github.com/rabernat,https://api.github.com/users/rabernat/followers,https://api.github.com/users/rabernat/following{/other_user},https://api.github.com/users/rabernat/gists{/gist_id},https://api.github.com/users/rabernat/starred{/owner}{/repo},https://api.github.com/users/rabernat/subscriptions,https://api.github.com/users/rabernat/orgs,https://api.github.com/users/rabernat/repos,https://api.github.com/users/rabernat/events{/privacy},https://api.github.com/users/rabernat/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4630/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
178,https://api.github.com/repos/dask/dask/issues/4635,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4635/labels{/name},https://api.github.com/repos/dask/dask/issues/4635/comments,https://api.github.com/repos/dask/dask/issues/4635/events,https://github.com/dask/dask/issues/4635,425673353,MDU6SXNzdWU0MjU2NzMzNTM=,4635,"Use da.eye with chunks=""auto"" fails","[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,7,2019-03-26T22:15:40Z,2019-05-28T16:36:09Z,,MEMBER,,"Currently if a user tries to create an array with `da.eye(..., chunks=""auto"")`, it fails. An MRE is included below.

<details>
<summary>Example:</summary>

```python
In [1]: import dask.array as da                                                 
da.ey	
In [2]: da.eye(100, chunks=10)                                                  
Out[2]: dask.array<eye, shape=(100, 100), dtype=float64, chunksize=(10, 10)>

In [3]: da.eye(100, chunks=""auto"")                                              
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-3-80d20afa2a92> in <module>
----> 1 da.eye(100, chunks=""auto"")

~/Developer/dask/dask/array/creation.py in eye(N, chunks, M, k, dtype)
    437     """"""
    438     if not isinstance(chunks, Integral):
--> 439         raise ValueError('chunks must be an int')
    440 
    441     token = tokenize(N, chunk, M, k, dtype)

ValueError: chunks must be an int
```

</details>

<br>

<details>
<summary>Environment:</summary>

```yaml
name: daskdev
channels:
  - conda-forge
  - defaults
dependencies:
  - appnope=0.1.0=py37_1000
  - asn1crypto=0.24.0=py37_1003
  - attrs=19.1.0=py_0
  - backcall=0.1.0=py_0
  - blas=1.1=openblas
  - bleach=3.1.0=py_0
  - bokeh=1.0.4=py37_1000
  - bzip2=1.0.6=h1de35cc_1002
  - ca-certificates=2019.3.9=hecc5488_0
  - certifi=2019.3.9=py37_0
  - cffi=1.12.2=py37h2d6ddff_1
  - chardet=3.0.4=py37_1003
  - click=7.0=py_0
  - cloudpickle=0.8.0=py_0
  - cryptography=2.6.1=py37hc2b1221_0
  - cycler=0.10.0=py_1
  - cytoolz=0.9.0.1=py37h470a237_1
  - dask-glm=0.1.0=0
  - dask-ml=0.12.0=py_0
  - decorator=4.3.2=py_0
  - defusedxml=0.5.0=py_1
  - distributed=1.26.0=py37_1
  - entrypoints=0.3=py37_1000
  - freetype=2.9.1=h597ad8a_1005
  - heapdict=1.0.0=py37_1000
  - idna=2.8=py37_1000
  - imageio=2.5.0=py37_0
  - ipykernel=5.1.0=py37h24bf2e0_1002
  - ipython=7.3.0=py37h24bf2e0_0
  - ipython_genutils=0.2.0=py_1
  - jedi=0.13.3=py37_0
  - jinja2=2.10=py_1
  - jpeg=9c=h1de35cc_1001
  - jsonschema=3.0.1=py37_0
  - jupyter_client=5.2.4=py_3
  - jupyter_core=4.4.0=py_0
  - kiwisolver=1.0.1=py37h04f5b5a_1002
  - libcxx=7.0.0=h2d50403_1
  - libffi=3.2.1=h0a44026_1005
  - libgfortran=3.0.1=0
  - libpng=1.6.36=ha441bb4_1000
  - libsodium=1.0.16=h1de35cc_1001
  - libtiff=4.0.10=h79f4b77_1001
  - llvm-meta=7.0.0=0
  - llvmlite=0.26.0=py37h8c7ce04_0
  - locket=0.2.0=py_2
  - markupsafe=1.1.1=py37h1de35cc_0
  - matplotlib-base=3.0.3=py37hf043ca5_0
  - mistune=0.8.4=py37h1de35cc_1000
  - msgpack-python=0.6.1=py37h04f5b5a_0
  - multipledispatch=0.6.0=py_0
  - nbconvert=5.4.1=py_2
  - nbformat=4.4.0=py_1
  - ncurses=6.1=h0a44026_1002
  - networkx=2.2=py_1
  - notebook=5.7.6=py37_0
  - numba=0.41.0=py37h1702cab_1000
  - numpy=1.16.2=py37_blas_openblash486cb9f_0
  - olefile=0.46=py_0
  - openblas=0.3.3=hdc02c5d_1001
  - openssl=1.1.1b=h1de35cc_1
  - packaging=19.0=py_0
  - pandas=0.24.2=py37h0a44026_0
  - pandoc=2.6=1
  - pandocfilters=1.4.2=py_1
  - parso=0.3.4=py_0
  - partd=0.3.9=py_0
  - pexpect=4.6.0=py37_1000
  - pickleshare=0.7.5=py37_1000
  - pillow=5.4.1=py37hbddbef0_1000
  - pip=19.0.3=py37_0
  - prometheus_client=0.6.0=py_0
  - prompt_toolkit=2.0.9=py_0
  - psutil=5.6.1=py37h1de35cc_0
  - ptyprocess=0.6.0=py37_1000
  - pycparser=2.19=py37_1
  - pygments=2.3.1=py_0
  - pyopenssl=19.0.0=py37_0
  - pyparsing=2.3.1=py_0
  - pyrsistent=0.14.11=py37h1de35cc_0
  - pysocks=1.6.8=py37_1002
  - python=3.7.1=hbdd33cc_1003
  - python-dateutil=2.8.0=py_0
  - pytz=2018.9=py_0
  - pywavelets=1.0.2=py37h917ab60_0
  - pyyaml=5.1=py37h1de35cc_0
  - pyzmq=18.0.1=py37h4cc6ddd_0
  - readline=7.0=hcfe32e1_1001
  - requests=2.21.0=py37_1000
  - scikit-image=0.14.2=py37h0a44026_1
  - scikit-learn=0.20.3=py37_blas_openblashc6dc708_0
  - scipy=1.2.1=py37_blas_openblash486cb9f_0
  - send2trash=1.5.0=py_0
  - setuptools=40.8.0=py37_0
  - six=1.12.0=py37_1000
  - sortedcontainers=2.1.0=py_0
  - sparse=0.6.0=py_0
  - sqlite=3.26.0=h1765d9f_1001
  - tblib=1.3.2=py_1
  - terminado=0.8.1=py37_1001
  - testpath=0.4.2=py37_1000
  - tk=8.6.9=ha441bb4_1000
  - toolz=0.9.0=py_1
  - tornado=6.0.1=py37h1de35cc_0
  - traitlets=4.3.2=py37_1000
  - urllib3=1.24.1=py37_1000
  - wcwidth=0.1.7=py_1
  - webencodings=0.5.1=py_1
  - wheel=0.33.1=py37_0
  - xz=5.2.4=h1de35cc_1001
  - yaml=0.1.7=h1de35cc_1001
  - zeromq=4.2.5=h0a44026_1006
  - zict=0.1.4=py_0
  - zlib=1.2.11=h1de35cc_1004
```

</details>",,https://api.github.com/repos/dask/dask/issues/4635/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4635/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
179,https://api.github.com/repos/dask/dask/issues/4763,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4763/labels{/name},https://api.github.com/repos/dask/dask/issues/4763/comments,https://api.github.com/repos/dask/dask/issues/4763/events,https://github.com/dask/dask/issues/4763,439023501,MDU6SXNzdWU0MzkwMjM1MDE=,4763,Rechunk in unify_chunks,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2019-04-30T23:48:08Z,2019-04-30T23:48:08Z,,MEMBER,,"When multiple dask arrays with different chunking combine we need to align their chunks.  We do that today in the unify_chunks function.  

When chunking is particularly out of alignment, we get many more output chunks than input chunks, triggering a warning to users:

```python
In [1]: import dask.array as da

In [2]: x = da.ones((1000, 1000), chunks=(1000, 10))

In [3]: x + x.T
/Users/mrocklin/workspace/dask/dask/array/core.py:3233: PerformanceWarning: Increasing number of chunks by factor of 100
  **blockwise_kwargs)
Out[3]: dask.array<add, shape=(1000, 1000), dtype=float64, chunksize=(10, 10)>
```

Unfortunately, this warning doesn't give users a good idea of how to change things.  Indeed, this function is used in enough places that it's often tricky to tell them which array to rechunk how.

However, we might rechunk for them automatically in some naive way.  For example in the example above things would be better if we first rechunked to `(100, 100)`

```python
In [4]: y = x.rechunk((100, 100))

In [5]: y + y.T
Out[5]: dask.array<add, shape=(1000, 1000), dtype=float64, chunksize=(100, 100)>
```

There is a larger conversation about auto-rechunking for particular operations in https://github.com/dask/dask/issues/3587 .  This might be a lower level stopgap for many operations, particularly those that rely on `blockwise` (previously called `atop`).

Maybe we have enough information in `unify_chunks` to always improve the situation?  I'm not sure.  I haven't gotten too deeply into this problem.  

cc @shoyer @birdsarah",,https://api.github.com/repos/dask/dask/issues/4763/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4763/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
180,https://api.github.com/repos/dask/dask/issues/4797,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4797/labels{/name},https://api.github.com/repos/dask/dask/issues/4797/comments,https://api.github.com/repos/dask/dask/issues/4797/events,https://github.com/dask/dask/issues/4797,444049243,MDU6SXNzdWU0NDQwNDkyNDM=,4797,Check for `__array_function__` when skipping `__array_wrap__`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2019-05-14T17:58:38Z,2019-05-14T17:59:07Z,,MEMBER,,"In PR ( https://github.com/dask/dask/pull/4708 ), we chose to keep using `__array_wrap__` instead of `__array_function__` for dataframes. This is a reasonable choice as currently dataframe libraries don't implement this functionality, but they may in the future ( https://github.com/rapidsai/cudf/issues/1728 ) ( https://github.com/pandas-dev/pandas/issues/26380 ). It could make sense to adjust this code to somehow check for `__array_function__` explicitly and skip `__array_wrap__` in those cases as opposed to special casing dataframes.",,https://api.github.com/repos/dask/dask/issues/4797/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4797/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
181,https://api.github.com/repos/dask/dask/issues/4840,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4840/labels{/name},https://api.github.com/repos/dask/dask/issues/4840/comments,https://api.github.com/repos/dask/dask/issues/4840/events,https://github.com/dask/dask/issues/4840,448083042,MDU6SXNzdWU0NDgwODMwNDI=,4840,Support for sparse TileDB arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2019-05-24T09:57:43Z,2019-05-28T15:12:40Z,,NONE,,"Currently, sparse TileDB arrays are not supported:
https://github.com/dask/dask/blob/41e5026b482bfb4c39535f8f301a1832f8a2630f/dask/array/tiledb_io.py#L53-L54

I think it should be possible to wrap TileDB with e.g. [pydata/sparse](https://github.com/pydata/sparse/).
At least, that's my current type of workaround, but it would be much more comfortable having this directly in Dask.",,https://api.github.com/repos/dask/dask/issues/4840/timeline,,,Hoeze,1200058,MDQ6VXNlcjEyMDAwNTg=,https://avatars.githubusercontent.com/u/1200058?v=4,,https://api.github.com/users/Hoeze,https://github.com/Hoeze,https://api.github.com/users/Hoeze/followers,https://api.github.com/users/Hoeze/following{/other_user},https://api.github.com/users/Hoeze/gists{/gist_id},https://api.github.com/users/Hoeze/starred{/owner}{/repo},https://api.github.com/users/Hoeze/subscriptions,https://api.github.com/users/Hoeze/orgs,https://api.github.com/users/Hoeze/repos,https://api.github.com/users/Hoeze/events{/privacy},https://api.github.com/users/Hoeze/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4840/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
182,https://api.github.com/repos/dask/dask/issues/4845,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4845/labels{/name},https://api.github.com/repos/dask/dask/issues/4845/comments,https://api.github.com/repos/dask/dask/issues/4845/events,https://github.com/dask/dask/issues/4845,448576561,MDU6SXNzdWU0NDg1NzY1NjE=,4845,ValueError: cannot handle a non-unique multi-index!,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,27,2019-05-26T15:09:25Z,2024-03-26T13:55:56Z,,NONE,,"[dask_error.txt](https://github.com/dask/dask/files/3220417/dask_error.txt)

This might be related to Dask not supporting multi-indexes. My code was randomly
failing, which made me first assume there was a problem in the input data. Running
with the versions

dask: 1.2.2
numpy: 1.16.3
pandas: 0.24.2

the minimal example below fails. Is there a way of making this error message more
intuitive? Or having this operation working.

```
import numpy as np
import pandas as pd
import dask.dataframe as dd

df = pd.DataFrame({'ind_a': np.arange(100), 'ind_b': 1, 'var': 'whatever'})
df = dd.from_pandas(df, npartitions=90)
    
# Only fails when grouping with two variables.
df['nr'] = df.groupby(['ind_a', 'ind_b']).cumcount()
len(df)
```",,https://api.github.com/repos/dask/dask/issues/4845/timeline,,,marberi,2119690,MDQ6VXNlcjIxMTk2OTA=,https://avatars.githubusercontent.com/u/2119690?v=4,,https://api.github.com/users/marberi,https://github.com/marberi,https://api.github.com/users/marberi/followers,https://api.github.com/users/marberi/following{/other_user},https://api.github.com/users/marberi/gists{/gist_id},https://api.github.com/users/marberi/starred{/owner}{/repo},https://api.github.com/users/marberi/subscriptions,https://api.github.com/users/marberi/orgs,https://api.github.com/users/marberi/repos,https://api.github.com/users/marberi/events{/privacy},https://api.github.com/users/marberi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4845/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
183,https://api.github.com/repos/dask/dask/issues/4849,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4849/labels{/name},https://api.github.com/repos/dask/dask/issues/4849/comments,https://api.github.com/repos/dask/dask/issues/4849/events,https://github.com/dask/dask/issues/4849,449373954,MDU6SXNzdWU0NDkzNzM5NTQ=,4849,Allow `da.bincount` to handle N-D arrays (with warning),"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2019-05-28T16:47:22Z,2020-04-30T17:24:05Z,,MEMBER,,"Currently [`da.bincount` requires the input array be 1-D]( https://github.com/dask/dask/blob/2f308e72a46de818055819108429e8f7ce7ba03b/dask/array/routines.py#L529-L531 ). If the actual array is multidimensional, this requires the user to flatten the array first, which can be quite expensive. It would be preferable to relax this to a warning and simply handle `bincount` on all of the chunks as if the array were flattened already.",,https://api.github.com/repos/dask/dask/issues/4849/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4849/reactions,0,0,0,0,0,0,0,0,0,jsignell,4806877.0,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
184,https://api.github.com/repos/dask/dask/issues/4855,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4855/labels{/name},https://api.github.com/repos/dask/dask/issues/4855/comments,https://api.github.com/repos/dask/dask/issues/4855/events,https://github.com/dask/dask/issues/4855,449883347,MDU6SXNzdWU0NDk4ODMzNDc=,4855,Flattening Dask Arrays without spreading out chunks,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,19,2019-05-29T15:42:35Z,2023-03-03T19:01:12Z,,MEMBER,,"Currently functions like [`ravel`]( http://docs.dask.org/en/latest/array-api.html#dask.array.Array.ravel ) and [`flatten`]( http://docs.dask.org/en/latest/array-api.html#dask.array.Array.flatten ) follow the same traversal that one would expect when using NumPy. This makes sense for users coming from NumPy, who would expect this. Also there are some Dask Array functions that rely on this behavior to match their NumPy counterparts. However this means that `ravel` and `flatten` must spread out the chunks (rechunk the array), which can have a non-negligible performance cost associated.

That said, not all cases rely on matching the same order that NumPy would provide when flattening out an array. For cases like this, a nice alternative would be to flatten chunks themselves and merely stitch together the flattened chunks into a new 1-D array. This strategy would require no rechunking and would be embarrassingly parallel. Thus it would avoid the performance penalties that `ravel` and `flatten` have today.

Assuming this strategy is reasonable, there are a few ways we could go about implementing it.

1. Allow some additional options to the `order` parameter to handle this need.
2. Add a new parameter to toggle NumPy or chunk-based traversal strategies.
3. Include a config option to enable this behavior for Dask Arrays more generally.
4. Add a new function entirely for this behavior.
5. ?

Thoughts on this?",,https://api.github.com/repos/dask/dask/issues/4855/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4855/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
185,https://api.github.com/repos/dask/dask/issues/4869,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4869/labels{/name},https://api.github.com/repos/dask/dask/issues/4869/comments,https://api.github.com/repos/dask/dask/issues/4869/events,https://github.com/dask/dask/issues/4869,451220632,MDU6SXNzdWU0NTEyMjA2MzI=,4869,Groupby NUnique is slow and possibly buggy,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,17,2019-06-02T18:34:00Z,2023-10-28T13:10:41Z,,CONTRIBUTOR,,"## Overview 
I ran into some issues where groupby nunique was bottle-necking my computations. In chasing things, I found that by re-implementing and I was able to get over 100x improvement in speed in lots of test cases, but I'm unsure of the extra requirements to merge this / generalize my solution to work for all dask groupby nunique. (not sure current status / support on multi-index groupbys)

The core of the implementation is to use `groupby` on a multi index (including the values), and `.sum()` and `.count()` rather than `.apply(M.drop_duplicates)`. 

Also note: `.apply(M.drop_duplicates)` seems to have a bug as well: https://github.com/pandas-dev/pandas/issues/26515

## Slow Example

```
from dask.datasets import timeseries
df = timeseries()
super_slow = df['y'].groupby(df['x']).nunique()
result = super_slow.compute()
```
Note: I've never actually let this finish, it seems (on my computer) to take over 10 minutes and still hasn't completed.

## Faster, bespoke implementation
<details><summary>Code Here</summary>
<p>

### ACA methods for nunique
```
import pandas as pd
from dask.dataframe.core import aca

def split_out_on_column(df, col_name='Unknown'):
    return df[col_name]


def unique_count_chunk(target_series, groupby_series, rename='__count'):
    grouped = target_series.groupby([groupby_series, target_series]).count().rename(rename)
    return grouped.reset_index()


def unique_count_combine(df, groupby_name='groupby_col', target_name='target_col', rename='__count'):
    grouped = df.groupby([groupby_name, target_name])[rename].sum().rename(rename)
    return grouped.reset_index()


def nunique_aggregate(df, groupby_name='groupby_col', target_name='target_col', rename='__count'):
    grouped = df.groupby([groupby_name, target_name])[rename].sum().rename(rename)
    return grouped.groupby(groupby_name).count().astype('Int64').rename(rename)


def series_groupby_nunique(series_groupby, rename='__count', split_out=None, split_every=None):
    if isinstance(series_groupby.index, list):
        raise NotImplementedError(""Multi-column groupby not supported in series-nunique"")
    groupby_name = series_groupby.index.name
    target_name = series_groupby.obj.name
    meta = pd.Series([], dtype='Int64', name=rename,
                     index=pd.Series([], dtype=series_groupby.obj.dtype, name=groupby_name))
    return aca([series_groupby.obj, series_groupby.index],
               token='series-groupby-nunique',
               chunk=unique_count_chunk,
               chunk_kwargs={'rename': rename},
               aggregate=nunique_aggregate,
               aggregate_kwargs={'groupby_name': groupby_name, 'target_name': target_name, 'rename': rename},
               combine=unique_count_combine,
               combine_kwargs={'groupby_name': groupby_name, 'target_name': target_name, 'rename': rename},
               meta=meta,
               split_every=split_every, split_out=split_out,
               split_out_setup=split_out_on_column, split_out_setup_kwargs={'col_name': groupby_name})
```

</p>
</details>


Some aspects that make the above bespoke: 
1) Not allowing multiple column groupbys, this is just a series groupby series.
2) Reliance on pandas to make the meta (not sure best practice here)
3) Using `Int64` as my dtype since I prefer ints that can be nulled. Not sure of the implications of this / what dask standards are?
4) Used `reset_index` on each level, since `concat` on `MultiIndex` seems to cause a memory leak? Was blowing out RAM on large `split_out=100`, but by resetting index and just passing around dataframes instead of indexed series to be combined, everything behaved well in terms of RAM.
5) Not tested against categorical columns which have some different groupby behaviors.

```
from dask.datasets import timeseries
df = timeseries()
much_faster = series_groupby_nunique(df['y'].groupby(df['x']))
result = much_faster.compute()
```

## Question:

What was the reasoning behind using `.apply(drop_duplicates)` as part of the `nunique` groupby agg?

Does the faster implementation above seem like a reasonable alternative, or am I missing an edge case / have a clear failure in my implementation? Should I work towards putting this in as a PR?",,https://api.github.com/repos/dask/dask/issues/4869/timeline,,reopened,bluecoconut,916073,MDQ6VXNlcjkxNjA3Mw==,https://avatars.githubusercontent.com/u/916073?v=4,,https://api.github.com/users/bluecoconut,https://github.com/bluecoconut,https://api.github.com/users/bluecoconut/followers,https://api.github.com/users/bluecoconut/following{/other_user},https://api.github.com/users/bluecoconut/gists{/gist_id},https://api.github.com/users/bluecoconut/starred{/owner}{/repo},https://api.github.com/users/bluecoconut/subscriptions,https://api.github.com/users/bluecoconut/orgs,https://api.github.com/users/bluecoconut/repos,https://api.github.com/users/bluecoconut/events{/privacy},https://api.github.com/users/bluecoconut/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4869/reactions,0,0,0,0,0,0,0,0,0,bluecoconut,916073.0,MDQ6VXNlcjkxNjA3Mw==,https://avatars.githubusercontent.com/u/916073?v=4,,https://api.github.com/users/bluecoconut,https://github.com/bluecoconut,https://api.github.com/users/bluecoconut/followers,https://api.github.com/users/bluecoconut/following{/other_user},https://api.github.com/users/bluecoconut/gists{/gist_id},https://api.github.com/users/bluecoconut/starred{/owner}{/repo},https://api.github.com/users/bluecoconut/subscriptions,https://api.github.com/users/bluecoconut/orgs,https://api.github.com/users/bluecoconut/repos,https://api.github.com/users/bluecoconut/events{/privacy},https://api.github.com/users/bluecoconut/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
186,https://api.github.com/repos/dask/dask/issues/4876,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4876/labels{/name},https://api.github.com/repos/dask/dask/issues/4876/comments,https://api.github.com/repos/dask/dask/issues/4876/events,https://github.com/dask/dask/issues/4876,451681014,MDU6SXNzdWU0NTE2ODEwMTQ=,4876,[QST] Optimized hashing/shuffling,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,7,2019-06-03T20:44:25Z,2019-06-15T16:42:01Z,,MEMBER,,"When dataframes are shuffled, dask builds a hash of the index for each partition and buckets the hashes modulo n_partitions.  cuDF has an optimized hash partitioning scheme:

https://github.com/rapidsai/cudf/blob/81a85a39dc03c7c4bd7b0c7f8f39447b14747ca2/python/cudf/bindings/hash.pyx#L54-L67

Could dask take advantage of such a routine when shuffling ?",,https://api.github.com/repos/dask/dask/issues/4876/timeline,,,quasiben,1403768,MDQ6VXNlcjE0MDM3Njg=,https://avatars.githubusercontent.com/u/1403768?v=4,,https://api.github.com/users/quasiben,https://github.com/quasiben,https://api.github.com/users/quasiben/followers,https://api.github.com/users/quasiben/following{/other_user},https://api.github.com/users/quasiben/gists{/gist_id},https://api.github.com/users/quasiben/starred{/owner}{/repo},https://api.github.com/users/quasiben/subscriptions,https://api.github.com/users/quasiben/orgs,https://api.github.com/users/quasiben/repos,https://api.github.com/users/quasiben/events{/privacy},https://api.github.com/users/quasiben/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4876/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
187,https://api.github.com/repos/dask/dask/issues/4899,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4899/labels{/name},https://api.github.com/repos/dask/dask/issues/4899/comments,https://api.github.com/repos/dask/dask/issues/4899/events,https://github.com/dask/dask/issues/4899,453603675,MDU6SXNzdWU0NTM2MDM2NzU=,4899,[BUG] dask.array.linalg.inv fails on CuPy backed arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,8,2019-06-07T16:47:07Z,2021-02-15T14:14:01Z,,MEMBER,,"`Linalg.inv` appears to fail for the same general reason as #4898 . Filing this for visibility purposes in case others run into this issue before #4731 is resolved.

```python
import dask.array as da
import cupy as cp
import numpy as np

np.random.seed(12)
arr = np.random.normal(10, 10, (1000,1000))
arr_cp = cp.asarray(arr)
darr_cp = da.from_array(arr_cp, asarray=False)
da.linalg.inv(darr_cp).compute()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-1-a9c479838e0d> in <module>
      7 arr_cp = cp.asarray(arr)
      8 darr_cp = da.from_array(arr_cp, asarray=False)
----> 9 da.linalg.inv(darr_cp).compute()

/conda/envs/rapids/lib/python3.7/site-packages/dask/base.py in compute(self, **kwargs)
    154         dask.base.compute
    155         """"""
--> 156         (result,) = compute(self, traverse=False, **kwargs)
    157         return result
    158 

/conda/envs/rapids/lib/python3.7/site-packages/dask/base.py in compute(*args, **kwargs)
    396     keys = [x.__dask_keys__() for x in collections]
    397     postcomputes = [x.__dask_postcompute__() for x in collections]
--> 398     results = schedule(dsk, keys, **kwargs)
    399     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    400 

/conda/envs/rapids/lib/python3.7/site-packages/dask/threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     74     results = get_async(pool.apply_async, len(pool._pool), dsk, result,
     75                         cache=cache, get_id=_thread_get_id,
---> 76                         pack_exception=pack_exception, **kwargs)
     77 
     78     # Cleanup pools associated to dead threads

/conda/envs/rapids/lib/python3.7/site-packages/dask/local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    460                         _execute_task(task, data)  # Re-execute locally
    461                     else:
--> 462                         raise_exception(exc, tb)
    463                 res, worker_id = loads(res_info)
    464                 state['cache'][key] = res

/conda/envs/rapids/lib/python3.7/site-packages/dask/compatibility.py in reraise(exc, tb)
    110         if exc.__traceback__ is not tb:
    111             raise exc.with_traceback(tb)
--> 112         raise exc
    113 
    114     import pickle as cPickle

/conda/envs/rapids/lib/python3.7/site-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    228     try:
    229         task, data = loads(task_info)
--> 230         result = _execute_task(task, data)
    231         id = get_id()
    232         result = dumps((result, id))

/conda/envs/rapids/lib/python3.7/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    117         func, args = arg[0], arg[1:]
    118         args2 = [_execute_task(a, cache) for a in args]
--> 119         return func(*args2)
    120     elif not ishashable(arg):
    121         return arg

/conda/envs/rapids/lib/python3.7/site-packages/scipy/linalg/decomp_lu.py in lu(a, permute_l, overwrite_a, check_finite)
    209     """"""
    210     if check_finite:
--> 211         a1 = asarray_chkfinite(a)
    212     else:
    213         a1 = asarray(a)

/conda/envs/rapids/lib/python3.7/site-packages/numpy/lib/function_base.py in asarray_chkfinite(a, dtype, order)
    493 
    494     """"""
--> 495     a = asarray(a, dtype=dtype, order=order)
    496     if a.dtype.char in typecodes['AllFloat'] and not np.isfinite(a).all():
    497         raise ValueError(

/conda/envs/rapids/lib/python3.7/site-packages/numpy/core/numeric.py in asarray(a, dtype, order)
    536 
    537     """"""
--> 538     return array(a, dtype, copy=False, order=order)
    539 
    540 

ValueError: object __array__ method not producing an array
```

I do have the `NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1` environment variable set for this test

```
import os
os.environ['NUMPY_EXPERIMENTAL_ARRAY_FUNCTION']
'1'
```",,https://api.github.com/repos/dask/dask/issues/4899/timeline,,,beckernick,8457388,MDQ6VXNlcjg0NTczODg=,https://avatars.githubusercontent.com/u/8457388?v=4,,https://api.github.com/users/beckernick,https://github.com/beckernick,https://api.github.com/users/beckernick/followers,https://api.github.com/users/beckernick/following{/other_user},https://api.github.com/users/beckernick/gists{/gist_id},https://api.github.com/users/beckernick/starred{/owner}{/repo},https://api.github.com/users/beckernick/subscriptions,https://api.github.com/users/beckernick/orgs,https://api.github.com/users/beckernick/repos,https://api.github.com/users/beckernick/events{/privacy},https://api.github.com/users/beckernick/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4899/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
188,https://api.github.com/repos/dask/dask/issues/4922,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4922/labels{/name},https://api.github.com/repos/dask/dask/issues/4922/comments,https://api.github.com/repos/dask/dask/issues/4922/events,https://github.com/dask/dask/issues/4922,455180636,MDU6SXNzdWU0NTUxODA2MzY=,4922,Assignments to integer column name fail,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2019-06-12T12:19:37Z,2020-04-30T13:27:03Z,,NONE,,"Dask can't handle assignments to integer column names, returning `TypeError: assign() keywords must be a string`.

**Objective:**
I'm trying to cast all potentially mixed object columns to string, then categorise (i.e. `[0, 'a', 1.1]` -> `['0', 'a', '1.1']` -> categories).

**Environment:**
On the latest versions of Dask and Pandas.

**MVE:**

    import pandas as pd
    pdf = pd.DataFrame({0:[0, 'a', 1.1], 1:[0, 'a', 1.1]})
    pdf[0] = pdf[1].astype(str).astype('category')

    import dask.dataframe as dd
    ddf = dd.from_pandas(pdf, npartitions=1)
    ddf[0] = ddf[1].astype(str).astype('category')

**Expected vs actual behaviour:**
In Pandas, the code executes fine. In Dask, it does not, failing with a `TypeError: assign() keywords must be a string` error as under the hood it appears to be trying to do `ddf.assign(0=series)`.

**Workarounds:**
I think I'm just going to do

    ddf = ddf.astype({0: str}).astype({0: 'category').categorize()

I'm trying to do a similar thing with casting a float-based column to integers (if it's int-equivalent) or string if it's not, which I imagine will need the same fix.",,https://api.github.com/repos/dask/dask/issues/4922/timeline,,,smangham,8093436,MDQ6VXNlcjgwOTM0MzY=,https://avatars.githubusercontent.com/u/8093436?v=4,,https://api.github.com/users/smangham,https://github.com/smangham,https://api.github.com/users/smangham/followers,https://api.github.com/users/smangham/following{/other_user},https://api.github.com/users/smangham/gists{/gist_id},https://api.github.com/users/smangham/starred{/owner}{/repo},https://api.github.com/users/smangham/subscriptions,https://api.github.com/users/smangham/orgs,https://api.github.com/users/smangham/repos,https://api.github.com/users/smangham/events{/privacy},https://api.github.com/users/smangham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4922/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
189,https://api.github.com/repos/dask/dask/issues/4930,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4930/labels{/name},https://api.github.com/repos/dask/dask/issues/4930/comments,https://api.github.com/repos/dask/dask/issues/4930/events,https://github.com/dask/dask/issues/4930,455446020,MDU6SXNzdWU0NTU0NDYwMjA=,4930,Dask and pandas mean/std result disperancy for timedelta columns ,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2019-06-12T22:08:14Z,2019-06-13T22:11:09Z,,CONTRIBUTOR,,"There are two things dask does differently when computing std and mean for timedelta columns.
For dataframe timedelta columns are dropped and for series different dtype is returned (float64 or numpy.timedelta64, while in pandas it's Timedelta).

Examples: 
```python
import pandas as pd
import dask.dataframe as dd
import numpy as np

df = pd.DataFrame({""a"":[np.timedelta64(1, 'D'), 
np.timedelta64(2, 'D'), 
np.timedelta64(3,'D')],""b"":[1,2,3]})
ddf = dd.from_pandas(df, 2)
 
df.mean()
a    2 days 00:00:00
b                  2
dtype: object

ddf.mean().compute()
b    2.0
dtype: float64

df.std()
a    1 days 00:00:00
b                  1
dtype: object

ddf.std().compute()
a    8.640000e+13
b    1.000000e+00
dtype: float64
 
df.a.mean()
Timedelta('2 days 00:00:00')

ddf.a.mean().compute()
numpy.timedelta64(172800000000000,'ns')

df.a.std()
Timedelta('1 days 00:00:00')

ddf.a.std().compute()
86400000000000.0
```

Given that variance handles timedeltas it should be easy to change.
",,https://api.github.com/repos/dask/dask/issues/4930/timeline,,,almaleksia,1885174,MDQ6VXNlcjE4ODUxNzQ=,https://avatars.githubusercontent.com/u/1885174?v=4,,https://api.github.com/users/almaleksia,https://github.com/almaleksia,https://api.github.com/users/almaleksia/followers,https://api.github.com/users/almaleksia/following{/other_user},https://api.github.com/users/almaleksia/gists{/gist_id},https://api.github.com/users/almaleksia/starred{/owner}{/repo},https://api.github.com/users/almaleksia/subscriptions,https://api.github.com/users/almaleksia/orgs,https://api.github.com/users/almaleksia/repos,https://api.github.com/users/almaleksia/events{/privacy},https://api.github.com/users/almaleksia/received_events,User,True,https://api.github.com/repos/dask/dask/issues/4930/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
190,https://api.github.com/repos/dask/dask/issues/4950,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4950/labels{/name},https://api.github.com/repos/dask/dask/issues/4950/comments,https://api.github.com/repos/dask/dask/issues/4950/events,https://github.com/dask/dask/issues/4950,456899666,MDU6SXNzdWU0NTY4OTk2NjY=,4950,No way to elegantly rename dataframe index,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,4,2019-06-17T12:09:52Z,2019-06-19T14:01:22Z,,NONE,,"The pandas [`DataFrame.rename_axis`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rename_axis.html) is not supported and also, `dd.DataFrame.index.name = <new_value>` has [no effect](https://notebooks.azure.com/styagev/projects/scratch/html/dask_rename_index.ipynb), so there is no elegant way to rename a dataframe index. Some users [suggest](https://stackoverflow.com/questions/44337910/how-to-rename-the-index-of-a-dask-dataframe) to rename the index directly on the partitions but this seems non-elegant.

Example 1:
```
df = dd.from_pandas(pd.DataFrame({'a':[1,2]}, index=['i1','i2']), npartitions=1)
df.rename_axis('new_name')
```
Should yield:
```
	a
new_name	
i1	1
i2	2
```
Also, the following should yield the same result:
```
df.index.name = 'new_name'
```",,https://api.github.com/repos/dask/dask/issues/4950/timeline,,,syagev,5247438,MDQ6VXNlcjUyNDc0Mzg=,https://avatars.githubusercontent.com/u/5247438?v=4,,https://api.github.com/users/syagev,https://github.com/syagev,https://api.github.com/users/syagev/followers,https://api.github.com/users/syagev/following{/other_user},https://api.github.com/users/syagev/gists{/gist_id},https://api.github.com/users/syagev/starred{/owner}{/repo},https://api.github.com/users/syagev/subscriptions,https://api.github.com/users/syagev/orgs,https://api.github.com/users/syagev/repos,https://api.github.com/users/syagev/events{/privacy},https://api.github.com/users/syagev/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4950/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
191,https://api.github.com/repos/dask/dask/issues/4951,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4951/labels{/name},https://api.github.com/repos/dask/dask/issues/4951/comments,https://api.github.com/repos/dask/dask/issues/4951/events,https://github.com/dask/dask/issues/4951,456944491,MDU6SXNzdWU0NTY5NDQ0OTE=,4951,Support identification of _meta-related issues,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2019-06-17T13:46:46Z,2019-07-15T18:59:25Z,,MEMBER,,"While handling `_meta`, we tried to be very conservative, defaulting to NumPy anywhere we couldn't find an appropriate solution. We have a few ways of handling such situations, including maintaining the current behavior, as noted by @mrocklin in https://github.com/dask/dask/pull/4914#issuecomment-502111112.

Option 2 seems to be a good compromise between usability and developer support, allowing developers to more quickly identify issues that cause Dask to default to NumPy.

Such a warning should then be added to several parts of Dask, as for example `blockwise` and `meta_from_array` functions. Warnings suppressed by #5103 should be reenabled.",,https://api.github.com/repos/dask/dask/issues/4951/timeline,,,pentschev,4398246,MDQ6VXNlcjQzOTgyNDY=,https://avatars.githubusercontent.com/u/4398246?v=4,,https://api.github.com/users/pentschev,https://github.com/pentschev,https://api.github.com/users/pentschev/followers,https://api.github.com/users/pentschev/following{/other_user},https://api.github.com/users/pentschev/gists{/gist_id},https://api.github.com/users/pentschev/starred{/owner}{/repo},https://api.github.com/users/pentschev/subscriptions,https://api.github.com/users/pentschev/orgs,https://api.github.com/users/pentschev/repos,https://api.github.com/users/pentschev/events{/privacy},https://api.github.com/users/pentschev/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4951/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
192,https://api.github.com/repos/dask/dask/issues/4952,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4952/labels{/name},https://api.github.com/repos/dask/dask/issues/4952/comments,https://api.github.com/repos/dask/dask/issues/4952/events,https://github.com/dask/dask/issues/4952,456948235,MDU6SXNzdWU0NTY5NDgyMzU=,4952,Improve blockwise_meta exception handling,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2019-06-17T13:53:24Z,2019-06-24T21:13:49Z,,MEMBER,,"Current `blockwise_meta`/`blockwise` implementation defaults to `dtype` construction of `Dask.Array` when an non-trivial exception is raised when computing `_meta`. This is suboptimal for two reasons:

1. It's difficult to trace that the defaulting happened within `blockwise` for somewhat complex user code;
1. Exceptions that come from the array compute task (with NumPy, CuPy, etc.) are not raised to the user during graph construction.

Ideally, we would handle all possible exceptions, with all remaining ones assumed to be user's mistake, such as passing `casting` to `cupy.einsum` (which isn't supported), as discussed in https://github.com/dask/dask/pull/4914.

Given that `_meta` now exists, Dask has become a universal scheduler, which probably means we can't handle every single possible exception, but we should at least allow developers to know about such cases, as well as letting users know they possibly made a mistake. We should therefore let most exceptions pass back to the user in `blockwise`.

This is loosely related to #4951, where we wish to allow users/developers be alerted of conditions that Dask can't handle and should probably be better handled by the library which Dask is using as a backend through `__array_function__`.",,https://api.github.com/repos/dask/dask/issues/4952/timeline,,,pentschev,4398246,MDQ6VXNlcjQzOTgyNDY=,https://avatars.githubusercontent.com/u/4398246?v=4,,https://api.github.com/users/pentschev,https://github.com/pentschev,https://api.github.com/users/pentschev/followers,https://api.github.com/users/pentschev/following{/other_user},https://api.github.com/users/pentschev/gists{/gist_id},https://api.github.com/users/pentschev/starred{/owner}{/repo},https://api.github.com/users/pentschev/subscriptions,https://api.github.com/users/pentschev/orgs,https://api.github.com/users/pentschev/repos,https://api.github.com/users/pentschev/events{/privacy},https://api.github.com/users/pentschev/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4952/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
193,https://api.github.com/repos/dask/dask/issues/4966,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4966/labels{/name},https://api.github.com/repos/dask/dask/issues/4966/comments,https://api.github.com/repos/dask/dask/issues/4966/events,https://github.com/dask/dask/issues/4966,457971021,MDU6SXNzdWU0NTc5NzEwMjE=,4966,nc file locked by da.compute() operation,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2019-06-19T11:59:00Z,2019-06-25T07:08:56Z,,NONE,,"Hi,
I've recently started to use dask.array to compute and load only chunks of a huge dataset for the development of [Parcels](https://github.com/OceanParcels/parcels). I've run into an issue of locked netcdf files while running multiple tests using py.test, and I think my bug should be related to the reduced issue that I reproduce hereinafter:

```
import numpy as np
import xarray as xr
import dask.array as da

def create_ds():
    temp = 15 + 8 * np.random.randn(2, 2)
    precip = 10 * np.random.rand(2, 2)
    lon = [[-99.83, -99.32], [-99.79, -99.23]]
    lat = [[42.25, 42.21], [42.63, 42.59]]
    ds = xr.Dataset({'temperature': (['x', 'y'],  temp),
                     'precipitation': (['x', 'y'], precip)},
                      coords={'lon': (['x', 'y'], lon),
                              'lat': (['x', 'y'], lat)})
    ds.to_netcdf('test.nc')

def dask_op():
    ds = xr.open_dataset('test.nc')
    temp = da.from_array(ds.temperature, chunks='auto')
    temp.compute()
    temp.compute()

create_ds()
dask_op()
dset = xr.Dataset()
dset.to_netcdf('test.nc')
```

Is it normal that `test.nc` is still locked after returning from `dask_op` function?
I know the example does not crash anymore if I call `temp.compute()` only once or if I close the dataset after last computing. And if I have closed earlier the ds (like before compute()) it does not work anymore.
But is it normal I should close the the dataset explicitly?

So to summarise this works

```
temp.compute()
```
```
temp.compute()
temp.compute()
ds.close
``` 

And this doesn't
```
temp.compute()
temp.compute()
```
```
ds.close
temp.compute()
temp.compute()
ds.close
```

Does that make sense to someone? Is it expected or a bug?

Thanks!
Philippe",,https://api.github.com/repos/dask/dask/issues/4966/timeline,,,delandmeterp,31093031,MDQ6VXNlcjMxMDkzMDMx,https://avatars.githubusercontent.com/u/31093031?v=4,,https://api.github.com/users/delandmeterp,https://github.com/delandmeterp,https://api.github.com/users/delandmeterp/followers,https://api.github.com/users/delandmeterp/following{/other_user},https://api.github.com/users/delandmeterp/gists{/gist_id},https://api.github.com/users/delandmeterp/starred{/owner}{/repo},https://api.github.com/users/delandmeterp/subscriptions,https://api.github.com/users/delandmeterp/orgs,https://api.github.com/users/delandmeterp/repos,https://api.github.com/users/delandmeterp/events{/privacy},https://api.github.com/users/delandmeterp/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4966/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
194,https://api.github.com/repos/dask/dask/issues/4997,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/4997/labels{/name},https://api.github.com/repos/dask/dask/issues/4997/comments,https://api.github.com/repos/dask/dask/issues/4997/events,https://github.com/dask/dask/issues/4997,460179503,MDU6SXNzdWU0NjAxNzk1MDM=,4997,Optimizing reductions with `axis=()`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,4,2019-06-25T02:38:45Z,2019-07-16T18:26:19Z,,MEMBER,,"Reductions with `axis=()` are a special set of reductions where little if any work needs to be done. It might be valuable to optimizes these. Here's a few classes of results that are seen by looking at NumPy.

With statistical reductions like `a.mean(axis=())`, passing `axis=()` results in a no-op. It would be nice in these cases to return the Dask Array unaltered.

The `nan*` equivalent operations are nearly the same, but swap out all `nan` values for `0`s leaving the rest of the array unchanged. These might benefit from a simple application of `da.nan_to_num`.

OTOH reductions like `a.var(axis=())` and `a.std(axis=())` return an array full of `0`s. Similarly these would be nice to optimize out to avoid unnecessary computation. Currently they raise exceptions ( https://github.com/dask/dask/issues/4996 ).

For `bool` style reductions like `any` and `all`. These return a result equivalent to `a != 0`.",,https://api.github.com/repos/dask/dask/issues/4997/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/4997/reactions,0,0,0,0,0,0,0,0,0,mrocklin,306380.0,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
195,https://api.github.com/repos/dask/dask/issues/5001,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5001/labels{/name},https://api.github.com/repos/dask/dask/issues/5001/comments,https://api.github.com/repos/dask/dask/issues/5001/events,https://github.com/dask/dask/issues/5001,460636204,MDU6SXNzdWU0NjA2MzYyMDQ=,5001,Add Series.array,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,6,2019-06-25T20:52:15Z,2021-10-12T09:02:09Z,,MEMBER,,"Pandas 0.24.0 added a new recommended API for extracting the array (NumPy array or extension array) from a Series or index: http://pandas.pydata.org/pandas-docs/stable/whatsnew/v0.24.0.html#accessing-the-values-in-a-series-or-index

```python
In [15]: idx = pd.period_range('2000', periods=4)

In [16]: idx.array
Out[16]: 
<PeriodArray>
['2000-01-01', '2000-01-02', '2000-01-03', '2000-01-04']
Length: 4, dtype: period[D]

In [17]: pd.Series(idx).array
Out[17]: 
<PeriodArray>
['2000-01-01', '2000-01-02', '2000-01-03', '2000-01-04']
Length: 4, dtype: period[D]
```

What does this look like for dask dataframe?

For regular, NumPy dtypes, this is the same as `.values`.

For extension types, I think any array-like thing that implements dask collections interface is reasonable: https://github.com/ContinuumIO/cyberpandas/pull/39/files has a rough example. We should think about what dask.dataframe can provide to make that easier (perhaps not much).",,https://api.github.com/repos/dask/dask/issues/5001/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5001/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
196,https://api.github.com/repos/dask/dask/issues/5007,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5007/labels{/name},https://api.github.com/repos/dask/dask/issues/5007/comments,https://api.github.com/repos/dask/dask/issues/5007/events,https://github.com/dask/dask/issues/5007,461031651,MDU6SXNzdWU0NjEwMzE2NTE=,5007,Questions about map_blocks and _meta,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,16,2019-06-26T15:13:46Z,2021-10-19T21:35:01Z,,CONTRIBUTOR,,"This is a general question but is more focused on lower-level dask development so I figured I'd ask it here. This has to do with the recent `_meta` changes from #2977, #4543, and others from @mrocklin @shoyer and @pentschev.

Starting with dask 2.0, some of my tests on my Satpy library are failing because I was checking how often my `map_blocks`'d function was being called. To determine the meta information, the function is now being called once for meta and once for actual usage from what I can tell.

So my main question is, is it possible to provide keyword arguments to `map_blocks` to say ""this is the array type that will be returned by this function"" or could it be changed to default to the type of the input arrays? Is there some way to skip this meta generation step? Would this interfere with the sparse/masked array support?

Relevant source code: https://github.com/dask/dask/blob/master/dask/array/utils.py#L118-L133",,https://api.github.com/repos/dask/dask/issues/5007/timeline,,,djhoese,1828519,MDQ6VXNlcjE4Mjg1MTk=,https://avatars.githubusercontent.com/u/1828519?v=4,,https://api.github.com/users/djhoese,https://github.com/djhoese,https://api.github.com/users/djhoese/followers,https://api.github.com/users/djhoese/following{/other_user},https://api.github.com/users/djhoese/gists{/gist_id},https://api.github.com/users/djhoese/starred{/owner}{/repo},https://api.github.com/users/djhoese/subscriptions,https://api.github.com/users/djhoese/orgs,https://api.github.com/users/djhoese/repos,https://api.github.com/users/djhoese/events{/privacy},https://api.github.com/users/djhoese/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5007/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
197,https://api.github.com/repos/dask/dask/issues/5012,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5012/labels{/name},https://api.github.com/repos/dask/dask/issues/5012/comments,https://api.github.com/repos/dask/dask/issues/5012/events,https://github.com/dask/dask/issues/5012,461406853,MDU6SXNzdWU0NjE0MDY4NTM=,5012,Groupby apply using pd.Grouper yields ValueError,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,10,2019-06-27T09:02:19Z,2020-07-14T20:40:59Z,,NONE,,"I tried to use a groupby using a pd.Grouper (actually a list of pd.Groupers) followed by an apply and got an ValueError.

I reproduced the error using the example given in https://github.com/dask/dask/issues/1749, where it is shown that pd.Grouper does work when using the implemented computations like sum, max, mean etc. : 

```
import dask
df = dask.datasets.timeseries()

# This works, as expected
df.groupby('name').id.sum().compute()

# This also works, yielding the same result
df.groupby('name').apply(lambda df_grp: sum(df_grp.id)).compute()

# Using pd.Grouper works as well, yielding again the same result
df.groupby(pd.Grouper(key='name')).id.sum().compute()

# However, this doesn't work and yields a ValueError
df.groupby(pd.Grouper(key='name')).apply(lambda df_grp: sum(df_grp.id)).compute()
```

The ValueError is related to creating a Pandas Series where the length of the values is 0, but the index implies a non-zero length. For the specific example above:

```
ValueError: Length of passed values is 0, index implies 86400
```

pd.Groupers are really useful when wanting to group based on freq, so it would be great if groupby apply using pd.Groupers would be supported. Any help is greatly appreciated!",,https://api.github.com/repos/dask/dask/issues/5012/timeline,,,antonDA,25005600,MDQ6VXNlcjI1MDA1NjAw,https://avatars.githubusercontent.com/u/25005600?v=4,,https://api.github.com/users/antonDA,https://github.com/antonDA,https://api.github.com/users/antonDA/followers,https://api.github.com/users/antonDA/following{/other_user},https://api.github.com/users/antonDA/gists{/gist_id},https://api.github.com/users/antonDA/starred{/owner}{/repo},https://api.github.com/users/antonDA/subscriptions,https://api.github.com/users/antonDA/orgs,https://api.github.com/users/antonDA/repos,https://api.github.com/users/antonDA/events{/privacy},https://api.github.com/users/antonDA/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5012/reactions,4,4,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
198,https://api.github.com/repos/dask/dask/issues/5020,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5020/labels{/name},https://api.github.com/repos/dask/dask/issues/5020/comments,https://api.github.com/repos/dask/dask/issues/5020/events,https://github.com/dask/dask/issues/5020,462052710,MDU6SXNzdWU0NjIwNTI3MTA=,5020,Proposal: cookbook of Dask array patterns,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,3,2019-06-28T14:07:32Z,2021-10-18T14:53:47Z,,CONTRIBUTOR,,"Dask.array is an awesome package, but I've found that for any given computation that I want to implement over some multi-dimensional input array, it often takes me some time to figure out how to parallelise it with Dask. This is particularly true when the input array is also chunked in multiple dimensions, and the computation is adding, removing or transforming one or more dimensions somehow.

The function I use most often is `map_blocks()`, but when data are chunked in two dimensions, and the function I want to map either adds, removes or transforms some axis of the data, it can take some head-scratching to figure out how to set this up correctly, both in the function that I pass into `map_blocks()`, and in getting the values of the `drop_axis`, `new_axis`, and `chunks` arguments correct.

I'm also recently dealing with some use cases where I have multiple output arrays, which are not supported by `map_blocks()` but are supported by `apply_gufunc()`. But again there I am finding it challenging to figure out both how to set up the function to be passed in, and how to define the gufunc signature.

I was thinking that it could really help me and my colleagues to have some kind of ""patterns"" cookbook, i.e., a piece of documentation which was a list of generalised patterns of array computations, and then an implementation strategy for each. So then when I have a new problem, I can look up the cookbook and find the pattern that applies, and see a worked example of how to solve it with dask.array. If there was some way of visually representing each pattern too, and/or some clear naming of the different possible patterns, that could help a lot to find the right pattern.

FWIW I'd be happy to contribute to something like this if deemed useful.",,https://api.github.com/repos/dask/dask/issues/5020/timeline,,,alimanfoo,703554,MDQ6VXNlcjcwMzU1NA==,https://avatars.githubusercontent.com/u/703554?v=4,,https://api.github.com/users/alimanfoo,https://github.com/alimanfoo,https://api.github.com/users/alimanfoo/followers,https://api.github.com/users/alimanfoo/following{/other_user},https://api.github.com/users/alimanfoo/gists{/gist_id},https://api.github.com/users/alimanfoo/starred{/owner}{/repo},https://api.github.com/users/alimanfoo/subscriptions,https://api.github.com/users/alimanfoo/orgs,https://api.github.com/users/alimanfoo/repos,https://api.github.com/users/alimanfoo/events{/privacy},https://api.github.com/users/alimanfoo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5020/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
199,https://api.github.com/repos/dask/dask/issues/5021,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5021/labels{/name},https://api.github.com/repos/dask/dask/issues/5021/comments,https://api.github.com/repos/dask/dask/issues/5021/events,https://github.com/dask/dask/issues/5021,462086739,MDU6SXNzdWU0NjIwODY3Mzk=,5021,Convenience function to create Dask DataFrame from a mapping of sliceables,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,8,2019-06-28T15:22:20Z,2021-10-12T08:49:06Z,,CONTRIBUTOR,,"I have a common use case where I have an h5py or zarr group, which contains arrays that I would like to use as columns of a dataframe. Each array (column) is one-dimensional and may have a different dtype. In some cases an array might have two dimensions where the second dimension is very short, in which case I'd like to break out this second dimension as separate columns. E.g.:

```python
In [7]: variants
Out[7]: <zarr.hierarchy.Group '/3L/variants'>

In [8]: variants['POS']
Out[8]: <zarr.core.Array '/3L/variants/POS' (18167056,) int32>

In [9]: variants['DP']
Out[9]: <zarr.core.Array '/3L/variants/DP' (18167056,) int32>

In [10]: variants['AC']
Out[10]: <zarr.core.Array '/3L/variants/AC' (18167056, 3) int32>
```

I can create the dataframe I want with the following:

```python
In [22]: df = dd.concat([
    ...:    da.from_zarr(variants['POS']).to_dask_dataframe(columns='POS'),
    ...:    da.from_zarr(variants['DP']).to_dask_dataframe(columns='DP'),
    ...:    da.from_zarr(variants['AC']).to_dask_dataframe(columns=['AC_1', 'AC_2', 'AC_3'])],
    ...:    axis=1)

In [23]: df.head()
Out[23]:
   POS  DP  AC_1  AC_2  AC_3
0   15   1     2    -1    -1
1   19   2     2    -1    -1
2   20   2     2    -1    -1
3   23   2     2    -1    -1
4   24   2     2    -1    -1
```

However, it would be handy if there was a convenience function for this in dask dataframe, e.g., so I could just call something like `df = dd.from_dict(variants)`, although ""from_dict"" is possibly not the right name here as this doesn't exactly follow the pandas API. If this is too specialised then no problem to close, but if this is something more broadly useful then happy to submit a PR with some advice on function naming.
",,https://api.github.com/repos/dask/dask/issues/5021/timeline,,,alimanfoo,703554,MDQ6VXNlcjcwMzU1NA==,https://avatars.githubusercontent.com/u/703554?v=4,,https://api.github.com/users/alimanfoo,https://github.com/alimanfoo,https://api.github.com/users/alimanfoo/followers,https://api.github.com/users/alimanfoo/following{/other_user},https://api.github.com/users/alimanfoo/gists{/gist_id},https://api.github.com/users/alimanfoo/starred{/owner}{/repo},https://api.github.com/users/alimanfoo/subscriptions,https://api.github.com/users/alimanfoo/orgs,https://api.github.com/users/alimanfoo/repos,https://api.github.com/users/alimanfoo/events{/privacy},https://api.github.com/users/alimanfoo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5021/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
200,https://api.github.com/repos/dask/dask/issues/5051,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5051/labels{/name},https://api.github.com/repos/dask/dask/issues/5051/comments,https://api.github.com/repos/dask/dask/issues/5051/events,https://github.com/dask/dask/issues/5051,463274545,MDU6SXNzdWU0NjMyNzQ1NDU=,5051,Implement mean for Series[datetime64[ns]] and DatetimeIndex,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,11,2019-07-02T14:50:39Z,2023-05-02T22:09:56Z,,MEMBER,,"Pandas 0.25.0 adds Series[datetime64[ns, tz]].mean() and DatetimeIndex.mean(). We should as well


```python

In [1]: import pandas as pd

In [2]: pd.Series(pd.date_range('2000', periods=4)).mean()
Out[2]: Timestamp('2000-01-02 12:00:00')

In [3]: pd.__version__
Out[3]: '0.25.0.dev0+862.g02b552d28'

```",,https://api.github.com/repos/dask/dask/issues/5051/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5051/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
201,https://api.github.com/repos/dask/dask/issues/5059,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5059/labels{/name},https://api.github.com/repos/dask/dask/issues/5059/comments,https://api.github.com/repos/dask/dask/issues/5059/events,https://github.com/dask/dask/issues/5059,463754510,MDU6SXNzdWU0NjM3NTQ1MTA=,5059,Expand not working when spliting string column,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,17,2019-07-03T13:30:24Z,2020-09-02T13:03:36Z,,CONTRIBUTOR,,"Trying to split a string column using a delimiter raises exception. Here is a minimal example:

```python
df = pd.DataFrame({'channel_hash': ['1&2&3']})
ddf = dd.from_pandas(df, npartitions=1)
ddf.channel_hash.str.split('&', expand=True, n=3)
```
This fails with the following exception:

```python
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-98-fe4c812d7362> in <module>
----> 1 ddf.channel_hash.str.split(pat='&', expand=True, n=3).compute()

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/base.py in compute(self, **kwargs)
    173         dask.base.compute
    174         """"""
--> 175         (result,) = compute(self, traverse=False, **kwargs)
    176         return result
    177 

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/base.py in compute(*args, **kwargs)
    444     keys = [x.__dask_keys__() for x in collections]
    445     postcomputes = [x.__dask_postcompute__() for x in collections]
--> 446     results = schedule(dsk, keys, **kwargs)
    447     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    448 

~/virtualenvs/statistics3/lib/python3.6/site-packages/distributed/client.py in get(self, dsk, keys, restrictions, loose_restrictions, resources, sync, asynchronous, direct, retries, priority, fifo_timeout, actors, **kwargs)
   2508                     should_rejoin = False
   2509             try:
-> 2510                 results = self.gather(packed, asynchronous=asynchronous, direct=direct)
   2511             finally:
   2512                 for f in futures.values():

~/virtualenvs/statistics3/lib/python3.6/site-packages/distributed/client.py in gather(self, futures, errors, direct, asynchronous)
   1799                 direct=direct,
   1800                 local_worker=local_worker,
-> 1801                 asynchronous=asynchronous,
   1802             )
   1803 

~/virtualenvs/statistics3/lib/python3.6/site-packages/distributed/client.py in sync(self, func, *args, **kwargs)
    762             return future
    763         else:
--> 764             return sync(self.loop, func, *args, **kwargs)
    765 
    766     def __repr__(self):

~/virtualenvs/statistics3/lib/python3.6/site-packages/distributed/utils.py in sync(loop, func, *args, **kwargs)
    329             e.wait(10)
    330     if error[0]:
--> 331         six.reraise(*error[0])
    332     else:
    333         return result[0]

~/virtualenvs/statistics3/lib/python3.6/site-packages/six.py in reraise(tp, value, tb)
    691             if value.__traceback__ is not tb:
    692                 raise value.with_traceback(tb)
--> 693             raise value
    694         finally:
    695             value = None

~/virtualenvs/statistics3/lib/python3.6/site-packages/distributed/utils.py in f()
    314             if timeout is not None:
    315                 future = gen.with_timeout(timedelta(seconds=timeout), future)
--> 316             result[0] = yield future
    317         except Exception as exc:
    318             error[0] = sys.exc_info()

~/virtualenvs/statistics3/lib/python3.6/site-packages/tornado/gen.py in run(self)
   1131 
   1132                     try:
-> 1133                         value = future.result()
   1134                     except Exception:
   1135                         self.had_exception = True

~/virtualenvs/statistics3/lib/python3.6/site-packages/tornado/gen.py in run(self)
   1139                     if exc_info is not None:
   1140                         try:
-> 1141                             yielded = self.gen.throw(*exc_info)
   1142                         finally:
   1143                             # Break up a reference to itself

~/virtualenvs/statistics3/lib/python3.6/site-packages/distributed/client.py in _gather(self, futures, errors, direct, local_worker)
   1656                             exc = CancelledError(key)
   1657                         else:
-> 1658                             six.reraise(type(exception), exception, traceback)
   1659                         raise exc
   1660                     if errors == ""skip"":

~/virtualenvs/statistics3/lib/python3.6/site-packages/six.py in reraise(tp, value, tb)
    690                 value = tp()
    691             if value.__traceback__ is not tb:
--> 692                 raise value.with_traceback(tb)
    693             raise value
    694         finally:

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/optimization.py in __call__()
   1057         if not len(args) == len(self.inkeys):
   1058             raise ValueError(""Expected %d args, got %d"" % (len(self.inkeys), len(args)))
-> 1059         return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
   1060 
   1061     def __reduce__(self):

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/core.py in get()
    147     for key in toposort(dsk):
    148         task = dsk[key]
--> 149         result = _execute_task(task, cache)
    150         cache[key] = result
    151     result = _execute_task(out, cache)

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/core.py in _execute_task()
    117         func, args = arg[0], arg[1:]
    118         args2 = [_execute_task(a, cache) for a in args]
--> 119         return func(*args2)
    120     elif not ishashable(arg):
    121         return arg

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/compatibility.py in apply()
    105     def apply(func, args, kwargs=None):
    106         if kwargs:
--> 107             return func(*args, **kwargs)
    108         else:
    109             return func(*args)

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/dataframe/core.py in apply_and_enforce()
   4780             ):
   4781                 raise ValueError(
-> 4782                     ""The columns in the computed data do not match""
   4783                     "" the columns in the provided metadata""
   4784                 )

ValueError: The columns in the computed data do not match the columns in the provided metadata
```

Tried splitting without expansion but still raises the following exception:

```python
---------------------------------------------------------------------------
UnboundLocalError                         Traceback (most recent call last)
<ipython-input-99-a5b359767346> in <module>
----> 1 ddf.channel_hash.str.split(pat='&' ).compute()

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/dataframe/accessor.py in split(self, pat, n, expand)
    148                 meta = type(self._series._meta)(["" "".join([""a""] * 2 * n)])
    149                 meta = meta.str.split(n=n, expand=expand, pat=pat)
--> 150         return self._function_map(""split"", pat=pat, n=n, expand=expand, meta=meta)
    151 
    152     @derived_from(pd.core.strings.StringMethods)

UnboundLocalError: local variable 'meta' referenced before assignment
```

Python version: 3.6.8
Dask-version:    2.0.0",,https://api.github.com/repos/dask/dask/issues/5059/timeline,,,avlahop,3893010,MDQ6VXNlcjM4OTMwMTA=,https://avatars.githubusercontent.com/u/3893010?v=4,,https://api.github.com/users/avlahop,https://github.com/avlahop,https://api.github.com/users/avlahop/followers,https://api.github.com/users/avlahop/following{/other_user},https://api.github.com/users/avlahop/gists{/gist_id},https://api.github.com/users/avlahop/starred{/owner}{/repo},https://api.github.com/users/avlahop/subscriptions,https://api.github.com/users/avlahop/orgs,https://api.github.com/users/avlahop/repos,https://api.github.com/users/avlahop/events{/privacy},https://api.github.com/users/avlahop/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5059/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
202,https://api.github.com/repos/dask/dask/issues/5067,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5067/labels{/name},https://api.github.com/repos/dask/dask/issues/5067/comments,https://api.github.com/repos/dask/dask/issues/5067/events,https://github.com/dask/dask/issues/5067,464199180,MDU6SXNzdWU0NjQxOTkxODA=,5067,kernel dies when calling da.compress(),"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,9,2019-07-04T10:47:53Z,2019-08-30T18:14:25Z,,NONE,,"I'm attempting to compress a large array (125M x 361 x 2) by the 1st dimension. 

The `loc` object I am using to compress is a 125M bool- which I think should be about 125MB in memory.

Each chunk of my large array is 512MB.

The kernel dies/restarts when I call `da.compress()` (ie _before_ I attempt any computation)

```
gc = da.compress(random_loc, random_gt_stack)
gc
```

I created a gist based on the example dask notebook using binder. Binder was used to generate this error.

https://gist.github.com/hardingnj/eb0ba40828cbfc475371f4fcfce426b3

I presume this is a memory error, however given the sizes, I don't think I am exceeding any kernel limits here?

Many thanks
",,https://api.github.com/repos/dask/dask/issues/5067/timeline,,,hardingnj,4437708,MDQ6VXNlcjQ0Mzc3MDg=,https://avatars.githubusercontent.com/u/4437708?v=4,,https://api.github.com/users/hardingnj,https://github.com/hardingnj,https://api.github.com/users/hardingnj/followers,https://api.github.com/users/hardingnj/following{/other_user},https://api.github.com/users/hardingnj/gists{/gist_id},https://api.github.com/users/hardingnj/starred{/owner}{/repo},https://api.github.com/users/hardingnj/subscriptions,https://api.github.com/users/hardingnj/orgs,https://api.github.com/users/hardingnj/repos,https://api.github.com/users/hardingnj/events{/privacy},https://api.github.com/users/hardingnj/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5067/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
203,https://api.github.com/repos/dask/dask/issues/5087,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5087/labels{/name},https://api.github.com/repos/dask/dask/issues/5087/comments,https://api.github.com/repos/dask/dask/issues/5087/events,https://github.com/dask/dask/issues/5087,467010642,MDU6SXNzdWU0NjcwMTA2NDI=,5087,dask-ssh will not send correct address when scheduler is localhost,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,8,2019-07-11T17:10:28Z,2021-10-13T01:19:19Z,,NONE,,"Hello (again!),
When using dask-ssh specifying localhost as the scheduler, ""localhost"" is the address given to the workers, so no connection is made if the workers aren't on localhost as well. Easy solution is not specifying scheduler as localhost but as the ""actual"" address. Still a problem in my opinion, though! The console will repeatedly say:

```[ worker NotARealMachine.edu ] : distributed.worker - INFO - Waiting to connect to: tcp://localhost:8786```

reproduce:
`dask-ssh --scheduler localhost NotARealMachine.edu AnotherFakemachine.edu`
This occurs for both TCP and TLS connections.",,https://api.github.com/repos/dask/dask/issues/5087/timeline,,,landonzweigle,44909659,MDQ6VXNlcjQ0OTA5NjU5,https://avatars.githubusercontent.com/u/44909659?v=4,,https://api.github.com/users/landonzweigle,https://github.com/landonzweigle,https://api.github.com/users/landonzweigle/followers,https://api.github.com/users/landonzweigle/following{/other_user},https://api.github.com/users/landonzweigle/gists{/gist_id},https://api.github.com/users/landonzweigle/starred{/owner}{/repo},https://api.github.com/users/landonzweigle/subscriptions,https://api.github.com/users/landonzweigle/orgs,https://api.github.com/users/landonzweigle/repos,https://api.github.com/users/landonzweigle/events{/privacy},https://api.github.com/users/landonzweigle/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5087/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
204,https://api.github.com/repos/dask/dask/issues/5092,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5092/labels{/name},https://api.github.com/repos/dask/dask/issues/5092/comments,https://api.github.com/repos/dask/dask/issues/5092/events,https://github.com/dask/dask/issues/5092,467649070,MDU6SXNzdWU0Njc2NDkwNzA=,5092,unclear if possible or how to add meta type info to a custom Aggregation,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,9,2019-07-13T00:58:52Z,2022-05-02T17:23:08Z,,NONE,,"``` ValueError: Metadata inference failed in `_groupby_apply_funcs`. ``` received when I tried my hand at custom Aggregation. It seems like it would be reasonable to add meta to the Aggregation object but that errors differently.

```python
def percentile(n):
    from crick import TDigest
    # doc https://github.com/jcrist/crick/blob/master/crick/tdigest.pyx
    # doc https://docs.dask.org/en/stable/dataframe-api.html#dask.dataframe.groupby.Aggregation
    
    
    def percentile_chunck(grouped):
        g_res = []
        for items in grouped:
            t = TDigest()
            g_res.append(t.update(items))
        return(g_res) 
    
    def percentile_agg(chunk_TDigests):
        tagg = TDigest()
        for t in chunk_TDigests:
            tagg.merge(t)
        return tagg
   
    def percentile_finalize(tagg):
        return tagg.quantile(n)
    
    return dd.Aggregation(
        name    = 'percentile_{:2.0f}'.format(n*100),
        chunk   = percentile_chunck,
        agg     = percentile_agg,
        finalize=percentile_finalize,
    )

Spike_day = Spike_data.groupby('modulus_min')['abs_filtered_count'].agg([
    np.sum, 
    np.mean, 
    np.std, 
#    np.median,
    np.var,
    np.min,
    np.max,
    percentile(0.05),
    percentile(0.25),
    percentile(0.50),
    percentile(0.75),
    percentile(0.95)
])
display(Spike_day.head(10)) # prove the aggs work
```

If there is a better way to combine percentiles with other aggregations, I would like to hear that as well.  But, I was thinking if I could work through this I could answer several Aggregation related questions on StackOverflow even if there was a better approach.
",,https://api.github.com/repos/dask/dask/issues/5092/timeline,,,nbmorgan,1404206,MDQ6VXNlcjE0MDQyMDY=,https://avatars.githubusercontent.com/u/1404206?v=4,,https://api.github.com/users/nbmorgan,https://github.com/nbmorgan,https://api.github.com/users/nbmorgan/followers,https://api.github.com/users/nbmorgan/following{/other_user},https://api.github.com/users/nbmorgan/gists{/gist_id},https://api.github.com/users/nbmorgan/starred{/owner}{/repo},https://api.github.com/users/nbmorgan/subscriptions,https://api.github.com/users/nbmorgan/orgs,https://api.github.com/users/nbmorgan/repos,https://api.github.com/users/nbmorgan/events{/privacy},https://api.github.com/users/nbmorgan/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5092/reactions,4,4,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
205,https://api.github.com/repos/dask/dask/issues/5097,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5097/labels{/name},https://api.github.com/repos/dask/dask/issues/5097/comments,https://api.github.com/repos/dask/dask/issues/5097/events,https://github.com/dask/dask/issues/5097,467768916,MDU6SXNzdWU0Njc3Njg5MTY=,5097,"Have dask array use the information contained in gufuncs to create the ""test"" _meta run","[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2019-07-13T21:38:13Z,2019-07-24T15:55:19Z,,NONE,,"This could be viewed as either a bug or feature request, but here's the gist of the problem:

```
import numpy as np

import dask.array as da
from astropy import _erfa

a = da.from_array(np.random.randn(1000,3,3), chunks=100)
_erfa.bpn2xy(a)
```
which raises the following exception:
```
ValueError: `dtype` inference failed in `apply_gufunc`.

Please specify the dtype explicitly using the `output_dtypes` kwarg.

Original error is below:
------------------------
ValueError('bpn2xy: Input operand 0 has a mismatch in its core dimension 1, with gufunc signature (d3, d3)->(),() (size 1 is different from fixed size 3)',)

Traceback:
---------
  File "".../dask/array/core.py"", line 340, in apply_infer_dtype
    o = func(*args, **kwargs)
```

The fix (from some out-of-band discussion with @mrocklin) would likely be to have dask use `np.empty_like` to build the new `_meta`, but use the information in the `gufunc` to ensure it's the right shape (in this case that's ``(0, 3, 3)``, but of course it depends on the specific gufunc).",,https://api.github.com/repos/dask/dask/issues/5097/timeline,,,eteq,346587,MDQ6VXNlcjM0NjU4Nw==,https://avatars.githubusercontent.com/u/346587?v=4,,https://api.github.com/users/eteq,https://github.com/eteq,https://api.github.com/users/eteq/followers,https://api.github.com/users/eteq/following{/other_user},https://api.github.com/users/eteq/gists{/gist_id},https://api.github.com/users/eteq/starred{/owner}{/repo},https://api.github.com/users/eteq/subscriptions,https://api.github.com/users/eteq/orgs,https://api.github.com/users/eteq/repos,https://api.github.com/users/eteq/events{/privacy},https://api.github.com/users/eteq/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5097/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
206,https://api.github.com/repos/dask/dask/issues/5101,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5101/labels{/name},https://api.github.com/repos/dask/dask/issues/5101/comments,https://api.github.com/repos/dask/dask/issues/5101/events,https://github.com/dask/dask/issues/5101,467794137,MDU6SXNzdWU0Njc3OTQxMzc=,5101,Have the dask array __getattr__ fall back on _meta when an attribute is missing from the array itself,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2019-07-14T04:34:54Z,2021-10-13T01:12:28Z,,NONE,,"While trying to make the [astropy Quantity object](https://docs.astropy.org/en/stable/units/) compatible with Dask we encountered a possible interface change that might be necessary.  Specifically, it needs to be possible for `DaskArray` to access attributes on the `_meta` as though the `DaskArray` were the `_meta` - most particularly the `unit` attribute of `Quantity` and possibly similar informational methods/attributes related to the `unit`.

To enable `DaskArray`'s to work as a near- or actual drop-in, the suggested fix would then be to add/adjust `__getattr__` on `DaskArray` to look at the `_meta` and try to get attributes from there (if they aren't on `DaskArray`, although a `__getattr__` implementation means that part happens automatically).  Something like this:
```
class DaskArray(...):
    ...
    def __getattr__(self, name):
        return getattr(self._meta, name)
```

cc @mrocklin @bsipocz @astrofrog",,https://api.github.com/repos/dask/dask/issues/5101/timeline,,,eteq,346587,MDQ6VXNlcjM0NjU4Nw==,https://avatars.githubusercontent.com/u/346587?v=4,,https://api.github.com/users/eteq,https://github.com/eteq,https://api.github.com/users/eteq/followers,https://api.github.com/users/eteq/following{/other_user},https://api.github.com/users/eteq/gists{/gist_id},https://api.github.com/users/eteq/starred{/owner}{/repo},https://api.github.com/users/eteq/subscriptions,https://api.github.com/users/eteq/orgs,https://api.github.com/users/eteq/repos,https://api.github.com/users/eteq/events{/privacy},https://api.github.com/users/eteq/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5101/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
207,https://api.github.com/repos/dask/dask/issues/5110,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5110/labels{/name},https://api.github.com/repos/dask/dask/issues/5110/comments,https://api.github.com/repos/dask/dask/issues/5110/events,https://github.com/dask/dask/issues/5110,469676292,MDU6SXNzdWU0Njk2NzYyOTI=,5110,Sparse COO divide by zero is zero,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,9,2019-07-18T09:53:16Z,2021-10-13T06:34:38Z,,NONE,,"Thanks so much for creating this great library!

There seems to be an inconsistency when dividing by zero with sparse matrices:

```python
import dask
import dask.array as da
import sparse
print(f""dask version {dask.__version__}"")
print(f""sparse version {sparse.__version__}"")

coo = da.zeros(10).map_blocks(sparse.COO)

print((1 / coo).compute().todense())
# [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
# should be: [inf inf inf inf inf inf inf inf inf inf] ?

print((1 / coo.compute()).todense())
# [inf inf inf inf inf inf inf inf inf inf]
```
output:
```
dask version 2.1.0
sparse version 0.7.0
[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
[inf inf inf inf inf inf inf inf inf inf]
```

Am I missing something here?",,https://api.github.com/repos/dask/dask/issues/5110/timeline,,,philipp-block,24493918,MDQ6VXNlcjI0NDkzOTE4,https://avatars.githubusercontent.com/u/24493918?v=4,,https://api.github.com/users/philipp-block,https://github.com/philipp-block,https://api.github.com/users/philipp-block/followers,https://api.github.com/users/philipp-block/following{/other_user},https://api.github.com/users/philipp-block/gists{/gist_id},https://api.github.com/users/philipp-block/starred{/owner}{/repo},https://api.github.com/users/philipp-block/subscriptions,https://api.github.com/users/philipp-block/orgs,https://api.github.com/users/philipp-block/repos,https://api.github.com/users/philipp-block/events{/privacy},https://api.github.com/users/philipp-block/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5110/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
208,https://api.github.com/repos/dask/dask/issues/5113,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5113/labels{/name},https://api.github.com/repos/dask/dask/issues/5113/comments,https://api.github.com/repos/dask/dask/issues/5113/events,https://github.com/dask/dask/issues/5113,469882345,MDU6SXNzdWU0Njk4ODIzNDU=,5113,Couldn't head return early?,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,4,2019-07-18T16:57:59Z,2021-10-13T00:44:20Z,,NONE,,"**Feature Request:** Couldn't `head()` (and perhaps also `tail()`) return early?

I've a largish dataset that I'm building a script against. I've sampled a few tens of thousands of records to accelerate development while having something meaningful to work on, and I'm using `apply()` to populate a few extra columns based on `urlsplit`. (Aside: this might not be the optimal way; if there is a better one, kindly let me know in a comment.)

While testing the script, I figured I'd use head() at the very end of the pipeline (rather than before, since that would return a Pandas dataframe and I'd like to make sure I don't run into Dash incompatibilities).

It seems that Dash applies the function to the whole sample regardless. Couldn't it bail early instead, propagate the head call to each partition or something so they return as soon as they found enough records?

(The temporary workaround is of course to create an even smaller sample in the meanwhile.)",,https://api.github.com/repos/dask/dask/issues/5113/timeline,,,ddebernardy,225259,MDQ6VXNlcjIyNTI1OQ==,https://avatars.githubusercontent.com/u/225259?v=4,,https://api.github.com/users/ddebernardy,https://github.com/ddebernardy,https://api.github.com/users/ddebernardy/followers,https://api.github.com/users/ddebernardy/following{/other_user},https://api.github.com/users/ddebernardy/gists{/gist_id},https://api.github.com/users/ddebernardy/starred{/owner}{/repo},https://api.github.com/users/ddebernardy/subscriptions,https://api.github.com/users/ddebernardy/orgs,https://api.github.com/users/ddebernardy/repos,https://api.github.com/users/ddebernardy/events{/privacy},https://api.github.com/users/ddebernardy/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5113/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
209,https://api.github.com/repos/dask/dask/issues/5115,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5115/labels{/name},https://api.github.com/repos/dask/dask/issues/5115/comments,https://api.github.com/repos/dask/dask/issues/5115/events,https://github.com/dask/dask/issues/5115,470049796,MDU6SXNzdWU0NzAwNDk3OTY=,5115,Adding `copy` function and standardizing `copy` method,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2019-07-18T23:46:44Z,2019-07-18T23:46:44Z,,MEMBER,,"For Dask Array, currently the `copy` method is basically a no-op that creates a new Dask Array object unless it is a single chunk, in which case it calls `.copy` on that chunk. However it might make a bit more sense to use `map_blocks` to call `copy` on all chunks regardless of how many there are. This would provide a solution (albeit a manual one) to [problems like this one]( https://github.com/dask/dask/issues/3595#issuecomment-449544992 ). It would also make the behavior here a bit easier to understand.

Additionally it would be valuable to have a `copy` function to override `np.copy` with. This would help in user code like `np.copy(a)` where `a` is a Dask Array. Currently this materializes a NumPy array, which is not likely what users would expect.",,https://api.github.com/repos/dask/dask/issues/5115/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5115/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
210,https://api.github.com/repos/dask/dask/issues/5127,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5127/labels{/name},https://api.github.com/repos/dask/dask/issues/5127/comments,https://api.github.com/repos/dask/dask/issues/5127/events,https://github.com/dask/dask/issues/5127,470929526,MDU6SXNzdWU0NzA5Mjk1MjY=,5127,Custom defined Aggregations faile with empty partitiions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2019-07-22T07:08:38Z,2021-10-13T00:41:13Z,,CONTRIBUTOR,,"I was trying to apply a custom aggregation on data that were read from a csv. The csvs contained data per day. After that I wanted to apply a filter (`loc`) on the data on a column. The result was that one of my partitions was left empty. So when trying to execute my defined Aggregation I got the following error message:

```python
ValueError: multiple levels only valid with MultiIndex
```
since I was grouping by with more than one keys. Grouping  with on field, succeeds. You can see that on the following example:

```python
df_empty = pd.DataFrame(columns=['col1', 'col2', 'col3', 'col4'])
ddf_empty = dd.from_pandas(df_empty, npartitions=4)
ddf_empty.groupby(['col1', 'col2', 'col3']).col4.agg(a_in_data).compute()

---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-54-eb3f6087572d> in <module>
----> 1 ddf_empty.groupby(['col1', 'col2', 'col3']).col4.agg(a_in_data).compute()

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/base.py in compute(self, **kwargs)
    173         dask.base.compute
    174         """"""
--> 175         (result,) = compute(self, traverse=False, **kwargs)
    176         return result
    177 

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/base.py in compute(*args, **kwargs)
    444     keys = [x.__dask_keys__() for x in collections]
    445     postcomputes = [x.__dask_postcompute__() for x in collections]
--> 446     results = schedule(dsk, keys, **kwargs)
    447     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    448 

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     80         get_id=_thread_get_id,
     81         pack_exception=pack_exception,
---> 82         **kwargs
     83     )
     84 

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    489                         _execute_task(task, data)  # Re-execute locally
    490                     else:
--> 491                         raise_exception(exc, tb)
    492                 res, worker_id = loads(res_info)
    493                 state[""cache""][key] = res

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/compatibility.py in reraise(exc, tb)
    128         if exc.__traceback__ is not tb:
    129             raise exc.with_traceback(tb)
--> 130         raise exc
    131 
    132     import pickle as cPickle

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    231     try:
    232         task, data = loads(task_info)
--> 233         result = _execute_task(task, data)
    234         id = get_id()
    235         result = dumps((result, id))

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    116     elif istask(arg):
    117         func, args = arg[0], arg[1:]
--> 118         args2 = [_execute_task(a, cache) for a in args]
    119         return func(*args2)
    120     elif not ishashable(arg):

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/core.py in <listcomp>(.0)
    116     elif istask(arg):
    117         func, args = arg[0], arg[1:]
--> 118         args2 = [_execute_task(a, cache) for a in args]
    119         return func(*args2)
    120     elif not ishashable(arg):

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    117         func, args = arg[0], arg[1:]
    118         args2 = [_execute_task(a, cache) for a in args]
--> 119         return func(*args2)
    120     elif not ishashable(arg):
    121         return arg

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/compatibility.py in apply(func, args, kwargs)
    105     def apply(func, args, kwargs=None):
    106         if kwargs:
--> 107             return func(*args, **kwargs)
    108         else:
    109             return func(*args)

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/dataframe/groupby.py in _agg_finalize(df, aggregate_funcs, finalize_funcs, level)
    860 def _agg_finalize(df, aggregate_funcs, finalize_funcs, level):
    861     # finish the final aggregation level
--> 862     df = _groupby_apply_funcs(df, funcs=aggregate_funcs, level=level)
    863 
    864     # and finalize the result

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/dataframe/groupby.py in _groupby_apply_funcs(df, *index, **kwargs)
    833 
    834     funcs = kwargs.pop(""funcs"")
--> 835     grouped = _groupby_raise_unaligned(df, **kwargs)
    836 
    837     result = collections.OrderedDict()

~/virtualenvs/statistics3/lib/python3.6/site-packages/dask/dataframe/groupby.py in _groupby_raise_unaligned(df, **kwargs)
    161         # We want multiple keys
    162         kwargs.update(by=list(by))
--> 163     return df.groupby(**kwargs)
    164 
    165 

~/virtualenvs/statistics3/lib/python3.6/site-packages/pandas/core/generic.py in groupby(self, by, axis, level, as_index, sort, group_keys, squeeze, observed, **kwargs)
   7630         return groupby(self, by=by, axis=axis, level=level, as_index=as_index,
   7631                        sort=sort, group_keys=group_keys, squeeze=squeeze,
-> 7632                        observed=observed, **kwargs)
   7633 
   7634     def asfreq(self, freq, method=None, how=None, normalize=False,

~/virtualenvs/statistics3/lib/python3.6/site-packages/pandas/core/groupby/groupby.py in groupby(obj, by, **kwds)
   2108         raise TypeError('invalid type: {}'.format(obj))
   2109 
-> 2110     return klass(obj, by, **kwds)

~/virtualenvs/statistics3/lib/python3.6/site-packages/pandas/core/groupby/groupby.py in __init__(self, obj, keys, axis, level, grouper, exclusions, selection, as_index, sort, group_keys, squeeze, observed, **kwargs)
    358                                                     sort=sort,
    359                                                     observed=observed,
--> 360                                                     mutated=self.mutated)
    361 
    362         self.obj = obj

~/virtualenvs/statistics3/lib/python3.6/site-packages/pandas/core/groupby/grouper.py in _get_grouper(obj, key, axis, level, sort, observed, mutated, validate)
    458                     raise ValueError('No group keys passed!')
    459                 else:
--> 460                     raise ValueError('multiple levels only valid with '
    461                                      'MultiIndex')
    462 

ValueError: multiple levels only valid with MultiIndex
```

Grouping by on a single column works correclty.

```python
ddf_empty.groupby('col1').col4.agg(a_in_data).compute()
Series([], Name: col4, dtype: bool)
```
Using the same dask dataframe on the `custom_sum` Aggregation described on the dask documentation gives me the same result:

```python
custom_sum = dd.Aggregation('custom_sum', lambda s: s.sum(), lambda s0: s0.sum())
ddf_empty.groupby(['col1', 'col2', 'col3']).col4.agg(custom_sum).compute() # raises the Exception above
```

Dask version: 2.1.0
distributed version: 2.0.1
Python version: 3.6.8
pandas version: 0.24.2",,https://api.github.com/repos/dask/dask/issues/5127/timeline,,,avlahop,3893010,MDQ6VXNlcjM4OTMwMTA=,https://avatars.githubusercontent.com/u/3893010?v=4,,https://api.github.com/users/avlahop,https://github.com/avlahop,https://api.github.com/users/avlahop/followers,https://api.github.com/users/avlahop/following{/other_user},https://api.github.com/users/avlahop/gists{/gist_id},https://api.github.com/users/avlahop/starred{/owner}{/repo},https://api.github.com/users/avlahop/subscriptions,https://api.github.com/users/avlahop/orgs,https://api.github.com/users/avlahop/repos,https://api.github.com/users/avlahop/events{/privacy},https://api.github.com/users/avlahop/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5127/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
211,https://api.github.com/repos/dask/dask/issues/5133,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5133/labels{/name},https://api.github.com/repos/dask/dask/issues/5133/comments,https://api.github.com/repos/dask/dask/issues/5133/events,https://github.com/dask/dask/issues/5133,471355841,MDU6SXNzdWU0NzEzNTU4NDE=,5133,Generalize categorical handling to support cuDF and other backend libraries,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2019-07-22T21:51:38Z,2021-10-13T01:28:52Z,,MEMBER,,"As discussed in #5090 , we should generalize Dask's categorical handling to support multiple backend dataframe libraries. Currently, examples like the following will cause TypeErrors:

```python
pdf = pd.DataFrame({'a':range(5), 'b':['a','a','b','c','q']})
gdf = cudf.from_pandas(pdf)

ddf = dd.from_pandas(pdf, 2)
dgdf = dd.from_pandas(gdf, 2)

categorize(ddf, 'b').compute()
categorize(dgdf, 'b').compute()
```

This issue can serve as a tracker for several generalization sub-tasks. The following functions seem like good candidates for initial work related to categoricals:

- [ ] dask.dataframe.categorical._categorize_block
- [ ] dask.dataframe.categorical._get_categories
- [ ] dask.dataframe.categorical._get_categories_agg
- [ ] dask.dataframe.categorical.categorize
- [ ] dask.dataframe.categorical.CategoricalAccessor
- [ ] dask.dataframe.categorical.CategoricalAccessor. remove_unused_categories
- [ ] dask.dataframe.utils.clear_known_categories
- [ ] dask.dataframe.utils. strip_unknown_categories
",,https://api.github.com/repos/dask/dask/issues/5133/timeline,,,beckernick,8457388,MDQ6VXNlcjg0NTczODg=,https://avatars.githubusercontent.com/u/8457388?v=4,,https://api.github.com/users/beckernick,https://github.com/beckernick,https://api.github.com/users/beckernick/followers,https://api.github.com/users/beckernick/following{/other_user},https://api.github.com/users/beckernick/gists{/gist_id},https://api.github.com/users/beckernick/starred{/owner}{/repo},https://api.github.com/users/beckernick/subscriptions,https://api.github.com/users/beckernick/orgs,https://api.github.com/users/beckernick/repos,https://api.github.com/users/beckernick/events{/privacy},https://api.github.com/users/beckernick/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5133/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
212,https://api.github.com/repos/dask/dask/issues/5158,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5158/labels{/name},https://api.github.com/repos/dask/dask/issues/5158/comments,https://api.github.com/repos/dask/dask/issues/5158/events,https://github.com/dask/dask/issues/5158,473175535,MDU6SXNzdWU0NzMxNzU1MzU=,5158,Why uneven task allocation on many identical operations?,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,5,2019-07-26T04:48:32Z,2021-10-13T01:16:24Z,,CONTRIBUTOR,,"This may be just be a docs issue as I just don't understand what's happening here.

I am on @rjzamora's #5157 branch, but I doubt that's the cause of this issue.

Dask was set up using dask yarn:

```
profile = {
    'worker_vcores': 2,
    'worker_memory': '2.75GB',
    'n_workers': 78,
}
```

My code is very simple:

```
df = dd.read_parquet(s3_parquet, engine='fast_parquet', gather_statistics=False)
len(df)
```
My parquet file is ~74k partitions.

So ~74k tasks are created to read_parquet and get the len. Specifically

![Screenshot from 2019-07-25 23-42-08](https://user-images.githubusercontent.com/1796208/61926356-dd27a080-af35-11e9-8703-ae2998c37b0f.png)

I am having a pretty poor success rate in getting this to run. It fails more times than it passes. The failure is a credentials error which I posted on gitter about. 

That's a bit mysterious, and specific, so I just want to keep this issue about why the task allocation is so uneven. Here are some example shots of the distribution of the number of items processing:

![Screenshot from 2019-07-25 23-44-01](https://user-images.githubusercontent.com/1796208/61926476-51624400-af36-11e9-8532-02871fc96372.png)
![Screenshot from 2019-07-25 23-37-31](https://user-images.githubusercontent.com/1796208/61926477-51624400-af36-11e9-95f4-ff6a672845c7.png)
![Screenshot from 2019-07-25 23-45-48](https://user-images.githubusercontent.com/1796208/61926492-5fb06000-af36-11e9-8b7b-0921eb311f50.png)
![Screenshot from 2019-07-25 23-47-23](https://user-images.githubusercontent.com/1796208/61926539-92f2ef00-af36-11e9-8d45-f0db8895ad7d.png)

Why are all my workers not chugging away at the queue evenly. It appears to me (happy to be wrong) that things would be running faster if the tasks were more evenly allocated.",,https://api.github.com/repos/dask/dask/issues/5158/timeline,,,birdsarah,1796208,MDQ6VXNlcjE3OTYyMDg=,https://avatars.githubusercontent.com/u/1796208?v=4,,https://api.github.com/users/birdsarah,https://github.com/birdsarah,https://api.github.com/users/birdsarah/followers,https://api.github.com/users/birdsarah/following{/other_user},https://api.github.com/users/birdsarah/gists{/gist_id},https://api.github.com/users/birdsarah/starred{/owner}{/repo},https://api.github.com/users/birdsarah/subscriptions,https://api.github.com/users/birdsarah/orgs,https://api.github.com/users/birdsarah/repos,https://api.github.com/users/birdsarah/events{/privacy},https://api.github.com/users/birdsarah/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5158/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
213,https://api.github.com/repos/dask/dask/issues/5159,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5159/labels{/name},https://api.github.com/repos/dask/dask/issues/5159/comments,https://api.github.com/repos/dask/dask/issues/5159/events,https://github.com/dask/dask/issues/5159,473431763,MDU6SXNzdWU0NzM0MzE3NjM=,5159,MemoryError while to_parquet or .repartition ,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,4,2019-07-26T16:07:01Z,2021-10-13T00:32:12Z,,NONE,,"I'm running into a MemoryError when I try to save in a parquet format, or repartition(by size).
I didn't have this issue before, but after merging two dask dataframes, it's giving me this error.
The memory usage of python terminal keeps going up, and the it takes most of my machine's memory even after the error.

```
EWQ = dd.read_parquet('./merged1.parquet')
R = dd.read_parquet('./price.parquet')
print(EWQ.npartitions);print(R.npartitions)#500, 207 each
EWQR = dd.merge(EWQ, R, on = 'Symbol', how='left')
EWQR.npartitions # 500 partitions

with ProgressBar():
    EWQR.to_parquet('./merged2.parquet')
[########################                ] | 61% Completed | 16min 49.2s

Traceback (most recent call last):
  File ""<input>"", line 2, in <module>
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\dask\dataframe\core.py"", line 3618, in to_parquet
    return to_parquet(self, path, *args, **kwargs)
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\dask\dataframe\io\parquet.py"", line 1496, in to_parquet
    out.compute()
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\dask\base.py"", line 175, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\dask\base.py"", line 446, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\dask\threaded.py"", line 82, in get
    **kwargs
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\dask\local.py"", line 491, in get_async
    raise_exception(exc, tb)
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\dask\compatibility.py"", line 130, in reraise
    raise exc
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\dask\local.py"", line 233, in execute_task
    result = _execute_task(task, data)
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\dask\core.py"", line 119, in _execute_task
    return func(*args2)
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\dask\compatibility.py"", line 107, in apply
    return func(*args, **kwargs)
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\dask\dataframe\multi.py"", line 224, in merge_chunk
    out = lhs.merge(*args, **kwargs)
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\pandas\core\frame.py"", line 6868, in merge
    copy=copy, indicator=indicator, validate=validate)
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\pandas\core\reshape\merge.py"", line 48, in merge
    return op.get_result()
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\pandas\core\reshape\merge.py"", line 546, in get_result
    join_index, left_indexer, right_indexer = self._get_join_info()
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\pandas\core\reshape\merge.py"", line 756, in _get_join_info
    right_indexer) = self._get_join_indexers()
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\pandas\core\reshape\merge.py"", line 735, in _get_join_indexers
    how=self.how)
  File ""C:\Users\gunsu.son\AppData\Local\Continuum\miniconda3\lib\site-packages\pandas\core\reshape\merge.py"", line 1146, in _get_join_indexers
    return join_func(lkey, rkey, count, **kwargs)
  File ""pandas/_libs/join.pyx"", line 98, in pandas._libs.join.left_outer_join
MemoryError

```

One thing I'm a little bit suspicious about is that merged1.parquet file is unevenly partitioned in terms of size. It was partitioned into 500 files, but when I look at the size of each, some partitions have only 23KB, while some others have >500MB. I'm uncertain if this has to do with the error through. What possibly is causing the problem? How can I evade MemoryError in this case?

",,https://api.github.com/repos/dask/dask/issues/5159/timeline,,,matthewgson,46496637,MDQ6VXNlcjQ2NDk2NjM3,https://avatars.githubusercontent.com/u/46496637?v=4,,https://api.github.com/users/matthewgson,https://github.com/matthewgson,https://api.github.com/users/matthewgson/followers,https://api.github.com/users/matthewgson/following{/other_user},https://api.github.com/users/matthewgson/gists{/gist_id},https://api.github.com/users/matthewgson/starred{/owner}{/repo},https://api.github.com/users/matthewgson/subscriptions,https://api.github.com/users/matthewgson/orgs,https://api.github.com/users/matthewgson/repos,https://api.github.com/users/matthewgson/events{/privacy},https://api.github.com/users/matthewgson/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5159/reactions,0,0,0,0,0,0,0,0,0,matthewgson,46496637.0,MDQ6VXNlcjQ2NDk2NjM3,https://avatars.githubusercontent.com/u/46496637?v=4,,https://api.github.com/users/matthewgson,https://github.com/matthewgson,https://api.github.com/users/matthewgson/followers,https://api.github.com/users/matthewgson/following{/other_user},https://api.github.com/users/matthewgson/gists{/gist_id},https://api.github.com/users/matthewgson/starred{/owner}{/repo},https://api.github.com/users/matthewgson/subscriptions,https://api.github.com/users/matthewgson/orgs,https://api.github.com/users/matthewgson/repos,https://api.github.com/users/matthewgson/events{/privacy},https://api.github.com/users/matthewgson/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
214,https://api.github.com/repos/dask/dask/issues/5160,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5160/labels{/name},https://api.github.com/repos/dask/dask/issues/5160/comments,https://api.github.com/repos/dask/dask/issues/5160/events,https://github.com/dask/dask/issues/5160,473446378,MDU6SXNzdWU0NzM0NDYzNzg=,5160,interpolation in dask dataframe,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,4,2019-07-26T16:45:52Z,2021-10-13T00:19:23Z,,NONE,,"Hello, is there an implementation of 1D interpolation function for irregularly sampled points for dask dataframe columns? Applying a numpy/scipy interpolation function to a column directly through DataFrame.apply() appears very slow, compared with, say, using them separately on an array of the same length without the dask framework.",,https://api.github.com/repos/dask/dask/issues/5160/timeline,,,RealPolitiX,19738116,MDQ6VXNlcjE5NzM4MTE2,https://avatars.githubusercontent.com/u/19738116?v=4,,https://api.github.com/users/RealPolitiX,https://github.com/RealPolitiX,https://api.github.com/users/RealPolitiX/followers,https://api.github.com/users/RealPolitiX/following{/other_user},https://api.github.com/users/RealPolitiX/gists{/gist_id},https://api.github.com/users/RealPolitiX/starred{/owner}{/repo},https://api.github.com/users/RealPolitiX/subscriptions,https://api.github.com/users/RealPolitiX/orgs,https://api.github.com/users/RealPolitiX/repos,https://api.github.com/users/RealPolitiX/events{/privacy},https://api.github.com/users/RealPolitiX/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5160/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
215,https://api.github.com/repos/dask/dask/issues/5198,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5198/labels{/name},https://api.github.com/repos/dask/dask/issues/5198/comments,https://api.github.com/repos/dask/dask/issues/5198/events,https://github.com/dask/dask/issues/5198,475599479,MDU6SXNzdWU0NzU1OTk0Nzk=,5198,Incorrect behavior for dask array __setitem__ ,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2019-08-01T10:21:21Z,2019-08-03T08:40:31Z,,NONE,,"Inplace modification of a dask array via `__setindex__` always assumes input array is boolean.

```python
# Using dask v2.2.0, numpy 1.17.0
import dask.array as da
z = da.zeros(5)
z[da.arange(5)] = 1
print(z.compute())
# [0. 1. 1. 1. 1.]
```

I think this could be solved by checking the type of the indexing array around here: https://github.com/dask/dask/blob/02cbc4667e3b06cae0baa2b63d85622145cc0bc2/dask/array/core.py#L1401-L1404",,https://api.github.com/repos/dask/dask/issues/5198/timeline,,,ivirshup,8238804,MDQ6VXNlcjgyMzg4MDQ=,https://avatars.githubusercontent.com/u/8238804?v=4,,https://api.github.com/users/ivirshup,https://github.com/ivirshup,https://api.github.com/users/ivirshup/followers,https://api.github.com/users/ivirshup/following{/other_user},https://api.github.com/users/ivirshup/gists{/gist_id},https://api.github.com/users/ivirshup/starred{/owner}{/repo},https://api.github.com/users/ivirshup/subscriptions,https://api.github.com/users/ivirshup/orgs,https://api.github.com/users/ivirshup/repos,https://api.github.com/users/ivirshup/events{/privacy},https://api.github.com/users/ivirshup/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5198/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
216,https://api.github.com/repos/dask/dask/issues/5199,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5199/labels{/name},https://api.github.com/repos/dask/dask/issues/5199/comments,https://api.github.com/repos/dask/dask/issues/5199/events,https://github.com/dask/dask/issues/5199,475618838,MDU6SXNzdWU0NzU2MTg4Mzg=,5199,Inplace operators behaviour for dask arrays inconsistent with numpy,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2019-08-01T11:04:08Z,2022-03-23T17:02:09Z,,NONE,,"Inplace operators modify numpy arrays inplace, but end up making a copy of dask arrays. 

```python
# Using dask v2.2.0, numpy 1.17.0
import numpy as np
import dask.array as da
x_np = np.zeros(5)
y_np = x_np
y_np += 1

x_da = da.zeros(5)
y_da = x_da
y_da += 1

print(x_np == y_np)
# [ True  True  True  True  True]
print(id(x_np) == id(y_np))
# True
print(x_da.compute() == y_da.compute())
# [False False False False False]
print(id(x_da) == id(y_da))
# False
```

I'm not sure if you'd qualify this as a bug, since the behaviour between the two is known to not line up completely. I have also seen related issues have been brought up, like #2588 and #2000. 

I think a warning for this behavior could be useful. Alternatively, I think this could just be an inplace operation. Here's are some proof of concept implementations. This should probably be done with ufuncs if implemented.

```python
import dask.array as da
import numpy as np

# Something like this
def dask_iadd(x, y):
    np.add(x, y, out=x)
    return x
da.core.Array.__iadd__ = dask_iadd

a = da.ones((10, 10))
b = a
b += 1
print(id(a) == id(b))
# True
print(np.all(a.compute() == b.compute()))
# True
```

<details>
<summary> Previous crude implementation </summary>

```python
import dask.array as da

def _replace(x, y):
    x._meta = y._meta
    x.dask = y.dask
    x.name = y.name
    x._chunks = y.chunks
    return x

da.core.Array.__iadd__ = lambda x, y: _replace(x, x + y)
# etc

z = da.zeros((2, 2))
z += 1
z.compute()
#  array([[1., 1.],
#         [1., 1.]])
```

</details>

",,https://api.github.com/repos/dask/dask/issues/5199/timeline,,,ivirshup,8238804,MDQ6VXNlcjgyMzg4MDQ=,https://avatars.githubusercontent.com/u/8238804?v=4,,https://api.github.com/users/ivirshup,https://github.com/ivirshup,https://api.github.com/users/ivirshup/followers,https://api.github.com/users/ivirshup/following{/other_user},https://api.github.com/users/ivirshup/gists{/gist_id},https://api.github.com/users/ivirshup/starred{/owner}{/repo},https://api.github.com/users/ivirshup/subscriptions,https://api.github.com/users/ivirshup/orgs,https://api.github.com/users/ivirshup/repos,https://api.github.com/users/ivirshup/events{/privacy},https://api.github.com/users/ivirshup/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5199/reactions,0,0,0,0,0,0,0,0,0,jsignell,4806877.0,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
217,https://api.github.com/repos/dask/dask/issues/5202,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5202/labels{/name},https://api.github.com/repos/dask/dask/issues/5202/comments,https://api.github.com/repos/dask/dask/issues/5202/events,https://github.com/dask/dask/issues/5202,475744091,MDU6SXNzdWU0NzU3NDQwOTE=,5202,Sparse SVD Implementation,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2019-08-01T15:20:13Z,2021-10-13T00:22:48Z,,MEMBER,,"Naively I tried to run svd on a sparse matrix:

```python
import dask.array as da
import scipy.sparse
import numpy as np

data = np.random.rand(100,100)
sparse = scipy.sparse.csc_matrix(data)
ds = da.from_array(sparse)
u, s, v = da.linalg.svd(ds)
v.compute()
```

The following breaks with a tuple index error:
```
~/GitRepos/dask/dask/array/linalg.py in _wrapped_qr(a)
     45     """"""
     46     # workaround may be removed when numpy stops rejecting edge cases
---> 47     if a.shape[0] == 0:
     48         return np.zeros((0, 0)), np.zeros((0, a.shape[1]))
     49     else:

IndexError: tuple index out of range
```

Is there any interest in supporting a sparse SVD implementation with dask ?

cc @davidsebfischer",,https://api.github.com/repos/dask/dask/issues/5202/timeline,,,quasiben,1403768,MDQ6VXNlcjE0MDM3Njg=,https://avatars.githubusercontent.com/u/1403768?v=4,,https://api.github.com/users/quasiben,https://github.com/quasiben,https://api.github.com/users/quasiben/followers,https://api.github.com/users/quasiben/following{/other_user},https://api.github.com/users/quasiben/gists{/gist_id},https://api.github.com/users/quasiben/starred{/owner}{/repo},https://api.github.com/users/quasiben/subscriptions,https://api.github.com/users/quasiben/orgs,https://api.github.com/users/quasiben/repos,https://api.github.com/users/quasiben/events{/privacy},https://api.github.com/users/quasiben/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5202/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
218,https://api.github.com/repos/dask/dask/issues/5211,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5211/labels{/name},https://api.github.com/repos/dask/dask/issues/5211/comments,https://api.github.com/repos/dask/dask/issues/5211/events,https://github.com/dask/dask/issues/5211,476120535,MDU6SXNzdWU0NzYxMjA1MzU=,5211,Computing windowed statistics,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2019-08-02T10:51:20Z,2020-02-10T09:16:33Z,,CONTRIBUTOR,,"I have a use case where I need to compute some statistic over windows of a 1D input array. In some cases these are moving windows with a regular size and step, but in other cases the size and step of the windows may be irregular. I'm trying to figure out the best strategy for constructing this as a Dask graph.

In general I have some input data which is a dask array, e.g. for illustration:

```python
x = da.arange(1000, chunks=100)
```

... and I have an array of window start and stop indices, e.g.:

```python
indices = np.array([[i, i+100] for i in range(0, 500, 50)])
```

I can see how to manually construct a graph which has the input values for each window, e.g.:

```
dsk = {
    ('windows', c): (dask.base.getitem, x, (slice(start, stop),))
    for c, (start, stop) in enumerate(indices)
}
chunks = (tuple(stop - start for start, stop in indices),)
windows = da.Array(dsk, name='windows', chunks=chunks, dtype=x.dtype)
```

...and from there I can see how to use `map_blocks` to compute a statistic for each window, e.g.:

```
result = windows.map_blocks(np.mean, chunks=((1,) * len(windows.chunks[0]),), dtype=np.float64, keepdims=True)
```

Is this the best strategy? Am I missing an easier or more efficient way?

A follow-up question, what if the input array has much larger chunk sizes than the window sizes? I.e., multiple windows fall into each input chunk (which a few windows overlapping two chunks)? Will the above strategy have inefficiencies in that case (e.g., causing input chunks to be computed multiple times)?

I did look at `map_overlaps()` but I think because the windows have arbitrary starts and stops then I need something different.

Thanks in advance.

",,https://api.github.com/repos/dask/dask/issues/5211/timeline,,,alimanfoo,703554,MDQ6VXNlcjcwMzU1NA==,https://avatars.githubusercontent.com/u/703554?v=4,,https://api.github.com/users/alimanfoo,https://github.com/alimanfoo,https://api.github.com/users/alimanfoo/followers,https://api.github.com/users/alimanfoo/following{/other_user},https://api.github.com/users/alimanfoo/gists{/gist_id},https://api.github.com/users/alimanfoo/starred{/owner}{/repo},https://api.github.com/users/alimanfoo/subscriptions,https://api.github.com/users/alimanfoo/orgs,https://api.github.com/users/alimanfoo/repos,https://api.github.com/users/alimanfoo/events{/privacy},https://api.github.com/users/alimanfoo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5211/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
219,https://api.github.com/repos/dask/dask/issues/5259,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5259/labels{/name},https://api.github.com/repos/dask/dask/issues/5259/comments,https://api.github.com/repos/dask/dask/issues/5259/events,https://github.com/dask/dask/issues/5259,479448656,MDU6SXNzdWU0Nzk0NDg2NTY=,5259,sparse + dask array not supported,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,9,2019-08-12T02:49:39Z,2019-08-18T16:32:26Z,,MEMBER,,"cc @hameerabbasi 

dask+sparse works, but not sparse+dask.

I think dask should probably implement this case, via it's `__array_ufunc__` method. Here's the traceback:
```
In [1]: import sparse

In [2]: import dask.array as da

In [3]: import numpy as np

In [4]: x = np.arange(3)

In [5]: y = sparse.COO(x)

In [6]: z = da.from_array(y, chunks=3)

In [7]: z + y
Out[7]: dask.array<add, shape=(3,), dtype=int64, chunksize=(3,)>

In [8]: y + z
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-8-ff96b8185f8d> in <module>
----> 1 y + z

~/miniconda3/envs/xarray-py37-dev/lib/python3.7/site-packages/numpy/lib/mixins.py in func(self, other)
     23         if _disables_array_ufunc(other):
     24             return NotImplemented
---> 25         return ufunc(self, other)
     26     func.__name__ = '__{}__'.format(name)
     27     return func

TypeError: operand type(s) all returned NotImplemented from __array_ufunc__(<ufunc 'add'>, '__call__', <COO: shape=(3,), dtype=int64, nnz=2, fill_value=0>, dask.array<array, shape=(3,), dtype=int64, chunksize=(3,)>): 'COO', 'Array'
```",,https://api.github.com/repos/dask/dask/issues/5259/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5259/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
220,https://api.github.com/repos/dask/dask/issues/5263,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5263/labels{/name},https://api.github.com/repos/dask/dask/issues/5263/comments,https://api.github.com/repos/dask/dask/issues/5263/events,https://github.com/dask/dask/issues/5263,479737947,MDU6SXNzdWU0Nzk3Mzc5NDc=,5263,`DataFrame.values` doesn't work after reduction in `map_partitions`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2019-08-12T16:27:15Z,2019-09-06T19:38:04Z,,CONTRIBUTOR,,"I don't know if this is to be expected, but the dask graph appears to break when a reduction is performed in the function passed to `map_partitions`.

It seems like the dask graph expects pd.DataFrames out of `map_partitions` and fails when that's not the case.

Code example:
```
import dask
print(dask.__version__)

import dask.dataframe as dd
import pandas as pd

df = pd.DataFrame({""A"": [1, 2]})
ddf = dd.from_pandas(df, npartitions=1)

meta = (""A"", ""int"")
ddf.map_partitions(lambda df: df[""A""].sum(), meta=meta).values.compute()
```

Output:
```
2.2.0
Traceback (most recent call last):
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/IPython/core/interactiveshell.py"", line 3296, in run_code
    exec(code_obj, self.user_global_ns, self.user_ns)
  File ""<ipython-input-21-71ba78ae2b82>"", line 13, in <module>
    ddf.map_partitions(lambda df: df[""A""].sum(), meta=meta).values.compute()
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/base.py"", line 175, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/base.py"", line 446, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/threaded.py"", line 82, in get
    **kwargs
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/local.py"", line 491, in get_async
    raise_exception(exc, tb)
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/compatibility.py"", line 130, in reraise
    raise exc
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/local.py"", line 233, in execute_task
    result = _execute_task(task, data)
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/core.py"", line 119, in _execute_task
    return func(*args2)
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/optimization.py"", line 1059, in __call__
    return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/core.py"", line 149, in get
    result = _execute_task(task, cache)
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/core.py"", line 119, in _execute_task
    return func(*args2)
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/compatibility.py"", line 107, in apply
    return func(*args, **kwargs)
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/dataframe/core.py"", line 4829, in apply_and_enforce
    df = func(*args, **kwargs)
  File ""/Users/xrzq/miniconda3/envs/py36/lib/python3.6/site-packages/dask/dataframe/methods.py"", line 274, in values
    return df.values
AttributeError: 'numpy.int64' object has no attribute 'values'
```",,https://api.github.com/repos/dask/dask/issues/5263/timeline,,,lr4d,44430780,MDQ6VXNlcjQ0NDMwNzgw,https://avatars.githubusercontent.com/u/44430780?v=4,,https://api.github.com/users/lr4d,https://github.com/lr4d,https://api.github.com/users/lr4d/followers,https://api.github.com/users/lr4d/following{/other_user},https://api.github.com/users/lr4d/gists{/gist_id},https://api.github.com/users/lr4d/starred{/owner}{/repo},https://api.github.com/users/lr4d/subscriptions,https://api.github.com/users/lr4d/orgs,https://api.github.com/users/lr4d/repos,https://api.github.com/users/lr4d/events{/privacy},https://api.github.com/users/lr4d/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5263/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
221,https://api.github.com/repos/dask/dask/issues/5278,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5278/labels{/name},https://api.github.com/repos/dask/dask/issues/5278/comments,https://api.github.com/repos/dask/dask/issues/5278/events,https://github.com/dask/dask/issues/5278,480807523,MDU6SXNzdWU0ODA4MDc1MjM=,5278,ValueError in dask.array.reductions.reduction,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2019-08-14T17:50:06Z,2019-08-15T10:47:09Z,,CONTRIBUTOR,,"Ran into this error while attempting to use `dask.array.reductions.reduction` to wrap `numpy.ma.median`. This only happens when `axis=(0,1)` or `axis=(2,3)` or similar. Does not happen with `axis=0` or similar.

My dask version is 2.2.0

```
Traceback (most recent call last):
  File ""/home/stephanie/.local/lib/python3.6/site-packages/dask/array/reductions.py"", line 304, in partial_reduce
    meta = func(reduced_meta, computing_meta=True)
  File ""/home/stephanie/.local/lib/python3.6/site-packages/toolz/functoolz.py"", line 486, in __call__
    ret = self.first(*args, **kwargs)
TypeError: _concatenate2() got an unexpected keyword argument 'computing_meta'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""test_reduction.py"", line 14, in <module>
    keepdims=True
  File ""/home/stephanie/.local/lib/python3.6/site-packages/dask/array/reductions.py"", line 188, in reduction
    reduced_meta=reduced_meta,
  File ""/home/stephanie/.local/lib/python3.6/site-packages/dask/array/reductions.py"", line 253, in _tree_reduce
    reduced_meta=reduced_meta,
  File ""/home/stephanie/.local/lib/python3.6/site-packages/dask/array/reductions.py"", line 307, in partial_reduce
    meta = func(reduced_meta)
  File ""/home/stephanie/.local/lib/python3.6/site-packages/toolz/functoolz.py"", line 488, in __call__
    ret = f(ret)
  File ""/home/stephanie/.local/lib/python3.6/site-packages/numpy/ma/extras.py"", line 687, in median
    keepdims=keepdims)
  File ""/home/stephanie/.local/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 3497, in median
    overwrite_input=overwrite_input)
  File ""/home/stephanie/.local/lib/python3.6/site-packages/numpy/lib/function_base.py"", line 3399, in _ureduce
    a = a.reshape(a.shape[:nkeep] + (-1,))
ValueError: cannot reshape array of size 0 into shape (0,0,newaxis)
```

Can be reproduced with the following code:
```
import dask.array as da
import numpy as np

arr = da.from_array(np.arange(384).reshape(3,4,4,8)).rechunk((1,1,4,8))

reduced = da.reductions.reduction(
        arr,
        chunk=lambda arr, axis, keepdims: arr,
        aggregate=np.ma.median,
        split_every={ax: arr.shape[ax] for ax in range(len(arr.shape))},
        concatenate=True,
        dtype=np.int64,
        axis=(0,1),
        keepdims=True
)
```",,https://api.github.com/repos/dask/dask/issues/5278/timeline,,,stephaniegott,13060286,MDQ6VXNlcjEzMDYwMjg2,https://avatars.githubusercontent.com/u/13060286?v=4,,https://api.github.com/users/stephaniegott,https://github.com/stephaniegott,https://api.github.com/users/stephaniegott/followers,https://api.github.com/users/stephaniegott/following{/other_user},https://api.github.com/users/stephaniegott/gists{/gist_id},https://api.github.com/users/stephaniegott/starred{/owner}{/repo},https://api.github.com/users/stephaniegott/subscriptions,https://api.github.com/users/stephaniegott/orgs,https://api.github.com/users/stephaniegott/repos,https://api.github.com/users/stephaniegott/events{/privacy},https://api.github.com/users/stephaniegott/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5278/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
222,https://api.github.com/repos/dask/dask/issues/5281,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5281/labels{/name},https://api.github.com/repos/dask/dask/issues/5281/comments,https://api.github.com/repos/dask/dask/issues/5281/events,https://github.com/dask/dask/issues/5281,481211205,MDU6SXNzdWU0ODEyMTEyMDU=,5281,Docs: Exactly which numpy slicing features does an array-like need to support to be used with Dask.from_array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2019-08-15T15:39:42Z,2019-08-20T14:19:02Z,,NONE,,"From https://docs.dask.org/en/latest/array-creation.html#create-dask-arrays

> any format that supports NumPy-style slicing

but the [from_array](https://docs.dask.org/en/latest/array-api.html#dask.array.from_array) method has the `fancy` argument, suggesting that there's a way to implement a bare minimum of array slicing in the backend and let dask do the rest of the work.

What is that bare minimum?

`dask.array.slicing` seems to have utilities to fill out a lot of possibilities; my hope is that the backend for an `N`-D array would only have to support an `N`-length tuple of `slice` objects with >=0 `start` and `stop`,  `step=None`.

Context:  [h5py_like](https://github.com/clbarnes/h5py_like) attempts to provide base classes and utilities for libraries implementing ndarray storage (like [pyn5](https://github.com/pattonw/rust-pyn5)) to make them behave like h5py objects, including *some* [array indexing cases](https://github.com/clbarnes/h5py_like/blob/master/h5py_like/shape_utils.py) and rudimentary concurrent IO. I'd love to offload both responsibilities to dask's utilities, as it's much more mature, better tested, and has more eyes on it.

Same question for writing with `dask.array.store`.",,https://api.github.com/repos/dask/dask/issues/5281/timeline,,,clbarnes,8995328,MDQ6VXNlcjg5OTUzMjg=,https://avatars.githubusercontent.com/u/8995328?v=4,,https://api.github.com/users/clbarnes,https://github.com/clbarnes,https://api.github.com/users/clbarnes/followers,https://api.github.com/users/clbarnes/following{/other_user},https://api.github.com/users/clbarnes/gists{/gist_id},https://api.github.com/users/clbarnes/starred{/owner}{/repo},https://api.github.com/users/clbarnes/subscriptions,https://api.github.com/users/clbarnes/orgs,https://api.github.com/users/clbarnes/repos,https://api.github.com/users/clbarnes/events{/privacy},https://api.github.com/users/clbarnes/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5281/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
223,https://api.github.com/repos/dask/dask/issues/5284,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5284/labels{/name},https://api.github.com/repos/dask/dask/issues/5284/comments,https://api.github.com/repos/dask/dask/issues/5284/events,https://github.com/dask/dask/issues/5284,481416403,MDU6SXNzdWU0ODE0MTY0MDM=,5284,Using retries with to_parquet incurrs data loss,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,8,2019-08-16T02:39:39Z,2021-10-13T02:21:53Z,,CONTRIBUTOR,,"I am experiencing problems with s3 errors (https://github.com/dask/s3fs/issues/218) so I am using multiple retries to work around as follows:

```py
        tasks = df.to_parquet(
            path=f'out.parquet',
            engine='fastparquet',
            storage_options={'s3_additional_kwargs': sse_args},
            compute=False,
        )
        client.compute(tasks, sync=True, retries=10)
```

This has allowed my code to continue and finish successfully.

However, some data is lost.

Specifically, I started with 3105 partitions and have ended up with 3088 (a difference of 17). My worker logs show 24 ""Access Denied"" errors, which is the s3 error I'm experiencing and 1 ValueError.

```
 ""distributed.worker - WARNING -  Compute Failed\nFunction:  execute_task\nargs:      ((<function safe_head at 0x7fc8a0daa6a8>, (subgraph_callable, (<function read_parquet_part at 0x7fc8a0d65ae8>, <function FastParquetEngine.read_partition at 0x7fc89e181400>, <s3fs.core.S3FileSystem object at 0x7fc8c1359eb8>, Empty DataFrame\nColumns: [metadata_timestamp, metadata_creation_timestamp]\nIndex: [], 'xxx', ['metadata_timestamp', 'metadata_creation_timestamp'], None, {'pf': None, 'categories': {}}), 'read-parquet-7cc708927a5151ff485c9fe42eb7fa69'), 5))\nkwargs:    {}\nException: ValueError('to assemble mappings requires at least that [year, month, day] be specified: [day,month,year] is missing')\n""
```",,https://api.github.com/repos/dask/dask/issues/5284/timeline,,,birdsarah,1796208,MDQ6VXNlcjE3OTYyMDg=,https://avatars.githubusercontent.com/u/1796208?v=4,,https://api.github.com/users/birdsarah,https://github.com/birdsarah,https://api.github.com/users/birdsarah/followers,https://api.github.com/users/birdsarah/following{/other_user},https://api.github.com/users/birdsarah/gists{/gist_id},https://api.github.com/users/birdsarah/starred{/owner}{/repo},https://api.github.com/users/birdsarah/subscriptions,https://api.github.com/users/birdsarah/orgs,https://api.github.com/users/birdsarah/repos,https://api.github.com/users/birdsarah/events{/privacy},https://api.github.com/users/birdsarah/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5284/reactions,0,0,0,0,0,0,0,0,0,birdsarah,1796208.0,MDQ6VXNlcjE3OTYyMDg=,https://avatars.githubusercontent.com/u/1796208?v=4,,https://api.github.com/users/birdsarah,https://github.com/birdsarah,https://api.github.com/users/birdsarah/followers,https://api.github.com/users/birdsarah/following{/other_user},https://api.github.com/users/birdsarah/gists{/gist_id},https://api.github.com/users/birdsarah/starred{/owner}{/repo},https://api.github.com/users/birdsarah/subscriptions,https://api.github.com/users/birdsarah/orgs,https://api.github.com/users/birdsarah/repos,https://api.github.com/users/birdsarah/events{/privacy},https://api.github.com/users/birdsarah/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
224,https://api.github.com/repos/dask/dask/issues/5292,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5292/labels{/name},https://api.github.com/repos/dask/dask/issues/5292/comments,https://api.github.com/repos/dask/dask/issues/5292/events,https://github.com/dask/dask/issues/5292,482222149,MDU6SXNzdWU0ODIyMjIxNDk=,5292,ValueError of DataFrame.merge,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,8,2019-08-19T10:09:45Z,2021-10-13T02:19:38Z,,NONE,,"The `DataFrame.join` cannot give the correct answer:

```python
>>> import dask.dataframe as dd
>>>
>>> df1 = pd.DataFrame([[1,3,3], [4,2,6], [7, 8, 9]], columns=['a1', 'a2', 'a3'])
>>> df2 = pd.concat([df1+1, df1+2])
>>>
>>> df1.join(df2, how='left', on='a1', lsuffix='_l', rsuffix='_r')
   a1  a1_l  a2_l  a3_l  a1_r  a2_r  a3_r
0   1     1     3     3   5.0   3.0   7.0
0   1     1     3     3   6.0   4.0   8.0
1   4     4     2     6   NaN   NaN   NaN
2   7     7     8     9   NaN   NaN   NaN
>>>
>>> ddf1 = dd.from_pandas(df1, npartitions=2)
>>> ddf2 = dd.from_pandas(df2, npartitions=2)
>>> ddf1.join(ddf2, how='left', on='a1', lsuffix='_l', rsuffix='_r').compute()
```

The exception traceback:

```python
ValueError                                Traceback (most recent call last)
<ipython-input-40-8cf730a949a3> in <module>
----> 1 ddf1.join(ddf2, how='left', on='a1', lsuffix='_l', rsuffix='_r').compute()

/usr/local/lib/python3.7/site-packages/dask/base.py in compute(self, **kwargs)
    173         dask.base.compute
    174         """"""
--> 175         (result,) = compute(self, traverse=False, **kwargs)
    176         return result
    177

/usr/local/lib/python3.7/site-packages/dask/base.py in compute(*args, **kwargs)
    444     keys = [x.__dask_keys__() for x in collections]
    445     postcomputes = [x.__dask_postcompute__() for x in collections]
--> 446     results = schedule(dsk, keys, **kwargs)
    447     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    448

/usr/local/lib/python3.7/site-packages/dask/threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     80         get_id=_thread_get_id,
     81         pack_exception=pack_exception,
---> 82         **kwargs
     83     )
     84

/usr/local/lib/python3.7/site-packages/dask/local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    489                         _execute_task(task, data)  # Re-execute locally
    490                     else:
--> 491                         raise_exception(exc, tb)
    492                 res, worker_id = loads(res_info)
    493                 state[""cache""][key] = res

/usr/local/lib/python3.7/site-packages/dask/compatibility.py in reraise(exc, tb)
    128         if exc.__traceback__ is not tb:
    129             raise exc.with_traceback(tb)
--> 130         raise exc
    131
    132     import pickle as cPickle

/usr/local/lib/python3.7/site-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    231     try:
    232         task, data = loads(task_info)
--> 233         result = _execute_task(task, data)
    234         id = get_id()
    235         result = dumps((result, id))

/usr/local/lib/python3.7/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    117         func, args = arg[0], arg[1:]
    118         args2 = [_execute_task(a, cache) for a in args]
--> 119         return func(*args2)
    120     elif not ishashable(arg):
    121         return arg

/usr/local/lib/python3.7/site-packages/dask/optimization.py in __call__(self, *args)
   1057         if not len(args) == len(self.inkeys):
   1058             raise ValueError(""Expected %d args, got %d"" % (len(self.inkeys), len(args)))
-> 1059         return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
   1060
   1061     def __reduce__(self):

/usr/local/lib/python3.7/site-packages/dask/core.py in get(dsk, out, cache)
    147     for key in toposort(dsk):
    148         task = dsk[key]
--> 149         result = _execute_task(task, cache)
    150         cache[key] = result
    151     result = _execute_task(out, cache)

/usr/local/lib/python3.7/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    117         func, args = arg[0], arg[1:]
    118         args2 = [_execute_task(a, cache) for a in args]
--> 119         return func(*args2)
    120     elif not ishashable(arg):
    121         return arg

/usr/local/lib/python3.7/site-packages/dask/compatibility.py in apply(func, args, kwargs)
    105     def apply(func, args, kwargs=None):
    106         if kwargs:
--> 107             return func(*args, **kwargs)
    108         else:
    109             return func(*args)

/usr/local/lib/python3.7/site-packages/dask/dataframe/core.py in apply_and_enforce(*args, **kwargs)
   4834             ):
   4835                 raise ValueError(
-> 4836                     ""The columns in the computed data do not match""
   4837                     "" the columns in the provided metadata""
   4838                 )

ValueError: The columns in the computed data do not match the columns in the provided metadata
```",,https://api.github.com/repos/dask/dask/issues/5292/timeline,,,sighingnow,7144772,MDQ6VXNlcjcxNDQ3NzI=,https://avatars.githubusercontent.com/u/7144772?v=4,,https://api.github.com/users/sighingnow,https://github.com/sighingnow,https://api.github.com/users/sighingnow/followers,https://api.github.com/users/sighingnow/following{/other_user},https://api.github.com/users/sighingnow/gists{/gist_id},https://api.github.com/users/sighingnow/starred{/owner}{/repo},https://api.github.com/users/sighingnow/subscriptions,https://api.github.com/users/sighingnow/orgs,https://api.github.com/users/sighingnow/repos,https://api.github.com/users/sighingnow/events{/privacy},https://api.github.com/users/sighingnow/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5292/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
225,https://api.github.com/repos/dask/dask/issues/5295,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5295/labels{/name},https://api.github.com/repos/dask/dask/issues/5295/comments,https://api.github.com/repos/dask/dask/issues/5295/events,https://github.com/dask/dask/issues/5295,482423107,MDU6SXNzdWU0ODI0MjMxMDc=,5295,Default npartitions  for parquet with fastparquet and parquet with pyarrow are incorrect,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,9,2019-08-19T16:59:50Z,2021-10-13T02:18:16Z,,NONE,,"When reading the same data in 1) csv format 2) parquet format using fastparquet and 3) parquet using pyarrow, the following default npartitions were allocated by dask: 

```
fastparquet version 0.3.2
 dask version 2.2.0
 pyarrow version 0.14.0`

count 15245673
csv partitions: 9
parquet npartitions pyarrow: 1
parquet npartitions fastparquet: 477
``` 
The data file contains 2 columns, 15M rows , Approx 540MB on disk in csv format. Parquet file  created by dotnet parquet 3.3.4 
The code to reproduce is simply the following:

```
print(f' fastparquet version {fp.__version__}')
print(f' dask version {dask.__version__}')
print(f' pyarrow version {pyarrow.__version__}')

dfpq = ParquetFile(f_bug_pq)
print(f'count {dfpq.count}')
dddf = dd.read_csv(f_bug_csv)
print(f'csv partitions: {dddf.npartitions}')
for engine in ['pyarrow', 'fastparquet']:
    dddf = dd.read_parquet(f_bug_pq, engine=engine)
    print(f'parquet npartitions {engine}: {dddf.npartitions}')
```

I can upload input file if required! 

thanks 
",,https://api.github.com/repos/dask/dask/issues/5295/timeline,,,telferm57,16674375,MDQ6VXNlcjE2Njc0Mzc1,https://avatars.githubusercontent.com/u/16674375?v=4,,https://api.github.com/users/telferm57,https://github.com/telferm57,https://api.github.com/users/telferm57/followers,https://api.github.com/users/telferm57/following{/other_user},https://api.github.com/users/telferm57/gists{/gist_id},https://api.github.com/users/telferm57/starred{/owner}{/repo},https://api.github.com/users/telferm57/subscriptions,https://api.github.com/users/telferm57/orgs,https://api.github.com/users/telferm57/repos,https://api.github.com/users/telferm57/events{/privacy},https://api.github.com/users/telferm57/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5295/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
226,https://api.github.com/repos/dask/dask/issues/5299,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5299/labels{/name},https://api.github.com/repos/dask/dask/issues/5299/comments,https://api.github.com/repos/dask/dask/issues/5299/events,https://github.com/dask/dask/issues/5299,482888662,MDU6SXNzdWU0ODI4ODg2NjI=,5299,BUG: Inline makes N^2 calls to subs.,[],open,False,,[],,3,2019-08-20T14:15:45Z,2019-09-17T16:38:05Z,,CONTRIBUTOR,,"The following function, when profile using %prun results in N^2+N calls to subs()

```def get_task(n, client):
    futs = client.map(int, [random.random() for _ in range(n)])
    z = str(uuid.uuid4())
    dsk = {z: (sum, list(fut.key for fut in futs))}
    for fut in futs:
        dsk[fut.key] = fut

    return Delayed(z, dsk)
```
for example, n=50:
``` 
         6629 function calls (3910 primitive calls) in 0.048 seconds

   Ordered by: cumulative time
   List reduced from 226 to 50 due to restriction <50>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.048    0.048 {built-in method builtins.exec}
        1    0.000    0.000    0.047    0.047 <string>:1(<module>)
        1    0.000    0.000    0.047    0.047 base.py:151(compute)
        1    0.000    0.000    0.047    0.047 base.py:391(compute)
        1    0.000    0.000    0.047    0.047 client.py:2275(get)
        1    0.000    0.000    0.044    0.044 client.py:1591(gather)
        1    0.000    0.000    0.044    0.044 client.py:666(sync)
        1    0.000    0.000    0.044    0.044 utils.py:236(sync)
        1    0.000    0.000    0.044    0.044 threading.py:534(wait)
        1    0.000    0.000    0.044    0.044 threading.py:264(wait)
        4    0.044    0.011    0.044    0.011 {method 'acquire' of '_thread.lock' objects}
        1    0.000    0.000    0.003    0.003 client.py:2195(_graph_to_futures)
        1    0.000    0.000    0.002    0.002 optimization.py:233(inline)
  2550/50    0.001    0.000    0.001    0.000 core.py:277(subs)```",,https://api.github.com/repos/dask/dask/issues/5299/timeline,,,mpeaton,823569,MDQ6VXNlcjgyMzU2OQ==,https://avatars.githubusercontent.com/u/823569?v=4,,https://api.github.com/users/mpeaton,https://github.com/mpeaton,https://api.github.com/users/mpeaton/followers,https://api.github.com/users/mpeaton/following{/other_user},https://api.github.com/users/mpeaton/gists{/gist_id},https://api.github.com/users/mpeaton/starred{/owner}{/repo},https://api.github.com/users/mpeaton/subscriptions,https://api.github.com/users/mpeaton/orgs,https://api.github.com/users/mpeaton/repos,https://api.github.com/users/mpeaton/events{/privacy},https://api.github.com/users/mpeaton/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5299/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
227,https://api.github.com/repos/dask/dask/issues/5320,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5320/labels{/name},https://api.github.com/repos/dask/dask/issues/5320/comments,https://api.github.com/repos/dask/dask/issues/5320/events,https://github.com/dask/dask/issues/5320,485365707,MDU6SXNzdWU0ODUzNjU3MDc=,5320,Applying ufuncs to dask scalars do not return dask scalars.,[],open,False,,[],,3,2019-08-26T18:05:20Z,2019-08-26T21:41:24Z,,NONE,,"Hey, I've been running into an issue where a dask.array ufunc applied to a dask.Scalar does not return a dask.Scalar.

Here is some reproducible code.

```
import pandas as pd
import dask.dataframe as dd
import dask.array as da

s = pd.Series([1,2,3,4,5])
ds = dd.from_pandas(s, npartitions=2)
print(ds.sum())
print(da.sqrt(ds.sum()))
print(da.sin(ds.sum()))
print(da.power(ds.sum(), 2))
```

Resulting in:
```
dd.Scalar<series-..., dtype=int64>
3.872983346207417
0.6502878401571169
225
```

Doing `ds.sum()`  returns a dask.Scalar as expected but applying any ufunc to this scalar, seems to trigger computation. 
Is this intended? If so, how can I get the graph, instead of the result?",,https://api.github.com/repos/dask/dask/issues/5320/timeline,,,pedroallenrevez,15174747,MDQ6VXNlcjE1MTc0NzQ3,https://avatars.githubusercontent.com/u/15174747?v=4,,https://api.github.com/users/pedroallenrevez,https://github.com/pedroallenrevez,https://api.github.com/users/pedroallenrevez/followers,https://api.github.com/users/pedroallenrevez/following{/other_user},https://api.github.com/users/pedroallenrevez/gists{/gist_id},https://api.github.com/users/pedroallenrevez/starred{/owner}{/repo},https://api.github.com/users/pedroallenrevez/subscriptions,https://api.github.com/users/pedroallenrevez/orgs,https://api.github.com/users/pedroallenrevez/repos,https://api.github.com/users/pedroallenrevez/events{/privacy},https://api.github.com/users/pedroallenrevez/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5320/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
228,https://api.github.com/repos/dask/dask/issues/5321,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5321/labels{/name},https://api.github.com/repos/dask/dask/issues/5321/comments,https://api.github.com/repos/dask/dask/issues/5321/events,https://github.com/dask/dask/issues/5321,485372107,MDU6SXNzdWU0ODUzNzIxMDc=,5321,`read_parquet` graph transfer grows more than lienearly with number of partitions,"[{'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,26,2019-08-26T18:19:26Z,2021-10-13T02:12:29Z,,CONTRIBUTOR,,"dask 2.3.0

my calls to to_parquet were never starting - meaning after waiting a long time I still didn't see the tasks appear in the ""progress"" bar which, to my untrained eye, means that the graph is taking a long time to compute.

I copy pasted the code from `dataframe/core.py to_parquet` to build my own `parts`

https://github.com/dask/dask/blob/master/dask/dataframe/io/parquet/core.py#L458-L481
```
    # write parts
    dwrite = delayed(engine.write_partition)
    parts = [
        dwrite(
            d,
            path,
            fs,
            filename,
            partition_on,
            write_metadata_file,
            fmd=meta,
            index_cols=index_cols,
            **kwargs_pass
        )
        for d, filename in zip(df.to_delayed(), filenames)
    ]

    # single task to complete
    out = delayed(lambda x: None)(parts)
    if write_metadata_file:
        out = delayed(engine.write_metadata)(
            parts, meta, fs, path, append=append, compression=compression
        )
```

I then manually put this in chunks into `client.compute` 

if I do 10 parts, after 27s my tasks appear. If I do 100 parts, after 4.5 minutes (270s) my tasks appear. My dataset has 4000 partitions so, at this rate, it will be 180 minutes before my task graph will even appear and start executing.

For comparison it takes ~2hours to do the full execution on dask 0.2.1.


",,https://api.github.com/repos/dask/dask/issues/5321/timeline,,,birdsarah,1796208,MDQ6VXNlcjE3OTYyMDg=,https://avatars.githubusercontent.com/u/1796208?v=4,,https://api.github.com/users/birdsarah,https://github.com/birdsarah,https://api.github.com/users/birdsarah/followers,https://api.github.com/users/birdsarah/following{/other_user},https://api.github.com/users/birdsarah/gists{/gist_id},https://api.github.com/users/birdsarah/starred{/owner}{/repo},https://api.github.com/users/birdsarah/subscriptions,https://api.github.com/users/birdsarah/orgs,https://api.github.com/users/birdsarah/repos,https://api.github.com/users/birdsarah/events{/privacy},https://api.github.com/users/birdsarah/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5321/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
229,https://api.github.com/repos/dask/dask/issues/5323,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5323/labels{/name},https://api.github.com/repos/dask/dask/issues/5323/comments,https://api.github.com/repos/dask/dask/issues/5323/events,https://github.com/dask/dask/issues/5323,485516825,MDU6SXNzdWU0ODU1MTY4MjU=,5323,"Adding multiple columns inside the same call doesn't work properly, while it does on Pandas","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2019-08-27T00:23:29Z,2021-10-13T02:12:14Z,,NONE,,"I made a simple method that essentially turns categories from a categorical feature into new, separate features (similarly to a pivot_table operation) and adds them to the dataframe. Here's its definition:

```python
def category_to_feature(df, categories_feature, values_feature):
    '''Convert a categorical column and its corresponding values column into
    new features, one for each category.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe on which to add the new features.
    categories_feature : string
        Name of the feature that contains the categories that will be converted
        to individual features.
    values_feature : string
        Name of the feature that has each category's corresponding value, which
        may or may not be a category on its own (e.g. it could be numeric values).

    Returns
    -------
    data_df : pandas.DataFrame or dask.DataFrame
        Dataframe with the newly created features.
    '''
    # Copy the dataframe to avoid potentially unwanted inplace changes
    data_df = df.copy()
    # Find the unique categories
    categories = data_df[categories_feature].unique()
    if 'dask' in str(type(df)):
        categories = categories.compute()
    # Create a feature for each category
    for category in categories:
        # Convert category to feature
        data_df[category] = data_df.apply(lambda x: x[values_feature] if x[categories_feature] == category
                                                    else np.nan, axis=1)
    return data_df
```

If we apply it on the following Pandas dataframe, it works as intended, creating a feature for each category:

**Input dataframe:**

```
	id	ts	categories	values
0	103	0	cat_a	        val_a1
1	103	1	cat_a	        val_a2
2	103	2	cat_b	        val_b1
3	104	0	cat_c	        val_c1
4	105	0	cat_a	        val_a3
5	106	0	cat_c	        val_c2
6	107	0	cat_b	        val_b1
7	108	0	cat_b	        val_b2
8	108	1	cat_d	        val_d1
9	108	2	cat_a	        val_a1
10	108	3	cat_a	        val_a3
```

**Resulting dataframe on Pandas:**

```
	id	ts	categories	values	cat_a	cat_b	cat_c	cat_d
0	103	0	cat_a	        val_a1	val_a1	NaN	NaN	NaN
1	103	1	cat_a	        val_a2	val_a2	NaN	NaN	NaN
2	103	2	cat_b	        val_b1	NaN	val_b1	NaN	NaN
3	104	0	cat_c	        val_c1	NaN	NaN	val_c1	NaN
4	105	0	cat_a	        val_a3	val_a3	NaN	NaN	NaN
5	106	0	cat_c	        val_c2	NaN	NaN	val_c2	NaN
6	107	0	cat_b	        val_b1	NaN	val_b1	NaN	NaN
7	108	0	cat_b	        val_b2	NaN	val_b2	NaN	NaN
8	108	1	cat_d	        val_d1	NaN	NaN	NaN	val_d1
9	108	2	cat_a	        val_a1	val_a1	NaN	NaN	NaN
10	108	3	cat_a	        val_a3	val_a3	NaN	NaN	NaN
```

Now, if we use it as a dask dataframe, all the newly created features assume the values of the feature that was added last, which in this case is `cat_d`.

**Resulting dataframe on Dask:**

```
	id	ts	categories	values	cat_a	cat_b	cat_c	cat_d
0	103	0	cat_a	        val_a1	NaN	NaN	NaN	NaN
1	103	1	cat_a	        val_a2	NaN	NaN	NaN	NaN
2	103	2	cat_b	        val_b1	NaN	NaN	NaN	NaN
3	104	0	cat_c	        val_c1	NaN	NaN	NaN	NaN
4	105	0	cat_a	        val_a3	NaN	NaN	NaN	NaN
5	106	0	cat_c	        val_c2	NaN	NaN	NaN	NaN
6	107	0	cat_b	        val_b1	NaN	NaN	NaN	NaN
7	108	0	cat_b	        val_b2	NaN	NaN	NaN	NaN
8	108	1	cat_d	        val_d1	val_d1	val_d1	val_d1	val_d1
9	108	2	cat_a	        val_a1	NaN	NaN	NaN	NaN
10	108	3	cat_a	        val_a3	NaN	NaN	NaN	NaN
```

Since the method works fine on Pandas, I'm guessing this might be an issue on Dask' side.

You can check the full example code on this notebook/script: 
[category_to_feature_example.zip](https://github.com/dask/dask/files/3542307/category_to_feature_example.zip)",,https://api.github.com/repos/dask/dask/issues/5323/timeline,,,AndreCNF,19359510,MDQ6VXNlcjE5MzU5NTEw,https://avatars.githubusercontent.com/u/19359510?v=4,,https://api.github.com/users/AndreCNF,https://github.com/AndreCNF,https://api.github.com/users/AndreCNF/followers,https://api.github.com/users/AndreCNF/following{/other_user},https://api.github.com/users/AndreCNF/gists{/gist_id},https://api.github.com/users/AndreCNF/starred{/owner}{/repo},https://api.github.com/users/AndreCNF/subscriptions,https://api.github.com/users/AndreCNF/orgs,https://api.github.com/users/AndreCNF/repos,https://api.github.com/users/AndreCNF/events{/privacy},https://api.github.com/users/AndreCNF/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5323/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
230,https://api.github.com/repos/dask/dask/issues/5329,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5329/labels{/name},https://api.github.com/repos/dask/dask/issues/5329/comments,https://api.github.com/repos/dask/dask/issues/5329/events,https://github.com/dask/dask/issues/5329,485927396,MDU6SXNzdWU0ODU5MjczOTY=,5329,Design: nested _meta,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,12,2019-08-27T17:03:42Z,2020-09-14T14:18:42Z,,MEMBER,,"I'm opening this on the dask board as it is the first package that came up with the idea of the _meta property, but this is really of interest of all NEP18-compatible packages that wrap around other NEP18 packages.

I'm in the early stages of a project where I will likely need to use xarray, pint, dask, and sparse within the same object. In addition to this, I believe I saw on the sparse board some discussion about using CuPy (or similar) for GPU acceleration.

This could potentially translate to
_an xarray.DataArray
that wraps around a pint.Quantity
that wraps around a dask.array.Array
that wraps around a sparse.COO
that wraps around a cupy.array_

and in theory, _it should just work_ as long as all the libraries in the stack implement the relevant numpy functions.

Ideally, as a final user I would like to see all of this information when invoking repr() on my top level object, something like
```
<xarray.DataArray (x: 100)>
<pint.Quantity::dask.array::sparse.COO::cupy.array, 
 unit=""seconds"", dtype=int64, nnz=2, fill_value=0, Device=0>
```

This thread is to understand:
1. how to best represent this kind of arbitrarily nested meta data,  both as a data structure and as a ``__repr__`` 
2. if it should be formalized through a NEP

@shoyer 
@keewis
@hameerabbasi 
@mrocklin ",,https://api.github.com/repos/dask/dask/issues/5329/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5329/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
231,https://api.github.com/repos/dask/dask/issues/5349,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5349/labels{/name},https://api.github.com/repos/dask/dask/issues/5349/comments,https://api.github.com/repos/dask/dask/issues/5349/events,https://github.com/dask/dask/issues/5349,487150133,MDU6SXNzdWU0ODcxNTAxMzM=,5349,Priority propagation,[],open,False,,[],,5,2019-08-29T20:01:42Z,2019-10-25T23:21:57Z,,NONE,,"My department requires all scripts to be ran with nice -19, however DaskSSH will not propagate this priority to the worker machines from what I know. It would be very nice if this could be a feature, if it is not already implemented.
",,https://api.github.com/repos/dask/dask/issues/5349/timeline,,,landonzweigle,44909659,MDQ6VXNlcjQ0OTA5NjU5,https://avatars.githubusercontent.com/u/44909659?v=4,,https://api.github.com/users/landonzweigle,https://github.com/landonzweigle,https://api.github.com/users/landonzweigle/followers,https://api.github.com/users/landonzweigle/following{/other_user},https://api.github.com/users/landonzweigle/gists{/gist_id},https://api.github.com/users/landonzweigle/starred{/owner}{/repo},https://api.github.com/users/landonzweigle/subscriptions,https://api.github.com/users/landonzweigle/orgs,https://api.github.com/users/landonzweigle/repos,https://api.github.com/users/landonzweigle/events{/privacy},https://api.github.com/users/landonzweigle/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5349/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
232,https://api.github.com/repos/dask/dask/issues/5361,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5361/labels{/name},https://api.github.com/repos/dask/dask/issues/5361/comments,https://api.github.com/repos/dask/dask/issues/5361/events,https://github.com/dask/dask/issues/5361,488705404,MDU6SXNzdWU0ODg3MDU0MDQ=,5361,Filesystem transactions,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,4,2019-09-03T16:27:50Z,2021-10-13T02:09:41Z,,MEMBER,,"Right now, Dask uses the various implementations of fsspec for writing. Since each task writes one file, the creation of any chunks on a remote server and finalising of the file happen serially in a single thread. However, if there is an exception, then finalising should happen anyway, resulting in partial content (as you would expect when writing to a local file too). This happens upon `del`, so it's timing cannot be guaranteed. 

If there are retries, this should then be over-written, but I can imagine that with the eventual-consistency of S3/GCS, you are not guaranteed as to which version you end up with. The existing transactions mechanism in fsspec could be used to prevent automatically committing whatever was written, but requires some coordination. An additional wrinkle, is that filesystem instances persist, and are shared between threads. 

Dask (and fsspec users in general) would like to have more guarantees about the state of writing, and the ability to commit/discard whole sets of files across a cluster, as well as, ideally, verification that writes/retries did indeed succeed. Also, it might be nice to distribute filesystem configuration globally.",,https://api.github.com/repos/dask/dask/issues/5361/timeline,,,martindurant,6042212,MDQ6VXNlcjYwNDIyMTI=,https://avatars.githubusercontent.com/u/6042212?v=4,,https://api.github.com/users/martindurant,https://github.com/martindurant,https://api.github.com/users/martindurant/followers,https://api.github.com/users/martindurant/following{/other_user},https://api.github.com/users/martindurant/gists{/gist_id},https://api.github.com/users/martindurant/starred{/owner}{/repo},https://api.github.com/users/martindurant/subscriptions,https://api.github.com/users/martindurant/orgs,https://api.github.com/users/martindurant/repos,https://api.github.com/users/martindurant/events{/privacy},https://api.github.com/users/martindurant/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5361/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
233,https://api.github.com/repos/dask/dask/issues/5373,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5373/labels{/name},https://api.github.com/repos/dask/dask/issues/5373/comments,https://api.github.com/repos/dask/dask/issues/5373/events,https://github.com/dask/dask/issues/5373,490767191,MDU6SXNzdWU0OTA3NjcxOTE=,5373,Cholesky fails for sparse matrices,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,9,2019-09-08T15:22:49Z,2022-01-12T16:15:35Z,,NONE,,"Hi I am trying to run a cholesky decomposition on a Sparse matrix like so:

```
# Make a random positive definite sparse matrix in numpy
X = np.random.randn(100,100)
X[X<1.7]=0
X = X + np.eye(100)
XtX = np.matmul(X.transpose(), X)

# Map it to a dask sparse matrix
XtX_da = da.from_array(XtX, chunks=(10, 10)).map_blocks(sparse.COO).rechunk('auto')

# Perform cholesky decomposition
L_da_chol = da.linalg.cholesky(XtX_da).compute()
```

But I get the following error:

```
RuntimeError                              Traceback (most recent call last)
<ipython-input-23-8ac43cb2d1f0> in <module>()
     66 
     67     t1 = time.time()
---> 68     L_da_chol = da.linalg.cholesky(XtX_da).compute()
     69     t2 = time.time()
     70     daptime=t2-t1

14 frames
/usr/local/lib/python3.6/dist-packages/dask/base.py in compute(self, **kwargs)
    154         dask.base.compute
    155         """"""
--> 156         (result,) = compute(self, traverse=False, **kwargs)
    157         return result
    158 

/usr/local/lib/python3.6/dist-packages/dask/base.py in compute(*args, **kwargs)
    396     keys = [x.__dask_keys__() for x in collections]
    397     postcomputes = [x.__dask_postcompute__() for x in collections]
--> 398     results = schedule(dsk, keys, **kwargs)
    399     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    400 

/usr/local/lib/python3.6/dist-packages/dask/threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     74     results = get_async(pool.apply_async, len(pool._pool), dsk, result,
     75                         cache=cache, get_id=_thread_get_id,
---> 76                         pack_exception=pack_exception, **kwargs)
     77 
     78     # Cleanup pools associated to dead threads

/usr/local/lib/python3.6/dist-packages/dask/local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    460                         _execute_task(task, data)  # Re-execute locally
    461                     else:
--> 462                         raise_exception(exc, tb)
    463                 res, worker_id = loads(res_info)
    464                 state['cache'][key] = res

/usr/local/lib/python3.6/dist-packages/dask/compatibility.py in reraise(exc, tb)
    110         if exc.__traceback__ is not tb:
    111             raise exc.with_traceback(tb)
--> 112         raise exc
    113 
    114     import pickle as cPickle

/usr/local/lib/python3.6/dist-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    228     try:
    229         task, data = loads(task_info)
--> 230         result = _execute_task(task, data)
    231         id = get_id()
    232         result = dumps((result, id))

/usr/local/lib/python3.6/dist-packages/dask/core.py in _execute_task(arg, cache, dsk)
    116     elif istask(arg):
    117         func, args = arg[0], arg[1:]
--> 118         args2 = [_execute_task(a, cache) for a in args]
    119         return func(*args2)
    120     elif not ishashable(arg):

/usr/local/lib/python3.6/dist-packages/dask/core.py in <listcomp>(.0)
    116     elif istask(arg):
    117         func, args = arg[0], arg[1:]
--> 118         args2 = [_execute_task(a, cache) for a in args]
    119         return func(*args2)
    120     elif not ishashable(arg):

/usr/local/lib/python3.6/dist-packages/dask/core.py in _execute_task(arg, cache, dsk)
    117         func, args = arg[0], arg[1:]
    118         args2 = [_execute_task(a, cache) for a in args]
--> 119         return func(*args2)
    120     elif not ishashable(arg):
    121         return arg

/usr/local/lib/python3.6/dist-packages/dask/array/linalg.py in _cholesky_lower(a)
    940 def _cholesky_lower(a):
    941     import scipy.linalg
--> 942     return scipy.linalg.cholesky(a, lower=True)
    943 
    944 

/usr/local/lib/python3.6/dist-packages/scipy/linalg/decomp_cholesky.py in cholesky(a, lower, overwrite_a, check_finite)
     89     """"""
     90     c, lower = _cholesky(a, lower=lower, overwrite_a=overwrite_a, clean=True,
---> 91                          check_finite=check_finite)
     92     return c
     93 

/usr/local/lib/python3.6/dist-packages/scipy/linalg/decomp_cholesky.py in _cholesky(a, lower, overwrite_a, clean, check_finite)
     17     """"""Common code for cholesky() and cho_factor().""""""
     18 
---> 19     a1 = asarray_chkfinite(a) if check_finite else asarray(a)
     20     a1 = atleast_2d(a1)
     21 

/usr/local/lib/python3.6/dist-packages/numpy/lib/function_base.py in asarray_chkfinite(a, dtype, order)
    493 
    494     """"""
--> 495     a = asarray(a, dtype=dtype, order=order)
    496     if a.dtype.char in typecodes['AllFloat'] and not np.isfinite(a).all():
    497         raise ValueError(

/usr/local/lib/python3.6/dist-packages/numpy/core/numeric.py in asarray(a, dtype, order)
    536 
    537     """"""
--> 538     return array(a, dtype, copy=False, order=order)
    539 
    540 

/usr/local/lib/python3.6/dist-packages/sparse/_sparse_array.py in __array__(self, **kwargs)
    210         from ._settings import AUTO_DENSIFY
    211         if not AUTO_DENSIFY:
--> 212             raise RuntimeError('Cannot convert a sparse array to dense automatically. '
    213                                'To manually densify, use the todense method.')
    214 

RuntimeError: Cannot convert a sparse array to dense automatically. To manually densify, use the todense method.
```

This was run on a CPU in a google colab notebook; any help on resolving this would be greatly appreciated... ideally I'm hoping to find a solution that at least allows some of the computation to be done using sparse operations as time efficiency is a big factor in what I am working on (the above is a toy example... my actual work uses much larger matrices).",,https://api.github.com/repos/dask/dask/issues/5373/timeline,,,TomMaullin,22241320,MDQ6VXNlcjIyMjQxMzIw,https://avatars.githubusercontent.com/u/22241320?v=4,,https://api.github.com/users/TomMaullin,https://github.com/TomMaullin,https://api.github.com/users/TomMaullin/followers,https://api.github.com/users/TomMaullin/following{/other_user},https://api.github.com/users/TomMaullin/gists{/gist_id},https://api.github.com/users/TomMaullin/starred{/owner}{/repo},https://api.github.com/users/TomMaullin/subscriptions,https://api.github.com/users/TomMaullin/orgs,https://api.github.com/users/TomMaullin/repos,https://api.github.com/users/TomMaullin/events{/privacy},https://api.github.com/users/TomMaullin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5373/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
234,https://api.github.com/repos/dask/dask/issues/5377,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5377/labels{/name},https://api.github.com/repos/dask/dask/issues/5377/comments,https://api.github.com/repos/dask/dask/issues/5377/events,https://github.com/dask/dask/issues/5377,490980480,MDU6SXNzdWU0OTA5ODA0ODA=,5377,"da.unique(<array with an unknown shape>,return_counts=True) raises","[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,9,2019-09-09T09:21:37Z,2021-10-13T01:38:58Z,,NONE,,"This code:
```
import dask.array as da
a = da.ones(10)
da.unique(a[a>0],return_counts=True)
```
produces an error.
I think that it should work theoretically, but the code tries to allocate ones at the shape of the original array and crashes (before computing).
Thanks",,https://api.github.com/repos/dask/dask/issues/5377/timeline,,,michaeldoron59,7224580,MDQ6VXNlcjcyMjQ1ODA=,https://avatars.githubusercontent.com/u/7224580?v=4,,https://api.github.com/users/michaeldoron59,https://github.com/michaeldoron59,https://api.github.com/users/michaeldoron59/followers,https://api.github.com/users/michaeldoron59/following{/other_user},https://api.github.com/users/michaeldoron59/gists{/gist_id},https://api.github.com/users/michaeldoron59/starred{/owner}{/repo},https://api.github.com/users/michaeldoron59/subscriptions,https://api.github.com/users/michaeldoron59/orgs,https://api.github.com/users/michaeldoron59/repos,https://api.github.com/users/michaeldoron59/events{/privacy},https://api.github.com/users/michaeldoron59/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5377/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
235,https://api.github.com/repos/dask/dask/issues/5380,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5380/labels{/name},https://api.github.com/repos/dask/dask/issues/5380/comments,https://api.github.com/repos/dask/dask/issues/5380/events,https://github.com/dask/dask/issues/5380,491184241,MDU6SXNzdWU0OTExODQyNDE=,5380,Avoid filesystem operations on the client,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,"[{'login': 'martindurant', 'id': 6042212, 'node_id': 'MDQ6VXNlcjYwNDIyMTI=', 'avatar_url': 'https://avatars.githubusercontent.com/u/6042212?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/martindurant', 'html_url': 'https://github.com/martindurant', 'followers_url': 'https://api.github.com/users/martindurant/followers', 'following_url': 'https://api.github.com/users/martindurant/following{/other_user}', 'gists_url': 'https://api.github.com/users/martindurant/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/martindurant/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/martindurant/subscriptions', 'organizations_url': 'https://api.github.com/users/martindurant/orgs', 'repos_url': 'https://api.github.com/users/martindurant/repos', 'events_url': 'https://api.github.com/users/martindurant/events{/privacy}', 'received_events_url': 'https://api.github.com/users/martindurant/received_events', 'type': 'User', 'site_admin': False}]",,7,2019-09-09T15:57:55Z,2020-04-21T20:36:28Z,,MEMBER,,"In certain configurations, users may have workers that have access to a filesystem that they don't have access to on their client (e.g. hdfs). It would be nice if we could move all graph-build-time filesystem operations (e.g. globbing files, etc...) to be run as tasks on the workers instead of locally. If needed this could be done by a configuration parameter, but I suspect we may want to do this always. This could also be used to parallelize filesystem operations during setup as well.",,https://api.github.com/repos/dask/dask/issues/5380/timeline,,,jcrist,2783717,MDQ6VXNlcjI3ODM3MTc=,https://avatars.githubusercontent.com/u/2783717?v=4,,https://api.github.com/users/jcrist,https://github.com/jcrist,https://api.github.com/users/jcrist/followers,https://api.github.com/users/jcrist/following{/other_user},https://api.github.com/users/jcrist/gists{/gist_id},https://api.github.com/users/jcrist/starred{/owner}{/repo},https://api.github.com/users/jcrist/subscriptions,https://api.github.com/users/jcrist/orgs,https://api.github.com/users/jcrist/repos,https://api.github.com/users/jcrist/events{/privacy},https://api.github.com/users/jcrist/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5380/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,martindurant,6042212.0,MDQ6VXNlcjYwNDIyMTI=,https://avatars.githubusercontent.com/u/6042212?v=4,,https://api.github.com/users/martindurant,https://github.com/martindurant,https://api.github.com/users/martindurant/followers,https://api.github.com/users/martindurant/following{/other_user},https://api.github.com/users/martindurant/gists{/gist_id},https://api.github.com/users/martindurant/starred{/owner}{/repo},https://api.github.com/users/martindurant/subscriptions,https://api.github.com/users/martindurant/orgs,https://api.github.com/users/martindurant/repos,https://api.github.com/users/martindurant/events{/privacy},https://api.github.com/users/martindurant/received_events,User,False
236,https://api.github.com/repos/dask/dask/issues/5408,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5408/labels{/name},https://api.github.com/repos/dask/dask/issues/5408/comments,https://api.github.com/repos/dask/dask/issues/5408/events,https://github.com/dask/dask/issues/5408,493600647,MDU6SXNzdWU0OTM2MDA2NDc=,5408,test_temporary_directory sporadically fails when run with xdist,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,3,2019-09-14T08:46:49Z,2021-10-13T01:32:03Z,,MEMBER,,"When running with `pytest-xdist`, the `test_temporary_directory` test seems to fail sporadically:
```pytb
___________________________ test_temporary_directory ___________________________
[gw1] linux -- Python 3.8.0 /usr/bin/python3

tmpdir = local('/tmp/pytest-of-mockbuild/pytest-0/popen-gw1/test_temporary_directory0')

    def test_temporary_directory(tmpdir):
        from multiprocessing.pool import Pool
    
        df = pd.DataFrame(
            {
                ""x"": np.random.random(100),
                ""y"": np.random.random(100),
                ""z"": np.random.random(100),
            }
        )
        ddf = dd.from_pandas(df, npartitions=10, name=""x"", sort=False)
    
        # We use a pool to avoid a race condition between the pool close
        # cleaning up files, and the assert below.
        pool = Pool(4)
        with pool:
            with dask.config.set(
                temporary_directory=str(tmpdir), scheduler=""processes"", pool=pool
            ):
                ddf2 = ddf.set_index(""x"", shuffle=""disk"")
>               ddf2.compute()

dask/dataframe/tests/test_shuffle.py:774: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dask/base.py:175: in compute
    (result,) = compute(self, traverse=False, **kwargs)
dask/base.py:446: in compute
    results = schedule(dsk, keys, **kwargs)
dask/multiprocessing.py:197: in get
    result = get_async(
dask/local.py:491: in get_async
    raise_exception(exc, tb)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = FileNotFoundError()
tb = '  File ""/builddir/build/BUILD/dask-2.4.0/dask/local.py"", line 233, in execute_task\n    result = _execute_task(task, ... ""/usr/lib/python3.8/site-packages/locket/__init__.py"", line 152, in acquire\n    self._file = open(self._path, ""w"")\n'

    def reraise(exc, tb):
        exc = remote_exception(exc, tb)
>       raise exc
E       dask.multiprocessing.FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-mockbuild/pytest-0/popen-gw1/test_temporary_directory0/tmp6gdd1xok.partd/.lock'
E       
E       Traceback
E       ---------
E         File ""/builddir/build/BUILD/dask-2.4.0/dask/local.py"", line 233, in execute_task
E           result = _execute_task(task, data)
E         File ""/builddir/build/BUILD/dask-2.4.0/dask/core.py"", line 119, in _execute_task
E           return func(*args2)
E         File ""/builddir/build/BUILD/dask-2.4.0/dask/dataframe/shuffle.py"", line 641, in shuffle_group_3
E           p.append(d, fsync=True)
E         File ""/usr/lib/python3.8/site-packages/partd/encode.py"", line 25, in append
E           self.partd.append(data, **kwargs)
E         File ""/usr/lib/python3.8/site-packages/partd/file.py"", line 37, in append
E           if lock: self.lock.acquire()
E         File ""/usr/lib/python3.8/site-packages/locket/__init__.py"", line 99, in acquire
E           lock.acquire()
E         File ""/usr/lib/python3.8/site-packages/locket/__init__.py"", line 152, in acquire
E           self._file = open(self._path, ""w"")

dask/multiprocessing.py:110: FileNotFoundError
```
It might be related to #5104, but there's no backtrace there, so I'm not sure.",,https://api.github.com/repos/dask/dask/issues/5408/timeline,,,QuLogic,302469,MDQ6VXNlcjMwMjQ2OQ==,https://avatars.githubusercontent.com/u/302469?v=4,,https://api.github.com/users/QuLogic,https://github.com/QuLogic,https://api.github.com/users/QuLogic/followers,https://api.github.com/users/QuLogic/following{/other_user},https://api.github.com/users/QuLogic/gists{/gist_id},https://api.github.com/users/QuLogic/starred{/owner}{/repo},https://api.github.com/users/QuLogic/subscriptions,https://api.github.com/users/QuLogic/orgs,https://api.github.com/users/QuLogic/repos,https://api.github.com/users/QuLogic/events{/privacy},https://api.github.com/users/QuLogic/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5408/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
237,https://api.github.com/repos/dask/dask/issues/5412,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5412/labels{/name},https://api.github.com/repos/dask/dask/issues/5412/comments,https://api.github.com/repos/dask/dask/issues/5412/events,https://github.com/dask/dask/issues/5412,494071009,MDU6SXNzdWU0OTQwNzEwMDk=,5412,Skip rows with lambda functions - 'function' object is not iterable,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,9,2019-09-16T14:03:29Z,2021-10-13T01:30:15Z,,NONE,,"print(pd.__version__): 0.25.0
print(dask.__version__): 2.2.0

import pandas as pd
import dask.dataframe as dd

```
n = 1
df = pd.read_csv(paths[1], 
                    skiprows = lambda i: (i % n != 0 and i > 22) or i<=21)
```

This works. But:

```
n = 1
df = dd.read_csv(paths[1], 
                    skiprows = lambda i: (i % n != 0 and i > 22) or i<=21)
```

Why do I obtain this error:?


---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-25-cdd89b49b99e> in <module>
      1 df = dd.read_csv(paths[1], 
      2                     #include_path_column = True,
----> 3                     skiprows = lambda i: (i % n != 0 and i > 22)
      4                                         or i<=21)

/opt/conda/lib/python3.7/site-packages/dask/dataframe/io/csv.py in read(urlpath, blocksize, collection, lineterminator, compression, sample, enforce, assume_missing, storage_options, include_path_column, **kwargs)
    580             storage_options=storage_options,
    581             include_path_column=include_path_column,
--> 582             **kwargs
    583         )
    584 

/opt/conda/lib/python3.7/site-packages/dask/dataframe/io/csv.py in read_pandas(reader, urlpath, blocksize, collection, lineterminator, compression, sample, enforce, assume_missing, storage_options, include_path_column, **kwargs)
    366         # be included in the sample. This means that [0,2] will work well,
    367         # but [0, 440] might not work.
--> 368         skiprows = set(kwargs.get(""skiprows""))
    369         lastskiprow = max(skiprows)
    370         # find the firstrow that is not skipped, for use as header

**TypeError: 'function' object is not iterable**



",,https://api.github.com/repos/dask/dask/issues/5412/timeline,,,masip85,12863854,MDQ6VXNlcjEyODYzODU0,https://avatars.githubusercontent.com/u/12863854?v=4,,https://api.github.com/users/masip85,https://github.com/masip85,https://api.github.com/users/masip85/followers,https://api.github.com/users/masip85/following{/other_user},https://api.github.com/users/masip85/gists{/gist_id},https://api.github.com/users/masip85/starred{/owner}{/repo},https://api.github.com/users/masip85/subscriptions,https://api.github.com/users/masip85/orgs,https://api.github.com/users/masip85/repos,https://api.github.com/users/masip85/events{/privacy},https://api.github.com/users/masip85/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5412/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
238,https://api.github.com/repos/dask/dask/issues/5432,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5432/labels{/name},https://api.github.com/repos/dask/dask/issues/5432/comments,https://api.github.com/repos/dask/dask/issues/5432/events,https://github.com/dask/dask/issues/5432,498240758,MDU6SXNzdWU0OTgyNDA3NTg=,5432,Proxying Dask (Bokeh) Web Interface on AWS SageMaker ,[],open,False,,[],,27,2019-09-25T12:03:34Z,2023-12-28T10:33:52Z,,NONE,,"Hi,
I am using Amazon SageMaker Instances to run self-contained JupyterLab environments.
I can run dask no problem, but it would be great to view the bokeh dashboard in my browser. 
I have so far looked into two approaches (see below) but **would welcome any solutions/ideas anyone has**:

### 1.  **Port Forwarding**: (as suggested [here](https://distributed.dask.org/en/latest/web.html#id1))
Unfortunately, (to the best of my knowledge), AWS Sagemaker Notebooks do not allow SSH access, and hence Port Forwarding is not an option
> NOTE: Google AI Notebook Instances **do** however and so this is a suitable solution for GCP `<VM-IP-ADDRESS>:8787/status`

### 2.  Using a jupyter proxy extension [google-server-proxy](https://github.com/jupyterhub/jupyter-server-proxy) 
This is close to a working solution, as I am able to view the dashboard, but am getting a websocket error 
**When I attempt to access the dashboard using the proxy** `bokeh.protocol.exceptions.ProtocolError: No bokeh-protocol-version specified`
![image](https://user-images.githubusercontent.com/2926574/65598312-06df6100-df93-11e9-8aba-482ba06fc373.png)
**The exception raised from bokeh**
![image](https://user-images.githubusercontent.com/2926574/65598079-8b7daf80-df92-11e9-9fb1-0ea58e4ac21a.png)

#### Steps to reproduce
- Create a new notebook instance [SageMaker](https://eu-west-2.console.aws.amazon.com/sagemaker/home?region=eu-west-2#/notebook-instances/create)
- Install Dask + Bokeh in a py3.6 kernel
- Install jupyter-server-proxy extension
```
git clone --depth 1 https://github.com/jupyterhub/jupyter-server-proxy
cd jupyter-server-proxy/jupyterlab-server-proxy
npm install && npm run build && jupyter labextension link .
npm run build && jupyter lab build
```
- Create a new notebook and create a client
```python
from dask.distributed import Client
client = Client()
```
- Navigate to the proxied web-proxy: 
```
# In web-browser
https://<SAGEMAKER-ENDPOINT>/proxy/8787/status
```
(Additional info on my runtime env)
![image](https://user-images.githubusercontent.com/2926574/65598017-66893c80-df92-11e9-8e3f-0c87b3d41931.png)



**Additional Comment**
I am a big advocate of dask and very much appreciate the ongoing work everyone is doing! 

I understand this may not be the appropriate repo for this issue/feature-request and may not appear of high priority. However, I feel SageMaker Notebooks/GCP AI Notebook environments will be an increasing use case for lots of ML researchers and developers and, consequently, a well supported solution to this would be a useful addition to the docs.

Thanks,

David",,https://api.github.com/repos/dask/dask/issues/5432/timeline,,,davidtwomey,2926574,MDQ6VXNlcjI5MjY1NzQ=,https://avatars.githubusercontent.com/u/2926574?v=4,,https://api.github.com/users/davidtwomey,https://github.com/davidtwomey,https://api.github.com/users/davidtwomey/followers,https://api.github.com/users/davidtwomey/following{/other_user},https://api.github.com/users/davidtwomey/gists{/gist_id},https://api.github.com/users/davidtwomey/starred{/owner}{/repo},https://api.github.com/users/davidtwomey/subscriptions,https://api.github.com/users/davidtwomey/orgs,https://api.github.com/users/davidtwomey/repos,https://api.github.com/users/davidtwomey/events{/privacy},https://api.github.com/users/davidtwomey/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5432/reactions,7,7,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
239,https://api.github.com/repos/dask/dask/issues/5452,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5452/labels{/name},https://api.github.com/repos/dask/dask/issues/5452/comments,https://api.github.com/repos/dask/dask/issues/5452/events,https://github.com/dask/dask/issues/5452,501712289,MDU6SXNzdWU1MDE3MTIyODk=,5452,Working towards best practices for packages based on dask,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,13,2019-10-02T20:35:12Z,2021-10-13T03:05:15Z,,CONTRIBUTOR,,"This topic was brought up by @mrocklin on twitter: what best practices and guidelines should packages that depend on dask and other pydata packages follow? This was specifically brought up when talking about Satpy which is highly dependent on xarray DataArrays using dask arrays underneath. So the question is, what kind of things could be presented/documented to people wanting to build a package dependent on these dask/xarray/others. Some initial thoughts and questions I had:

1. How/when to allow the user to define their own chunk sizes? With semi-recent updates for 'auto' chunking and setting chunks based on in-memory size this is easier, but still requires asking users to understand some low-level implementation details of a package.
2. How/when should number of workers be configured by the package's user? Things like `OMP_NUM_THREADS` and `DASK_NUM_WORKERS` (or the related dask.config.set parameter).
3. If the package wants to take the advantage of a distributed client (submit, gather, etc) what should the user be required to provide? Is it bad practice to use `get_client` inside the package's utilities to get any configured client? Should a user be required to provide a client? If not provided can/should a package create a local client? Is that too much magic happening without the user's knowledge (creating sub-processes, etc)?

What other areas could these best practices include?

CC @mraspaud (satpy core developer)",,https://api.github.com/repos/dask/dask/issues/5452/timeline,,,djhoese,1828519,MDQ6VXNlcjE4Mjg1MTk=,https://avatars.githubusercontent.com/u/1828519?v=4,,https://api.github.com/users/djhoese,https://github.com/djhoese,https://api.github.com/users/djhoese/followers,https://api.github.com/users/djhoese/following{/other_user},https://api.github.com/users/djhoese/gists{/gist_id},https://api.github.com/users/djhoese/starred{/owner}{/repo},https://api.github.com/users/djhoese/subscriptions,https://api.github.com/users/djhoese/orgs,https://api.github.com/users/djhoese/repos,https://api.github.com/users/djhoese/events{/privacy},https://api.github.com/users/djhoese/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5452/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
240,https://api.github.com/repos/dask/dask/issues/5455,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5455/labels{/name},https://api.github.com/repos/dask/dask/issues/5455/comments,https://api.github.com/repos/dask/dask/issues/5455/events,https://github.com/dask/dask/issues/5455,502126740,MDU6SXNzdWU1MDIxMjY3NDA=,5455,Avoid fusing literals,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,2,2019-10-03T15:09:51Z,2021-10-13T03:04:31Z,,MEMBER,,"We may want to avoid fusing literals in task graphs.  

Now that many computations are run through the distributed scheduler, it may be wise to avoid fusing literal values that are placed into task graphs.  The communication machinery is better able to handle these objects if they are on their own, rather than deep within a complex task.  For example for numpy arrays we're able to serialize and compress these much more effectively.  For HDF5 datasets we're actually able to serialize them, while if we fuse them into a task then we have to use cloudpickle, which ends up failing.

cc @eriknw in case you both have time and if this is easy.",,https://api.github.com/repos/dask/dask/issues/5455/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5455/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
241,https://api.github.com/repos/dask/dask/issues/5471,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5471/labels{/name},https://api.github.com/repos/dask/dask/issues/5471/comments,https://api.github.com/repos/dask/dask/issues/5471/events,https://github.com/dask/dask/issues/5471,503363279,MDU6SXNzdWU1MDMzNjMyNzk=,5471,Release alerts,[],open,False,,"[{'login': 'quasiben', 'id': 1403768, 'node_id': 'MDQ6VXNlcjE0MDM3Njg=', 'avatar_url': 'https://avatars.githubusercontent.com/u/1403768?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/quasiben', 'html_url': 'https://github.com/quasiben', 'followers_url': 'https://api.github.com/users/quasiben/followers', 'following_url': 'https://api.github.com/users/quasiben/following{/other_user}', 'gists_url': 'https://api.github.com/users/quasiben/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/quasiben/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/quasiben/subscriptions', 'organizations_url': 'https://api.github.com/users/quasiben/orgs', 'repos_url': 'https://api.github.com/users/quasiben/repos', 'events_url': 'https://api.github.com/users/quasiben/events{/privacy}', 'received_events_url': 'https://api.github.com/users/quasiben/received_events', 'type': 'User', 'site_admin': False}]",,8,2019-10-07T10:27:36Z,2020-02-10T09:10:11Z,,NONE,,"Is there an official way to be alerted about Dask releases? The GitHub functionality for watching releases doesn't work for the Dask project as the releases are only created as tags, not [GitHub releases](https://help.github.com/en/articles/creating-releases). The [blog](https://blog.dask.org/) also doesn't seem to be updated for each release.

It would be nice to have an alerting system for every release. I often only find out about a new version by our internal GitLab CI throwing errors, e.g. due to https://github.com/dask/dask/issues/5465.

",,https://api.github.com/repos/dask/dask/issues/5471/timeline,,,joschaschmiedt,2520458,MDQ6VXNlcjI1MjA0NTg=,https://avatars.githubusercontent.com/u/2520458?v=4,,https://api.github.com/users/joschaschmiedt,https://github.com/joschaschmiedt,https://api.github.com/users/joschaschmiedt/followers,https://api.github.com/users/joschaschmiedt/following{/other_user},https://api.github.com/users/joschaschmiedt/gists{/gist_id},https://api.github.com/users/joschaschmiedt/starred{/owner}{/repo},https://api.github.com/users/joschaschmiedt/subscriptions,https://api.github.com/users/joschaschmiedt/orgs,https://api.github.com/users/joschaschmiedt/repos,https://api.github.com/users/joschaschmiedt/events{/privacy},https://api.github.com/users/joschaschmiedt/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5471/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,quasiben,1403768.0,MDQ6VXNlcjE0MDM3Njg=,https://avatars.githubusercontent.com/u/1403768?v=4,,https://api.github.com/users/quasiben,https://github.com/quasiben,https://api.github.com/users/quasiben/followers,https://api.github.com/users/quasiben/following{/other_user},https://api.github.com/users/quasiben/gists{/gist_id},https://api.github.com/users/quasiben/starred{/owner}{/repo},https://api.github.com/users/quasiben/subscriptions,https://api.github.com/users/quasiben/orgs,https://api.github.com/users/quasiben/repos,https://api.github.com/users/quasiben/events{/privacy},https://api.github.com/users/quasiben/received_events,User,False
242,https://api.github.com/repos/dask/dask/issues/5492,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5492/labels{/name},https://api.github.com/repos/dask/dask/issues/5492/comments,https://api.github.com/repos/dask/dask/issues/5492/events,https://github.com/dask/dask/issues/5492,506999545,MDU6SXNzdWU1MDY5OTk1NDU=,5492,Dask dataframe resample - value too large to convert to int,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2019-10-15T04:36:18Z,2019-11-19T02:12:47Z,,NONE,,"**_This issue may not be related to Dask itself, but wanted to know if there is a better way._**

I have a very large time-series Dask dataframe (~2.7 billion rows) in which there are several million timestamps (rows) missing.

I am trying to do a `resample` to fill in the missing timestamps (rows) since there is no `reindex` in Dask.

**The problem appears to be in the following code.**

https://github.com/dask/dask/blob/0b2b15bd92857036e309f5e1bffbd766178361e9/dask/dataframe/tseries/resample.py#L41-L48

specifically, this line.

https://github.com/dask/dask/blob/0b2b15bd92857036e309f5e1bffbd766178361e9/dask/dataframe/tseries/resample.py#L48

For boolean indexing like this one, pandas eventually calls `DataFrame.take()` which only takes in integer indexes and is not able to handle large row indexes like 2.7 billion.

**Following is the full backtrace.**

```python
---------------------------------------------------------------------------
OverflowError                             Traceback (most recent call last)
/usr/local/lib/python3.6/site-packages/pandas/core/indexing.py in _getbool_axis(self, key, axis)
   1440         try:
-> 1441             return self.obj.take(inds, axis=axis)
   1442         except Exception as detail:

/usr/local/lib/python3.6/site-packages/pandas/core/series.py in take(self, indices, axis, is_copy, **kwargs)
   4431         indices = ensure_platform_int(indices)
-> 4432         new_index = self.index.take(indices)
   4433

/usr/local/lib/python3.6/site-packages/pandas/core/indexes/datetimelike.py in take(self, indices, axis, allow_fill, fill_value,
**kwargs)
    285
--> 286         maybe_slice = lib.maybe_indices_to_slice(indices, len(self))
    287         if isinstance(maybe_slice, slice):

pandas/_libs/lib.pyx in pandas._libs.lib.maybe_indices_to_slice()

OverflowError: value too large to convert to int

During handling of the above exception, another exception occurred:

KeyError                                  Traceback (most recent call last)
<ipython-input-10-1ad4e47f52da> in <module>
----> 1 df1 = df.resample('10ms').first()

/usr/local/lib/python3.6/site-packages/dask/dataframe/tseries/resample.py in first(self)
    154     @derived_from(pd_Resampler)
    155     def first(self):
--> 156         return self._agg(""first"")
    157
    158     @derived_from(pd_Resampler)

/usr/local/lib/python3.6/site-packages/dask/dataframe/tseries/resample.py in _agg(self, how, meta, fill_value, how_args, how_kwargs)
    110         # Create a grouper to determine closed and label conventions
    111         newdivs, outdivs = _resample_bin_and_out_divs(
--> 112             self.obj.divisions, rule, **kwargs
    113         )
    114

/usr/local/lib/python3.6/site-packages/dask/dataframe/tseries/resample.py in _resample_bin_and_out_divs(divisions, rule, closed, label)
     46     divs = pd.Series(range(len(divisions)), index=divisions)
     47     temp = divs.resample(rule, closed=closed, label=""left"").count()
---> 48     tempdivs = temp.loc[temp > 0].index
     49
     50     # Cleanup closed == 'right' and label == 'right'

/usr/local/lib/python3.6/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1422
   1423             maybe_callable = com.apply_if_callable(key, self.obj)
-> 1424             return self._getitem_axis(maybe_callable, axis=axis)
   1425
   1426     def _is_scalar_access(self, key: Tuple):

/usr/local/lib/python3.6/site-packages/pandas/core/indexing.py in _getitem_axis(self, key, axis)
   1797             return self._get_slice_axis(key, axis=axis)
   1798         elif com.is_bool_indexer(key):
-> 1799             return self._getbool_axis(key, axis=axis)
   1800         elif is_list_like_indexer(key):
   1801

/usr/local/lib/python3.6/site-packages/pandas/core/indexing.py in _getbool_axis(self, key, axis)
   1441             return self.obj.take(inds, axis=axis)
   1442         except Exception as detail:
-> 1443             raise self._exception(detail)
   1444
   1445     def _get_slice_axis(self, slice_obj: slice, axis: int):

KeyError: OverflowError('value too large to convert to int',)
> /usr/local/lib/python3.6/site-packages/pandas/core/indexing.py(1443)_getbool_axis()
   1441             return self.obj.take(inds, axis=axis)
   1442         except Exception as detail:
-> 1443             raise self._exception(detail)
   1444
   1445     def _get_slice_axis(self, slice_obj: slice, axis: int):
```

**Following are some of the values I'm dealing with.**

```python
> /usr/local/lib/python3.6/site-packages/dask/dataframe/tseries/resample.py(48)_resample_bin_and_out_divs()
     46     divs = pd.Series(range(len(divisions)), index=divisions)
     47     temp = divs.resample(rule, closed=closed, label=""left"").count()
---> 48     tempdivs = temp.loc[temp > 0].index
     49
     50     # Cleanup closed == 'right' and label == 'right'

ipdb> p temp
2018-09-21 00:44:32.180    1
2018-09-21 00:44:32.190    0
2018-09-21 00:44:32.200    0
2018-09-21 00:44:32.210    0
2018-09-21 00:44:32.220    0
                          ..
2019-07-30 17:40:23.080    0
2019-07-30 17:40:23.090    0
2019-07-30 17:40:23.100    0
2019-07-30 17:40:23.110    0
2019-07-30 17:40:23.120    1
Freq: 10L, Length: 2701775095, dtype: int64

ipdb> temp.loc[temp > 0]
*** KeyError: OverflowError('value too large to convert to int',)
```

```python
ipdb> d
> /usr/local/lib/python3.6/site-packages/pandas/core/indexing.py(1799)_getitem_axis()
   1797             return self._get_slice_axis(key, axis=axis)
   1798         elif com.is_bool_indexer(key):
-> 1799             return self._getbool_axis(key, axis=axis)
   1800         elif is_list_like_indexer(key):
   1801

ipdb> p key
2018-09-21 00:44:32.180     True
2018-09-21 00:44:32.190    False
2018-09-21 00:44:32.200    False
2018-09-21 00:44:32.210    False
2018-09-21 00:44:32.220    False
                           ...
2019-07-30 17:40:23.080    False
2019-07-30 17:40:23.090    False
2019-07-30 17:40:23.100    False
2019-07-30 17:40:23.110    False
2019-07-30 17:40:23.120     True
Freq: 10L, Length: 2701775095, dtype: bool
```

```python
ipdb> d
> /usr/local/lib/python3.6/site-packages/pandas/core/indexing.py(1443)_getbool_axis()
   1441             return self.obj.take(inds, axis=axis)
   1442         except Exception as detail:
-> 1443             raise self._exception(detail)
   1444
   1445     def _get_slice_axis(self, slice_obj: slice, axis: int):

ipdb> l
   1438         key = check_bool_indexer(labels, key)
   1439         inds, = key.nonzero()
   1440         try:
   1441             return self.obj.take(inds, axis=axis)
   1442         except Exception as detail:
-> 1443             raise self._exception(detail)
   1444
   1445     def _get_slice_axis(self, slice_obj: slice, axis: int):
   1446         """""" this is pretty simple as we just have to deal with labels """"""
   1447         # caller is responsible for ensuring non-None axis
   1448         obj = self.obj

ipdb> p inds
array([         0,       2782,       8782, ..., 2701766782, 2701772782,
       2701775094])
ipdb> len(inds)
450298
ipdb> p axis
0
```",,https://api.github.com/repos/dask/dask/issues/5492/timeline,,,varunbpatil,1353218,MDQ6VXNlcjEzNTMyMTg=,https://avatars.githubusercontent.com/u/1353218?v=4,,https://api.github.com/users/varunbpatil,https://github.com/varunbpatil,https://api.github.com/users/varunbpatil/followers,https://api.github.com/users/varunbpatil/following{/other_user},https://api.github.com/users/varunbpatil/gists{/gist_id},https://api.github.com/users/varunbpatil/starred{/owner}{/repo},https://api.github.com/users/varunbpatil/subscriptions,https://api.github.com/users/varunbpatil/orgs,https://api.github.com/users/varunbpatil/repos,https://api.github.com/users/varunbpatil/events{/privacy},https://api.github.com/users/varunbpatil/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5492/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
243,https://api.github.com/repos/dask/dask/issues/5503,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5503/labels{/name},https://api.github.com/repos/dask/dask/issues/5503/comments,https://api.github.com/repos/dask/dask/issues/5503/events,https://github.com/dask/dask/issues/5503,508862421,MDU6SXNzdWU1MDg4NjI0MjE=,5503,Distributing heavy functions via closures,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,4,2019-10-18T05:28:35Z,2021-03-12T14:37:17Z,,NONE,,"Hi,

So I had started investigating usage of heavy functions, e.g. something with large state such as the example below:
```python
from dask.distributed import Client
client = Client()

import numpy as np
import time

class Heavy():
    def __init__(self):
        self.state = np.arange(1000000)
    
    def __call__(self, arg):
        return np.sum(self.state * arg)

heavy = Heavy()
```

If I send jobs out using the function itself, or a small perturbation of it, it takes quite a while.  I assume there is some bottleneck in function distribution:
```python
from functools import partial

def dosomething(arg, func):
    return func(arg)

tic = time.time()
closure = partial(dosomething, func=heavy)
out = client.map(closure, np.random.normal(size=100))
sum(f.result() for f in out)
print(time.time() - tic)
```
returns 21 seconds on my laptop.  Now, clearly this is a case where broadcasting could help, so I do that:
```python
from itertools import repeat

def dosomething2(args):
    arg, func = args
    return func(arg)

tic = time.time()
heavy_token = client.scatter(heavy, broadcast=True, hash=False)
items = list(zip(np.random.normal(size=100), repeat(heavy_token)))
out = client.map(dosomething2, items)
sum(f.result() for f in out)
print(time.time() - tic)
```
and that gets me down to 0.97 seconds!
But I still want to do my closure trick, so I do this:
```python
def dosomething3(arg, func):
    func = func.result()
    return func(arg)

tic = time.time()
closure = partial(dosomething3, func=heavy_token)
out = client.map(closure, np.random.normal(size=100))
sum(f.result() for f in out)
print(time.time() - tic)
```
and it takes 1.9 seconds, which seems strange that it is slower.  Now this is all fine, but the issue I want to report is that after executing the third code snippet, if I navigate to `http://127.0.0.1:8787/graph`, an exception is produced:
```
distributed.utils - ERROR - '<' not supported between instances of 'NoneType' and 'tuple'
Traceback (most recent call last):
  File ""/usr/local/lib/python3.7/site-packages/distributed/utils.py"", line 662, in log_errors
    yield
  File ""/usr/local/lib/python3.7/site-packages/distributed/dashboard/components/scheduler.py"", line 1692, in graph_doc
    graph = TaskGraph(scheduler, sizing_mode=""stretch_both"")
  File ""/usr/local/lib/python3.7/site-packages/distributed/dashboard/components/scheduler.py"", line 1021, in __init__
    self.layout = GraphLayout(scheduler)
  File ""/usr/local/lib/python3.7/site-packages/distributed/diagnostics/graph_layout.py"", line 39, in __init__
    self.scheduler, dependencies=dependencies, priority=priority
  File ""/usr/local/lib/python3.7/site-packages/distributed/diagnostics/graph_layout.py"", line 43, in update_graph
    stack = sorted(dependencies, key=lambda k: priority.get(k, 0), reverse=True)
TypeError: '<' not supported between instances of 'NoneType' and 'tuple'
tornado.application - ERROR - Uncaught exception GET /graph (127.0.0.1)
HTTPServerRequest(protocol='http', host='127.0.0.1:8787', method='GET', uri='/graph', version='HTTP/1.1', remote_ip='127.0.0.1')
Traceback (most recent call last):
  File ""/usr/local/Cellar/ipython/7.2.0/libexec/vendor/lib/python3.7/site-packages/tornado/web.py"", line 1592, in _execute
    result = yield result
  File ""/usr/local/Cellar/ipython/7.2.0/libexec/vendor/lib/python3.7/site-packages/tornado/gen.py"", line 1133, in run
    value = future.result()
  File ""/usr/local/Cellar/ipython/7.2.0/libexec/vendor/lib/python3.7/site-packages/tornado/gen.py"", line 1141, in run
    yielded = self.gen.throw(*exc_info)
  File ""/usr/local/lib/python3.7/site-packages/bokeh/server/views/doc_handler.py"", line 55, in get
    session = yield self.get_session()
  File ""/usr/local/Cellar/ipython/7.2.0/libexec/vendor/lib/python3.7/site-packages/tornado/gen.py"", line 1133, in run
    value = future.result()
  File ""/usr/local/Cellar/ipython/7.2.0/libexec/vendor/lib/python3.7/site-packages/tornado/gen.py"", line 1141, in run
    yielded = self.gen.throw(*exc_info)
  File ""/usr/local/lib/python3.7/site-packages/bokeh/server/views/session_handler.py"", line 77, in get_session
    session = yield self.application_context.create_session_if_needed(session_id, self.request)
  File ""/usr/local/Cellar/ipython/7.2.0/libexec/vendor/lib/python3.7/site-packages/tornado/gen.py"", line 1133, in run
    value = future.result()
  File ""/usr/local/Cellar/ipython/7.2.0/libexec/vendor/lib/python3.7/site-packages/tornado/gen.py"", line 1147, in run
    yielded = self.gen.send(value)
  File ""/usr/local/lib/python3.7/site-packages/bokeh/server/contexts.py"", line 215, in create_session_if_needed
    self._application.initialize_document(doc)
  File ""/usr/local/lib/python3.7/site-packages/bokeh/application/application.py"", line 178, in initialize_document
    h.modify_document(doc)
  File ""/usr/local/lib/python3.7/site-packages/bokeh/application/handlers/function.py"", line 133, in modify_document
    self._func(doc)
  File ""/usr/local/lib/python3.7/site-packages/distributed/dashboard/components/scheduler.py"", line 1692, in graph_doc
    graph = TaskGraph(scheduler, sizing_mode=""stretch_both"")
  File ""/usr/local/lib/python3.7/site-packages/distributed/dashboard/components/scheduler.py"", line 1021, in __init__
    self.layout = GraphLayout(scheduler)
  File ""/usr/local/lib/python3.7/site-packages/distributed/diagnostics/graph_layout.py"", line 39, in __init__
    self.scheduler, dependencies=dependencies, priority=priority
  File ""/usr/local/lib/python3.7/site-packages/distributed/diagnostics/graph_layout.py"", line 43, in update_graph
    stack = sorted(dependencies, key=lambda k: priority.get(k, 0), reverse=True)
TypeError: '<' not supported between instances of 'NoneType' and 'tuple'
Exception ignored in: <function TaskGraph.__del__ at 0x1125a1950>
Traceback (most recent call last):
  File ""/usr/local/lib/python3.7/site-packages/distributed/dashboard/components/scheduler.py"", line 1175, in __del__
    self.scheduler.remove_plugin(self.layout)
AttributeError: 'TaskGraph' object has no attribute 'layout'
```
and subsequent calls continue to produce the same error.",,https://api.github.com/repos/dask/dask/issues/5503/timeline,,,nsmith-,6587412,MDQ6VXNlcjY1ODc0MTI=,https://avatars.githubusercontent.com/u/6587412?v=4,,https://api.github.com/users/nsmith-,https://github.com/nsmith-,https://api.github.com/users/nsmith-/followers,https://api.github.com/users/nsmith-/following{/other_user},https://api.github.com/users/nsmith-/gists{/gist_id},https://api.github.com/users/nsmith-/starred{/owner}{/repo},https://api.github.com/users/nsmith-/subscriptions,https://api.github.com/users/nsmith-/orgs,https://api.github.com/users/nsmith-/repos,https://api.github.com/users/nsmith-/events{/privacy},https://api.github.com/users/nsmith-/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5503/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
244,https://api.github.com/repos/dask/dask/issues/5518,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5518/labels{/name},https://api.github.com/repos/dask/dask/issues/5518/comments,https://api.github.com/repos/dask/dask/issues/5518/events,https://github.com/dask/dask/issues/5518,510272388,MDU6SXNzdWU1MTAyNzIzODg=,5518,DaskMethodsMixin compute does not work with async clients,[],open,False,,[],,8,2019-10-21T20:31:16Z,2021-05-14T17:52:17Z,,NONE,,"Below is a minimal repro
```
import dask.distributed as dd
import dask.bag as db

cluster = dd.LocalCluster()
client = dd.Client(cluster.scheduler_address,asynchronous=True)

bag = db.from_sequence(range(0,4))
bag.map(lambda x:x).compute()
```
Gives the error
```
/opt/conda/envs/python3/lib/python3.7/site-packages/dask/base.py in compute(*args, **kwargs)
    445     postcomputes = [x.__dask_postcompute__() for x in collections]
    446     results = schedule(dsk, keys, **kwargs)
--> 447     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    448 
    449 

TypeError: zip argument #1 must support iteration
```

It looks like compute has not been changed to deal with the coroutine when the client is asynchronous.  Presumably compute should be a coroutine in that case.

I believe this affects all versions but just in case my environment is:
```
dask                      2.3.0                      py_0    conda-forge
dask-core                 2.3.0                      py_0    conda-forge
distributed               2.5.1                      py_0    conda-forge
```",,https://api.github.com/repos/dask/dask/issues/5518/timeline,,,tilign,1727639,MDQ6VXNlcjE3Mjc2Mzk=,https://avatars.githubusercontent.com/u/1727639?v=4,,https://api.github.com/users/tilign,https://github.com/tilign,https://api.github.com/users/tilign/followers,https://api.github.com/users/tilign/following{/other_user},https://api.github.com/users/tilign/gists{/gist_id},https://api.github.com/users/tilign/starred{/owner}{/repo},https://api.github.com/users/tilign/subscriptions,https://api.github.com/users/tilign/orgs,https://api.github.com/users/tilign/repos,https://api.github.com/users/tilign/events{/privacy},https://api.github.com/users/tilign/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5518/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
245,https://api.github.com/repos/dask/dask/issues/5533,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5533/labels{/name},https://api.github.com/repos/dask/dask/issues/5533/comments,https://api.github.com/repos/dask/dask/issues/5533/events,https://github.com/dask/dask/issues/5533,512643045,MDU6SXNzdWU1MTI2NDMwNDU=,5533,Dataclass traversal breaks delayed __init__ and __post_init__,"[{'id': 1968982461, 'node_id': 'MDU6TGFiZWwxOTY4OTgyNDYx', 'url': 'https://api.github.com/repos/dask/dask/labels/delayed', 'name': 'delayed', 'color': '4f6edd', 'default': False, 'description': ''}]",open,False,,[],,3,2019-10-25T17:56:01Z,2021-10-13T02:50:39Z,,NONE,,"We use `dataclasses.dataclass` to instantiate resources. Since PR 4165, they are traversed and rebuilt on `delayed`. This causes:
1) not being able to delay `__init__` and 
2) re-invokation of `__post_init__` .

```python
from dataclasses import dataclass
from dask import delayed

@dataclass
class D:
    x: int
    y: float
    def __post_init__(self):
        print(""getting expensive resource"")
        self.z = self.x + self.y
    def __call__(self):
        print(self.z, ""is ready"")
        
d = D(1,1.0)
## getting expensive resource
d()
## 2.0 is ready

# Problem 1)

# Trying to instantiate a dataclass:
# AttributeError: type object 'D' has no attribute 'x' in delayed::unpack_collections
# because `is_dataclass` is True for D and instances of D
delayed(D)(1, 1.0).compute().z

# Problem 2)

# z is created twice
delayed(D(1, 1.0))().compute()
## getting expensive resource
## getting expensive resource
## 2.0 is ready

# z is created again
def operate_on(d: D):
    d()
    print(""Thanks for"", d.z)

delayed(operate_on, traverse=False)(d).compute()
## getting expensive resource
## 2.0 is ready
## Thanks for 2.0
```
_dask 2.6 (and also on 2.2)
python 3.6.7 with dataclass backport_


I think we can work around by delaying collections with dataclasses separately. However, I'm not sure if there are more elegant ways. 

Passing traverse=False down to `Delayed.__call__`  is maybe one way, or discriminating between dataclasses with and without `__post_init__` at some point.

(edits: wording and traverse=False for last example)",,https://api.github.com/repos/dask/dask/issues/5533/timeline,,,ahirner,6055037,MDQ6VXNlcjYwNTUwMzc=,https://avatars.githubusercontent.com/u/6055037?v=4,,https://api.github.com/users/ahirner,https://github.com/ahirner,https://api.github.com/users/ahirner/followers,https://api.github.com/users/ahirner/following{/other_user},https://api.github.com/users/ahirner/gists{/gist_id},https://api.github.com/users/ahirner/starred{/owner}{/repo},https://api.github.com/users/ahirner/subscriptions,https://api.github.com/users/ahirner/orgs,https://api.github.com/users/ahirner/repos,https://api.github.com/users/ahirner/events{/privacy},https://api.github.com/users/ahirner/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5533/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
246,https://api.github.com/repos/dask/dask/issues/5540,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5540/labels{/name},https://api.github.com/repos/dask/dask/issues/5540/comments,https://api.github.com/repos/dask/dask/issues/5540/events,https://github.com/dask/dask/issues/5540,513942430,MDU6SXNzdWU1MTM5NDI0MzA=,5540,Cross-Chunk Slicing Memory Error,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,8,2019-10-29T14:04:49Z,2020-03-19T13:09:57Z,,NONE,,"My team's userbase of scientists often need to slice data in shapes that result in each slice touching high numbers of the source data's chunks. This causes sub-optimal memory usage by Dask - see [Specifying Chunk shapes](https://docs.dask.org/en/latest/array-chunks.html#specifying-chunk-shapes) in the documentation. In some examples this is causing memory errors, and unfortunately the users have no control over the source data's chunking. The current difficulty with 'cross-chunk slicing' is therefore a blocker preventing this group of scientists from adopting Dask.

Could changes be made to Dask that would remove this limitation, without negatively affecting performance in other scenarios? I see that this has been discussed in #3595, but that no conclusions have been reached since workarounds were possible. We are hoping a general solution may be reachable since developing case-by-case workarounds for each of our users is beyond the resource we have.

I'd be happy to spend time upskilling enough to discuss / work on a solution myself, but first it would be very helpful to know whether this might be a dead-end or whether it is worth investing the time. Thanks!

_The below two examples of cross-chunk slicing cause memory errors with Dask 2.5.2, Numpy 1.17.2._

<details>
    <summary>System specs</summary>

````
$ lscpu
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                4
On-line CPU(s) list:   0-3
Thread(s) per core:    1
Core(s) per socket:    4
Socket(s):             1
NUMA node(s):          1
Vendor ID:             GenuineIntel
CPU family:            6
Model:                 79
Model name:            Intel(R) Xeon(R) CPU E5-2690 v4 @ 2.60GHz
Stepping:              1
CPU MHz:               2599.998
BogoMIPS:              5199.99
Virtualization:        VT-x
Hypervisor vendor:     VMware
Virtualization type:   full
L1d cache:             32K
L1i cache:             32K
L2 cache:              256K
L3 cache:              35840K
NUMA node0 CPU(s):     0-3
````
```
$ lsmem
RANGE                                 SIZE  STATE REMOVABLE BLOCK
0x0000000000000000-0x00000000bfffffff   3G online        no  0-23
0x0000000100000000-0x00000001bfffffff   3G online        no 32-55

Memory block size:       128M
Total online memory:       6G
Total offline memory:      0B

```

</details>

```python
# Example using the shape of a real dataset that has this problem.
shape_original = da.random.random(
    size=[11280, 720, 1440],
    chunks=[16, -1, -1])
slice_original = shape_original[:, :71, :130]
slice_original.compute()
```
```python
# Simplified example demonstrating the same problem.
shape_simplified = da.random.random(
    size=[100000, 100000],
    chunks=[1, -1])
slice_simplified = shape_simplified[:, 1]
slice_simplified.compute()
```",,https://api.github.com/repos/dask/dask/issues/5540/timeline,,,trexfeathers,40734014,MDQ6VXNlcjQwNzM0MDE0,https://avatars.githubusercontent.com/u/40734014?v=4,,https://api.github.com/users/trexfeathers,https://github.com/trexfeathers,https://api.github.com/users/trexfeathers/followers,https://api.github.com/users/trexfeathers/following{/other_user},https://api.github.com/users/trexfeathers/gists{/gist_id},https://api.github.com/users/trexfeathers/starred{/owner}{/repo},https://api.github.com/users/trexfeathers/subscriptions,https://api.github.com/users/trexfeathers/orgs,https://api.github.com/users/trexfeathers/repos,https://api.github.com/users/trexfeathers/events{/privacy},https://api.github.com/users/trexfeathers/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5540/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
247,https://api.github.com/repos/dask/dask/issues/5544,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5544/labels{/name},https://api.github.com/repos/dask/dask/issues/5544/comments,https://api.github.com/repos/dask/dask/issues/5544/events,https://github.com/dask/dask/issues/5544,514943833,MDU6SXNzdWU1MTQ5NDM4MzM=,5544,chunks get combined in 4d array reshape,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,22,2019-10-30T19:57:15Z,2020-10-19T18:39:41Z,,MEMBER,,"I want to reshape a 4D dask array in such a way that I expect should preserve the original chunk structure. I am finding that `reshape` is instead rechunking my array in a non-optimal way.

Things work as expected in 3D:
```python
import dask.array as dsa
data = dsa.ones((20, 20, 5), chunks=(10, 10, 5))
display(data)
dsa.reshape(data, (400, 5))
```

![image](https://user-images.githubusercontent.com/1197350/67893356-d90ab080-fb2c-11e9-9b05-3938df254d4c.png)

The chunks simply get stacked into a single column. Examining the graph, however, reveals there is an intermediate merge step:

![image](https://user-images.githubusercontent.com/1197350/67893884-d9f01200-fb2d-11e9-8962-28a80b28d663.png)


If I add another dimension at the beginning, things don't look as nice:
```python
data = dsa.ones((2, 20, 20, 5), chunks=(1, 10, 10, 5))
display(data)
dsa.reshape(data, (800, 5))
```

![image](https://user-images.githubusercontent.com/1197350/67893508-13744d80-fb2d-11e9-96f0-0cd92b942f75.png)

Rather than seeing a neat stack of 8 chunks as I expected, the chunks have been fused.

![image](https://user-images.githubusercontent.com/1197350/67893915-ea07f180-fb2d-11e9-9c4e-2936dcf6f01e.png)

This causes big problems for me when I am trying to do some processing of very large arrays. I can't afford to have the chunks fused, or else I will run out of memory.

Dask version 2.6.0+10.g8179f7f3",,https://api.github.com/repos/dask/dask/issues/5544/timeline,,,rabernat,1197350,MDQ6VXNlcjExOTczNTA=,https://avatars.githubusercontent.com/u/1197350?v=4,,https://api.github.com/users/rabernat,https://github.com/rabernat,https://api.github.com/users/rabernat/followers,https://api.github.com/users/rabernat/following{/other_user},https://api.github.com/users/rabernat/gists{/gist_id},https://api.github.com/users/rabernat/starred{/owner}{/repo},https://api.github.com/users/rabernat/subscriptions,https://api.github.com/users/rabernat/orgs,https://api.github.com/users/rabernat/repos,https://api.github.com/users/rabernat/events{/privacy},https://api.github.com/users/rabernat/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5544/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
248,https://api.github.com/repos/dask/dask/issues/5610,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5610/labels{/name},https://api.github.com/repos/dask/dask/issues/5610/comments,https://api.github.com/repos/dask/dask/issues/5610/events,https://github.com/dask/dask/issues/5610,525779100,MDU6SXNzdWU1MjU3NzkxMDA=,5610,Clean up warnings in doc build,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,8,2019-11-20T12:40:58Z,2023-08-10T09:18:47Z,,MEMBER,,"Right now our doc build has many warnings. This makes it hard to catch newly introduced errors in the doc build. Sphinx has an option to elevate warnings to errors.

In the details, I've included some warnings from a recent local build

<details>

```
/Users/taugspurger/miniconda3/envs/dask-dev/lib/python3.7/site-packages/numpydoc/docscrape.py:377: UserWarning: Unknown section Paramters in the docstring of None in None.
  warn(msg)
/Users/taugspurger/miniconda3/envs/dask-dev/lib/python3.7/site-packages/numpydoc/docscrape.py:377: UserWarning: Unknown section Paramters in the docstring of <function make_people at 0x1053d3c80> in /Users/taugspurger/sandbox/dask/dask/datasets.py.
  warn(msg)
/Users/taugspurger/miniconda3/envs/dask-dev/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: numpy.ufunc size changed, may indicate binary incompatibility. Expected 192 from C header, got 216 from PyObject
  return f(*args, **kwds)
/Users/taugspurger/miniconda3/envs/dask-dev/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: numpy.ufunc size changed, may indicate binary incompatibility. Expected 192 from C header, got 216 from PyObject
  return f(*args, **kwds)
/Users/taugspurger/miniconda3/envs/dask-dev/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: numpy.ufunc size changed, may indicate binary incompatibility. Expected 192 from C header, got 216 from PyObject
  return f(*args, **kwds)
/Users/taugspurger/sandbox/dask/dask/array/core.py:docstring of dask.array.from_array:16: WARNING: Unexpected indentation.
/Users/taugspurger/sandbox/dask/dask/array/core.py:docstring of dask.array.from_array:17: WARNING: Block quote ends without a blank line; unexpected unindent.
/Users/taugspurger/sandbox/dask/dask/array/routines.py:docstring of dask.array.apply_along_axis:13: WARNING: Unexpected section title.

Parameters
__________
/Users/taugspurger/sandbox/dask/dask/array/creation.py:docstring of dask.array.indices:26: WARNING: Bullet list ends without a blank line; unexpected unindent.
/Users/taugspurger/sandbox/dask/dask/array/percentile.py:docstring of dask.array.percentile:19: WARNING: Bullet list ends without a blank line; unexpected unindent.
/Users/taugspurger/sandbox/dask/dask/array/core.py:docstring of dask.array.from_array:16: WARNING: Unexpected indentation.
/Users/taugspurger/sandbox/dask/dask/array/core.py:docstring of dask.array.from_array:17: WARNING: Block quote ends without a blank line; unexpected unindent.
/Users/taugspurger/sandbox/dask/dask/array/core.py:docstring of dask.array.to_npy_stack:26: WARNING: Inline substitution_reference start-string without end-string.
/Users/taugspurger/sandbox/dask/dask/array/core.py:docstring of dask.array.to_npy_stack:26: WARNING: Inline substitution_reference start-string without end-string.
/Users/taugspurger/sandbox/dask/dask/array/core.py:docstring of dask.array.to_npy_stack:26: WARNING: Inline substitution_reference start-string without end-string.
/Users/taugspurger/sandbox/dask/dask/array/core.py:docstring of dask.array.to_npy_stack:26: WARNING: Inline substitution_reference start-string without end-string.
/Users/taugspurger/sandbox/dask/dask/array/core.py:docstring of dask.array.Array.moment:44: WARNING: Explicit markup ends without a blank line; unexpected unindent.
/Users/taugspurger/sandbox/dask/dask/array/core.py:docstring of dask.array.Array.vindex:12: WARNING: Unknown target name: ""1"".
/Users/taugspurger/sandbox/dask/docs/source/array-creation.rst:221: WARNING: Duplicate explicit target name: ""zarr"".
/Users/taugspurger/sandbox/dask/docs/source/custom-collections.rst:46: WARNING: Unexpected section title.

Returns
-------
/Users/taugspurger/sandbox/dask/docs/source/custom-collections.rst:58: WARNING: Unexpected section title.

Returns
-------
/Users/taugspurger/sandbox/dask/docs/source/custom-collections.rst:79: WARNING: Unexpected section title.

Parameters
----------
/Users/taugspurger/sandbox/dask/docs/source/custom-collections.rst:91: WARNING: Unexpected section title.

Returns
-------
/Users/taugspurger/sandbox/dask/docs/source/custom-collections.rst:116: WARNING: Unexpected section title.

Returns
-------
/Users/taugspurger/sandbox/dask/docs/source/custom-collections.rst:139: WARNING: Unexpected section title.

Returns
-------
WARNING: failed to import to_dask_array
WARNING: failed to import to_delayed
/Users/taugspurger/sandbox/dask/dask/dataframe/core.py:docstring of dask.dataframe.DataFrame.merge:17: WARNING: Unexpected indentation.
/Users/taugspurger/sandbox/dask/dask/dataframe/core.py:docstring of dask.dataframe.DataFrame.merge:19: WARNING: Block quote ends without a blank line; unexpected unindent.
/Users/taugspurger/sandbox/dask/dask/dataframe/core.py:docstring of dask.dataframe.DataFrame.where:141: WARNING: Duplicate explicit target name: ""user guide"".
/Users/taugspurger/sandbox/dask/dask/dataframe/core.py:docstring of dask.dataframe.Series.where:141: WARNING: Duplicate explicit target name: ""user guide"".
/Users/taugspurger/sandbox/dask/dask/dataframe/core.py:docstring of dask.dataframe.Series.where:141: WARNING: Duplicate explicit target name: ""user guide"".
/Users/taugspurger/sandbox/dask/dask/dataframe/io/parquet/core.py:docstring of dask.dataframe.read_parquet:25: WARNING: Definition list ends without a blank line; unexpected unindent.
WARNING: autodoc: failed to import function 'make_meta' from module 'utils'; the following exception was raised:
No module named 'utils'
/Users/taugspurger/sandbox/dask/docs/source/institutional-faq.rst:158: WARNING: Bullet list ends without a blank line; unexpected unindent.
/Users/taugspurger/sandbox/dask/docs/source/institutional-faq.rst:160: WARNING: Block quote ends without a blank line; unexpected unindent.
/Users/taugspurger/sandbox/dask/docs/source/institutional-faq.rst:161: WARNING: Bullet list ends without a blank line; unexpected unindent.
/Users/taugspurger/sandbox/dask/docs/source/institutional-faq.rst:171: WARNING: Bullet list ends without a blank line; unexpected unindent.
/Users/taugspurger/sandbox/dask/docs/source/institutional-faq.rst:174: WARNING: Bullet list ends without a blank line; unexpected unindent.
/Users/taugspurger/sandbox/dask/docs/source/remote-data-services.rst:262: WARNING: Explicit markup ends without a blank line; unexpected unindent.
WARNING: duplicate object description of distributed.Client.register_worker_plugin, other instance in futures, use :noindex: for one of them
/Users/taugspurger/sandbox/distributed/distributed/deploy/ssh.py:docstring of distributed.deploy.ssh.SSHCluster:30: WARNING: Unexpected indentation.
looking for now-outdated files... none found
pickling environment... done
checking consistency... /Users/taugspurger/sandbox/dask/docs/source/phases-of-computation.rst: WARNING: document isn't included in any toctree
/Users/taugspurger/sandbox/dask/docs/source/scheduler-choice.rst: WARNING: document isn't included in any toctree
/Users/taugspurger/sandbox/dask/docs/source/scheduler-overview.rst: WARNING: document isn't included in any toctree
/Users/taugspurger/sandbox/dask/docs/source/scheduling-policy.rst: WARNING: document isn't included in any toctree
/Users/taugspurger/sandbox/dask/docs/source/shared.rst: WARNING: document isn't included in any toctree

/Users/taugspurger/miniconda3/envs/dask-dev/lib/python3.7/site-packages/dask_sphinx_theme/layout.html:22: RemovedInSphinx30Warning: To modify script_files in the theme is deprecated. Please insert a <script> tag directly in your theme instead.
  <ul>
/Users/taugspurger/sandbox/dask/docs/source/dataframe-create.rst:10: WARNING: unknown document: dataframe-overview
/Users/taugspurger/sandbox/distributed/distributed/client.py:docstring of distributed.Client.compute:44: WARNING: unknown document: resources
/Users/taugspurger/sandbox/distributed/distributed/client.py:docstring of distributed.Client.compute:51: WARNING: unknown document: actors
/Users/taugspurger/sandbox/distributed/distributed/client.py:docstring of distributed.Client.map:40: WARNING: unknown document: resources
/Users/taugspurger/sandbox/distributed/distributed/client.py:docstring of distributed.Client.map:46: WARNING: unknown document: actors
/Users/taugspurger/sandbox/distributed/distributed/client.py:docstring of distributed.Client.persist:38: WARNING: unknown document: resources
/Users/taugspurger/sandbox/distributed/distributed/client.py:docstring of distributed.Client.persist:45: WARNING: unknown document: actors
/Users/taugspurger/sandbox/distributed/distributed/client.py:docstring of distributed.Client.submit:42: WARNING: unknown document: resources
/Users/taugspurger/sandbox/distributed/distributed/client.py:docstring of distributed.Client.submit:47: WARNING: unknown document: actors
/Users/taugspurger/sandbox/dask/docs/source/setup/custom-startup.rst:30: WARNING: unknown document: plugins

copying static files... done
copying extra files... /Users/taugspurger/miniconda3/envs/dask-dev/lib/python3.7/site-packages/sphinx_rtd_theme/search.html:20: RemovedInSphinx30Warning: To modify script_files in the theme is deprecated. Please insert a <script> tag directly in your theme instead.
  {{ super() }}
WARNING: html_extra_path entry '/Users/taugspurger/sandbox/dask/docs/source/index.html' does not exist

```

</details>",,https://api.github.com/repos/dask/dask/issues/5610/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5610/reactions,0,0,0,0,0,0,0,0,0,jsignell,4806877.0,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
249,https://api.github.com/repos/dask/dask/issues/5631,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5631/labels{/name},https://api.github.com/repos/dask/dask/issues/5631/comments,https://api.github.com/repos/dask/dask/issues/5631/events,https://github.com/dask/dask/pull/5631,527737351,MDExOlB1bGxSZXF1ZXN0MzQ0OTM0ODQy,5631,Warn user when tokenize function is slow,[],open,False,,[],,5,2019-11-24T18:31:38Z,2021-03-08T20:19:37Z,,FIRST_TIME_CONTRIBUTOR,,"- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask`

https://github.com/dask/dask/issues/4275",,https://api.github.com/repos/dask/dask/issues/5631/timeline,,,mikedeltalima,19712828,MDQ6VXNlcjE5NzEyODI4,https://avatars.githubusercontent.com/u/19712828?v=4,,https://api.github.com/users/mikedeltalima,https://github.com/mikedeltalima,https://api.github.com/users/mikedeltalima/followers,https://api.github.com/users/mikedeltalima/following{/other_user},https://api.github.com/users/mikedeltalima/gists{/gist_id},https://api.github.com/users/mikedeltalima/starred{/owner}{/repo},https://api.github.com/users/mikedeltalima/subscriptions,https://api.github.com/users/mikedeltalima/orgs,https://api.github.com/users/mikedeltalima/repos,https://api.github.com/users/mikedeltalima/events{/privacy},https://api.github.com/users/mikedeltalima/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5631/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/5631,https://github.com/dask/dask/pull/5631,https://github.com/dask/dask/pull/5631.diff,https://github.com/dask/dask/pull/5631.patch,,,,,,,,,,,,,,,,,,,
250,https://api.github.com/repos/dask/dask/issues/5633,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5633/labels{/name},https://api.github.com/repos/dask/dask/issues/5633/comments,https://api.github.com/repos/dask/dask/issues/5633/events,https://github.com/dask/dask/issues/5633,528137403,MDU6SXNzdWU1MjgxMzc0MDM=,5633,Add partition lengths to DataFrame metadata.,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,11,2019-11-25T14:51:06Z,2022-03-15T21:22:18Z,,NONE,,"*edit by TomAugspurger*

Currently partitions within a dask DataFrame do not known their own length. Anything using the length of the DataFrame or the partitions will need to compute it at runtime. The simplest case is `len`, which involves computing the graph and summing up the length of each partition

```python
In [1]: import dask

In [8]: ts = dask.datasets.timeseries()

In [9]: len(ts)
Out[9]: 2592000

In [10]: ts.map_partitions(len).compute()
Out[10]:
0     86400
1     86400
2     86400
...
27    86400
28    86400
29    86400
dtype: int64
```

Certain data storage formats (e.g. parquet) know the number of rows and could provide that to Dask, if there was a way to store it. This is somewhat complicated though (https://github.com/dask/dask/issues/5633#issuecomment-558228192).

*original post below*

---

Following this SO question: https://stackoverflow.com/questions/59023793/why-is-computing-the-shape-on-an-indexed-parquet-file-so-slow-in-dask/59034239#59034239

It would be nice to compute the length of a dataframe from its metadata (if available) instead of iterating over all partitions.",,https://api.github.com/repos/dask/dask/issues/5633/timeline,,,hadim,528003,MDQ6VXNlcjUyODAwMw==,https://avatars.githubusercontent.com/u/528003?v=4,,https://api.github.com/users/hadim,https://github.com/hadim,https://api.github.com/users/hadim/followers,https://api.github.com/users/hadim/following{/other_user},https://api.github.com/users/hadim/gists{/gist_id},https://api.github.com/users/hadim/starred{/owner}{/repo},https://api.github.com/users/hadim/subscriptions,https://api.github.com/users/hadim/orgs,https://api.github.com/users/hadim/repos,https://api.github.com/users/hadim/events{/privacy},https://api.github.com/users/hadim/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5633/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
251,https://api.github.com/repos/dask/dask/issues/5644,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5644/labels{/name},https://api.github.com/repos/dask/dask/issues/5644/comments,https://api.github.com/repos/dask/dask/issues/5644/events,https://github.com/dask/dask/issues/5644,528837200,MDU6SXNzdWU1Mjg4MzcyMDA=,5644,Plan for high level graph optimizations,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,10,2019-11-26T16:28:50Z,2021-10-12T07:35:17Z,,MEMBER,,"Now that we have high level graphs in our collections, we can do some more complex optimizations.  We've done a little bit of this with blockwise fusion, read_parquet and column selection, and root fusion, all of which have had really positive effects. 

There is likely more that we can do here.  Some thoughts ...

-  Fuse column selection with other kinds of data access, like read_csv or ORC
-  Pass slicing through some blockwise operations in Dask array (a long-held request by @shoyer)
-  Optimize the subgraph callables in blockwise with Numba (or something else) for dask array to avoid memory copies and maybe reduce serialization time
-  Swap around Joins and filters and column access
-  ...

It would be nice to have a current maintainer consider these options, guess how long they would take, and see what makes sense to do short term",,https://api.github.com/repos/dask/dask/issues/5644/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5644/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
252,https://api.github.com/repos/dask/dask/issues/5652,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5652/labels{/name},https://api.github.com/repos/dask/dask/issues/5652/comments,https://api.github.com/repos/dask/dask/issues/5652/events,https://github.com/dask/dask/issues/5652,530481024,MDU6SXNzdWU1MzA0ODEwMjQ=,5652,KeyErrors in scheduler with large dataset and sklearn,[],open,False,,[],,4,2019-11-29T20:29:38Z,2019-12-17T15:21:26Z,,NONE,,"I am running ElasticNetCV.fit() in parallel using Dask client.submit, and continue to see KeyErrors in the scheduler. I'm not sure if this is a problem, but it seems to be for large datasets. The fits finish despite the errors on smaller datasets, but with with higher NxP and default tolerance, I have yet to see the fit complete. On a single box using pandas/sklearn, it always completes. 

Note that my call to client.submit includes an int parameter that isn't used in the process method. Without it, I would only see one instance of process() running, even though the results would include 2 models

The errors:

```
distributed.scheduler - ERROR - 'ndarray-e2403ddc588fc5516afcb36223c43bf3'
Traceback (most recent call last):
  File ""/opt/conda/lib/python3.7/site-packages/distributed/scheduler.py"", line 1753, in update_graph
    resources=resources,
  File ""/opt/conda/lib/python3.7/site-packages/distributed/diagnostics/graph_layout.py"", line 48, in update_graph
    deps = dependencies[key]
KeyError: 'ndarray-e2403ddc588fc5516afcb36223c43bf3'

distributed.scheduler - INFO - Plugin failed with exception
Traceback (most recent call last):
  File ""/opt/conda/lib/python3.7/site-packages/distributed/scheduler.py"", line 4359, in transition
    plugin.transition(key, start, finish2, *args, **kwargs)
  File ""/opt/conda/lib/python3.7/site-packages/distributed/diagnostics/graph_layout.py"", line 91, in transition
    self.state_updates.append((self.index[key], finish))
KeyError: '_path_residuals-batch-923e2deb56564bd2923f7337cdffc9fb'
```

...errors repeat

Example code. On my test cluster of 2x96 cores, it completes, but logs the above errors.
```
import numpy as np
import dask.array as da
from dask.distributed import Client
from sklearn import linear_model
from joblib import parallel_backend
from dask_glm.utils import make_y

client = Client(<scheduler>)
    
N = 200000
P = 10000
chunks = 3e3
    
beta = (np.random.random(P) - 0.5) * 3 
X = da.random.random((N,len(beta)), chunks=(chunks,P))
y = make_y(X, beta=np.array(beta), chunks=chunks)
   
def process(x, y, i):
    enet = linear_model.ElasticNetCV(fit_intercept=True, tol=0.5, normalize=True, n_jobs=-1, max_iter=50000, selection='random')

    with parallel_backend('dask'):
        enet.fit(x, y)
    return enet

results = [client.submit(process, X, y, i) for i in range(2)]
client.gather(results)
```


",,https://api.github.com/repos/dask/dask/issues/5652/timeline,,,kaptravis,35045516,MDQ6VXNlcjM1MDQ1NTE2,https://avatars.githubusercontent.com/u/35045516?v=4,,https://api.github.com/users/kaptravis,https://github.com/kaptravis,https://api.github.com/users/kaptravis/followers,https://api.github.com/users/kaptravis/following{/other_user},https://api.github.com/users/kaptravis/gists{/gist_id},https://api.github.com/users/kaptravis/starred{/owner}{/repo},https://api.github.com/users/kaptravis/subscriptions,https://api.github.com/users/kaptravis/orgs,https://api.github.com/users/kaptravis/repos,https://api.github.com/users/kaptravis/events{/privacy},https://api.github.com/users/kaptravis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5652/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
253,https://api.github.com/repos/dask/dask/issues/5686,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5686/labels{/name},https://api.github.com/repos/dask/dask/issues/5686/comments,https://api.github.com/repos/dask/dask/issues/5686/events,https://github.com/dask/dask/pull/5686,534434086,MDExOlB1bGxSZXF1ZXN0MzUwMzMzNjA0,5686,Add astype errors,[],open,False,,[],,3,2019-12-07T18:16:27Z,2021-03-08T20:19:38Z,,FIRST_TIME_CONTRIBUTOR,,"As described in #5666 

- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask`
",,https://api.github.com/repos/dask/dask/issues/5686/timeline,,,zacharylawrence,4469505,MDQ6VXNlcjQ0Njk1MDU=,https://avatars.githubusercontent.com/u/4469505?v=4,,https://api.github.com/users/zacharylawrence,https://github.com/zacharylawrence,https://api.github.com/users/zacharylawrence/followers,https://api.github.com/users/zacharylawrence/following{/other_user},https://api.github.com/users/zacharylawrence/gists{/gist_id},https://api.github.com/users/zacharylawrence/starred{/owner}{/repo},https://api.github.com/users/zacharylawrence/subscriptions,https://api.github.com/users/zacharylawrence/orgs,https://api.github.com/users/zacharylawrence/repos,https://api.github.com/users/zacharylawrence/events{/privacy},https://api.github.com/users/zacharylawrence/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5686/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/5686,https://github.com/dask/dask/pull/5686,https://github.com/dask/dask/pull/5686.diff,https://github.com/dask/dask/pull/5686.patch,,,,,,,,,,,,,,,,,,,
254,https://api.github.com/repos/dask/dask/issues/5689,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5689/labels{/name},https://api.github.com/repos/dask/dask/issues/5689/comments,https://api.github.com/repos/dask/dask/issues/5689/events,https://github.com/dask/dask/issues/5689,534612168,MDU6SXNzdWU1MzQ2MTIxNjg=,5689,Support byteswap,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2019-12-08T22:20:57Z,2019-12-16T14:41:39Z,,NONE,,"I am trying to add Dask support to `astropy.io.fits` and because it's such a lovely file format FITS is big endian on disk, so before I can `.store()` the data to the file I need to byteswap the array.

What I have currently done which seems to work is:

```python
        @delayed
        def _byteswap(arr):
            return np.array(arr).byteswap(True).newbyteorder(""S"")

        return dask.array.from_delayed(_byteswap(array), shape=array.shape,
                                       dtype=array.dtype.newbyteorder(""S""))
```

which appears to work but is somewhat weird.

I was wondering what would be involved in adding `.byteswap` to `Array` [this](https://github.com/dask/dask/issues/1647#issuecomment-252945402) seems to suggest it wouldn't be that hard, but I wouldn't know where to start.",,https://api.github.com/repos/dask/dask/issues/5689/timeline,,,Cadair,1391051,MDQ6VXNlcjEzOTEwNTE=,https://avatars.githubusercontent.com/u/1391051?v=4,,https://api.github.com/users/Cadair,https://github.com/Cadair,https://api.github.com/users/Cadair/followers,https://api.github.com/users/Cadair/following{/other_user},https://api.github.com/users/Cadair/gists{/gist_id},https://api.github.com/users/Cadair/starred{/owner}{/repo},https://api.github.com/users/Cadair/subscriptions,https://api.github.com/users/Cadair/orgs,https://api.github.com/users/Cadair/repos,https://api.github.com/users/Cadair/events{/privacy},https://api.github.com/users/Cadair/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5689/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
255,https://api.github.com/repos/dask/dask/issues/5691,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5691/labels{/name},https://api.github.com/repos/dask/dask/issues/5691/comments,https://api.github.com/repos/dask/dask/issues/5691/events,https://github.com/dask/dask/issues/5691,534679209,MDU6SXNzdWU1MzQ2NzkyMDk=,5691,Providing URLs to imread,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,8,2019-12-09T04:14:59Z,2019-12-12T15:47:18Z,,CONTRIBUTOR,,"The `imread` function currently performs a glob on the filename given to it as it expects a glob pattern to find local files. I have a case where I have a series of URLs, something that skimage imread can handle, and would like to load them in to one large dask array. I can see by reading the code that this is outside the expected use case of the function, but I think it could be updated to handle it. I'm wondering what be the best way to accomplish this if it fits in with what the original authors expected. Here's the main problem line:

https://github.com/dask/dask/blob/d0daa5bc7e86677b38794d4f9294fcc386f7b067/dask/array/image.py#L48

I'd like to make this take an iterable in which case we expect it not to be a glob pattern and don't assume that the image is on the local system at all.

```
if isinstance(filename, str):
    # assume glob
else:
    # assume iterable of URIs that exist
# continue on as normal
```

Thoughts? Problems?",,https://api.github.com/repos/dask/dask/issues/5691/timeline,,,djhoese,1828519,MDQ6VXNlcjE4Mjg1MTk=,https://avatars.githubusercontent.com/u/1828519?v=4,,https://api.github.com/users/djhoese,https://github.com/djhoese,https://api.github.com/users/djhoese/followers,https://api.github.com/users/djhoese/following{/other_user},https://api.github.com/users/djhoese/gists{/gist_id},https://api.github.com/users/djhoese/starred{/owner}{/repo},https://api.github.com/users/djhoese/subscriptions,https://api.github.com/users/djhoese/orgs,https://api.github.com/users/djhoese/repos,https://api.github.com/users/djhoese/events{/privacy},https://api.github.com/users/djhoese/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5691/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
256,https://api.github.com/repos/dask/dask/issues/5695,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5695/labels{/name},https://api.github.com/repos/dask/dask/issues/5695/comments,https://api.github.com/repos/dask/dask/issues/5695/events,https://github.com/dask/dask/issues/5695,535118666,MDU6SXNzdWU1MzUxMTg2NjY=,5695,Configuration Validation,"[{'id': 1012929478, 'node_id': 'MDU6TGFiZWwxMDEyOTI5NDc4', 'url': 'https://api.github.com/repos/dask/dask/labels/config', 'name': 'config', 'color': '1586c0', 'default': False, 'description': ''}]",open,False,,[],,7,2019-12-09T18:32:07Z,2022-12-08T18:12:08Z,,MEMBER,,"I wanted to start a discussion on how to improve dask configuration through validation. 

A common problem users experience (with regards to configuration) is invalid and/or missing values.  This can often bubble up to the user in obscure errors and only after the application has started.  

A simple example:

```python
In [1]: import dask

In [2]: dask.config.get(""logging"")
Out[2]: {'distributed': 'info', 'distributed.client': 'warning', 'bokeh': 'critical'}

In [3]: dask.config.set({""logging.distributed"": ""inf""})
Out[3]: <dask.config.set at 0x7f0ddec57ac8>

In [4]: from distributed import Client
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-4-fa1827681742> in <module>
----> 1 from distributed import Client

/datasets/bzaitlen/GitRepos/distributed/distributed/__init__.py in <module>
----> 1 from . import config
      2 from dask.config import config
      3 from .actor import Actor, ActorFuture
      4 from .core import connect, rpc
      5 from .deploy import LocalCluster, Adaptive, SpecCluster, SSHCluster

/datasets/bzaitlen/GitRepos/distributed/distributed/config.py in <module>
    134
    135
--> 136 initialize_logging(dask.config.config)

/datasets/bzaitlen/GitRepos/distributed/distributed/config.py in initialize_logging(config)
    131             _initialize_logging_new_style(config)
    132         else:
--> 133             _initialize_logging_old_style(config)
    134
    135

/datasets/bzaitlen/GitRepos/distributed/distributed/config.py in _initialize_logging_old_style(config)
     91     for name, level in loggers.items():
     92         if isinstance(level, str):
---> 93             level = logging_names[level.upper()]
     94         logger = logging.getLogger(name)
     95         logger.setLevel(level)

KeyError: 'INF'
```

With configuration validation in place, the user would have received an error at the time of setting the value to `inf`, an invalid logging value.


I think it would be beneficial to do one, possibly two things:

1) Schema-tize configuration -- strongly type configuration values for a given key
2) build cli tool to validate configuration is correct (dask-config)

Some potentially libraries to consider in pursuit of validation:
- https://schematics.readthedocs.io/en/latest/
- https://traitlets.readthedocs.io/en/stable/
- https://docs.python-cerberus.org/en/stable/index.html
- https://marshmallow.readthedocs.io/en/stable/",,https://api.github.com/repos/dask/dask/issues/5695/timeline,,,quasiben,1403768,MDQ6VXNlcjE0MDM3Njg=,https://avatars.githubusercontent.com/u/1403768?v=4,,https://api.github.com/users/quasiben,https://github.com/quasiben,https://api.github.com/users/quasiben/followers,https://api.github.com/users/quasiben/following{/other_user},https://api.github.com/users/quasiben/gists{/gist_id},https://api.github.com/users/quasiben/starred{/owner}{/repo},https://api.github.com/users/quasiben/subscriptions,https://api.github.com/users/quasiben/orgs,https://api.github.com/users/quasiben/repos,https://api.github.com/users/quasiben/events{/privacy},https://api.github.com/users/quasiben/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5695/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
257,https://api.github.com/repos/dask/dask/issues/5702,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5702/labels{/name},https://api.github.com/repos/dask/dask/issues/5702/comments,https://api.github.com/repos/dask/dask/issues/5702/events,https://github.com/dask/dask/issues/5702,536478346,MDU6SXNzdWU1MzY0NzgzNDY=,5702,Merged dataframe complains that not all divisions are known,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,4,2019-12-11T16:23:33Z,2021-10-13T03:42:55Z,,CONTRIBUTOR,,"## versions
```
# Name                    Version                   Build  Channel
dask                      2.9.0                      py_0  
dask-core                 2.9.0                      py_0  
```

## simple example
I'm having trouble merging datatime indexed dataframes. The merge appears to complete but some further actions on the DataFrame fail with division and alignment errors. Is this a bug or improper use of merge?

```python
import dask.dataframe as dd
import pandas as pd

left = (dd.
        from_pandas(
            pd.DataFrame(data = {'value':'left'},
                         index = pd.date_range('2019-11-1', '2019-11-30', freq='d')),
            npartitions=4
        )
)
print(left.divisions)

right = (dd.
        from_pandas(
            pd.DataFrame(data = {'value':'right'},
                         index = pd.date_range('2019-11-10', '2019-11-19', freq='d')),
            npartitions=2
        )
)
print(right.divisions)

merged = dd.merge(
    left, right,
    left_index=True, right_index=True
)
print(merged.divisions)

merged['day'] = merged.index.dt.day_name()
print(merged['day'].head())
```

The last line throws the following error

```pytb
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-6-6b1df607cef3> in <module>
----> 1 merged['day'] = merged.index.dt.day_name()
      2 merged['day'].head()

~/Applications/miniconda3/envs/dask-merge/lib/python3.7/site-packages/dask/dataframe/core.py in __setitem__(self, key, value)
   3349             df = self.assign(**{k: value for k in key})
   3350         else:
-> 3351             df = self.assign(**{key: value})
   3352 
   3353         self.dask = df.dask

~/Applications/miniconda3/envs/dask-merge/lib/python3.7/site-packages/dask/dataframe/core.py in assign(self, **kwargs)
   3612         # Figure out columns of the output
   3613         df2 = self._meta_nonempty.assign(**_extract_meta(kwargs, nonempty=True))
-> 3614         return elemwise(methods.assign, self, *pairs, meta=df2)
   3615 
   3616     @derived_from(pd.DataFrame, ua_args=[""index""])

~/Applications/miniconda3/envs/dask-merge/lib/python3.7/site-packages/dask/dataframe/core.py in elemwise(op, *args, **kwargs)
   4442     from .multi import _maybe_align_partitions
   4443 
-> 4444     args = _maybe_align_partitions(args)
   4445     dasks = [arg for arg in args if isinstance(arg, (_Frame, Scalar, Array))]
   4446     dfs = [df for df in dasks if isinstance(df, _Frame)]

~/Applications/miniconda3/envs/dask-merge/lib/python3.7/site-packages/dask/dataframe/multi.py in _maybe_align_partitions(args)
    155     divisions = dfs[0].divisions
    156     if not all(df.divisions == divisions for df in dfs):
--> 157         dfs2 = iter(align_partitions(*dfs)[0])
    158         return [a if not isinstance(a, _Frame) else next(dfs2) for a in args]
    159     return args

~/Applications/miniconda3/envs/dask-merge/lib/python3.7/site-packages/dask/dataframe/multi.py in align_partitions(*dfs)
    110     if not all(df.known_divisions for df in dfs1):
    111         raise ValueError(
--> 112             ""Not all divisions are known, can't align ""
    113             ""partitions. Please use `set_index` ""
    114             ""to set the index.""

ValueError: Not all divisions are known, can't align partitions. Please use `set_index` to set the index.
```",,https://api.github.com/repos/dask/dask/issues/5702/timeline,,,AlbertDeFusco,43654,MDQ6VXNlcjQzNjU0,https://avatars.githubusercontent.com/u/43654?v=4,,https://api.github.com/users/AlbertDeFusco,https://github.com/AlbertDeFusco,https://api.github.com/users/AlbertDeFusco/followers,https://api.github.com/users/AlbertDeFusco/following{/other_user},https://api.github.com/users/AlbertDeFusco/gists{/gist_id},https://api.github.com/users/AlbertDeFusco/starred{/owner}{/repo},https://api.github.com/users/AlbertDeFusco/subscriptions,https://api.github.com/users/AlbertDeFusco/orgs,https://api.github.com/users/AlbertDeFusco/repos,https://api.github.com/users/AlbertDeFusco/events{/privacy},https://api.github.com/users/AlbertDeFusco/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5702/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
258,https://api.github.com/repos/dask/dask/issues/5703,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5703/labels{/name},https://api.github.com/repos/dask/dask/issues/5703/comments,https://api.github.com/repos/dask/dask/issues/5703/events,https://github.com/dask/dask/pull/5703,536507484,MDExOlB1bGxSZXF1ZXN0MzUyMDI1NzM5,5703,Properly support dd.Index in setitem,[],open,False,,[],,4,2019-12-11T17:16:07Z,2021-03-08T20:19:39Z,,MEMBER,,"We don't want to align these. It has the same semantics as setting a dask array: we validate that the number of blocks match the number of partitions, and assume that the size of each block / partition matches.

This is a bit light on tests at the moment for invalid input (since we're re-using the dask.array implementation).

Closes https://github.com/dask/dask/issues/5702

cc @AlbertDeFusco",,https://api.github.com/repos/dask/dask/issues/5703/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5703/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/5703,https://github.com/dask/dask/pull/5703,https://github.com/dask/dask/pull/5703.diff,https://github.com/dask/dask/pull/5703.patch,,,,,,,,,,,,,,,,,,,
259,https://api.github.com/repos/dask/dask/issues/5723,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5723/labels{/name},https://api.github.com/repos/dask/dask/issues/5723/comments,https://api.github.com/repos/dask/dask/issues/5723/events,https://github.com/dask/dask/issues/5723,539426346,MDU6SXNzdWU1Mzk0MjYzNDY=,5723,Dask read sql table() sometimes not functioning properly for reading DB ,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,13,2019-12-18T03:15:59Z,2021-10-13T03:39:44Z,,NONE,,"Yesterday, I am using Dask to try to working with a Local DB, I also post this at StackOverflow with some detailed explanation: https://stackoverflow.com/questions/59370582/does-dask-dataframes-not-tolerate-for-na-values-in-it-getting-valueerror-canno

read_sql_table is able to read the table from my LocalDB, but The main issue I encounter is when I check it personally by inspecting each table using .head(). Here is my snippets:

```
ddf_authorized = dd.read_sql_table(""cz_transaction_authorized"", 
                                   ""mysql+pymysql://user_account:mysqlworld@127.0.0.1:3306/user"",""id"")
ddf_mobileuser = dd.read_sql_table(""cz_mobile_user"", 
                                   ""mysql+pymysql://user_account:mysqlworld@127.0.0.1:3306/user"",""id"")
ddf_users = dd.read_sql_table(""users"", 
                              ""mysql+pymysql://user_account:mysqlworld@127.0.0.1:3306/user"",""id"")
ddf_reader = dd.read_sql_table(""reader"", 
                               ""mysql+pymysql://user_account:mysqlworld@127.0.0.1:3306/user"",""id"")
ddf_mid = dd.read_sql_table(""cz_mid"",
                            ""mysql+pymysql://user_account:mysqlworld@127.0.0.1:3306/user"",""id"")
ddf_categorymastermcc = dd.read_sql_table(""category_master_mcc"",
                                          ""mysql+pymysql://user_account:mysqlworld@127.0.0.1:3306/user"",""id"")
```
There are tables that I used .head() is giving an expected output, which is the first 5 rows of the table, in my case, it is only mobileuser, users, and categorymastermcc from above, other tables beside that will return `ValueError: Cannot convert non-finite values (NA or inf) to integer` even though I already get rid the NA Values and also use the tables that clear from NA, change the column dtype to its optimal dtype using astype(). I also tried to read with dd.read_csv() by exporting one of the tables into csv (which is reader contains 8K rows), the results is I can read the table fine and inspect it fine too using ,head()

But since I am working also with Transacation that have 1.4M rows, (which in my case it is failed just to inspect the head()), it will be troublesome to export this kind to csv and then read it using dask.read_csv()

Is there any thing I miss? or is this a bug from the read_sql_table()? 

Thank You
",,https://api.github.com/repos/dask/dask/issues/5723/timeline,,,Vanderser,40754909,MDQ6VXNlcjQwNzU0OTA5,https://avatars.githubusercontent.com/u/40754909?v=4,,https://api.github.com/users/Vanderser,https://github.com/Vanderser,https://api.github.com/users/Vanderser/followers,https://api.github.com/users/Vanderser/following{/other_user},https://api.github.com/users/Vanderser/gists{/gist_id},https://api.github.com/users/Vanderser/starred{/owner}{/repo},https://api.github.com/users/Vanderser/subscriptions,https://api.github.com/users/Vanderser/orgs,https://api.github.com/users/Vanderser/repos,https://api.github.com/users/Vanderser/events{/privacy},https://api.github.com/users/Vanderser/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5723/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
260,https://api.github.com/repos/dask/dask/issues/5729,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5729/labels{/name},https://api.github.com/repos/dask/dask/issues/5729/comments,https://api.github.com/repos/dask/dask/issues/5729/events,https://github.com/dask/dask/issues/5729,539917344,MDU6SXNzdWU1Mzk5MTczNDQ=,5729,[FEA] API method for removing empty partitions from a dataframe,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2019-12-18T20:51:38Z,2020-04-01T23:07:01Z,,MEMBER,,It would be nice if there was a clean API method to remove empty partitions from a dataframe. This is particularly relevant given issues like #5726 .,,https://api.github.com/repos/dask/dask/issues/5729/timeline,,,beckernick,8457388,MDQ6VXNlcjg0NTczODg=,https://avatars.githubusercontent.com/u/8457388?v=4,,https://api.github.com/users/beckernick,https://github.com/beckernick,https://api.github.com/users/beckernick/followers,https://api.github.com/users/beckernick/following{/other_user},https://api.github.com/users/beckernick/gists{/gist_id},https://api.github.com/users/beckernick/starred{/owner}{/repo},https://api.github.com/users/beckernick/subscriptions,https://api.github.com/users/beckernick/orgs,https://api.github.com/users/beckernick/repos,https://api.github.com/users/beckernick/events{/privacy},https://api.github.com/users/beckernick/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5729/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
261,https://api.github.com/repos/dask/dask/issues/5756,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5756/labels{/name},https://api.github.com/repos/dask/dask/issues/5756/comments,https://api.github.com/repos/dask/dask/issues/5756/events,https://github.com/dask/dask/issues/5756,544172413,MDU6SXNzdWU1NDQxNzI0MTM=,5756,`clear_known_categories` overrides categories.dtype for non-object dtypes,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2019-12-31T11:59:44Z,2021-10-13T03:29:52Z,,CONTRIBUTOR,,"At https://github.com/dask/dask/blob/c69d10f97cadd06f147817f0084bddeadb8195e6/dask/dataframe/utils.py#L262, dask doesn't check the dtype of the categories, and just assumes it's an object (overwriting the original categorical dtype for one where `categories.dtype == object`).

Minimal example:
```
import pandas as pd
date_col = pd.Categorical([], categories=[pd.Timestamp(""2019-01-01"")])
df = pd.DataFrame({""date"":date_col})
df[""date""].dtype.categories.dtype == date_col.categories.dtype  # True

from dask.dataframe.categorical import clear_known_categories
clear_known_categories(df)[""date""].dtype.categories.dtype == date_col.categories.dtype  # False
```

This can cause an exception at https://github.com/dask/dask/blob/master/dask/dataframe/methods.py#L460 when using `dd.concat` if there is a categorical column with non-object categories (in our case, datetimes), when during the concatenation, an empty pandas dataframes and a non-empty one are to be concatenated.

Original stacktrace when calling `dd.concat`:
```
/home/xrzq/venv/lib/python3.6/site-packages/dask/base.py:165: in compute
    (result,) = compute(self, traverse=False, **kwargs)
/home/xrzq/venv/lib/python3.6/site-packages/dask/base.py:436: in compute
    results = schedule(dsk, keys, **kwargs)
/home/xrzq/venv/lib/python3.6/site-packages/dask/threaded.py:81: in get
    **kwargs
/home/xrzq/venv/lib/python3.6/site-packages/dask/local.py:486: in get_async
    raise_exception(exc, tb)
/home/xrzq/venv/lib/python3.6/site-packages/dask/local.py:316: in reraise
    raise exc
/home/xrzq/venv/lib/python3.6/site-packages/dask/local.py:222: in execute_task
    result = _execute_task(task, data)
/home/xrzq/venv/lib/python3.6/site-packages/dask/core.py:119: in _execute_task
    return func(*args2)
/home/xrzq/venv/lib/python3.6/site-packages/dask/dataframe/methods.py:356: in concat
    dfs, axis=axis, join=join, uniform=uniform, filter_warning=filter_warning
/home/xrzq/venv/lib/python3.6/site-packages/dask/dataframe/methods.py:460: in concat_pandas
    out[col] = union_categoricals(parts)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

to_union = [[], Categories (0, object): [], [2019-12-30 16:59:09.534787, 2019-12-31 16:59:09.534787, 2020-01-01 16:59:09.534787, ..., 2019-12-31 16:59:09.534787,
                                 2020-01-01 16:59:09.534787, 2020-01-02 16:59:09.534787]]
sort_categories = False, ignore_order = False
E           TypeError: dtype of categories must be the same

/home/xrzq/venv/lib/python3.6/site-packages/pandas/core/dtypes/concat.py:346: TypeError
```
",,https://api.github.com/repos/dask/dask/issues/5756/timeline,,,lr4d,44430780,MDQ6VXNlcjQ0NDMwNzgw,https://avatars.githubusercontent.com/u/44430780?v=4,,https://api.github.com/users/lr4d,https://github.com/lr4d,https://api.github.com/users/lr4d/followers,https://api.github.com/users/lr4d/following{/other_user},https://api.github.com/users/lr4d/gists{/gist_id},https://api.github.com/users/lr4d/starred{/owner}{/repo},https://api.github.com/users/lr4d/subscriptions,https://api.github.com/users/lr4d/orgs,https://api.github.com/users/lr4d/repos,https://api.github.com/users/lr4d/events{/privacy},https://api.github.com/users/lr4d/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5756/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
262,https://api.github.com/repos/dask/dask/issues/5769,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5769/labels{/name},https://api.github.com/repos/dask/dask/issues/5769/comments,https://api.github.com/repos/dask/dask/issues/5769/events,https://github.com/dask/dask/issues/5769,546109123,MDU6SXNzdWU1NDYxMDkxMjM=,5769,Retaining chunking when reading HDF files (on cloud storage),"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,9,2020-01-07T06:40:36Z,2021-10-13T03:27:58Z,,CONTRIBUTOR,,"We have a project creating microscope O(1000) images in chunked HDF format, which we ship off the machine ASAP and into a GCS cloud bucket.  We are then attempting to process them later using dask.  When attempting this on a the processes scheduler, I run into the standard problem of needing to open the unpicklable objects in a delayed function.  (This probably needed anyway, since opening a GCS file can take seconds -- better to shard all that file I/O.)  

The first thing I hit was #5763 , where I shouldn't return an HDF5 dataset from my delayed function, since it doesn't seem to have the right API that dask is expecting.   As @mrocklin suggested, I should just return the materialized array directly.  This has the disadvantage of throwing away the chunking.

Is the code below the recommended approach? 

Is the alternative of returning a dask array (also suggested by @mrocklin) during creation viable?  It seems to recover the chunking and is much faster for a random lookup.  *It oddly seems to need a "".compute().compute()"" in order to fully compute a result.  Is that something people do?*

```
import dask
import dask.array as da
from dask.diagnostics import ProgressBar
import gcsfs
import h5py
import numpy as np

gcs = gcsfs.GCSFileSystem()

# Use a function to lazily load an h5py.File on a worker, 
# since they aren't picklable
def get_data(fname, group):
    h5f = gcs.open(fname, 'rb')
    arr = h5py.File(h5f, 'r').get(group)
    return arr[()]  # Cannot return `arr` directly, since it doesn't have correct API for dask.delayed
    # Another option would be to return an array, but that requires .compute().compute()!
    # return da.from_array(arr, chunks=(16, 128, 128))
    
rnd = []
for fov in range(8):
    fname = 'gs://dask-hdf-gcs/dataset/data-R00-F%03d.h5' % fov
    acq = []
    # Lazily load h5py files
    for c in range(4):
        delayed = dask.delayed(get_data)(fname, '/channel%d' % c)
        # Shape and type need to be known!
        chn = da.from_delayed(delayed, shape=(96, 2048, 2048), dtype=np.uint16)
        acq.append(chn)
        
    rnd.append(da.stack(acq))
data = da.concatenate(rnd, axis=3)

with ProgressBar():
    result = data[2,40,1000,5000].compute()  # Need 2nd .compute() call if get_data returns dask array
```",,https://api.github.com/repos/dask/dask/issues/5769/timeline,,,chrisroat,1053153,MDQ6VXNlcjEwNTMxNTM=,https://avatars.githubusercontent.com/u/1053153?v=4,,https://api.github.com/users/chrisroat,https://github.com/chrisroat,https://api.github.com/users/chrisroat/followers,https://api.github.com/users/chrisroat/following{/other_user},https://api.github.com/users/chrisroat/gists{/gist_id},https://api.github.com/users/chrisroat/starred{/owner}{/repo},https://api.github.com/users/chrisroat/subscriptions,https://api.github.com/users/chrisroat/orgs,https://api.github.com/users/chrisroat/repos,https://api.github.com/users/chrisroat/events{/privacy},https://api.github.com/users/chrisroat/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5769/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
263,https://api.github.com/repos/dask/dask/issues/5780,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5780/labels{/name},https://api.github.com/repos/dask/dask/issues/5780/comments,https://api.github.com/repos/dask/dask/issues/5780/events,https://github.com/dask/dask/issues/5780,548456774,MDU6SXNzdWU1NDg0NTY3NzQ=,5780,Feature Request: Export performance reports in machine readable format,[],open,False,,[],,4,2020-01-11T17:26:59Z,2020-01-21T16:19:06Z,,NONE,,"Dask's new [performance reports](https://distributed.dask.org/en/latest/diagnosing-performance.html#performance-reports) are very useful for understanding performance of an individual job.

However, I am looking at analyzing a large number of jobs and trying to understand, in aggregate, which operations should I try to speed up to get the greatest overall performance improvement.

It would be nice if in addition to an HTML file, the performance report could be exported as CSV or JSON or other format easier to analyze with scripts.

In particular, the task stream and worker profile data is of interest for this analysis.

For the task stream, a useful JSON format would be something like:
```
[
 {worker_1: [{timestamp: '01/10/2020 12:00:00', read_parquet: 3.06}, {timestamp: .., transfer-drop-duplicates...: 10s}..]},
 {worker_2: [{timestamp:.., read_parquet: 2.04}, {timestamp:.., transfer-drop-duplicates...: 13s}..]
...
}
```

For the worker profile, something like:
```
[
{row: 0, Name: '', Filename: '', Line_number: 0, Line: '', Time: 80.03, Percentage: 100.0},
{row: 1, Name: 'read_parquet_part', Filename: '/home/user/conda/env/my_env/lib/python3.7/dask/dataframe/io/parquet/core.py', Line_number: 259, Line: ..., Time: 58.08, Percentage: 72.3}
...
]
```

I'm presently working on a parser for the HTML file, but Bokeh's large blog of JSON isn't very straightforward. If others have looked into this already, I'm eager to hear what worked for them.",,https://api.github.com/repos/dask/dask/issues/5780/timeline,,,randerzander,1692914,MDQ6VXNlcjE2OTI5MTQ=,https://avatars.githubusercontent.com/u/1692914?v=4,,https://api.github.com/users/randerzander,https://github.com/randerzander,https://api.github.com/users/randerzander/followers,https://api.github.com/users/randerzander/following{/other_user},https://api.github.com/users/randerzander/gists{/gist_id},https://api.github.com/users/randerzander/starred{/owner}{/repo},https://api.github.com/users/randerzander/subscriptions,https://api.github.com/users/randerzander/orgs,https://api.github.com/users/randerzander/repos,https://api.github.com/users/randerzander/events{/privacy},https://api.github.com/users/randerzander/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5780/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
264,https://api.github.com/repos/dask/dask/issues/5794,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5794/labels{/name},https://api.github.com/repos/dask/dask/issues/5794/comments,https://api.github.com/repos/dask/dask/issues/5794/events,https://github.com/dask/dask/pull/5794,550591260,MDExOlB1bGxSZXF1ZXN0MzYzNDY5NDk1,5794,Mean implementation for datetime series ,[],open,False,,[],,12,2020-01-16T05:56:26Z,2023-05-02T22:05:07Z,,CONTRIBUTOR,,"Fixes #5051 

- modifies `mean` to handle calculation for datetime series

- adds test to check result is equivalent to pandas

- [ ] Tests added / passed
- [ ] Passes `black dask` / `flake8 dask`
",,https://api.github.com/repos/dask/dask/issues/5794/timeline,,,exemplary-citizen,51683050,MDQ6VXNlcjUxNjgzMDUw,https://avatars.githubusercontent.com/u/51683050?v=4,,https://api.github.com/users/exemplary-citizen,https://github.com/exemplary-citizen,https://api.github.com/users/exemplary-citizen/followers,https://api.github.com/users/exemplary-citizen/following{/other_user},https://api.github.com/users/exemplary-citizen/gists{/gist_id},https://api.github.com/users/exemplary-citizen/starred{/owner}{/repo},https://api.github.com/users/exemplary-citizen/subscriptions,https://api.github.com/users/exemplary-citizen/orgs,https://api.github.com/users/exemplary-citizen/repos,https://api.github.com/users/exemplary-citizen/events{/privacy},https://api.github.com/users/exemplary-citizen/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5794/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/5794,https://github.com/dask/dask/pull/5794,https://github.com/dask/dask/pull/5794.diff,https://github.com/dask/dask/pull/5794.patch,,,,,,,,,,,,,,,,,,,
265,https://api.github.com/repos/dask/dask/issues/5809,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5809/labels{/name},https://api.github.com/repos/dask/dask/issues/5809/comments,https://api.github.com/repos/dask/dask/issues/5809/events,https://github.com/dask/dask/issues/5809,552556590,MDU6SXNzdWU1NTI1NTY1OTA=,5809,[FEA] Dask graph optimization pass for dropping columns during multi-merge workflows,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,5,2020-01-20T23:58:15Z,2020-09-17T14:24:30Z,,MEMBER,,"#### [FEA] Dask graph optimization pass for dropping columns during multi-merge workflows

When working on multiple merge heavy workflows, I have often found that keeping only columns to be used in the final step and dropping columns  once they are no longer needed in the merge makes them more efficient. 

It would be amazing if `dask` could optimize the column selection process for us. 
",,https://api.github.com/repos/dask/dask/issues/5809/timeline,,,VibhuJawa,4837571,MDQ6VXNlcjQ4Mzc1NzE=,https://avatars.githubusercontent.com/u/4837571?v=4,,https://api.github.com/users/VibhuJawa,https://github.com/VibhuJawa,https://api.github.com/users/VibhuJawa/followers,https://api.github.com/users/VibhuJawa/following{/other_user},https://api.github.com/users/VibhuJawa/gists{/gist_id},https://api.github.com/users/VibhuJawa/starred{/owner}{/repo},https://api.github.com/users/VibhuJawa/subscriptions,https://api.github.com/users/VibhuJawa/orgs,https://api.github.com/users/VibhuJawa/repos,https://api.github.com/users/VibhuJawa/events{/privacy},https://api.github.com/users/VibhuJawa/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5809/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
266,https://api.github.com/repos/dask/dask/issues/5822,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5822/labels{/name},https://api.github.com/repos/dask/dask/issues/5822/comments,https://api.github.com/repos/dask/dask/issues/5822/events,https://github.com/dask/dask/issues/5822,553710157,MDU6SXNzdWU1NTM3MTAxNTc=,5822,Set Directory Permissions with to_parquet,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,2,2020-01-22T18:14:51Z,2021-10-13T03:24:23Z,,NONE,,"When calling `to_parquet`, would it be possible to add an argument to modify the permissions of the top-level parquet directory?

```python
ddf = dd.from_pandas(pd.DataFrame({""a"": [0, 1, 2], ""b"": [3, 4, 5]}), npartitions=2)
ddf.to_parquet(""test_data.parquet"")
```

The top-level directory ""test_data.parquet"" will be written with my default permissions. However, if I'm using a scheduler that is shared (and I'm not the owner), then each file (part.0.parquet, etc.) will be written by the owner of the scheduler. If my directory doesn't have group/global write-access, then the writing of each partition will fail with a `PermissionError`.

It seems the easiest workaround would be to allow the following:

```python
ddf.to_parquet(""test_data.parquet"", mode=0o775)
```

The current workaround I'm having to put into place is:

```python
os.makedirs(""'test_data.parquet"", exist_ok=True)
os.chmod(""test_data.parquet"", 0o775)
ddf.to_parquet(""test_data.parquet"")
```

While not an issue, I don't really want to create a function for this when it seems first class support in dask would be best.",,https://api.github.com/repos/dask/dask/issues/5822/timeline,,,rileyschack,33992842,MDQ6VXNlcjMzOTkyODQy,https://avatars.githubusercontent.com/u/33992842?v=4,,https://api.github.com/users/rileyschack,https://github.com/rileyschack,https://api.github.com/users/rileyschack/followers,https://api.github.com/users/rileyschack/following{/other_user},https://api.github.com/users/rileyschack/gists{/gist_id},https://api.github.com/users/rileyschack/starred{/owner}{/repo},https://api.github.com/users/rileyschack/subscriptions,https://api.github.com/users/rileyschack/orgs,https://api.github.com/users/rileyschack/repos,https://api.github.com/users/rileyschack/events{/privacy},https://api.github.com/users/rileyschack/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5822/reactions,3,3,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
267,https://api.github.com/repos/dask/dask/issues/5823,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5823/labels{/name},https://api.github.com/repos/dask/dask/issues/5823/comments,https://api.github.com/repos/dask/dask/issues/5823/events,https://github.com/dask/dask/issues/5823,553855415,MDU6SXNzdWU1NTM4NTU0MTU=,5823,Parse environmental variables in configuration yaml file,"[{'id': 1012929478, 'node_id': 'MDU6TGFiZWwxMDEyOTI5NDc4', 'url': 'https://api.github.com/repos/dask/dask/labels/config', 'name': 'config', 'color': '1586c0', 'default': False, 'description': ''}]",open,False,,[],,5,2020-01-22T23:31:05Z,2020-01-29T22:22:40Z,,CONTRIBUTOR,,"I would like to be able to use environmental variables in the configuration yaml file (see also [here](https://stackoverflow.com/questions/59402998/parsing-environment-variables-into-configuration-yaml-file)). 

My use case: I am using dask on a cluster where nodes are assigned upon login, and the fast temporary storage will change depending on the particular node one is logged in. It is always identified as `$TMPDIR`. 

Would it be possible to use a special syntax e.g. `temporary-directory: (($TMPDIR))`, so that dask parses the environmental variable each time a cluster/worker is started?

",,https://api.github.com/repos/dask/dask/issues/5823/timeline,,,jbusecke,14314623,MDQ6VXNlcjE0MzE0NjIz,https://avatars.githubusercontent.com/u/14314623?v=4,,https://api.github.com/users/jbusecke,https://github.com/jbusecke,https://api.github.com/users/jbusecke/followers,https://api.github.com/users/jbusecke/following{/other_user},https://api.github.com/users/jbusecke/gists{/gist_id},https://api.github.com/users/jbusecke/starred{/owner}{/repo},https://api.github.com/users/jbusecke/subscriptions,https://api.github.com/users/jbusecke/orgs,https://api.github.com/users/jbusecke/repos,https://api.github.com/users/jbusecke/events{/privacy},https://api.github.com/users/jbusecke/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5823/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
268,https://api.github.com/repos/dask/dask/issues/5834,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5834/labels{/name},https://api.github.com/repos/dask/dask/issues/5834/comments,https://api.github.com/repos/dask/dask/issues/5834/events,https://github.com/dask/dask/issues/5834,555964573,MDU6SXNzdWU1NTU5NjQ1NzM=,5834,[FEA] Support for as_index in groupby,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,6,2020-01-28T03:42:52Z,2020-12-19T13:31:25Z,,MEMBER,,"I'd like to be able to pass `as_index=False` to Dask groupbys, like I can do in pandas and cuDF. Currently, this causes a TypeError due to the groupby constructor getting an unexpected argument. 

See prior discussion in #735


```python
import dask.dataframe as dd
import pandas as pd
import numpy as np

data = np.random.normal(5,5,(5,3))
df = pd.DataFrame(data)
df['key'] = ['a','b','b','c','a']
ddf = dd.from_pandas(df, 2)
print(df.groupby('key', as_index=False).mean())

  key          0          1         2
0   a   2.278160   5.219407  5.527213
1   b   2.064907   1.729929  9.289048
2   c  10.781695  13.021780  2.804494
```

```python
ddf.groupby('key', as_index=False)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-22-77562f3b8193> in <module>
----> 1 ddf.groupby('key', as_index=False).mean()

~/miniconda3/envs/nytimes-crossword/lib/python3.7/site-packages/dask/dataframe/core.py in groupby(self, by, **kwargs)
   3596         from dask.dataframe.groupby import DataFrameGroupBy
   3597 
-> 3598         return DataFrameGroupBy(self, by=by, **kwargs)
   3599 
   3600     @wraps(categorize)

TypeError: __init__() got an unexpected keyword argument 'as_index'
```",,https://api.github.com/repos/dask/dask/issues/5834/timeline,,,beckernick,8457388,MDQ6VXNlcjg0NTczODg=,https://avatars.githubusercontent.com/u/8457388?v=4,,https://api.github.com/users/beckernick,https://github.com/beckernick,https://api.github.com/users/beckernick/followers,https://api.github.com/users/beckernick/following{/other_user},https://api.github.com/users/beckernick/gists{/gist_id},https://api.github.com/users/beckernick/starred{/owner}{/repo},https://api.github.com/users/beckernick/subscriptions,https://api.github.com/users/beckernick/orgs,https://api.github.com/users/beckernick/repos,https://api.github.com/users/beckernick/events{/privacy},https://api.github.com/users/beckernick/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5834/reactions,4,4,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
269,https://api.github.com/repos/dask/dask/issues/5837,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5837/labels{/name},https://api.github.com/repos/dask/dask/issues/5837/comments,https://api.github.com/repos/dask/dask/issues/5837/events,https://github.com/dask/dask/issues/5837,556471657,MDU6SXNzdWU1NTY0NzE2NTc=,5837,"Individual aggregations work, multiple fail","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2020-01-28T21:12:54Z,2020-05-01T17:28:47Z,,NONE,,"I have a custom aggregation that computes the mode for a categorical column. The aggregation works fine when applied individually, but fails with the message metadata inference failed when combined with aggregating by the min for another column.
```
import dask.dataframe as dd
import pandas as pd
import scipy.sparse

test_df = pd.DataFrame(scipy.sparse.eye(10).toarray())
test_df['x'] =  ['a', 'b', 'a', 'c', 'b', 'a', 'a', 'b', 'e', 'x']
test_df['x'] = test_df['x'].astype('category')
test_dd = dd.from_pandas(test_df, 2)


def mode_chunk(x):
    return x.value_counts(sort=False)


def mode_agg(x):
    return x.apply(lambda s: s.groupby(level=-1).sum())


def mode_finalize(x):
    # return x.groupby(level=level).apply(lambda s: s.reset_index(level=level, drop=True).idxmax())
    return x.groupby(level=0).agg(lambda s: s.nlargest(1).index[0][1])


dask_agg_mode = dd.Aggregation(
    name='dd_mode',
    chunk=mode_chunk,
    agg=mode_agg,
    finalize=mode_finalize
)
test_dd.groupby(0).agg({'x': dask_agg_mode}).compute()  # works
test_dd.groupby(0).agg({1: 'min'}).compute()  # works
test_dd.groupby(0).agg({'x': dask_agg_mode, 1: 'min'}).compute()  # fails

```",,https://api.github.com/repos/dask/dask/issues/5837/timeline,,,joshua-gould,5237151,MDQ6VXNlcjUyMzcxNTE=,https://avatars.githubusercontent.com/u/5237151?v=4,,https://api.github.com/users/joshua-gould,https://github.com/joshua-gould,https://api.github.com/users/joshua-gould/followers,https://api.github.com/users/joshua-gould/following{/other_user},https://api.github.com/users/joshua-gould/gists{/gist_id},https://api.github.com/users/joshua-gould/starred{/owner}{/repo},https://api.github.com/users/joshua-gould/subscriptions,https://api.github.com/users/joshua-gould/orgs,https://api.github.com/users/joshua-gould/repos,https://api.github.com/users/joshua-gould/events{/privacy},https://api.github.com/users/joshua-gould/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5837/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
270,https://api.github.com/repos/dask/dask/issues/5847,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5847/labels{/name},https://api.github.com/repos/dask/dask/issues/5847/comments,https://api.github.com/repos/dask/dask/issues/5847/events,https://github.com/dask/dask/issues/5847,557466642,MDU6SXNzdWU1NTc0NjY2NDI=,5847,DataFrame: incorrect agg results with sparse values with categorical index and npartitions > 1,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2020-01-30T12:39:28Z,2020-02-07T14:05:31Z,,NONE,,"```
import dask.dataframe as dd
import numpy as np
import pandas as pd
import scipy.sparse

X = np.array([[0.1, 0.2, 0.3, 0.2]])

df = pd.DataFrame.sparse.from_spmatrix(scipy.sparse.csr_matrix(X).T)
df.index = ['a', 'b', 'c', 'a']
# converting index to category causes incorrect results when npartitions > 1
df.index = df.index.astype('category')
ddf = dd.from_pandas(df, 2)


def sparse_min(x):
    if x.sparse.npoints == 0:
        return x.sparse.fill_value
    value = x.sparse.sp_values.min()
    return min(x.sparse.fill_value, value) if x.sparse.density < 1 else value


def sparse_min_chunk(x):
    return x.apply(sparse_min)


def sparse_min_agg(x):
    return x.min()


dask_agg_sparse_min = dd.Aggregation(
    name='dd_sparse_min',
    chunk=sparse_min_chunk,
    agg=sparse_min_agg
)

pandas_result = df.groupby(df.index).agg(sparse_min)
dask_result = ddf.groupby(ddf.index).agg(dask_agg_sparse_min).compute()
# bug-dask result is all zeros

```",,https://api.github.com/repos/dask/dask/issues/5847/timeline,,,joshua-gould,5237151,MDQ6VXNlcjUyMzcxNTE=,https://avatars.githubusercontent.com/u/5237151?v=4,,https://api.github.com/users/joshua-gould,https://github.com/joshua-gould,https://api.github.com/users/joshua-gould/followers,https://api.github.com/users/joshua-gould/following{/other_user},https://api.github.com/users/joshua-gould/gists{/gist_id},https://api.github.com/users/joshua-gould/starred{/owner}{/repo},https://api.github.com/users/joshua-gould/subscriptions,https://api.github.com/users/joshua-gould/orgs,https://api.github.com/users/joshua-gould/repos,https://api.github.com/users/joshua-gould/events{/privacy},https://api.github.com/users/joshua-gould/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5847/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
271,https://api.github.com/repos/dask/dask/issues/5865,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5865/labels{/name},https://api.github.com/repos/dask/dask/issues/5865/comments,https://api.github.com/repos/dask/dask/issues/5865/events,https://github.com/dask/dask/issues/5865,560475970,MDU6SXNzdWU1NjA0NzU5NzA=,5865,Require fastparquet>=0.3.3,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,1,2020-02-05T16:12:57Z,2021-10-13T03:13:32Z,,MEMBER,,"Followup to https://github.com/dask/dask/pull/5821. We'd like to require fastparquet>=0.3.3 to cut down our maintenance burden. That was released just today. I think we should see if there are any issues with the 0.3.3 release over the next month or so, and require at least that version if things look OK.",,https://api.github.com/repos/dask/dask/issues/5865/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5865/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
272,https://api.github.com/repos/dask/dask/issues/5913,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5913/labels{/name},https://api.github.com/repos/dask/dask/issues/5913/comments,https://api.github.com/repos/dask/dask/issues/5913/events,https://github.com/dask/dask/issues/5913,566540936,MDU6SXNzdWU1NjY1NDA5MzY=,5913,performance indexing stacked array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,14,2020-02-17T22:19:44Z,2022-10-18T18:54:01Z,,MEMBER,,"I have a large imaging dataset with ~30k images, each 40 MB. I'm combining these images into a large dask array by defining a delayed function for loading each individual image, then using `da.from_delayed` and a `da.stack`. The resulting array has dimensions (30265, 2, 1000, 10000) and chunksize (1, 2, 1000, 10000), for a total of ~120k tasks (4 tasks per image file). 

I noticed that indexing along the first axis of this array (i.e., along the chunked axis) takes 30 ms; i.e., calling `[x for x in array]` takes ~900s, which seems a bit on the long side, given that these tasks have 0 horizontal dependencies, and everything is lazy. By contrast, the same indexing pattern used on a dummy dataset (`da.zeros` combined with `stack`) with the same shape + dtype + chunking takes ~.700 ms per ""image"" with a total of ~9s for `[x for x in dummy_data]`. That's not lighting-fast but it's acceptable, unlike 900s.

Short-term it's clear that I should simply avoid the pattern of `big_array = da.stack(sub_arrays)...[b for b in big_array] ` when `big_array` is large... But I wonder a) why this pattern is so slow and b) if there's anything I can do (or dask can do) to speed up this access pattern. ",,https://api.github.com/repos/dask/dask/issues/5913/timeline,,,d-v-b,3805136,MDQ6VXNlcjM4MDUxMzY=,https://avatars.githubusercontent.com/u/3805136?v=4,,https://api.github.com/users/d-v-b,https://github.com/d-v-b,https://api.github.com/users/d-v-b/followers,https://api.github.com/users/d-v-b/following{/other_user},https://api.github.com/users/d-v-b/gists{/gist_id},https://api.github.com/users/d-v-b/starred{/owner}{/repo},https://api.github.com/users/d-v-b/subscriptions,https://api.github.com/users/d-v-b/orgs,https://api.github.com/users/d-v-b/repos,https://api.github.com/users/d-v-b/events{/privacy},https://api.github.com/users/d-v-b/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5913/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
273,https://api.github.com/repos/dask/dask/issues/5914,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5914/labels{/name},https://api.github.com/repos/dask/dask/issues/5914/comments,https://api.github.com/repos/dask/dask/issues/5914/events,https://github.com/dask/dask/issues/5914,566589230,MDU6SXNzdWU1NjY1ODkyMzA=,5914,Intermittent CI failure in test_rolling_methods,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,3,2020-02-18T01:21:34Z,2021-03-12T14:50:05Z,,MEMBER,,"Observed in https://ci.appveyor.com/project/daskdev/dask/builds/30866014

```
________________ test_rolling_methods[True-4-kurt-args9-True] _________________
method = 'kurt', args = (), window = 4, center = True, check_less_precise = True
    @pytest.mark.parametrize(
        ""method,args,check_less_precise"", rolling_method_args_check_less_precise
    )
    @pytest.mark.parametrize(""window"", [1, 2, 4, 5])
    @pytest.mark.parametrize(""center"", [True, False])
    def test_rolling_methods(method, args, window, center, check_less_precise):
        # DataFrame
        prolling = df.rolling(window, center=center)
        drolling = ddf.rolling(window, center=center)
        if method == ""apply"":
            kwargs = {""raw"": False}
        else:
            kwargs = {}
    
        assert_eq(
            getattr(prolling, method)(*args, **kwargs),
            getattr(drolling, method)(*args, **kwargs),
>           check_less_precise=check_less_precise,
        )
dask\dataframe\tests\test_rolling.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
dask\dataframe\utils.py:807: in assert_eq
    tm.assert_frame_equal(a, b, **kwargs)
pandas\_libs\testing.pyx:65: in pandas._libs.testing.assert_almost_equal
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
>   ???
E   AssertionError: DataFrame.iloc[:, 0] (column name=""a"") are different
E   
E   DataFrame.iloc[:, 0] (column name=""a"") values are different (2.5 %)
E   [left]:  [nan, nan, 1.6400083981143272, 0.026610671116499063, 3.030069853172879, -3.0919629314737485, 1.9642921986706554, -4.614829071080285, 2.9527148373343692, 1.4963657085528919, 3.100443089351433, -5.035450839875914, 0.824854063691653, -5.182875273725815, 1.822753110952334, -1.944484706074734, 0.7297960749815502, -3.640846856159097, -2.5570523181378366, -1.398508588905127, 0.5183731666721041, 2.397539761680404, -4.880518208820032, -4.879241624105642, 0.43662959528148093, -5.899645036701958, 1.6611247540371945, -2.3019475870237986, 1.7399328583104303, -4.416121331819701, 1.470365575346987, -3.8359742111430126, 2.6723734165670905, 0.624823586400252, 3.9594732751701542, -0.6550739977932434, 3.9998328801635523, -4.9860455715241425, 1.937256658296679, nan]
E   [right]: [nan, nan, 1.6400083981143272, 0.026610671116499063, 3.030069853172879, -3.0919629314737485, 1.9642921986706554, -4.614829071080285, 2.9527148373343692, 1.4963657085528919, 3.100443089351433, -5.035450839875914, 0.824854063691653, -5.182875273725815, 1.8227531109522772, -1.9444847060755102, 0.7297960749815093, -3.640846856158843, -2.557052318136936, -1.398508588904713, 0.518373166671708, 2.3975397616770753, -4.880518208821561, -4.879241624107173, 0.4366295952813086, -5.899645036701958, 1.6611247540371945, -2.3019475870237986, 1.7399328582727112, -4.416121333318102, 1.4703655753093745, -3.8359742111989217, 2.6723734162183455, 0.6248235517355134, 3.959470900841506, -1.1364253361792134, 3.9998328799614633, -4.986045571592452, 1.937256658218013, nan]
```",,https://api.github.com/repos/dask/dask/issues/5914/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5914/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
274,https://api.github.com/repos/dask/dask/issues/5915,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5915/labels{/name},https://api.github.com/repos/dask/dask/issues/5915/comments,https://api.github.com/repos/dask/dask/issues/5915/events,https://github.com/dask/dask/issues/5915,566823517,MDU6SXNzdWU1NjY4MjM1MTc=,5915,MemoryError with `dask.array.from_tiledb`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,11,2020-02-18T11:18:16Z,2021-03-12T14:51:35Z,,NONE,,"TileDB allows you to create arrays with an effectively unlimited domain. If you try to create a dask array from such a TileDB array, however, you unsurprisingly hit issues. For example, if you run the code below you get a Segmentation Fault, which I think is hiding a `MemoryError` (I've seen this error before with similar code to this, but unfortunately can't reproduce it here).

Here's some code to demonstrate the problem:
```python
import dask.array as da
import numpy as np
import tiledb

array_name = './tdb/example'
attr_name = 'test'

x_dim = tiledb.Dim(name=""x"", domain=(0, np.iinfo(np.uint64).max-1), tile=1, dtype=np.uint64)
y_dim = tiledb.Dim(name=""y"", domain=(0, 100), tile=10, dtype=np.uint64)
domain = tiledb.Domain(x_dim, y_dim)

attr = tiledb.Attr(name=attr_name, dtype=np.int64)
schema = tiledb.ArraySchema(domain=domain, sparse=False, attrs=[attr])
tiledb.Array.create(array_name, schema)

data = np.arange(100).reshape(10, 10)
with tiledb.open(array_name, 'w') as A:
    A[0:10, 0:10] = data
    
with tiledb.open(array_name, 'r') as A:
    print(f'Nonempty domain: {A.nonempty_domain()}')
    
array = da.from_tiledb(array_name, attribute=attr_name)
```
And here's an example of running the code:
```bash
$ python dask_memerror_code.py 
Nonempty domain: ((0, 9), (0, 9))
Segmentation fault (core dumped)
```

I think dask is unable to create a Python array large enough for the size of the TileDB array, regardless of the TileDB array's nonempty domain.

A possible solution for this would be to add functionality to `da.from_tiledb` to allow the TileDB array to be subset when it's read into a dask array, such as:
```
inds = (slice(0, 10, None), slice(0, 10, None))
array = da.from_tiledb(array_name, attribute='attr', inds=inds)
```
which could then be used [when creating the dask array](https://github.com/dask/dask/blob/master/dask/array/tiledb_io.py#L72) to subset the TileDB array:
```python
    return core.from_array(tdb[inds], chunks, name=""tiledb-%s"" % uri)
```
I'm not sure, however, whether this would cause the data from the TileDB array to be loaded into local memory and potentially cause a different problem with memory being flooded if the indexed array were itself large.
",,https://api.github.com/repos/dask/dask/issues/5915/timeline,,,DPeterK,3473068,MDQ6VXNlcjM0NzMwNjg=,https://avatars.githubusercontent.com/u/3473068?v=4,,https://api.github.com/users/DPeterK,https://github.com/DPeterK,https://api.github.com/users/DPeterK/followers,https://api.github.com/users/DPeterK/following{/other_user},https://api.github.com/users/DPeterK/gists{/gist_id},https://api.github.com/users/DPeterK/starred{/owner}{/repo},https://api.github.com/users/DPeterK/subscriptions,https://api.github.com/users/DPeterK/orgs,https://api.github.com/users/DPeterK/repos,https://api.github.com/users/DPeterK/events{/privacy},https://api.github.com/users/DPeterK/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5915/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
275,https://api.github.com/repos/dask/dask/issues/5918,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5918/labels{/name},https://api.github.com/repos/dask/dask/issues/5918/comments,https://api.github.com/repos/dask/dask/issues/5918/events,https://github.com/dask/dask/issues/5918,567007907,MDU6SXNzdWU1NjcwMDc5MDc=,5918,Discussion: making slicing scale better,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,12,2020-02-18T16:24:49Z,2021-03-20T17:00:51Z,,MEMBER,,"I've got an idea for an optimization that I'd like to bounce off some core developers, because it would probably have fairly significant impact on multiple areas of dask.I'd guess @mrocklin and @jcrist would have an interest - anyone else that should be added to cc? Is this the appropriate forum for this sort of discussion?

# Background
For a while I've been gradually trying to improve the performance of dask for slicing out a small piece of a large dask array and computing it. In our application we present an interface somewhat like h5py does, with a huge virtual array that can be indexed to load data from it; but with dask used under the hood to handle all the messy details of lazily loading the right chunks and stitching bits of them together.

Ideally, I'd like to reach a point where `arr[index].compute()` requires time only proportional to the size of `arr[index]`, not `arr` (logarithmic scaling in `arr` would be acceptable). Bugs like #5913 shows that I'm not the only one who is running into performance problems here. I think with #5916 the indexing part should finally scale well, but the computation is still a problem.

Array optimisation has a few steps that are slow (i.e. cales with the number of chunks in the original array):
1. After high-level optimisations, it calls [ensure_dict](https://github.com/dask/dask/blob/d676b2d8a2e776cb711e4da4c95a936c52e338da/dask/array/optimization.py#L46). This copies all the keys from the HighLevelGraph into a flat dict.
2. Almost any operation (like `__iter__`, `__contains__` or `__getitem__`) on a Blockwise will cause it to instantiate its underlying graph. It's cached, so that's fine if it was a Blockwise in the graph of `arr`, but if it's a transient Blockwise generated by `optimize_blockwise` it will occur every time.
3. `fuse_roots` also turns Blockwises into their underlying graphs. I haven't thought about this problem yet so I won't discuss it here.

# Proposal
I would like to combine the operations of `cull` and `ensure_dict` into a single operation that extracts only the necessary keys from a HLG. In fact, `cull` can already work from a HLG (since it is a Mapping), so I'm not entirely sure why `ensure_dict` is needed. I'm guessing that key lookups on a HLG are slower because the key has to be searched in every layer, so doing `ensure_dict` early speeds things up in general. So if we walk the dependencies on the HLG we'd need to speed up lookup: can we assume that keys always either match the layer name or are a tuple starting with the layer name? #5824 and #5850 suggest we might not be quite there yet. We could possibly also use the dependency information in the HLG to restrict the search when chasing dependencies.

That leads to my next proposal: defining some protocol for graph layers, with a default implementation for plain-dict layers, and a custom implementation for Blockwise. My rough idea for the interface is that Blockwise (or any other layer class) would define a method that takes an iterable of keys, and returns a dict representing the graph for those keys (of those that are present) and a list of dependencies (which I'm guessing Blockwise can produce more efficiently than running `get_dependencies` on the returned graph). Then `cull` looks something like this:
1. Start with `keys` equal to the needed keys.
2. For each layer in topological order (from roots), ask the layer for its piece of the graph (passing `keys`). Use it to update the output graph, remove the subgraph keys from `keys` and add the new dependencies to `keys`.

Possibly variations would involve the protocol method modifying data structures in place to avoid double-copies, but that might be a more brittle interface.

As discussed above, that won't scale well with large numbers of layers because every key gets tested against every layer, so it would probably need to be refined to group keys into layers up front.

# Issues
My main concern is that while this will improve scaling for one use case, it may significantly increase the overheads in the general case where most or all of the graph is needed for the computation. Flattening things into plain dicts is slow up front but then operations on the plain dict are relatively very fast, and when doing an operation on every key in the graph the current approach will be hard to beat.

The other concern is how feasible it will be to enforce relationships between keys and layer names, given that third-party code may be building their own graphs. I think it will be fine for layers to have internal keys that are only referenced from inside the layer - it's only inter-layer keys that will need to match, and hopefully that's generally the case with our collections.",,https://api.github.com/repos/dask/dask/issues/5918/timeline,,,bmerry,1963944,MDQ6VXNlcjE5NjM5NDQ=,https://avatars.githubusercontent.com/u/1963944?v=4,,https://api.github.com/users/bmerry,https://github.com/bmerry,https://api.github.com/users/bmerry/followers,https://api.github.com/users/bmerry/following{/other_user},https://api.github.com/users/bmerry/gists{/gist_id},https://api.github.com/users/bmerry/starred{/owner}{/repo},https://api.github.com/users/bmerry/subscriptions,https://api.github.com/users/bmerry/orgs,https://api.github.com/users/bmerry/repos,https://api.github.com/users/bmerry/events{/privacy},https://api.github.com/users/bmerry/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5918/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
276,https://api.github.com/repos/dask/dask/issues/5942,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5942/labels{/name},https://api.github.com/repos/dask/dask/issues/5942/comments,https://api.github.com/repos/dask/dask/issues/5942/events,https://github.com/dask/dask/issues/5942,570039129,MDU6SXNzdWU1NzAwMzkxMjk=,5942,Writing inplace a modified zarr array with dask failed,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,10,2020-02-24T18:21:53Z,2022-07-01T08:15:17Z,,NONE,,"I read a zarr array, where i need to modify some values.
And after i want to save at same place, with overwrite options.

```python
import dask.array as da
from dask.distributed import Client, LocalCluster
import dask

def put_2(data):
    # Put 2 at first index of block
    data[0] = 2
    return data

if __name__ == '__main__':
    print('Version ', dask.__version__)
    # Bug come, when i used a cluster
    cluster = LocalCluster()
    client = Client(cluster)

    # Create ones matrix with two chunk
    d = da.ones(10, chunks=(5,), dtype='i4')
    # Save it
    d.to_zarr('/tmp/data.zarr', component='d', overwrite=True)

    # Read Ones
    read_d = da.from_zarr('/tmp/data.zarr', component='d')
    # Apply put_2 on each block
    new_d = da.blockwise(put_2, 'i', read_d, 'i', dtype='i4')
    print(new_d.compute())
    # Save inplace of previous array
    a = new_d.to_zarr('/tmp/data.zarr', component='d', overwrite='True')
    # Read new save :(
    read_d = da.from_zarr('/tmp/data.zarr', component='d')
    print(read_d.compute())
```

Output
```python
Version  2.11.0
[2 1 1 1 1 2 1 1 1 1]
[2 0 0 0 0 2 0 0 0 0]
```

It seems ""create"" command from zarr is apply before readings value, so when we try to read we get an empty dataset.",,https://api.github.com/repos/dask/dask/issues/5942/timeline,,,AntSimi,36040805,MDQ6VXNlcjM2MDQwODA1,https://avatars.githubusercontent.com/u/36040805?v=4,,https://api.github.com/users/AntSimi,https://github.com/AntSimi,https://api.github.com/users/AntSimi/followers,https://api.github.com/users/AntSimi/following{/other_user},https://api.github.com/users/AntSimi/gists{/gist_id},https://api.github.com/users/AntSimi/starred{/owner}{/repo},https://api.github.com/users/AntSimi/subscriptions,https://api.github.com/users/AntSimi/orgs,https://api.github.com/users/AntSimi/repos,https://api.github.com/users/AntSimi/events{/privacy},https://api.github.com/users/AntSimi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5942/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
277,https://api.github.com/repos/dask/dask/issues/5953,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5953/labels{/name},https://api.github.com/repos/dask/dask/issues/5953/comments,https://api.github.com/repos/dask/dask/issues/5953/events,https://github.com/dask/dask/issues/5953,572164502,MDU6SXNzdWU1NzIxNjQ1MDI=,5953,Allow explicit chunk size for `to_zarr`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,7,2020-02-27T15:34:39Z,2021-03-12T16:21:33Z,,CONTRIBUTOR,,"## Description

Currently working on a project with zarr and dask where the on-disc dataset has less than optimal  chunk sizes for computation with dask (specifically creating image tiles). Fortunately, `data.array.from_zarr` allows you to specify the chunk sizes explicitly and optimize for computation, but `dask.array.to_zarr` does not allow the reverse when creating an array. 


### Example

```python
z = zarr.open('my_image.zarr')
print(z.shape)
# (50000, 50000, 4)
print(z.chunks)
# (512, 512, 4)

img = da.from_zarr('my_image.zarr', chunks=(5000, 5000, 4))
downsampled = da.coarsen(np.mean, img, {1: 2, 2: 2})
downsampled.to_zarr(""downsampled01.zarr"", chunks=(512, 512, 4))
# TypeError: DelayedLeaf object got multiple values for keyword argument 'chunks'
```

A work around at the moment is:

```python
downsampled.rechunk((512, 512, 4)).to_zarr(""downsampled01.zarr"")
```

However, it seems that there is likely a bit of overhead with rechunking to this extreme just to write to a store on-disc. Many thanks in advance for having a look at this. I love using dask!",,https://api.github.com/repos/dask/dask/issues/5953/timeline,,,manzt,24403730,MDQ6VXNlcjI0NDAzNzMw,https://avatars.githubusercontent.com/u/24403730?v=4,,https://api.github.com/users/manzt,https://github.com/manzt,https://api.github.com/users/manzt/followers,https://api.github.com/users/manzt/following{/other_user},https://api.github.com/users/manzt/gists{/gist_id},https://api.github.com/users/manzt/starred{/owner}{/repo},https://api.github.com/users/manzt/subscriptions,https://api.github.com/users/manzt/orgs,https://api.github.com/users/manzt/repos,https://api.github.com/users/manzt/events{/privacy},https://api.github.com/users/manzt/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5953/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
278,https://api.github.com/repos/dask/dask/issues/5955,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5955/labels{/name},https://api.github.com/repos/dask/dask/issues/5955/comments,https://api.github.com/repos/dask/dask/issues/5955/events,https://github.com/dask/dask/issues/5955,572315416,MDU6SXNzdWU1NzIzMTU0MTY=,5955,Implement sparse lsqr,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,25,2020-02-27T19:46:30Z,2021-10-13T04:49:29Z,,MEMBER,,"In a conversation, I heard this might be useful: https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.sparse.linalg.lsqr.html

We have `array.linalg.lstsq`, but this would be for sparse data.

cc @jkmacc-lanl

- http://www.cs.ucf.edu/~lwang/LSQR.html
- http://www.math.kent.edu/~reichel/publications/glsqr.pdf
- https://www.cs.uwyo.edu/~lwang7/papers/ICCS-2013.pdf",,https://api.github.com/repos/dask/dask/issues/5955/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5955/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
279,https://api.github.com/repos/dask/dask/issues/5957,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5957/labels{/name},https://api.github.com/repos/dask/dask/issues/5957/comments,https://api.github.com/repos/dask/dask/issues/5957/events,https://github.com/dask/dask/issues/5957,572511482,MDU6SXNzdWU1NzI1MTE0ODI=,5957,Dask Orc Files - Mismatched Schema Feature Request,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,2,2020-02-28T04:26:16Z,2021-10-13T02:39:59Z,,NONE,,"It would be nice to be able to select multiple orc files at once that contain different schema. For instance, if the user has three files with structs:

1. struct<id, name, city, state>
2. struct<id, city, state>
3. struct<id, name, state>

And then used the following code:

`data = dd.read_orc(path, column=['id', 'name', 'state'])`

Dask should be able to pull from the files, and replace any values with nulls if they don't exist in the data set instead of throwing ValueError: Incompatible schemas while parsing ORC files.
",,https://api.github.com/repos/dask/dask/issues/5957/timeline,,,LongBeach805,29713678,MDQ6VXNlcjI5NzEzNjc4,https://avatars.githubusercontent.com/u/29713678?v=4,,https://api.github.com/users/LongBeach805,https://github.com/LongBeach805,https://api.github.com/users/LongBeach805/followers,https://api.github.com/users/LongBeach805/following{/other_user},https://api.github.com/users/LongBeach805/gists{/gist_id},https://api.github.com/users/LongBeach805/starred{/owner}{/repo},https://api.github.com/users/LongBeach805/subscriptions,https://api.github.com/users/LongBeach805/orgs,https://api.github.com/users/LongBeach805/repos,https://api.github.com/users/LongBeach805/events{/privacy},https://api.github.com/users/LongBeach805/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5957/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
280,https://api.github.com/repos/dask/dask/issues/5965,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5965/labels{/name},https://api.github.com/repos/dask/dask/issues/5965/comments,https://api.github.com/repos/dask/dask/issues/5965/events,https://github.com/dask/dask/issues/5965,574135227,MDU6SXNzdWU1NzQxMzUyMjc=,5965,[DOCS] Flowcharts for intro docs,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,3,2020-03-02T17:38:41Z,2021-10-13T04:46:19Z,,MEMBER,,"As discussed at the dask dev meeting it would be nice to have some visual representations of the top-level concepts presented in the dask docs. 

Specifically, the sci-kit learn flowchart was referenced as a helpful guide. 

Here is what we came up with at the meeting:
![image](https://user-images.githubusercontent.com/4806877/75697735-83314b00-5c7b-11ea-88cf-762bd67a9711.png)

And here is my first attempt at vectorizing it:
[![What API to Use](https://user-images.githubusercontent.com/4806877/75697681-6c8af400-5c7b-11ea-9b6d-6b2f68c3cd9b.png)](https://docs.google.com/drawings/d/1T3VJlW-IOGFNyvkflgZu-l8OCjxXWA4Lgo4dh4AWCs8/edit)

The other one that we thought might be useful is this one:
![image](https://user-images.githubusercontent.com/4806877/75697924-c55a8c80-5c7b-11ea-82a8-eec373c14532.png)

Which I rendered as:
[![How to Deploy](https://user-images.githubusercontent.com/4806877/75701933-9c89c580-5c82-11ea-9b1c-1bf267e94d0e.png)](https://docs.google.com/drawings/d/1BqPK92m2cF0wele2S7FXrWeXMvHESSXjc9KuzZC0QUI/edit?usp=sharing)

",,https://api.github.com/repos/dask/dask/issues/5965/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5965/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
281,https://api.github.com/repos/dask/dask/issues/5985,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5985/labels{/name},https://api.github.com/repos/dask/dask/issues/5985/comments,https://api.github.com/repos/dask/dask/issues/5985/events,https://github.com/dask/dask/issues/5985,576887644,MDU6SXNzdWU1NzY4ODc2NDQ=,5985,Array fully loaded into memory when trying to store into a memmap array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}]",open,False,,[],,11,2020-03-06T12:01:07Z,2022-06-19T19:07:20Z,,CONTRIBUTOR,,"I am trying to load data from a memory-mapped array, do operations with it in dask, and store the result in another memory-mapped array. Currently this results in the entire array being loaded into memory when calling ``Array.store``. Here is an example:

```python
import numpy as np
from dask.array import from_array


@profile
def main():

    N = 512

    original_array = np.memmap('original.mmap', dtype=float, mode='w+', shape=(N, N, N))
    for i in range(N):
        original_array[i] = i

    original_array = np.memmap('original.mmap', dtype=float, mode='r', shape=(N, N, N))

    dask_array = from_array(original_array)
    dask_array = dask_array.rechunk('auto')
    print('chunksize', dask_array.chunksize)

    dask_array = np.sqrt(dask_array)

    output_array = np.memmap('final.mmap', dtype=float, mode='w+', shape=(N, N, N))
    dask_array.store(output_array, lock=True, compute=True)


main()
```

The memory profile obtained with the ``memory_profile`` package is:

```
Line #    Mem usage    Increment   Line Contents
================================================
    31   56.801 MiB   56.801 MiB   @profile
    32                             def main():
    33                             
    34   56.801 MiB    0.000 MiB       N = 512
    35                             
    36   57.086 MiB    0.285 MiB       original_array = np.memmap('original.mmap', dtype=float, mode='w+', shape=(N, N, N))
    37 1081.070 MiB    0.000 MiB       for i in range(N):
    38 1081.070 MiB    2.000 MiB           original_array[i] = i
    39                             
    40   57.121 MiB    0.000 MiB       original_array = np.memmap('original.mmap', dtype=float, mode='r', shape=(N, N, N))
    41                             
    42   57.121 MiB    0.000 MiB       dask_array = from_array(original_array)
    43   57.121 MiB    0.000 MiB       dask_array = dask_array.rechunk('auto')
    44   57.121 MiB    0.000 MiB       print('chunksize', dask_array.chunksize)
    45                             
    46   57.121 MiB    0.000 MiB       dask_array = np.sqrt(dask_array)
    47                             
    48   57.121 MiB    0.000 MiB       output_array = np.memmap('final.mmap', dtype=float, mode='w+', shape=(N, N, N))
    49 2105.648 MiB 2105.648 MiB       dask_array.store(output_array, lock=True, compute=True)
```

I would have expected the array to be computed/written chunk by chunk to the output memory mapped array, resulting in a maximum memory usage of the size of a chunk, not that of the whole array. This seems like a possible bug?",,https://api.github.com/repos/dask/dask/issues/5985/timeline,,,astrofrog,314716,MDQ6VXNlcjMxNDcxNg==,https://avatars.githubusercontent.com/u/314716?v=4,,https://api.github.com/users/astrofrog,https://github.com/astrofrog,https://api.github.com/users/astrofrog/followers,https://api.github.com/users/astrofrog/following{/other_user},https://api.github.com/users/astrofrog/gists{/gist_id},https://api.github.com/users/astrofrog/starred{/owner}{/repo},https://api.github.com/users/astrofrog/subscriptions,https://api.github.com/users/astrofrog/orgs,https://api.github.com/users/astrofrog/repos,https://api.github.com/users/astrofrog/events{/privacy},https://api.github.com/users/astrofrog/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5985/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
282,https://api.github.com/repos/dask/dask/issues/5986,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5986/labels{/name},https://api.github.com/repos/dask/dask/issues/5986/comments,https://api.github.com/repos/dask/dask/issues/5986/events,https://github.com/dask/dask/issues/5986,576984933,MDU6SXNzdWU1NzY5ODQ5MzM=,5986,[Feature request] aggregate syntax and quantile computation,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,6,2020-03-06T14:58:16Z,2021-07-19T15:10:10Z,,NONE,,"Hi,

The Dask API provides a method to compute quantiles of Series:
https://docs.dask.org/en/latest/dataframe-api.html#dask.dataframe.DataFrame.quantile

This is already a great thing as quantile distributed computation is known to be a real challenge.

Unfortunately, this is not available using aggregate API.
https://docs.dask.org/en/latest/dataframe-groupby.html#aggregate

Would it be possible to provide quantile computation to Dask aggregate syntax?",,https://api.github.com/repos/dask/dask/issues/5986/timeline,,,Amyantis,16001402,MDQ6VXNlcjE2MDAxNDAy,https://avatars.githubusercontent.com/u/16001402?v=4,,https://api.github.com/users/Amyantis,https://github.com/Amyantis,https://api.github.com/users/Amyantis/followers,https://api.github.com/users/Amyantis/following{/other_user},https://api.github.com/users/Amyantis/gists{/gist_id},https://api.github.com/users/Amyantis/starred{/owner}{/repo},https://api.github.com/users/Amyantis/subscriptions,https://api.github.com/users/Amyantis/orgs,https://api.github.com/users/Amyantis/repos,https://api.github.com/users/Amyantis/events{/privacy},https://api.github.com/users/Amyantis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5986/reactions,8,0,0,0,0,0,8,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
283,https://api.github.com/repos/dask/dask/issues/5993,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/5993/labels{/name},https://api.github.com/repos/dask/dask/issues/5993/comments,https://api.github.com/repos/dask/dask/issues/5993/events,https://github.com/dask/dask/issues/5993,577445954,MDU6SXNzdWU1Nzc0NDU5NTQ=,5993,RandomForests Performance Bug,[],open,False,,[],,40,2020-03-08T05:00:24Z,2021-03-19T14:07:03Z,,NONE,,"Running randomforests with dask joblib backend does not scale well (4.8 minutes to run the below code). Multiprocessing performs 20X better. The machine used is m5.8xlarge instance. A code to reproduce:
```python
from joblib import parallel_backend
import numpy as np
from dask.distributed import Client
from sklearn.datasets import load_digits
from sklearn.ensemble import RandomForestClassifier
digits = load_digits()
from sklearn.model_selection import cross_val_score
client=Client(processes=None)
clf = RandomForestClassifier(n_estimators=45000,verbose=1)
X = np.concatenate((digits.data,digits.data),axis=0)
y = np.concatenate((digits.target,digits.target))
with parallel_backend('dask'):
    clf.fit(X,y)
```",,https://api.github.com/repos/dask/dask/issues/5993/timeline,,,AmeerHajAli,18361764,MDQ6VXNlcjE4MzYxNzY0,https://avatars.githubusercontent.com/u/18361764?v=4,,https://api.github.com/users/AmeerHajAli,https://github.com/AmeerHajAli,https://api.github.com/users/AmeerHajAli/followers,https://api.github.com/users/AmeerHajAli/following{/other_user},https://api.github.com/users/AmeerHajAli/gists{/gist_id},https://api.github.com/users/AmeerHajAli/starred{/owner}{/repo},https://api.github.com/users/AmeerHajAli/subscriptions,https://api.github.com/users/AmeerHajAli/orgs,https://api.github.com/users/AmeerHajAli/repos,https://api.github.com/users/AmeerHajAli/events{/privacy},https://api.github.com/users/AmeerHajAli/received_events,User,False,https://api.github.com/repos/dask/dask/issues/5993/reactions,0,0,0,0,0,0,0,0,0,TomAugspurger,1312546.0,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
284,https://api.github.com/repos/dask/dask/issues/6012,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6012/labels{/name},https://api.github.com/repos/dask/dask/issues/6012/comments,https://api.github.com/repos/dask/dask/issues/6012/events,https://github.com/dask/dask/issues/6012,580609238,MDU6SXNzdWU1ODA2MDkyMzg=,6012,Issue while reading a parquet file with different data types like decimal using Dask read parquet,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,17,2020-03-13T13:42:42Z,2021-10-13T04:53:53Z,,NONE,,"I have some parquet files which are created by Spark converting AVRO file to parquet file. And these parquet files contain different data types like decimal, int,string. But when I read this file using the dd.read_parquet with pyarrow engine, except int everything else is converted to object data types and which causes an issue in arithmetic calculations. And i tried with the float dtypes for the decimal columns (which is having, upto 10 decimal places) but that will loose precision.
one thing I noticed when I read the same file with pandas dataframe it worked perfectly means the decimal columns are consider as object but still can do the arithmetic operations, but when it comes to Dask dataframe, the same decimal object is consider as string and getting the error like TypeError(""can't multiply sequence by non-int of type 'str'""). is this feature is not available in dask dataframe?
Dask version: '2.3.0'
Pandas version: '0.25.0'",,https://api.github.com/repos/dask/dask/issues/6012/timeline,,,aruns5640,45639264,MDQ6VXNlcjQ1NjM5MjY0,https://avatars.githubusercontent.com/u/45639264?v=4,,https://api.github.com/users/aruns5640,https://github.com/aruns5640,https://api.github.com/users/aruns5640/followers,https://api.github.com/users/aruns5640/following{/other_user},https://api.github.com/users/aruns5640/gists{/gist_id},https://api.github.com/users/aruns5640/starred{/owner}{/repo},https://api.github.com/users/aruns5640/subscriptions,https://api.github.com/users/aruns5640/orgs,https://api.github.com/users/aruns5640/repos,https://api.github.com/users/aruns5640/events{/privacy},https://api.github.com/users/aruns5640/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6012/reactions,1,1,0,0,0,0,0,0,0,mrocklin,306380.0,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
285,https://api.github.com/repos/dask/dask/issues/6018,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6018/labels{/name},https://api.github.com/repos/dask/dask/issues/6018/comments,https://api.github.com/repos/dask/dask/issues/6018/events,https://github.com/dask/dask/issues/6018,582658443,MDU6SXNzdWU1ODI2NTg0NDM=,6018,Merging fails when merging on a column of extension dtype of the same size (Int32 and int32),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2020-03-16T23:35:16Z,2023-04-05T08:25:33Z,,NONE,,"Ran across this issue after updating pandas version (1.0.2) and on latest dask (2.12.0). This feels similar to #5720 that was previously reported.

A snippet to reproduce the issue:
```
import pandas as pd
from dask.dataframe.multi import merge
import dask.dataframe as dd
import dask as d

print(""---versions for bug report---"")
print(f""pandas version: {pd.__version__}"")
print(f""dask version: {d.__version__}"")

df1 = pd.DataFrame(
    {""A"": pd.Series([1, 2, 3], dtype=""Int32""), ""B"": [1, 1, 3], ""C"": list(""aab"")}
)
df2 = pd.DataFrame(
    {""A"": pd.Series([1, 2, 3], dtype=""int32""), ""E"": [1, 1, 3], ""F"": list(""aab"")}
)
ddf1 = dd.from_pandas(df1, 1)
ddf2 = dd.from_pandas(df2, 2)

# pure pandas merge works
print(""pandas-only merge"")
print(df1.merge(df2, on=""A""))
print(""dask merge"")
# fails with ValueError: cannot convert to 'int64'-dtype NumPy array with missing values. Specify an appropriate 'na_value' for this dtype.
print(merge(ddf1, ddf2, on=""A""))
print(ddf1.merge(ddf2, on=""A""))
```

Pandas can merge on the column A with dtypes Int32 and int32 respectively on df1 and df2, however the dask-equivalents throw the following error:
`ValueError: cannot convert to 'int64'-dtype NumPy array with missing values. Specify an appropriate 'na_value' for this dtype.`

<details>
<summary>Full trace:</summary>
<p>

```
Traceback (most recent call last):
  File ""tests/test_merge_issue.py"", line 29, in <module>
    print(merge(ddf1, ddf2, on=""A""))
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/dask/dataframe/multi.py"", line 493, in merge
    indicator=indicator,
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/dask/dataframe/multi.py"", line 324, in single_partition_join
    meta = left._meta_nonempty.merge(right._meta_nonempty, **kwargs)
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pandas/core/frame.py"", line 7297, in merge
    validate=validate,
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pandas/core/reshape/merge.py"", line 88, in merge
    return op.get_result()
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pandas/core/reshape/merge.py"", line 643, in get_result
    join_index, left_indexer, right_indexer = self._get_join_info()
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pandas/core/reshape/merge.py"", line 862, in _get_join_info
    (left_indexer, right_indexer) = self._get_join_indexers()
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pandas/core/reshape/merge.py"", line 841, in _get_join_indexers
    self.left_join_keys, self.right_join_keys, sort=self.sort, how=self.how
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pandas/core/reshape/merge.py"", line 1311, in _get_join_indexers
    zipped = zip(*mapped)
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pandas/core/reshape/merge.py"", line 1309, in <genexpr>
    for n in range(len(left_keys))
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pandas/core/reshape/merge.py"", line 1901, in _factorize_keys
    lk = ensure_int64(com.values_from_object(lk))
  File ""pandas/_libs/algos_common_helper.pxi"", line 93, in pandas._libs.algos.ensure_int64
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pandas/core/arrays/masked.py"", line 145, in __array__
    return self.to_numpy(dtype=dtype)
  File ""/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pandas/core/arrays/masked.py"", line 127, in to_numpy
    f""cannot convert to '{dtype}'-dtype NumPy array ""
ValueError: cannot convert to 'int64'-dtype NumPy array with missing values. Specify an appropriate 'na_value' for this dtype.
```


</p>
</details>",,https://api.github.com/repos/dask/dask/issues/6018/timeline,,,lionsardesai,1217072,MDQ6VXNlcjEyMTcwNzI=,https://avatars.githubusercontent.com/u/1217072?v=4,,https://api.github.com/users/lionsardesai,https://github.com/lionsardesai,https://api.github.com/users/lionsardesai/followers,https://api.github.com/users/lionsardesai/following{/other_user},https://api.github.com/users/lionsardesai/gists{/gist_id},https://api.github.com/users/lionsardesai/starred{/owner}{/repo},https://api.github.com/users/lionsardesai/subscriptions,https://api.github.com/users/lionsardesai/orgs,https://api.github.com/users/lionsardesai/repos,https://api.github.com/users/lionsardesai/events{/privacy},https://api.github.com/users/lionsardesai/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6018/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
286,https://api.github.com/repos/dask/dask/issues/6058,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6058/labels{/name},https://api.github.com/repos/dask/dask/issues/6058/comments,https://api.github.com/repos/dask/dask/issues/6058/events,https://github.com/dask/dask/issues/6058,592574615,MDU6SXNzdWU1OTI1NzQ2MTU=,6058,Feature request: dask.dataframe.to_xarray(),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2020-04-02T11:56:13Z,2021-03-12T15:04:53Z,,MEMBER,,"See https://stackoverflow.com/questions/60896303/dask-convert-a-dask-dataframe-to-an-xarray-dataset/60904272#60904272

There is an equivalent method in `pandas` ([`pandas.DataFrame.to_xarray`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_xarray.html)) and `xarray` has the method to convert to a `dask.dataframe.` ([`xarray.Dataset.to_dask_dataframe`](http://xarray.pydata.org/en/stable/generated/xarray.Dataset.to_dask_dataframe.html))

My motivation is I was showing how a package I developed [`xskillscore`](https://github.com/raybellwaves/xskillscore) can be dropped in to your work flow if you are using `pandas.DataFrame`'s (https://github.com/raybellwaves/xskillscore-tutorial/blob/master/01_Determinisitic.ipynb). Because `xskillscore` is an extension of `xarray` it works with `dask`. I was looking to repeat this workflow using a `dask.dataframe`. In the end I went with the `dask.array` approach (https://github.com/raybellwaves/xskillscore-tutorial/blob/master/03_Big_Data.ipynb).

@mrocklin @TomAugspurger apologies for the tagging. you may know if there are `xarray` devs here who may be interested.",,https://api.github.com/repos/dask/dask/issues/6058/timeline,,,raybellwaves,17162724,MDQ6VXNlcjE3MTYyNzI0,https://avatars.githubusercontent.com/u/17162724?v=4,,https://api.github.com/users/raybellwaves,https://github.com/raybellwaves,https://api.github.com/users/raybellwaves/followers,https://api.github.com/users/raybellwaves/following{/other_user},https://api.github.com/users/raybellwaves/gists{/gist_id},https://api.github.com/users/raybellwaves/starred{/owner}{/repo},https://api.github.com/users/raybellwaves/subscriptions,https://api.github.com/users/raybellwaves/orgs,https://api.github.com/users/raybellwaves/repos,https://api.github.com/users/raybellwaves/events{/privacy},https://api.github.com/users/raybellwaves/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6058/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
287,https://api.github.com/repos/dask/dask/issues/6068,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6068/labels{/name},https://api.github.com/repos/dask/dask/issues/6068/comments,https://api.github.com/repos/dask/dask/issues/6068/events,https://github.com/dask/dask/issues/6068,595053879,MDU6SXNzdWU1OTUwNTM4Nzk=,6068,Dask apply throwing error using right meta,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2020-04-06T11:58:32Z,2021-02-26T07:58:02Z,,NONE,,"I'm trying to run the following code:
```
import pandas as pd
import dask.dataframe as dd

testpd = pd.DataFrame(
    {
        ""SKU_ID"": {0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 2, 6: 2},
        ""STR_ID"": {0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 64, 6: 64},
        ""DATE"": {
            0: Timestamp(""2018-01-01 00:00:00""),
            1: Timestamp(""2018-01-02 00:00:00""),
            2: Timestamp(""2018-01-03 00:00:00""),
            3: Timestamp(""2018-01-04 00:00:00""),
            4: Timestamp(""2018-01-05 00:00:00""),
            5: Timestamp(""2020-02-22 00:00:00""),
            6: Timestamp(""2020-02-23 00:00:00""),
        },
        ""ORD_UNITS"": {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0},
    }
)

testdd = dd.from_pandas(testpd, npartitions=2,)

def func(x):
    return pd.Series(x[""DATE""] == x[""DATE""].min(), name=""result"")

```
with pandas, works perfectly:
 ```
In [11]: testpd.groupby([""SKU_ID"", ""STR_ID""]).apply(func)
Out[11]:
SKU_ID  STR_ID
1       1       0     True
                1    False
                2    False
                3    False
                4    False
2       64      5     True
                6    False
Name: result, dtype: bool
 ```

But with dask I got:
```
In [12]: testdd.groupby([""SKU_ID"", ""STR_ID""]).apply(
    ...:     func, meta=pd.Series([], dtype=bool, name=""result"")
    ...: ).compute()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-12-e82967be25da> in <module>
      1 testdd.groupby([""SKU_ID"", ""STR_ID""]).apply(
----> 2     func, meta=pd.Series([], dtype=bool, name=""result"")
      3 ).compute()

~\Anaconda3\lib\site-packages\dask\base.py in compute(self, **kwargs)
    164         dask.base.compute
    165         """"""
--> 166         (result,) = compute(self, traverse=False, **kwargs)
    167         return result
    168

~\Anaconda3\lib\site-packages\dask\base.py in compute(*args, **kwargs)
    435     keys = [x.__dask_keys__() for x in collections]
    436     postcomputes = [x.__dask_postcompute__() for x in collections]
--> 437     results = schedule(dsk, keys, **kwargs)
    438     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    439

~\Anaconda3\lib\site-packages\dask\threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     82         get_id=_thread_get_id,
     83         pack_exception=pack_exception,
---> 84         **kwargs
     85     )
     86

~\Anaconda3\lib\site-packages\dask\local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    484                         _execute_task(task, data)  # Re-execute locally
    485                     else:
--> 486                         raise_exception(exc, tb)
    487                 res, worker_id = loads(res_info)
    488                 state[""cache""][key] = res

~\Anaconda3\lib\site-packages\dask\local.py in reraise(exc, tb)
    314     if exc.__traceback__ is not tb:
    315         raise exc.with_traceback(tb)
--> 316     raise exc
    317
    318

~\Anaconda3\lib\site-packages\dask\local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    220     try:
    221         task, data = loads(task_info)
--> 222         result = _execute_task(task, data)
    223         id = get_id()
    224         result = dumps((result, id))

~\Anaconda3\lib\site-packages\dask\core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

~\Anaconda3\lib\site-packages\dask\optimization.py in __call__(self, *args)
    980         if not len(args) == len(self.inkeys):
    981             raise ValueError(""Expected %d args, got %d"" % (len(self.inkeys), len(args)))
--> 982         return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
    983
    984     def __reduce__(self):

~\Anaconda3\lib\site-packages\dask\core.py in get(dsk, out, cache)
    149     for key in toposort(dsk):
    150         task = dsk[key]
--> 151         result = _execute_task(task, cache)
    152         cache[key] = result
    153     result = _execute_task(out, cache)

~\Anaconda3\lib\site-packages\dask\core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

~\Anaconda3\lib\site-packages\dask\utils.py in apply(func, args, kwargs)
     28 def apply(func, args, kwargs=None):
     29     if kwargs:
---> 30         return func(*args, **kwargs)
     31     else:
     32         return func(*args)

~\Anaconda3\lib\site-packages\dask\dataframe\core.py in apply_and_enforce(*args, **kwargs)
   5077             return meta
   5078         if is_dataframe_like(df):
-> 5079             check_matching_columns(meta, df)
   5080             c = meta.columns
   5081         else:

~\Anaconda3\lib\site-packages\dask\dataframe\utils.py in check_matching_columns(meta, actual)
    669 def check_matching_columns(meta, actual):
    670     # Need nan_to_num otherwise nan comparison gives False
--> 671     if not np.array_equal(np.nan_to_num(meta.columns), np.nan_to_num(actual.columns)):
    672         extra = actual.columns.difference(meta.columns).tolist()
    673         missing = meta.columns.difference(actual.columns).tolist()

~\Anaconda3\lib\site-packages\pandas\core\generic.py in __getattr__(self, name)
   5268             or name in self._accessors
   5269         ):
-> 5270             return object.__getattribute__(self, name)
   5271         else:
   5272             if self._info_axis._can_hold_identifiers_and_holds_name(name):

AttributeError: 'Series' object has no attribute 'columns'
```

```
In [2]: dask.__version__
Out[2]: '2.12.0'
In [4]: pandas.__version__
Out[4]: '1.0.1'
```",,https://api.github.com/repos/dask/dask/issues/6068/timeline,,,victor-ab,26576394,MDQ6VXNlcjI2NTc2Mzk0,https://avatars.githubusercontent.com/u/26576394?v=4,,https://api.github.com/users/victor-ab,https://github.com/victor-ab,https://api.github.com/users/victor-ab/followers,https://api.github.com/users/victor-ab/following{/other_user},https://api.github.com/users/victor-ab/gists{/gist_id},https://api.github.com/users/victor-ab/starred{/owner}{/repo},https://api.github.com/users/victor-ab/subscriptions,https://api.github.com/users/victor-ab/orgs,https://api.github.com/users/victor-ab/repos,https://api.github.com/users/victor-ab/events{/privacy},https://api.github.com/users/victor-ab/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6068/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
288,https://api.github.com/repos/dask/dask/issues/6070,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6070/labels{/name},https://api.github.com/repos/dask/dask/issues/6070/comments,https://api.github.com/repos/dask/dask/issues/6070/events,https://github.com/dask/dask/issues/6070,595964051,MDU6SXNzdWU1OTU5NjQwNTE=,6070,Groupby followed by another groupby raising error,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2020-04-07T15:40:06Z,2021-03-12T14:59:26Z,,NONE,,"Two groupby in a row is raising an error if the first groupby uses two columns. May be related to the unsupported multi-indexing. #1493 

```
ddf = dd.from_pandas(
    pd.DataFrame(
        {
            ""ID"": [1, 1, 2, 2],
            ""a"": [1, 2, 3, 4],
            ""date"": [
                datetime(2018, 1, 1),
                datetime(2018, 1, 2),
                datetime(2018, 1, 3),
                datetime(2018, 1, 1),
            ],
        }
    ),
    npartitions=2,
)

ddf.groupby([""ID"", ""date""])[[""a""]].sum().groupby([""ID""]).apply(
    lambda x: x, meta=pd.DataFrame(columns=[""ID"", ""date"", ""a""])
).compute()
```

```
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-101-20089f0ac304> in <module>
     16 
     17 A.groupby([""ID"", ""date""])[[""a""]].sum().groupby([""ID""]).apply(
---> 18     lambda x: x, meta=pd.DataFrame(columns=[""ID"", ""date"", ""a""])
     19 ).compute()

~\Anaconda3\lib\site-packages\dask\base.py in compute(self, **kwargs)
    164         dask.base.compute
    165         """"""
--> 166         (result,) = compute(self, traverse=False, **kwargs)
    167         return result
    168 

~\Anaconda3\lib\site-packages\dask\base.py in compute(*args, **kwargs)
    435     keys = [x.__dask_keys__() for x in collections]
    436     postcomputes = [x.__dask_postcompute__() for x in collections]
--> 437     results = schedule(dsk, keys, **kwargs)
    438     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    439 

~\Anaconda3\lib\site-packages\dask\threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     82         get_id=_thread_get_id,
     83         pack_exception=pack_exception,
---> 84         **kwargs
     85     )
     86 

~\Anaconda3\lib\site-packages\dask\local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    484                         _execute_task(task, data)  # Re-execute locally
    485                     else:
--> 486                         raise_exception(exc, tb)
    487                 res, worker_id = loads(res_info)
    488                 state[""cache""][key] = res

~\Anaconda3\lib\site-packages\dask\local.py in reraise(exc, tb)
    314     if exc.__traceback__ is not tb:
    315         raise exc.with_traceback(tb)
--> 316     raise exc
    317 
    318 

~\Anaconda3\lib\site-packages\dask\local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    220     try:
    221         task, data = loads(task_info)
--> 222         result = _execute_task(task, data)
    223         id = get_id()
    224         result = dumps((result, id))

~\Anaconda3\lib\site-packages\dask\core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

~\Anaconda3\lib\site-packages\dask\optimization.py in __call__(self, *args)
    980         if not len(args) == len(self.inkeys):
    981             raise ValueError(""Expected %d args, got %d"" % (len(self.inkeys), len(args)))
--> 982         return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
    983 
    984     def __reduce__(self):

~\Anaconda3\lib\site-packages\dask\core.py in get(dsk, out, cache)
    149     for key in toposort(dsk):
    150         task = dsk[key]
--> 151         result = _execute_task(task, cache)
    152         cache[key] = result
    153     result = _execute_task(out, cache)

~\Anaconda3\lib\site-packages\dask\core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

~\Anaconda3\lib\site-packages\dask\core.py in <genexpr>(.0)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

~\Anaconda3\lib\site-packages\dask\core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

~\Anaconda3\lib\site-packages\dask\utils.py in apply(func, args, kwargs)
     28 def apply(func, args, kwargs=None):
     29     if kwargs:
---> 30         return func(*args, **kwargs)
     31     else:
     32         return func(*args)

~\Anaconda3\lib\site-packages\dask\dataframe\core.py in apply_and_enforce(*args, **kwargs)
   5072     func = kwargs.pop(""_func"")
   5073     meta = kwargs.pop(""_meta"")
-> 5074     df = func(*args, **kwargs)
   5075     if is_dataframe_like(df) or is_series_like(df) or is_index_like(df):
   5076         if not len(df):

~\Anaconda3\lib\site-packages\dask\dataframe\shuffle.py in partitioning_index(df, npartitions)
    604         An array of int64 values mapping each record to a partition.
    605     """"""
--> 606     return hash_object_dispatch(df, index=False) % int(npartitions)
    607 
    608 

~\Anaconda3\lib\site-packages\dask\utils.py in __call__(self, arg, *args, **kwargs)
    504         """"""
    505         meth = self.dispatch(type(arg))
--> 506         return meth(arg, *args, **kwargs)
    507 
    508     @property

~\Anaconda3\lib\site-packages\dask\dataframe\utils.py in hash_object_pandas(obj, index, encoding, hash_key, categorize)
    470 ):
    471     return pd.util.hash_pandas_object(
--> 472         obj, index=index, encoding=encoding, hash_key=hash_key, categorize=categorize
    473     )
    474 

~\Anaconda3\lib\site-packages\pandas\core\util\hashing.py in hash_pandas_object(obj, index, encoding, hash_key, categorize)
    137         h = _combine_hash_arrays(hashes, num_items)
    138 
--> 139         h = Series(h, index=obj.index, dtype=""uint64"", copy=False)
    140     else:
    141         raise TypeError(f""Unexpected type for hashing {type(obj)}"")

~\Anaconda3\lib\site-packages\pandas\core\series.py in __init__(self, data, index, dtype, name, copy, fastpath)
    290                     if len(index) != len(data):
    291                         raise ValueError(
--> 292                             f""Length of passed values is {len(data)}, ""
    293                             f""index implies {len(index)}.""
    294                         )

ValueError: Length of passed values is 0, index implies 4.
```

if reset_index() is applied after the first groupby, it works:
```
A.groupby([""ID"", ""date""])[[""a""]].sum().reset_index().groupby([""ID""]).apply(
    lambda x: x, meta=pd.DataFrame(columns=[""ID"", ""date"", ""a""])
).compute()
```
```
	ID	date		a
0	1	2018-01-01	1
1	1	2018-01-02	2
2	2	2018-01-01	4
3	2	2018-01-03	3
```
dask.__version__: '2.12.0'
pandas.__version__: '1.0.1'",,https://api.github.com/repos/dask/dask/issues/6070/timeline,,,victor-ab,26576394,MDQ6VXNlcjI2NTc2Mzk0,https://avatars.githubusercontent.com/u/26576394?v=4,,https://api.github.com/users/victor-ab,https://github.com/victor-ab,https://api.github.com/users/victor-ab/followers,https://api.github.com/users/victor-ab/following{/other_user},https://api.github.com/users/victor-ab/gists{/gist_id},https://api.github.com/users/victor-ab/starred{/owner}{/repo},https://api.github.com/users/victor-ab/subscriptions,https://api.github.com/users/victor-ab/orgs,https://api.github.com/users/victor-ab/repos,https://api.github.com/users/victor-ab/events{/privacy},https://api.github.com/users/victor-ab/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6070/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
289,https://api.github.com/repos/dask/dask/issues/6083,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6083/labels{/name},https://api.github.com/repos/dask/dask/issues/6083/comments,https://api.github.com/repos/dask/dask/issues/6083/events,https://github.com/dask/dask/issues/6083,597934939,MDU6SXNzdWU1OTc5MzQ5Mzk=,6083,Configure Optimization Pipeline,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,5,2020-04-10T15:04:04Z,2021-10-13T04:08:19Z,,MEMBER,,"Currently the optimization pipeline for each collection is hardcoded into functions like `dask.array.optimization.optimization`.  In some applications people want to turn off various parts of this pipeline.  For example in https://github.com/napari/napari/issues/718 the Napari folks need to turn off task fusion so that they can get opportunistic caching to work well.  This has come up a few times in other cases as well.

It would be nice for users to be able to turn off and on various parts of the optimization pipeline (or even add parts) with some sort of configuration.  This might be some yaml config

```yaml
array:
  optimization:
  - optimize_blockwise
  - fuse_roots
  - cull
  - hold_keys
  - fuse
  - inline
  - optimize_slices
```

Or it might be by registering some custom module with hand-specified Python code

```yaml
array:
  optimization: my_module.optimize
```

or in python

```python
dask.config.set(array__optimization=my_optimization_func)
```

My guess is that the choice here depends on how easy it is to create a generic optimization pipeline and still keep things efficient.  Currently we're careful about avoiding recomputing dependencies (this can slow things down) but the optimization functions themselves aren't currently that uniform (some do and don't modify dependencies) so maybe we need to establish a more uniform interface so that things can be chained together more robustly.

cc @jcrist and @eriknw for feedback",,https://api.github.com/repos/dask/dask/issues/6083/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6083/reactions,3,2,0,0,0,0,1,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
290,https://api.github.com/repos/dask/dask/issues/6084,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6084/labels{/name},https://api.github.com/repos/dask/dask/issues/6084/comments,https://api.github.com/repos/dask/dask/issues/6084/events,https://github.com/dask/dask/pull/6084,598123443,MDExOlB1bGxSZXF1ZXN0NDAyMDkyMjk1,6084,Add configuration option for optimization functions,[],open,False,,[],,1,2020-04-10T22:34:20Z,2021-03-12T14:41:04Z,,MEMBER,,"This lets users specify optimization functions for our core classes.

Some mild issues:

1.  There is some code duplication here
2.  We're taking up the entire `foo.optimization` namespace with a string, which stops us from being able to add other things.

cc @jcrist ",,https://api.github.com/repos/dask/dask/issues/6084/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6084/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6084,https://github.com/dask/dask/pull/6084,https://github.com/dask/dask/pull/6084.diff,https://github.com/dask/dask/pull/6084.patch,,,,,,,,,,,,,,,,,,,
291,https://api.github.com/repos/dask/dask/issues/6104,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6104/labels{/name},https://api.github.com/repos/dask/dask/issues/6104/comments,https://api.github.com/repos/dask/dask/issues/6104/events,https://github.com/dask/dask/issues/6104,600654236,MDU6SXNzdWU2MDA2NTQyMzY=,6104,groupby apply using Grouper,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,7,2020-04-15T23:50:54Z,2021-07-15T21:07:42Z,,NONE,,"I would like to use an arbitrary function on each group after using groupby with Grouper, but `apply` isn't working. The following example

``` python
import dask.dataframe as dd
import pandas as pd
pdf = pd.DataFrame({'A':[1, 2, 3, 4, 5], 'B':['1985','1985','1990','1990','1990']})
pdf['B']=pd.to_datetime(pdf['B'], format=""%Y"")
ddf = dd.from_pandas(pdf, npartitions = 3)
ddf.groupby(pd.Grouper(key='B', freq=""Y"")).apply(lambda x: x['A'].mean()).compute()
```
gives the error

> ValueError: Length of passed values is 0, index implies 2

Versions:
dask: 2.13.0
pandas: 1.0.3
",,https://api.github.com/repos/dask/dask/issues/6104/timeline,,,brandonlockhart,25874021,MDQ6VXNlcjI1ODc0MDIx,https://avatars.githubusercontent.com/u/25874021?v=4,,https://api.github.com/users/brandonlockhart,https://github.com/brandonlockhart,https://api.github.com/users/brandonlockhart/followers,https://api.github.com/users/brandonlockhart/following{/other_user},https://api.github.com/users/brandonlockhart/gists{/gist_id},https://api.github.com/users/brandonlockhart/starred{/owner}{/repo},https://api.github.com/users/brandonlockhart/subscriptions,https://api.github.com/users/brandonlockhart/orgs,https://api.github.com/users/brandonlockhart/repos,https://api.github.com/users/brandonlockhart/events{/privacy},https://api.github.com/users/brandonlockhart/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6104/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
292,https://api.github.com/repos/dask/dask/issues/6123,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6123/labels{/name},https://api.github.com/repos/dask/dask/issues/6123/comments,https://api.github.com/repos/dask/dask/issues/6123/events,https://github.com/dask/dask/issues/6123,605135435,MDU6SXNzdWU2MDUxMzU0MzU=,6123,Compile Blockwise array sub graphs,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,2,2020-04-22T23:25:30Z,2021-10-13T04:05:40Z,,MEMBER,,"We currently collect a broad class of operations into high level graphs.

```python
In [1]: import dask.array as da                                                                          

In [2]: from dask.blockwise import optimize_blockwise                                                    

In [3]: x = da.ones((10, 10), chunks=(5, 5))                                                             

In [4]: y = da.cos(x) ** 2 + da.sin(x) ** 2                                                              

In [5]: graph = optimize_blockwise(y.dask)                                                               

In [6]: {k: type(v) for k, v in graph.layers.items()}                                                    
Out[6]: 
{'add-a2d88408268290d7edfe4ede916b05b4': dask.blockwise.Blockwise,
 'ones-b8c5986474b86c6e3a94246ecba1c6e4': dict}

In [7]: layer = graph.layers[""add-a2d88408268290d7edfe4ede916b05b4""]                                     

In [8]: layer                                                                                            
Out[8]: Blockwise<((2, None), ('ones-b8c5986474b86c6e3a94246ecba1c6e4', ('.1', '.0'))) -> add-a2d88408268290d7edfe4ede916b05b4>

In [9]: layer.dsk                                                                                        
Out[9]: 
{'add-a2d88408268290d7edfe4ede916b05b4': (<function _operator.add(a, b, /)>,
  'pow-235ad71f84352db184f344e57d4ac82d',
  'pow-4f17fda523d5e314cbcdb23b6972e013'),
 'pow-235ad71f84352db184f344e57d4ac82d': (<function _operator.pow(a, b, /)>,
  'cos-58716fab65fe91a0e56f8d12baabec04',
  '_0'),
 'cos-58716fab65fe91a0e56f8d12baabec04': (<ufunc 'cos'>, '_1'),
 'pow-4f17fda523d5e314cbcdb23b6972e013': (<function _operator.pow(a, b, /)>,
  'sin-968a3d0e9b788b4f0cc55ac5c3e938f7',
  '_0'),
 'sin-968a3d0e9b788b4f0cc55ac5c3e938f7': (<ufunc 'sin'>, '_1')}

In [10]: layer.__dict__                                                                                  
Out[10]: 
{'output': 'add-a2d88408268290d7edfe4ede916b05b4',
 'output_indices': ('.1', '.0'),
 'dsk': {'add-a2d88408268290d7edfe4ede916b05b4': (<function _operator.add(a, b, /)>,
   'pow-235ad71f84352db184f344e57d4ac82d',
   'pow-4f17fda523d5e314cbcdb23b6972e013'),
  'pow-235ad71f84352db184f344e57d4ac82d': (<function _operator.pow(a, b, /)>,
   'cos-58716fab65fe91a0e56f8d12baabec04',
   '_0'),
  'cos-58716fab65fe91a0e56f8d12baabec04': (<ufunc 'cos'>, '_1'),
  'pow-4f17fda523d5e314cbcdb23b6972e013': (<function _operator.pow(a, b, /)>,
   'sin-968a3d0e9b788b4f0cc55ac5c3e938f7',
   '_0'),
  'sin-968a3d0e9b788b4f0cc55ac5c3e938f7': (<ufunc 'sin'>, '_1')},
 'indices': ((2, None),
  ('ones-b8c5986474b86c6e3a94246ecba1c6e4', ('.1', '.0'))),
 'numblocks': {'ones-b8c5986474b86c6e3a94246ecba1c6e4': (2, 2)},
 'concatenate': None,
 'new_axes': {}}
```

This includes elementwise operations (as above) and also transpose, the first bits of reductions, tensordot, and so on.  The object `layer.dsk` is a computation to run in a single task.  Normally it gets evaluated by `dask.get` (I think) (a simple single threaded scheduler) by calling these functions in a sensible order on the input chunks.  

However we could also choose to be more intelligent here, and modify this sequence of functions.  This is a good time to perform intelligent optimizations because we know that this one sub-graph is likely both small, and likely to be run many times across all of our chunks.  Two optimizations have come up in the past:

1.  Using inplace operations, like rewriting `a = a + 1` to `a += 1` when safe to do so
2.  Handing everything to Numba, which maybe does optimizations like the above, and hopefully others.  
3.  Handing everything to Numba, and optionally using some of the fancier flags within numba, like `fastmath=True`

This came up briefly in https://github.com/dask/dask/issues/1964 .  @jcrist may also have an experiment lying around

### GPUs

Avoiding memory copies becomes more important when the underlying chunks are cupy rather than numpy arrays.  An optimization of this sort may also be interested in knowing what the metadata of the input chunks are.",,https://api.github.com/repos/dask/dask/issues/6123/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6123/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
293,https://api.github.com/repos/dask/dask/issues/6127,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6127/labels{/name},https://api.github.com/repos/dask/dask/issues/6127/comments,https://api.github.com/repos/dask/dask/issues/6127/events,https://github.com/dask/dask/issues/6127,605374283,MDU6SXNzdWU2MDUzNzQyODM=,6127,un-numpy like behavior of `da.pad` ,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2020-04-23T09:17:48Z,2020-05-20T13:26:22Z,,CONTRIBUTOR,,"This issue is related to #5303 and #6042. As explained in the pull request there are still 2 small bugs related to un-numpy like behavior of `da.pad`.

Test for these issues are already added. The tests are currently failing when the `pytest.mark.skip` is removed. https://github.com/dask/dask/blob/0de3c64272dbc2e4a7370797dc3bc63ee49eb01c/dask/array/tests/test_creation.py#L772.

__Pad with `mode=""mean""` converts data to float__
```
>>> arr = np.arange(1, 3)

>>> np.pad(arr, 1, mode=""mean"")
array([2, 1, 2, 2])

>>> da.pad(arr, 1, mode=""mean"").compute()
array([1.5, 1. , 2. , 1.5])
```

__Shape of output does not match when pad_width is larger than the shape of the input__
```
>>> arr = np.arange(1, 3)

>>> np.pad(arr, (0, 3), mode=""wrap"")
array([1, 2, 1, 2, 1])

>>> da.pad(arr, (0,3), mode=""wrap"").compute()
array([1, 2, 1, 2])
```
",,https://api.github.com/repos/dask/dask/issues/6127/timeline,,,mark-boer,12862013,MDQ6VXNlcjEyODYyMDEz,https://avatars.githubusercontent.com/u/12862013?v=4,,https://api.github.com/users/mark-boer,https://github.com/mark-boer,https://api.github.com/users/mark-boer/followers,https://api.github.com/users/mark-boer/following{/other_user},https://api.github.com/users/mark-boer/gists{/gist_id},https://api.github.com/users/mark-boer/starred{/owner}{/repo},https://api.github.com/users/mark-boer/subscriptions,https://api.github.com/users/mark-boer/orgs,https://api.github.com/users/mark-boer/repos,https://api.github.com/users/mark-boer/events{/privacy},https://api.github.com/users/mark-boer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6127/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
294,https://api.github.com/repos/dask/dask/issues/6128,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6128/labels{/name},https://api.github.com/repos/dask/dask/issues/6128/comments,https://api.github.com/repos/dask/dask/issues/6128/events,https://github.com/dask/dask/issues/6128,605446474,MDU6SXNzdWU2MDU0NDY0NzQ=,6128,optimize() and compute() kwargs aren't passed to optimization functions,[],open,False,,[],,3,2020-04-23T11:11:40Z,2020-04-23T18:49:34Z,,MEMBER,,"From the documentation:

https://github.com/dask/dask/blob/f58b95584dbdd19aad5c409892196f1e29a84534/docs/source/optimize.rst#L271-L284

It doesn't seem to work:

```python
def myopt(dsk, keys, **kwargs):
    print(kwargs)
    return dsk

d = delayed(123)
dask.compute(d, optimizations=[myopt], myopt_foo=123)
dask.optimize(d, optimizations=[myopt], myopt_foo=123)
```
Expected output:
```
{""foo"": 123}
{""foo"": 123}
```
Actual output:
```
{}
{}
```
Workaround:
```python
dask.compute(d, optimizations=[partial(myopt, foo=123)])
dask.optimize(d, optimizations=[partial(myopt, foo=123)])
```
",,https://api.github.com/repos/dask/dask/issues/6128/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6128/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
295,https://api.github.com/repos/dask/dask/issues/6150,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6150/labels{/name},https://api.github.com/repos/dask/dask/issues/6150/comments,https://api.github.com/repos/dask/dask/issues/6150/events,https://github.com/dask/dask/issues/6150,608453769,MDU6SXNzdWU2MDg0NTM3Njk=,6150,Feature Request: support using bottleneck nan* functions,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2020-04-28T16:31:24Z,2020-04-30T21:10:09Z,,CONTRIBUTOR,,"It would be nice to have a way to use the [bottleneck](https://pypi.org/project/Bottleneck/) package's nan-aware functions such as ``nanmedian`` and so on when calling ``da.nanmedian`` and other similar dask functions. The bottleneck functions are in general faster and use up much less memory than their Numpy counterparts.

This could be done either by adding a kwarg to the dask functions, or maybe having a way to register in the dask configuration that bottleneck alternatives are acceptable, and then just using them behind the hood in ``da.nanmedian`` if that configuration value is set? Or if bottleneck is installed, they could even be used by default?",,https://api.github.com/repos/dask/dask/issues/6150/timeline,,,astrofrog,314716,MDQ6VXNlcjMxNDcxNg==,https://avatars.githubusercontent.com/u/314716?v=4,,https://api.github.com/users/astrofrog,https://github.com/astrofrog,https://api.github.com/users/astrofrog/followers,https://api.github.com/users/astrofrog/following{/other_user},https://api.github.com/users/astrofrog/gists{/gist_id},https://api.github.com/users/astrofrog/starred{/owner}{/repo},https://api.github.com/users/astrofrog/subscriptions,https://api.github.com/users/astrofrog/orgs,https://api.github.com/users/astrofrog/repos,https://api.github.com/users/astrofrog/events{/privacy},https://api.github.com/users/astrofrog/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6150/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
296,https://api.github.com/repos/dask/dask/issues/6161,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6161/labels{/name},https://api.github.com/repos/dask/dask/issues/6161/comments,https://api.github.com/repos/dask/dask/issues/6161/events,https://github.com/dask/dask/issues/6161,610937824,MDU6SXNzdWU2MTA5Mzc4MjQ=,6161,Support nlargest groupby aggregation,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,5,2020-05-01T19:55:14Z,2020-09-23T19:19:08Z,,MEMBER,,"Dask currently doesn't have build in `nlargest` groupby aggregation. There are examples of groupby-apply pattern used for this problem ([example_1](https://github.com/h2oai/db-benchmark/blob/master/dask/groupby-dask.py#L238) and [example_2](https://stackoverflow.com/questions/47227874/is-there-a-way-to-get-the-nlargest-items-per-group-in-dask)), afaiu this can be efficiently solved as a groupby aggregation using panda's `nlargest`. Please let me know if there is something I'm missing/misunderstanding, and if it's ok for me to submit a PR for this change.",,https://api.github.com/repos/dask/dask/issues/6161/timeline,,,ravwojdyla,1419010,MDQ6VXNlcjE0MTkwMTA=,https://avatars.githubusercontent.com/u/1419010?v=4,,https://api.github.com/users/ravwojdyla,https://github.com/ravwojdyla,https://api.github.com/users/ravwojdyla/followers,https://api.github.com/users/ravwojdyla/following{/other_user},https://api.github.com/users/ravwojdyla/gists{/gist_id},https://api.github.com/users/ravwojdyla/starred{/owner}{/repo},https://api.github.com/users/ravwojdyla/subscriptions,https://api.github.com/users/ravwojdyla/orgs,https://api.github.com/users/ravwojdyla/repos,https://api.github.com/users/ravwojdyla/events{/privacy},https://api.github.com/users/ravwojdyla/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6161/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
297,https://api.github.com/repos/dask/dask/issues/6163,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6163/labels{/name},https://api.github.com/repos/dask/dask/issues/6163/comments,https://api.github.com/repos/dask/dask/issues/6163/events,https://github.com/dask/dask/issues/6163,610961485,MDU6SXNzdWU2MTA5NjE0ODU=,6163,[DISCUSS] Improve client/scheduler performance during shuffling,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,2,2020-05-01T20:48:47Z,2021-10-13T05:45:53Z,,MEMBER,,"Lets use this issue to coordinate some ongoing efforts to improve client/scheduler graph performance related to large-scale shuffle operations.

In order to rearrange data between partitions in `dask.dataframe` (for parallel merge/sort/shuffle routines), the `rearrange_by_column_tasks` routine is used to build a task graph for staged shuffling.  Since this logic represents `n log(n)` scaling, the time required for graph creation and execution itself can be quite significant.

Note that a detailed explanation of a nearly identical ""staged shuffle"" is described [in this discussion](https://github.com/rapidsai/cudf/pull/4308#issuecomment-598219871).  One component of the algorithm that is clearly dominating the size of the graph is the repetition of `shuffle_group` tasks (which output dictionaries of pd/cudf DataFrame objects) and `getitem` tasks (which select elements of the `shuffle-group` output).  It is my understanding that some people may have promising ideas to improve performance here.

cc @kkraus14 @quasiben @mrocklin (Please do cc others as well..)",,https://api.github.com/repos/dask/dask/issues/6163/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6163/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
298,https://api.github.com/repos/dask/dask/issues/6164,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6164/labels{/name},https://api.github.com/repos/dask/dask/issues/6164/comments,https://api.github.com/repos/dask/dask/issues/6164/events,https://github.com/dask/dask/issues/6164,611090242,MDU6SXNzdWU2MTEwOTAyNDI=,6164,Distributed Partd,[],open,False,,[],,13,2020-05-02T02:30:35Z,2021-07-17T18:59:20Z,,MEMBER,,"### Problem

I was chatting with some RAPIDS devs today (@kkraus14 @quasiben @randerzander @jakirkham @madsbk @pentschev and others ) and they were generally concerned about the scheduling overhead of dataframe merges/set_index operations (anything that uses `shuffle`).  There is an effort to improve scheduling performance generally, but there is also an option to try to rethink how we handle shuffling in dataframes, and maybe other similar operations in the future as well (like array rechunking in extreme situations).  

The currrent `""tasks""` based shuffling method uses  `O(n log(n))` tasks and log(n) full-dataset communications.  This is fine for ~100 partitions, but becomes challenging once you get to 1000 partition datasets.  We also have a separate solution around [partd](https://github.com/dask/partd), which does things in `O(n)` tasks, by buffering small shards of the data and using disk as a global communication store.  Partd as written doesn't work in a distributed fashion, but we might think about how to do some similar approach in a distributed fashion.

### DHT

In principle, building some sort of distributed hash table (DHT) like thing out of Dask parts isn't hard (actors, pubsub, etc, are all good examples of similar systems that took a couple of days to build).  What is hard is making it resilient.  For this we might look to a mixture solution between some peer-to-peer system, and a centralized `SchedulerPlugin`.  Here is a rough design.

We run tasks on each partition of the to-be-shuffled dataframe that split that partition into pieces, and put into some local splitting service.  The first task on a machine probably creates the service (we use a local thread-based-lock to coordinate between multiple tasks on the same machine).  That service splits things apart, stores them in local buffers, and periodically sends batches them to peers.  

How does it learn what peers it should send things to?  Probably it has to check in with the scheduler, which will still act as centralized control here, but won't track every individual piece of data. Maybe these things check in with the scheduler, the scheduler alerts everyone else about what is going on, and the things push data around in a way similar to a distributed hash table (DHT).  (there is lots of prior art here and algorithms to steal).  

Once all of those tasks are done we run some barrier task, and then there are a bunch of other tasks which pull output partitions from the DHT.  There is some excess communication here because we aren't thinking about locality for the Dask-DHT nodes, but for now let's just allow that as an allowable cost (my apologies).  

So great, we get by with 2*n tasks, and probably two full communications.  Not great, but it's probably better than what we have now for large shuffle computations.

### What can go wrong

So what happens if a worker goes down during execution?  We haven't replicated data, and the task that created that chunk of data is gone, so we've lost some things.  We can still recreate and rerun that task though, we just need to tell the scheduler to do so.  So in order to get resilience, we register a [`SchedulerPlugin`](https://distributed.dask.org/en/latest/plugins.html) that calls some custom code whenever a worker goes down.  We know which workers processed which tasks, so we rerun those tasks.  The other DHT nodes will get some duplicate data unfortunately, so they'll probably have to track which tasks they've seen, and know to discard any message that comes from the same task twice.  

### Nice things

So we get a nice combination here of resilience provided by the centralized scheduler, as well as low overhead provided by decentralized execution.  

If we can create this as a more general purpose DHT solution then I suspect that people will find other uses for it other than just dataframe all-to-all shuffling.",,https://api.github.com/repos/dask/dask/issues/6164/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6164/reactions,9,0,0,0,0,0,9,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
299,https://api.github.com/repos/dask/dask/issues/6219,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6219/labels{/name},https://api.github.com/repos/dask/dask/issues/6219/comments,https://api.github.com/repos/dask/dask/issues/6219/events,https://github.com/dask/dask/issues/6219,619898853,MDU6SXNzdWU2MTk4OTg4NTM=,6219,Can't optimize HighLevelGraph (delayed object),"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,13,2020-05-18T04:28:27Z,2021-10-13T05:49:27Z,,MEMBER,,"I am trying to optimize a simple read / store pipeline by fusing the read and write tasks into a single operation.

Here is a concrete example:
```python
import zarr
import dask
import dask.array as dsa

store_source = {}
shape = (8, 8)
source_chunks = (1, 8) 
read_chunks = (2, 8)
dtype = 'f4'

a_source = zarr.ones(shape, chunks=source_chunks,
                     dtype=dtype, store=store_source)
a_source.attrs['foo'] = 'bar'
d_source = dsa.from_zarr(a_source, chunks=read_chunks)

target_store = {}
a_target = zarr.empty(shape, chunks=source_chunks, dtype=dtype, store=target_store)
a_target.attrs.update(a_source.attrs)
store_future = dsa.store(d_source, a_target, lock=False, compute=False)

dask.visualize(store_future)
```

![image](https://user-images.githubusercontent.com/1197350/82173989-31bd5300-989d-11ea-88de-022f9501210c.png)

I would like to fuse the `from-zarr` and `store` tasks into one task.

However, I can't apply any optimizations to my graph, because of this error:
```python
from dask.optimization import fuse
store_future_opt = dask.optimize(store_future, optimizations=[fuse])
```
raises
```
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-45-3afc3be4ea23> in <module>
      1 from dask.optimization import fuse
----> 2 store_future_opt = dask.optimize(store_future, optimizations=[fuse])

~/opt/miniconda3/envs/pangeo-py38/lib/python3.8/site-packages/dask/base.py in optimize(*args, **kwargs)
    366         return args
    367 
--> 368     dsk = collections_to_dsk(collections, **kwargs)
    369     postpersists = [
    370         a.__dask_postpersist__() if is_dask_collection(a) else (None, a) for a in args

~/opt/miniconda3/envs/pangeo-py38/lib/python3.8/site-packages/dask/base.py in collections_to_dsk(collections, optimize_graph, **kwargs)
    212 
    213         for opt in optimizations:
--> 214             groups = {k: (opt(dsk, keys), keys) for k, (dsk, keys) in groups.items()}
    215 
    216         dsk = merge(

~/opt/miniconda3/envs/pangeo-py38/lib/python3.8/site-packages/dask/base.py in <dictcomp>(.0)
    212 
    213         for opt in optimizations:
--> 214             groups = {k: (opt(dsk, keys), keys) for k, (dsk, keys) in groups.items()}
    215 
    216         dsk = merge(

~/opt/miniconda3/envs/pangeo-py38/lib/python3.8/site-packages/dask/optimization.py in fuse(dsk, keys, dependencies, ave_width, max_width, max_height, max_depth_new_edges, rename_keys, fuse_subgraphs)
    530         return dsk, deps
    531 
--> 532     rv = dsk.copy()
    533     fused_trees = {}
    534     # These are the stacks we use to store data as we traverse the graph

AttributeError: 'HighLevelGraph' object has no attribute 'copy'
```

(Something similar was seen in https://github.com/radix-ai/graphchain/pull/36.)

As a workaround, I tried to do the optimization on the low level graph:
```python
dsk_fused = fuse(store_future.dask.dicts)
dask.visualize(dsk_fused)
```
![image](https://user-images.githubusercontent.com/1197350/82174310-3afaef80-989e-11ea-87bc-ebb2ee47f7b0.png)

However, I don't know how to go from this back to a delayed object that I can compute. The [documentation on optimization](https://docs.dask.org/en/latest/optimize.html?highlight=fuse) does not really explain how to go back and forth between Dask's various datatypes and this low-level graph.

I feel I am missing some important concept ere, but I can't figure out what.

Dask version 2.10.1.",,https://api.github.com/repos/dask/dask/issues/6219/timeline,,,rabernat,1197350,MDQ6VXNlcjExOTczNTA=,https://avatars.githubusercontent.com/u/1197350?v=4,,https://api.github.com/users/rabernat,https://github.com/rabernat,https://api.github.com/users/rabernat/followers,https://api.github.com/users/rabernat/following{/other_user},https://api.github.com/users/rabernat/gists{/gist_id},https://api.github.com/users/rabernat/starred{/owner}{/repo},https://api.github.com/users/rabernat/subscriptions,https://api.github.com/users/rabernat/orgs,https://api.github.com/users/rabernat/repos,https://api.github.com/users/rabernat/events{/privacy},https://api.github.com/users/rabernat/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6219/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
300,https://api.github.com/repos/dask/dask/issues/6227,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6227/labels{/name},https://api.github.com/repos/dask/dask/issues/6227/comments,https://api.github.com/repos/dask/dask/issues/6227/events,https://github.com/dask/dask/issues/6227,622560123,MDU6SXNzdWU2MjI1NjAxMjM=,6227,Demonstration dataset for Dask Array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2020-05-21T14:58:34Z,2020-05-23T20:13:13Z,,MEMBER,,"The `dask.datasets` module includes functions like `dask.dataset.timeseries` or `dask.datasets.make_people` for Dask dataframes or Dask bags respectively from random data.

It would be useful to have other demonstration datasets for people who want to run performance benchmarks, particularly around Dask array.  Dask array is interesting because there are a few chunk-wise backends like cupy and sparse which would be fun to play with as well.

I was speaking with @eric-czech and @alimanfoo about genomics data, which is interesting both in that it has a small data type, and can be sparse and compressible.  They may have thoughts on how to effectively simulate large data sets.",,https://api.github.com/repos/dask/dask/issues/6227/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6227/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
301,https://api.github.com/repos/dask/dask/issues/6228,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6228/labels{/name},https://api.github.com/repos/dask/dask/issues/6228/comments,https://api.github.com/repos/dask/dask/issues/6228/events,https://github.com/dask/dask/issues/6228,622742045,MDU6SXNzdWU2MjI3NDIwNDU=,6228,Cache doesn't cull unreachable tasks after replacement,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,4,2020-05-21T19:52:11Z,2021-10-13T05:34:12Z,,MEMBER,,"Using the `Cache` class, tasks which are no longer neededbecause their results have been found in the cachemay still be run.

```python
In [1]: import time
In [2]: import dask
In [3]: import dask.cache

In [4]: @dask.delayed
   ...: def slow(x):
   ...:     print(f""slow {x}"")
   ...:     time.sleep(2)
   ...:     return x
   ...:

In [5]: @dask.delayed
   ...: def fast_add(x, y):
   ...:     print(f""fast_add {x} {y}"")
   ...:     return x + y
   ...:

In [6]: result = fast_add(slow(1), slow(2))

In [7]: cache = dask.cache.Cache(1e6)

In [8]: # as expected, the first run takes 2sec and all functions run
   ...: %%time
   ...: with cache:
   ...:     result.compute()
   ...:
slow 1
slow 2
fast_add 1 2
CPU times: user 6.66 ms, sys: 3.49 ms, total: 10.1 ms
Wall time: 2.01 s

In [9]: # also as expected, the second run is fast, since all results are in the cache---no functions run
   ...: %%time
   ...: with cache:
   ...:     result.compute()
   ...:
CPU times: user 422 s, sys: 24 s, total: 446 s
Wall time: 442 s

In [10]: cache.cache.data
Out[10]:
{'slow-3d3a6713-ce9f-49ea-9308-a765127fa68e': 1,
 'slow-670ba8b8-6ab1-4843-87d2-c5bdc7e0a730': 2,
 'fast_add-2432fe5a-e323-4bc5-b11d-7f357ac40f55': 3}

In [11]: # what if we had a cache miss on the upstream `slow` functions,
    ...: # but still a cache hit on the result we're actually trying to compute?
    ...: # we'd expect the slow functions to still not run, because with the result
    ...: # already in the cache, those upstream dependencies are essentially unreachable
    ...: # keys---nothing depends on them anymore.

In [11]: del cache.cache.data['slow-3d3a6713-ce9f-49ea-9308-a765127fa68e']
    ...: del cache.cache.data['slow-670ba8b8-6ab1-4843-87d2-c5bdc7e0a730']

In [12]: # to confirm: the only result key we need is still in the cache
    ...: result.__dask_keys__()                                                                                                                                                               
Out[12]: ['fast_add-2432fe5a-e323-4bc5-b11d-7f357ac40f55']

In [13]: cache.cache.data                                                                                                                                                                     
Out[13]: {'fast_add-2432fe5a-e323-4bc5-b11d-7f357ac40f55': 3}

In [14]: # yet the `slow` functions still run, even though they're unneeded. `fast_add` doesn't, because it's a cache hit.
    ...: %%time
    ...: with cache:
    ...:     result.compute()
    ...:
slow 1
slow 2
CPU times: user 3.44 ms, sys: 1.46 ms, total: 4.9 ms
Wall time: 2.01 s
```

The Cache class simply inserts cached values into the dask prior to computation:
https://github.com/dask/dask/blob/3b92efff2e779f59e95e05af9b8f371d56227d02/dask/cache.py#L47-L49

However, the implementation of `get_async` assumes the graph it's passed has already been optimized and culled. Since Cache is a Callback, and Callbacks operate post-optimization, the graph it produces won't ever get optimized. Therefore, the now-unreachable tasks in the graph are still computed.

There are a couple ways we could solve this:

1. Have `get_async` always cull the graph. IMO, the contract of `get_async` is just that it'll compute the `result` keys from the given `dsk`_not_ that it'll execute every task in the graph. To me, it's just an unfortunate implementation detail that it schedules tasks to run which are not direct dependencies of the `result` keys.

    I wouldn't necessarily implement this by just calling `cull` in `get_asyc` (though it may not be the worst idea). Instead, I imagine that [`start_state_from_dask`](https://github.com/dask/dask/blob/3b92efff2e779f59e95e05af9b8f371d56227d02/dask/local.py#L139-L198) could be refactored in such a way that it walks the graph starting from the result keys, which would probably be about the same performance-wise, but have the property of culling the graph along the way.

2. The Callback interface doesn't seem suited to callbacks that modify the graph, because they're not told which keys are being requested. If `_start` were called with `(dsk, keys)` instead of just `(dsk)`, then the callback could just call `cull` itself inside `_start`. But without `keys`, it doesn't have enough information to do any optimizations.

    This would be a pretty simple change, but a breaking change to the Callback interface.

3. Perhaps callbacks really shouldn't be modifying the graph like thisshould cache-replacement be considered an optimizer instead? That interface calls `optimize(dsk, keys)`, so it would work. `Cache.__enter__` could temporarily add a function to `config[""optimizations""]` that replaces the keys in the graph with their cached values, then culls it.

    However, that won't work with the current [`collections_to_dsk`](https://github.com/dask/dask/blob/3b92efff2e779f59e95e05af9b8f371d56227d02/dask/base.py#L204-L231) implementation, which is where `config[""optimizations""]` are applied: it applies `config[""optimizations""]` _before_ any collection-specific optimizations. Since the cache uses the `_posttask` callback for cache puts, where the keys are in their fully-optimized form, the cache gets also need to operate on the fully-optimized graph. Basically, cache replacement always has to be the very last optimization pass, and there's no interface for that right now.

    Two options for this:
        a. Flip these sections:
        https://github.com/dask/dask/blob/e3f80df7fff7627082688b7cccff1e9131001446/dask/base.py#L213-L221

      so that `optimizations` are applied after the collection-specific optimizations. Easy, but possibly a breaking change for anyone using the `optimizations=` interface.

      EDIT: looks like this flip actually just happened in #6137?! Hope that doesn't break anything for anyone...

      b. Add another kwarg for `""post_optimizations""`?

For context, I found this because I wrote a custom caching callback, and referred to the `Cache` implementation while writing it. I recently found this bug in mine, and because of all the limitations I've described above, I can't find any way to work around it without making some change to dask.

Which direction (cull in `get_async`, pass keys to `_start`, or register in `config[""optimizations""]`) do you think would be the best way to solve this?",,https://api.github.com/repos/dask/dask/issues/6228/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6228/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
302,https://api.github.com/repos/dask/dask/issues/6230,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6230/labels{/name},https://api.github.com/repos/dask/dask/issues/6230/comments,https://api.github.com/repos/dask/dask/issues/6230/events,https://github.com/dask/dask/issues/6230,623331446,MDU6SXNzdWU2MjMzMzE0NDY=,6230,Disagreement between dask.DataFrame.resample().count() and pd.resample().count(),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,23,2020-05-22T16:29:21Z,2020-06-02T21:15:38Z,,NONE,,"I have a large unsorted time series data with occasional irregular time intervals. I want to resample the data and perform summary statistics on larger chunks of time. But I'm running into an issue with dask resample().count() not properly computing the data.

```
import dask.dataframe as dd
import pandas as pd
import numpy
times = [1545362463409128000, 1545362504369352000, 1545362545326966000, 1545363118769636000, 1545363159726490000, 1545363200687178000, 1545363241648824000, 1573318190393973000, 1573318231353350000, 1573318272313774000, 1573318313275299000, 1573318354233962000, 1573318395195456000, 1573318436154609000, 1580687544437145000, 1580687585394881000, 1580687667316809000, 1580687708275414000, 1580687790195742000, 1580687831154951000, 1580687872115363000, 1580687954035133000, 1559127673402811000]
data = numpy.ones(len(times))
df = pd.DataFrame({'Time': times, 'Counts': data})
df['Time'] = pd.to_datetime(df['Time'],utc=True)
print(df.set_index('Time').resample('1Y').count())
print(dd.from_pandas(df, npartitions=2).set_index('Time').resample('1Y').count().compute())
```
Using pandas and resample I get the following
```
                           Counts
Time                             
2018-12-31 00:00:00+00:00       7
2019-12-31 00:00:00+00:00       8
2020-12-31 00:00:00+00:00       8
```
But using dask the counts are off by one
```
                           Counts
Time                             
2018-12-31 00:00:00+00:00       7
2019-12-31 00:00:00+00:00       8
2020-12-31 00:00:00+00:00       7
```
Apparently if I set npartitions=1 than dask properly computes the counts.
I'm using dask-core version 2.15.0 and pandas 1.0.2.
",,https://api.github.com/repos/dask/dask/issues/6230/timeline,,,tevi,1986831,MDQ6VXNlcjE5ODY4MzE=,https://avatars.githubusercontent.com/u/1986831?v=4,,https://api.github.com/users/tevi,https://github.com/tevi,https://api.github.com/users/tevi/followers,https://api.github.com/users/tevi/following{/other_user},https://api.github.com/users/tevi/gists{/gist_id},https://api.github.com/users/tevi/starred{/owner}{/repo},https://api.github.com/users/tevi/subscriptions,https://api.github.com/users/tevi/orgs,https://api.github.com/users/tevi/repos,https://api.github.com/users/tevi/events{/privacy},https://api.github.com/users/tevi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6230/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
303,https://api.github.com/repos/dask/dask/issues/6242,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6242/labels{/name},https://api.github.com/repos/dask/dask/issues/6242/comments,https://api.github.com/repos/dask/dask/issues/6242/events,https://github.com/dask/dask/pull/6242,624731261,MDExOlB1bGxSZXF1ZXN0NDIzMDg0NDYy,6242,WIP: fix categoricals for non-object dtypes,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3028194444, 'node_id': 'MDU6TGFiZWwzMDI4MTk0NDQ0', 'url': 'https://api.github.com/repos/dask/dask/labels/dispatch', 'name': 'dispatch', 'color': 'fc03db', 'default': False, 'description': 'Related to `Dispatch` extension objects'}]",open,False,,[],,2,2020-05-26T09:17:09Z,2021-06-11T15:03:58Z,,CONTRIBUTOR,,"This PR intends to fix categoricals support for categories whose dtypes are not `object`, see #5756 for more info.

I started work on this branch a while ago, receiving some input from @TomAugspurger . 
Unfortunately, I don't have time to work on this atm so if anybody would like to pick this up, feel free to do so.

Fixes #5756 


",,https://api.github.com/repos/dask/dask/issues/6242/timeline,,,lr4d,44430780,MDQ6VXNlcjQ0NDMwNzgw,https://avatars.githubusercontent.com/u/44430780?v=4,,https://api.github.com/users/lr4d,https://github.com/lr4d,https://api.github.com/users/lr4d/followers,https://api.github.com/users/lr4d/following{/other_user},https://api.github.com/users/lr4d/gists{/gist_id},https://api.github.com/users/lr4d/starred{/owner}{/repo},https://api.github.com/users/lr4d/subscriptions,https://api.github.com/users/lr4d/orgs,https://api.github.com/users/lr4d/repos,https://api.github.com/users/lr4d/events{/privacy},https://api.github.com/users/lr4d/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6242/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/6242,https://github.com/dask/dask/pull/6242,https://github.com/dask/dask/pull/6242.diff,https://github.com/dask/dask/pull/6242.patch,,,,,,,,,,,,,,,,,,,
304,https://api.github.com/repos/dask/dask/issues/6246,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6246/labels{/name},https://api.github.com/repos/dask/dask/issues/6246/comments,https://api.github.com/repos/dask/dask/issues/6246/events,https://github.com/dask/dask/issues/6246,625191062,MDU6SXNzdWU2MjUxOTEwNjI=,6246,Non-index-based partitioning of Dask DataFrames,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,8,2020-05-26T20:52:30Z,2020-08-21T08:44:54Z,,MEMBER,,"https://github.com/dask/dask/pull/6066 recently added a `DataFrame.shuffle`
method for partitioning a dataframe by one or more columns based on the hash of
the column's values. All rows with an equal has will end up in the same partition.

How should this be exposed to users through the DataFrame data model? At the
moment, `.shuffle()` just results in a complex task graph (and perhaps the
clearing of `.divisions`).

1. How should this affect `.divisions`? The current semantics and implementation
   of `.divisions` doesn't handle hash-based, column partitioning. The semantics
   are off, since we don't actually sort the data by the (hashed) values. And we
   might partition by multiple columns, so we might want a 2-D structure to
   whatever concept generalizes `.divisions`.
2. As usual with data model questions: how should this affect the repr?

Sorry for just raising questions and no answers thus far. I'll think on it some more.

cc @rjzamora.",,https://api.github.com/repos/dask/dask/issues/6246/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6246/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
305,https://api.github.com/repos/dask/dask/issues/6248,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6248/labels{/name},https://api.github.com/repos/dask/dask/issues/6248/comments,https://api.github.com/repos/dask/dask/issues/6248/events,https://github.com/dask/dask/pull/6248,625379425,MDExOlB1bGxSZXF1ZXN0NDIzNjA5MTY1,6248,Ensure `meta` is included when pickling `Array`,[],open,False,,[],,9,2020-05-27T05:03:33Z,2021-03-08T20:19:42Z,,MEMBER,,"- [ ] Tests added / passed
- [ ] Passes `black dask` / `flake8 dask`
",,https://api.github.com/repos/dask/dask/issues/6248/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6248/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6248,https://github.com/dask/dask/pull/6248,https://github.com/dask/dask/pull/6248.diff,https://github.com/dask/dask/pull/6248.patch,,,,,,,,,,,,,,,,,,,
306,https://api.github.com/repos/dask/dask/issues/6272,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6272/labels{/name},https://api.github.com/repos/dask/dask/issues/6272/comments,https://api.github.com/repos/dask/dask/issues/6272/events,https://github.com/dask/dask/issues/6272,628534264,MDU6SXNzdWU2Mjg1MzQyNjQ=,6272,Expose intermediate rechunking logic da.reshape,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2020-06-01T15:33:53Z,2020-06-29T11:32:47Z,,MEMBER,,"`da.reshape` does some clever tricks to avoid making too large intermediate chunks. Sometimes, however, the user can do better, especially given downstream operations.

In this example, we ""read"", reshape, and slice. The nature of the final slice happens to select data from just a single original chunk. But by default there's an intermediate `rechunk-merge` of two original chunks.

```python
# a has 4 chunks
x = np.arange(2 * 2 * 5).reshape((2, 2, 5))
a = da.from_array(x, chunks=(1, 1, 5))
a_reshaped = a.reshape((4, 5))
```


```python
a_reshaped[0].visualize(filename=""default"", optimize_graph=True)
```

![default](https://user-images.githubusercontent.com/1312546/83425082-f1a8b500-a3f2-11ea-99ea-a55eb4bd6e23.png)


If the user could specify the intermediate and output chunks, then they can get the desired chunking

```python
a_reshaped = a.reshape((2*2, 5),
                       inchunks=((1, 1), (1, 1), (5,)),
                       outchunks=((1, 1, 1, 1), (5,)))
```

```python
a_reshaped[0].visualize(filename=""manual"", optimize_graph=True)
```

![manual](https://user-images.githubusercontent.com/1312546/83425141-0e44ed00-a3f3-11ea-9c99-64c88e8ebe8a.png)

The change itself is pretty small

```diff
diff --git a/dask/array/core.py b/dask/array/core.py
index ef8970091..756b72bd5 100644
--- a/dask/array/core.py
+++ b/dask/array/core.py
@@ -1742,12 +1742,12 @@ class Array(DaskMethodsMixin):
         return choose(self, choices)
 
     @derived_from(np.ndarray)
-    def reshape(self, *shape):
+    def reshape(self, *shape, inchunks=None, outchunks=None):
         from .reshape import reshape
 
         if len(shape) == 1 and not isinstance(shape[0], Number):
             shape = shape[0]
-        return reshape(self, shape)
+        return reshape(self, shape, inchunks=inchunks, outchunks=outchunks)
 
     def topk(self, k, axis=-1, split_every=None):
         """"""The top k elements of an array.
diff --git a/dask/array/reshape.py b/dask/array/reshape.py
index 85b5ca33c..e00a0a191 100644
--- a/dask/array/reshape.py
+++ b/dask/array/reshape.py
@@ -133,7 +133,7 @@ def contract_tuple(chunks, factor):
     return tuple(out)
 
 
-def reshape(x, shape):
+def reshape(x, shape, inchunks=None, outchunks=None):
     """""" Reshape array to new shape
 
     This is a parallelized version of the ``np.reshape`` function with the
@@ -145,6 +145,23 @@ def reshape(x, shape):
 
     .. _`row-major order`: https://en.wikipedia.org/wiki/Row-_and_column-major_order
 
+    Parameters
+    ----------
+    shape : tuple
+        The new shape should be compatible with the original shape and should satisfy
+        Dask's additional restrictions. If
+        an integer, then the result will be a 1-D array of that length.
+        One shape dimension can be -1. In this case, the value is
+        inferred from the length of the array and remaining dimensions.
+    inchunks : tuple, optional
+        The chunks to use for an intermediate re-chunked array. By default, the array
+        is rechunked to keep roughly the same chunk sizes.
+    outchunks : tuple, optional
+        The chunks to use for the output array.
+
+    Notes
+    -----
+
     When communication is necessary this algorithm depends on the logic within
     rechunk.  It endeavors to keep chunk sizes roughly the same when possible.
 
@@ -192,7 +209,12 @@ def reshape(x, shape):
         return Array(graph, name, chunks, meta=meta)
 
     # Logic for how to rechunk
-    inchunks, outchunks = reshape_rechunk(x.shape, shape, x.chunks)
+    if inchunks is None and outchunks is None:
+        inchunks2, outchunks2 = reshape_rechunk(x.shape, shape, x.chunks)
+        if inchunks is None:
+            inchunks = inchunks2
+        if outchunks is None:
+            outchunks = outchunks2
     x2 = x.rechunk(inchunks)
 
     # Construct graph
```

The primary argument against is perhaps that this perhaps something Dask should be doing automatically. I'm not sure how feasible detecting this optimization is though.

This is a workaround that might be solved properly by https://github.com/dask/dask/issues/5544.",,https://api.github.com/repos/dask/dask/issues/6272/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6272/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
307,https://api.github.com/repos/dask/dask/issues/6275,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6275/labels{/name},https://api.github.com/repos/dask/dask/issues/6275/comments,https://api.github.com/repos/dask/dask/issues/6275/events,https://github.com/dask/dask/issues/6275,628716334,MDU6SXNzdWU2Mjg3MTYzMzQ=,6275,ones() and zeros() got multiple values for argument 'dtype',"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2020-06-01T20:47:37Z,2021-02-08T15:23:44Z,,NONE,,"While computing a dask array using the ones() (or zeros) API, and using `dtype` as a positional (second) argument, the following error occurs:

```python
TypeError: ones() got multiple values for argument 'dtype'
```

The documentation states that they follow the signature of the numpy variants exactly, which would not require `dtype` to be a keyword argument.

This works:

```python
da.ones((3, 3), dtype='bool').compute()
```

But this does not:

```python
da.ones((3, 3), 'bool').compute()
```

Using dask-2.17.2-py_0 with Python 3.6.9 installed using conda on MacOS 10.15.5
",,https://api.github.com/repos/dask/dask/issues/6275/timeline,,,bluegeo,19851732,MDQ6VXNlcjE5ODUxNzMy,https://avatars.githubusercontent.com/u/19851732?v=4,,https://api.github.com/users/bluegeo,https://github.com/bluegeo,https://api.github.com/users/bluegeo/followers,https://api.github.com/users/bluegeo/following{/other_user},https://api.github.com/users/bluegeo/gists{/gist_id},https://api.github.com/users/bluegeo/starred{/owner}{/repo},https://api.github.com/users/bluegeo/subscriptions,https://api.github.com/users/bluegeo/orgs,https://api.github.com/users/bluegeo/repos,https://api.github.com/users/bluegeo/events{/privacy},https://api.github.com/users/bluegeo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6275/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
308,https://api.github.com/repos/dask/dask/issues/6276,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6276/labels{/name},https://api.github.com/repos/dask/dask/issues/6276/comments,https://api.github.com/repos/dask/dask/issues/6276/events,https://github.com/dask/dask/pull/6276,628796525,MDExOlB1bGxSZXF1ZXN0NDI2MjY4NTY2,6276,Cleanup and modernize dask.array creation functions (e.g. da.ones),"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2020-06-01T23:38:24Z,2021-10-13T05:27:39Z,,MEMBER,,"These are some of the oldest methods in `dask.array`, and stylistically
no longer matched much of the codebase. The implementation was also
overcomplicated to support `ones` and `ones_like` with the same wrapper
code, even though we no longer used the `ones_like` defined in that file
(that had since moved to `da.creation` from `da.wrap`). The wrapping
code also didn't properly handle the differences between `*args` and
`**kwargs` well, leading to issues if e.g. `dtype` was passed as an
`arg` not a `kwarg`.

This fixes all of that, removing the old code in `wrap`, and moving
everything under `da.creation`.
`da.ones`/`da.zeros`/`da.full`/`da.empty` all have proper signatures
now, and the underlying implementation is much simpler.

Also fixes a bug where calling `da.full(large_shape, 1)` with no `dtype`
would actually create that array in memory when inferring the dtype.

Fixes #6275.

- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask`
",,https://api.github.com/repos/dask/dask/issues/6276/timeline,,,jcrist,2783717,MDQ6VXNlcjI3ODM3MTc=,https://avatars.githubusercontent.com/u/2783717?v=4,,https://api.github.com/users/jcrist,https://github.com/jcrist,https://api.github.com/users/jcrist/followers,https://api.github.com/users/jcrist/following{/other_user},https://api.github.com/users/jcrist/gists{/gist_id},https://api.github.com/users/jcrist/starred{/owner}{/repo},https://api.github.com/users/jcrist/subscriptions,https://api.github.com/users/jcrist/orgs,https://api.github.com/users/jcrist/repos,https://api.github.com/users/jcrist/events{/privacy},https://api.github.com/users/jcrist/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6276/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6276,https://github.com/dask/dask/pull/6276,https://github.com/dask/dask/pull/6276.diff,https://github.com/dask/dask/pull/6276.patch,,,,,,,,,,,,,,,,,,,
309,https://api.github.com/repos/dask/dask/issues/6288,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6288/labels{/name},https://api.github.com/repos/dask/dask/issues/6288/comments,https://api.github.com/repos/dask/dask/issues/6288/events,https://github.com/dask/dask/issues/6288,631197000,MDU6SXNzdWU2MzExOTcwMDA=,6288,Pushdown of slicing operator on arrays?,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,7,2020-06-04T22:56:50Z,2023-03-22T17:02:22Z,,NONE,,"Hi, I would like to use dask.delayed on a sparse TileDB array like described here:
https://docs.tiledb.com/dask/tiledb-with-dask-delayed

Due to the sparse nature of my array (shape is `[3x10^9, 3x10^9, 7000]`), dividing the dataset into separate chunks and loading them into memory is quite wasteful to impossible.
Instead, I would like to make use of the fancy slicing capabilities of TileDB.

Is it possible to have a custom Dask delayed object that pushes down slicing to the underlying array?

------
**EDIT to be more concrete:**
What happens when I do the following: 
```
x = dask.array.from_array(tdb, chunks=(1000,))[:1000]
y = x[:100]
z = y[:10]
```
Does Dask then call `tdb[:10]` or does it call `tdb[:1000][:100][:10]`?",,https://api.github.com/repos/dask/dask/issues/6288/timeline,,,Hoeze,1200058,MDQ6VXNlcjEyMDAwNTg=,https://avatars.githubusercontent.com/u/1200058?v=4,,https://api.github.com/users/Hoeze,https://github.com/Hoeze,https://api.github.com/users/Hoeze/followers,https://api.github.com/users/Hoeze/following{/other_user},https://api.github.com/users/Hoeze/gists{/gist_id},https://api.github.com/users/Hoeze/starred{/owner}{/repo},https://api.github.com/users/Hoeze/subscriptions,https://api.github.com/users/Hoeze/orgs,https://api.github.com/users/Hoeze/repos,https://api.github.com/users/Hoeze/events{/privacy},https://api.github.com/users/Hoeze/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6288/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
310,https://api.github.com/repos/dask/dask/issues/6306,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6306/labels{/name},https://api.github.com/repos/dask/dask/issues/6306/comments,https://api.github.com/repos/dask/dask/issues/6306/events,https://github.com/dask/dask/issues/6306,636231606,MDU6SXNzdWU2MzYyMzE2MDY=,6306,unexpected behavior of dask groupby std,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,7,2020-06-10T13:07:37Z,2021-10-13T05:25:05Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
Dask groupby std is different 
**What you expected to happen**:
Dask groupby std should be zero for a series of same values
**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import dask.dataframe as dd

# dask groupby std
def dd_std(value, n):
    df = pd.DataFrame([('a', value)]*n, columns=['x', 'y'])
    ddf = dd.from_pandas(df, npartitions=2)
    std = ddf.groupby('x')['y'].std().compute()[0]
    return std

# pandas groupby std
def pd_std(value, n):
    df = pd.DataFrame([('a', value)]*n, columns=['x', 'y'])
    std = df.groupby('x')['y'].std()[0]
    return std
```

One example, value = 0.011
```python
for i in range(2, 100):
    std = dd_std(0.011, i)
    if std > 0:
        print(i, std)
        break

for i in range(2, 100):
    std = pd_std(0.011, i)
    if std > 0:
        print(i, std)
        break
```
dd_std stops when i = 10

results:
dd_std: 10 1.5522042910257974e-10
pd_std prints nothing

Another example, value = 0.002:
```python
for i in range(2, 100):
    std = dd_std(0.002, i)
    if std > 0:
        print(i, std)
        break

for i in range(2, 100):
    std = pd_std(0.002, i)
    if std > 0:
        print(i, std)
        break
```
dd_std stops when i = 11

results:
dd_std: 11 2.6031257322754125e-11
pd_std prints nothing

In addition, dd_std prints nothing if value is an integer.

**Anything else we need to know?**:
the dask std is always zero if do not use groupby

**Environment**:

- Dask version: 2.17.2
- Python version: 3.7.7
- Operating System: MacOS
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/6306/timeline,,,mk0417,27696880,MDQ6VXNlcjI3Njk2ODgw,https://avatars.githubusercontent.com/u/27696880?v=4,,https://api.github.com/users/mk0417,https://github.com/mk0417,https://api.github.com/users/mk0417/followers,https://api.github.com/users/mk0417/following{/other_user},https://api.github.com/users/mk0417/gists{/gist_id},https://api.github.com/users/mk0417/starred{/owner}{/repo},https://api.github.com/users/mk0417/subscriptions,https://api.github.com/users/mk0417/orgs,https://api.github.com/users/mk0417/repos,https://api.github.com/users/mk0417/events{/privacy},https://api.github.com/users/mk0417/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6306/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
311,https://api.github.com/repos/dask/dask/issues/6312,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6312/labels{/name},https://api.github.com/repos/dask/dask/issues/6312/comments,https://api.github.com/repos/dask/dask/issues/6312/events,https://github.com/dask/dask/issues/6312,636568732,MDU6SXNzdWU2MzY1Njg3MzI=,6312,array.blockwise has incorrect output shape in task graph,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2020-06-10T21:43:08Z,2021-10-13T05:24:07Z,,NONE,,"**What happened**: The new_axes parameter only modifies the output array shape at compute time.  Because of this, it's not possible to build task graphs that depend on array.blockwise reshaping the array.

**What you expected to happen**: The output array should be registered as the correct shape in the computation graph, so that the in-dask statements in the example below run the same as the numpy ones.

**Minimal Complete Verifiable Example**:

```python
import dask.array as da
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer

tfidf = TfidfVectorizer().fit_transform([
    ""Hello world"",
    ""Hello bugs"",
    ""Goodbye world"",
    ""Goodbye bugs""
])
""""""
try to perform the following as a blocked computation in dask:
mat = cosine_similarity(tfidf, tfidf)
mat.shape 
###(4,4)
mat.ravel().shape
### (16,)
mat.ravel()
### array([1. , 0.5, 0.5, 0. , 0.5, 1. , 0. , 0.5, 0.5, 0. , 1. , 0.5, 0. , 0.5, 0.5, 1. ])
""""""

""""""perform the blockwise function in dask""""""
inputs = da.from_array([tfidf[:2,:], tfidf[2:,:]], chunks=(1))
mat = da.blockwise(
    (lambda x,y: cosine_similarity(x[0], y[0])), 'ij',
    inputs, 'i',
    inputs, 'j',
    dtype='f8',
    new_axes={0:4,1:4}
)

print(mat.compute().shape) 
### (4,4)

print(mat.compute().ravel().shape
### (16,)

mat.compute().ravel()
### array([1. , 0.5, 0.5, 0. , 0.5, 1. , 0. , 0.5, 0.5, 0. , 1. , 0.5, 0. , 0.5, 0.5, 1. ])

""""""So far so good, now perform the ravel in dask""""""

print(mat.shape) 
### (2, 2)

print(mat.ravel().shape)
### (4,)

mat.ravel().compute()
### ValueError: cannot reshape array of size 8 into shape (2,)
```

**Anything else we need to know?**: 

**Environment**: 

- Dask version: 2.18.0
- Python version: 3.6.9
- Operating System: MacOS Catalina 10.15.4
- Install method (conda, pip, source): pip
- sklearn version: 0.20.3",,https://api.github.com/repos/dask/dask/issues/6312/timeline,,,kortemaki,6666028,MDQ6VXNlcjY2NjYwMjg=,https://avatars.githubusercontent.com/u/6666028?v=4,,https://api.github.com/users/kortemaki,https://github.com/kortemaki,https://api.github.com/users/kortemaki/followers,https://api.github.com/users/kortemaki/following{/other_user},https://api.github.com/users/kortemaki/gists{/gist_id},https://api.github.com/users/kortemaki/starred{/owner}{/repo},https://api.github.com/users/kortemaki/subscriptions,https://api.github.com/users/kortemaki/orgs,https://api.github.com/users/kortemaki/repos,https://api.github.com/users/kortemaki/events{/privacy},https://api.github.com/users/kortemaki/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6312/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
312,https://api.github.com/repos/dask/dask/issues/6314,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6314/labels{/name},https://api.github.com/repos/dask/dask/issues/6314/comments,https://api.github.com/repos/dask/dask/issues/6314/events,https://github.com/dask/dask/issues/6314,637104146,MDU6SXNzdWU2MzcxMDQxNDY=,6314,Large Dataframe shuffle operations,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2020-06-11T15:18:36Z,2021-10-13T05:22:59Z,,MEMBER,,"Some dataframe operations require something like a full sort of the data.  This can be expensive for a variety of reasons.  This limits the scalability of Dask Dataframe to very large datasets.  These operations include:

1.  set_index
2.  groupby-apply
3.  join on a non-sorted column

Our current approach is to split every input partition into several pieces, move those pieces around to their final destination, and then merge them into output partitions.  In an unsorted input dataset every input partition will have something to contribute to most output partitions, so this is an `n**2` operation.  As the number of partitions increases this an become debilitating due to scheduler overhead.  

So for example if we have 1000 partitions then this might create 1,000,000 tasks, which if overhead is something like 1ms per task (an overetimate) then this would add 1000s of overhead (about 15 minutes) regardless of how large our cluster is.  

### Staging: Today's approach

Today we avoid this by staging communication.  We split things up not into 1000 little chunks, but into 30, and we do this a couple of times.  This results in `n * log_n` tasks and `log_n` full communications.  In our example above we would incur something like 30,000 + 30,000 tasks, or about 10s of overhead, but we would have to move our dataset around twice (which if you're on slow network can be troublesome)

What are some other approaches that we could take here?

See also
--------
-  A similar issue for Dask Array https://github.com/dask/dask/issues/3514
-  A plan for distributed shuffling service https://github.com/dask/dask/issues/6164
-  An approach to create tasks from tasks https://github.com/dask/distributed/pull/3879",,https://api.github.com/repos/dask/dask/issues/6314/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6314/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
313,https://api.github.com/repos/dask/dask/issues/6315,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6315/labels{/name},https://api.github.com/repos/dask/dask/issues/6315/comments,https://api.github.com/repos/dask/dask/issues/6315/events,https://github.com/dask/dask/issues/6315,637131367,MDU6SXNzdWU2MzcxMzEzNjc=,6315,FR: Add `Index.set_names()` from pandas.DataFrame,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2020-06-11T15:46:44Z,2020-06-22T11:26:18Z,,NONE,,"In pandas you can actually [`Index.set_names`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Index.set_names.html) of a `MultiIndex`, such as:

```
# l1s_per_minute is some pd.DataFrame with a MultiIndex. Goal: Setting the Index Names:
recover_ts_timeonly_cols = ['year', 'month', 'day', 'hour', 'minute']
l1s_per_minute.index.set_names(recover_ts_timeonly_cols, inplace=True)
```

while this method does not exists in `dask`:

```
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-21-f870324fbea6> in <module>
      6     # Recover ts_timeonly from indexes
      7     recover_ts_timeonly_cols = ['year', 'month', 'day', 'hour', 'minute']
----> 8     l1s_per_minute.index.set_names(recover_ts_timeonly_cols, inplace=True)
      9     l1s_per_minute = l1s_per_minute.reset_index()
     10 

~/.local/lib/python3.8/site-packages/dask/dataframe/core.py in __getattr__(self, key)
   3246         elif key in self._dt_attributes:
   3247             return getattr(self.dt, key)
-> 3248         raise AttributeError(""'Index' object has no attribute %r"" % key)
   3249 
   3250     def __dir__(self):

AttributeError: 'Index' object has no attribute 'set_names'
```

The reason for me, why I actually need to rename the `Indexes` is, that otherwise the `reset_index()` fails, because there are two Indexes with the same name (to be merged back from the Index site to the non-Index site - And there can be only one column on the non-Index side per name).
",,https://api.github.com/repos/dask/dask/issues/6315/timeline,,,cgi1,18695252,MDQ6VXNlcjE4Njk1MjUy,https://avatars.githubusercontent.com/u/18695252?v=4,,https://api.github.com/users/cgi1,https://github.com/cgi1,https://api.github.com/users/cgi1/followers,https://api.github.com/users/cgi1/following{/other_user},https://api.github.com/users/cgi1/gists{/gist_id},https://api.github.com/users/cgi1/starred{/owner}{/repo},https://api.github.com/users/cgi1/subscriptions,https://api.github.com/users/cgi1/orgs,https://api.github.com/users/cgi1/repos,https://api.github.com/users/cgi1/events{/privacy},https://api.github.com/users/cgi1/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6315/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
314,https://api.github.com/repos/dask/dask/issues/6316,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6316/labels{/name},https://api.github.com/repos/dask/dask/issues/6316/comments,https://api.github.com/repos/dask/dask/issues/6316/events,https://github.com/dask/dask/issues/6316,637176297,MDU6SXNzdWU2MzcxNzYyOTc=,6316,Infer shuffle='disk' for the DataFrame.set_index method when using a LocalCluster,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,10,2020-06-11T16:53:43Z,2020-09-29T13:47:26Z,,NONE,,"The documentation for the shuffle parameter in the dask.DataFrame.set_index method says:
- ""Either 'disk' for single-node operation or 'tasks' for distributed operation. Will be inferred by your current scheduler.""  

Currently, `tasks` is inferred when using the distributed scheduler regardless of cluster type.  However, given that the distributed scheduler is frequently used in a single machine context via LocalCluster, it seems like it would make sense to infer `shuffle='disk'` when used with a LocalCluster.  If that's not ideal for some reason, perhaps the dask.DataFrame.shuffle parameter documentation could be amended to say something like:
- ""Either 'disk' for single-node operation or 'tasks' for distributed operation. Will be inferred by your current scheduler.  It is recommended to use 'disk'  when using LocalCluster""  

My understanding is you wouldn't want to use `dd.DataFrame.set_index(df, shuffle='tasks')` when using LocalCluster, due to the high memory usage so this would make the default setting for this parameter more appropriate in the case when a LocalCluster is being used.",,https://api.github.com/repos/dask/dask/issues/6316/timeline,,,Adam-D-Lewis,23342526,MDQ6VXNlcjIzMzQyNTI2,https://avatars.githubusercontent.com/u/23342526?v=4,,https://api.github.com/users/Adam-D-Lewis,https://github.com/Adam-D-Lewis,https://api.github.com/users/Adam-D-Lewis/followers,https://api.github.com/users/Adam-D-Lewis/following{/other_user},https://api.github.com/users/Adam-D-Lewis/gists{/gist_id},https://api.github.com/users/Adam-D-Lewis/starred{/owner}{/repo},https://api.github.com/users/Adam-D-Lewis/subscriptions,https://api.github.com/users/Adam-D-Lewis/orgs,https://api.github.com/users/Adam-D-Lewis/repos,https://api.github.com/users/Adam-D-Lewis/events{/privacy},https://api.github.com/users/Adam-D-Lewis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6316/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
315,https://api.github.com/repos/dask/dask/issues/6324,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6324/labels{/name},https://api.github.com/repos/dask/dask/issues/6324/comments,https://api.github.com/repos/dask/dask/issues/6324/events,https://github.com/dask/dask/pull/6324,639022072,MDExOlB1bGxSZXF1ZXN0NDM0Njc4MTc5,6324,Define __tracebackhide__ in assert_eq,[],open,False,,[],,3,2020-06-15T17:35:10Z,2021-03-08T20:19:44Z,,MEMBER,,"Defines `__tracebackhide__` in assert_eq for nicer results.
https://docs.pytest.org/en/latest/example/simple.html

With this, it's more important that the messages in the assert are more
meaningful, since the context is hidden. I've done just a bit, but there's
room for improvement.

New

```pytb
________________________________________________________________________ test_array ________________________________________________________________________

    def test_array():
        a = da.ones((4, 4), chunks=(2, 2))
        b = np.zeros((5, 5))
>       da.utils.assert_eq(a, b)
E       AssertionError: ((4, 4), (5, 5))

test_foo.py:10: AssertionError
________________________________________________________________________ test_frame ________________________________________________________________________

    def test_frame():
        a = dd.from_pandas(pd.DataFrame({""A"": [1, 2, 2]}), 2)
        b = pd.DataFrame({""A"": [1, 2, 3]})
>       dd.utils.assert_eq(a, b)

test_foo.py:16:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
pandas/_libs/testing.pyx:68: in pandas._libs.testing.assert_almost_equal
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   AssertionError: DataFrame.iloc[:, 0] (column name=""A"") are different
E
E   DataFrame.iloc[:, 0] (column name=""A"") values are different (33.33333 %)
E   [index]: [0, 1, 2]
E   [left]:  [1, 2, 2]
E   [right]: [1, 2, 3]

pandas/_libs/testing.pyx:183: AssertionError
```

old:

```pytb
________________________________________________________________________ test_array ________________________________________________________________________

    def test_array():
        a = da.ones((4, 4), chunks=(2, 2))
        b = np.zeros((5, 5))
>       da.utils.assert_eq(a, b)

test_foo.py:10:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

a = array([[1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.]])
b = array([[0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.]])
check_shape = True, check_graph = True, check_meta = True, kwargs = {}
a_original = dask.array<ones, shape=(4, 4), dtype=float64, chunksize=(2, 2), chunktype=numpy.ndarray>
b_original = array([[0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.]])
adt = dtype('float64'), a_meta = array([], shape=(0, 0), dtype=float64)
a_computed = array([[1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.]]), bdt = dtype('float64'), b_meta = None

    def assert_eq(a, b, check_shape=True, check_graph=True, check_meta=True, **kwargs):
        a_original = a
        b_original = b

        a, adt, a_meta, a_computed = _get_dt_meta_computed(
            a, check_shape=check_shape, check_graph=check_graph
        )
        b, bdt, b_meta, b_computed = _get_dt_meta_computed(
            b, check_shape=check_shape, check_graph=check_graph
        )

        if str(adt) != str(bdt):
            # Ignore check for matching length of flexible dtypes, since Array._meta
            # can't encode that information
            if adt.type == bdt.type and not (adt.type == np.bytes_ or adt.type == np.str_):
                diff = difflib.ndiff(str(adt).splitlines(), str(bdt).splitlines())
                raise AssertionError(
                    ""string repr are different"" + os.linesep + os.linesep.join(diff)
                )

        try:
>           assert a.shape == b.shape
E           AssertionError

dask/array/utils.py:246: AssertionError
________________________________________________________________________ test_frame ________________________________________________________________________

    def test_frame():
        a = dd.from_pandas(pd.DataFrame({""A"": [1, 2, 2]}), 2)
        b = pd.DataFrame({""A"": [1, 2, 3]})
>       dd.utils.assert_eq(a, b)

test_foo.py:16:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
dask/dataframe/utils.py:813: in assert_eq
    tm.assert_frame_equal(a, b, **kwargs)
pandas/_libs/testing.pyx:68: in pandas._libs.testing.assert_almost_equal
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   AssertionError: DataFrame.iloc[:, 0] (column name=""A"") are different
E
E   DataFrame.iloc[:, 0] (column name=""A"") values are different (33.33333 %)
E   [index]: [0, 1, 2]
E   [left]:  [1, 2, 2]
E   [right]: [1, 2, 3]

pandas/_libs/testing.pyx:183: AssertionError
```

- [ ] Tests added / passed
- [ ] Passes `black dask` / `flake8 dask`
",,https://api.github.com/repos/dask/dask/issues/6324/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6324/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6324,https://github.com/dask/dask/pull/6324,https://github.com/dask/dask/pull/6324.diff,https://github.com/dask/dask/pull/6324.patch,,,,,,,,,,,,,,,,,,,
316,https://api.github.com/repos/dask/dask/issues/6329,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6329/labels{/name},https://api.github.com/repos/dask/dask/issues/6329/comments,https://api.github.com/repos/dask/dask/issues/6329/events,https://github.com/dask/dask/issues/6329,640119665,MDU6SXNzdWU2NDAxMTk2NjU=,6329,add mode example to custom aggregation,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,6,2020-06-17T03:53:38Z,2024-01-03T08:25:12Z,,MEMBER,,"There's an example of a mode custom aggregation on SO https://stackoverflow.com/a/46082075/6046019

Do you think it would be of benefit to add it the docs as another example at the bottom of https://docs.dask.org/en/latest/dataframe-groupby.html#aggregate?",,https://api.github.com/repos/dask/dask/issues/6329/timeline,,,raybellwaves,17162724,MDQ6VXNlcjE3MTYyNzI0,https://avatars.githubusercontent.com/u/17162724?v=4,,https://api.github.com/users/raybellwaves,https://github.com/raybellwaves,https://api.github.com/users/raybellwaves/followers,https://api.github.com/users/raybellwaves/following{/other_user},https://api.github.com/users/raybellwaves/gists{/gist_id},https://api.github.com/users/raybellwaves/starred{/owner}{/repo},https://api.github.com/users/raybellwaves/subscriptions,https://api.github.com/users/raybellwaves/orgs,https://api.github.com/users/raybellwaves/repos,https://api.github.com/users/raybellwaves/events{/privacy},https://api.github.com/users/raybellwaves/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6329/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
317,https://api.github.com/repos/dask/dask/issues/6332,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6332/labels{/name},https://api.github.com/repos/dask/dask/issues/6332/comments,https://api.github.com/repos/dask/dask/issues/6332/events,https://github.com/dask/dask/issues/6332,641099056,MDU6SXNzdWU2NDEwOTkwNTY=,6332,Add file name and line number caller info to diagnostics,[],open,False,,[],,6,2020-06-18T10:35:43Z,2021-10-13T05:16:23Z,,MEMBER,,"When profiling large task graphs it can be difficult to tell which tasks correspond to which function calls in the user's code. The function name is fairly generic (e.g. ""sum-aggregate"") and often not enough to tie down the originating call.

It would be useful to add caller information like the filename and line number to the task information, so it can be displayed in the web interface. Caller information should also be retrievable in diagnostics code, such as callbacks: https://docs.dask.org/en/latest/diagnostics-local.html#custom-callbacks.

Implementation-wise I think there are two parts: 1. where in Dask do we capture the call stack? 2. where do we store it so it's accessible in diagnostics code?",,https://api.github.com/repos/dask/dask/issues/6332/timeline,,,tomwhite,85085,MDQ6VXNlcjg1MDg1,https://avatars.githubusercontent.com/u/85085?v=4,,https://api.github.com/users/tomwhite,https://github.com/tomwhite,https://api.github.com/users/tomwhite/followers,https://api.github.com/users/tomwhite/following{/other_user},https://api.github.com/users/tomwhite/gists{/gist_id},https://api.github.com/users/tomwhite/starred{/owner}{/repo},https://api.github.com/users/tomwhite/subscriptions,https://api.github.com/users/tomwhite/orgs,https://api.github.com/users/tomwhite/repos,https://api.github.com/users/tomwhite/events{/privacy},https://api.github.com/users/tomwhite/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6332/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
318,https://api.github.com/repos/dask/dask/issues/6333,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6333/labels{/name},https://api.github.com/repos/dask/dask/issues/6333/comments,https://api.github.com/repos/dask/dask/issues/6333/events,https://github.com/dask/dask/issues/6333,641138840,MDU6SXNzdWU2NDExMzg4NDA=,6333,fromfunction signature is incompatible with numpy,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2020-06-18T11:41:39Z,2020-06-18T11:58:40Z,,NONE,,"**What happened**:
Calling `dask.array.fromfunction` with the shape as a positional argument fails.

**What you expected to happen**:
`da.fromfunction` should be callable with the same arguments as `np.fromfunction`.

**Minimal Complete Verifiable Example**:

```python
import dask.array as da
da.fromfunction(lambda i, j: j <= i, (4, 4))
```

<details>
<summary>Traceback</summary>

```python
In [3]: da.fromfunction(lambda i, j: j <= i + k, (4, 4))                                      
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-3-8c1a2e18442d> in <module>
----> 1 da.fromfunction(lambda i, j: j <= i + k, (4, 4))

~/miniconda3/envs/uarray-dev/lib/python3.7/site-packages/dask/array/creation.py in fromfunction(func, chunks, shape, dtype, **kwargs)
    731 @derived_from(np)
    732 def fromfunction(func, chunks=""auto"", shape=None, dtype=None, **kwargs):
--> 733     chunks = normalize_chunks(chunks, shape, dtype=dtype)
    734     name = ""fromfunction-"" + tokenize(func, chunks, shape, dtype, kwargs)
    735     keys = product([name], *(range(len(bd)) for bd in chunks))

~/miniconda3/envs/uarray-dev/lib/python3.7/site-packages/dask/array/core.py in normalize_chunks(chunks, shape, limit, dtype, previous_chunks)
   2503             )
   2504 
-> 2505     return tuple(tuple(int(x) if not math.isnan(x) else x for x in c) for c in chunks)
   2506 
   2507 

~/miniconda3/envs/uarray-dev/lib/python3.7/site-packages/dask/array/core.py in <genexpr>(.0)
   2503             )
   2504 
-> 2505     return tuple(tuple(int(x) if not math.isnan(x) else x for x in c) for c in chunks)
   2506 
   2507 

TypeError: 'int' object is not iterable
```

</details>

**Anything else we need to know?**:

It looks like the `chunks` argument has been moved ahead of the `shape` argument.
https://github.com/dask/dask/blob/149abe507a3988073a9acc9d5b8483f44c747f6b/dask/array/creation.py#L772

**Environment**:

- Dask version: 2.17.2
- Python version: 3.7
- Operating System: Ubuntu 20.04
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/6333/timeline,,,peterbell10,13238737,MDQ6VXNlcjEzMjM4NzM3,https://avatars.githubusercontent.com/u/13238737?v=4,,https://api.github.com/users/peterbell10,https://github.com/peterbell10,https://api.github.com/users/peterbell10/followers,https://api.github.com/users/peterbell10/following{/other_user},https://api.github.com/users/peterbell10/gists{/gist_id},https://api.github.com/users/peterbell10/starred{/owner}{/repo},https://api.github.com/users/peterbell10/subscriptions,https://api.github.com/users/peterbell10/orgs,https://api.github.com/users/peterbell10/repos,https://api.github.com/users/peterbell10/events{/privacy},https://api.github.com/users/peterbell10/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6333/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
319,https://api.github.com/repos/dask/dask/issues/6341,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6341/labels{/name},https://api.github.com/repos/dask/dask/issues/6341/comments,https://api.github.com/repos/dask/dask/issues/6341/events,https://github.com/dask/dask/issues/6341,643979102,MDU6SXNzdWU2NDM5NzkxMDI=,6341,Carry parquet getitem optimization over certain operations,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,0,2020-06-23T16:25:54Z,2021-10-13T04:54:13Z,,MEMBER,,"We currently take operations like

```python
df = pd.read_parquet('path/to/dataset.parquet')
df[['A', 'B']]
```

and rewrite them as

```python
df = pd.read_parquet(""/path/to/dataset.parquet"", columns=['A', 'B'])
```

However, if the computation contains any other steps the optimization is lost. For example, this computation needs to read at most the column A

```python
df = pd.read_parquet(""/path/to/dataset.parquet"")
df2 = df[df.A == 1]
len(df2)
```

So that would ideally be rewritten as

```python
df = pd.read_parquet(""/path/to/dataset.parquet"", columns=['A'])
df2 = df[df.A == 1]
len(df2)
```

(this is independent of the optimization in https://github.com/dask/dask/pull/6261, which would filter *rows* rather than columns).

To solve this issue, we need to

1. identify operations that it's *safe* to carry the column selection over.
2. Rewrite the parquet getitem optimization to not bail out when the graph contains just these ""safe"" operations.

cc @martindurant @dankerrigan @gforsyth.",,https://api.github.com/repos/dask/dask/issues/6341/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6341/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
320,https://api.github.com/repos/dask/dask/issues/6344,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6344/labels{/name},https://api.github.com/repos/dask/dask/issues/6344/comments,https://api.github.com/repos/dask/dask/issues/6344/events,https://github.com/dask/dask/pull/6344,644725996,MDExOlB1bGxSZXF1ZXN0NDM5Mjk4MTA5,6344,Added set_names to dask Index.,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,6,2020-06-24T15:53:32Z,2021-10-13T14:52:17Z,,FIRST_TIME_CONTRIBUTOR,,"This PR is related to issue  #6315.
It aims to add `set_names` method to Dask Index.

- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask`
",,https://api.github.com/repos/dask/dask/issues/6344/timeline,,,matheper,1433862,MDQ6VXNlcjE0MzM4NjI=,https://avatars.githubusercontent.com/u/1433862?v=4,,https://api.github.com/users/matheper,https://github.com/matheper,https://api.github.com/users/matheper/followers,https://api.github.com/users/matheper/following{/other_user},https://api.github.com/users/matheper/gists{/gist_id},https://api.github.com/users/matheper/starred{/owner}{/repo},https://api.github.com/users/matheper/subscriptions,https://api.github.com/users/matheper/orgs,https://api.github.com/users/matheper/repos,https://api.github.com/users/matheper/events{/privacy},https://api.github.com/users/matheper/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6344/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6344,https://github.com/dask/dask/pull/6344,https://github.com/dask/dask/pull/6344.diff,https://github.com/dask/dask/pull/6344.patch,,,,,,,,,,,,,,,,,,,
321,https://api.github.com/repos/dask/dask/issues/6352,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6352/labels{/name},https://api.github.com/repos/dask/dask/issues/6352/comments,https://api.github.com/repos/dask/dask/issues/6352/events,https://github.com/dask/dask/issues/6352,646968513,MDU6SXNzdWU2NDY5Njg1MTM=,6352,Compress collections,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,5,2020-06-28T17:19:51Z,2020-06-29T08:21:40Z,,MEMBER,,"With dask array and dask dataframe I find myself often wanting to store in-memory data in some other format than numpy arrays or pandas dataframes.

Two examples:

1.  With low-entropy data or low-bitcount data I want to store numpy arrays as Zarr arrays in memory
2.  With text data in Pandas I want to store Pandas dataframes as Arrow tables (here is a [notebook](https://gist.github.com/e0e3b4a468c17160c8ae6dc6b4bac651) (cc @wesm if you're interested))

There are two ways that we can do this:

1.  We can have Dask workers transform data by default when they start experiencing memory pressure.  This is the topic of https://github.com/dask/distributed/issues/3656
2.  We can have users opt-in to an alternative format when persisting their data, maybe something like the following:

    ```python
    df = df.persist(format=""arrow"")
    x = x.persist(format=""zarr"", format_options={""compressor"": ""blosc""})
    ```

Both of these seem useful sometimes, but also open us up to confusion in the future.",,https://api.github.com/repos/dask/dask/issues/6352/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6352/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
322,https://api.github.com/repos/dask/dask/issues/6354,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6354/labels{/name},https://api.github.com/repos/dask/dask/issues/6354/comments,https://api.github.com/repos/dask/dask/issues/6354/events,https://github.com/dask/dask/issues/6354,647569964,MDU6SXNzdWU2NDc1Njk5NjQ=,6354,Cannot compute min or max of dates in dask array when converted from dask dataframe using to_dask_array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,17,2020-06-29T18:13:04Z,2024-04-11T11:19:14Z,,CONTRIBUTOR,,"**What happened**:

Computing the minimum date from a dask array causes an exception to be thrown. That dask array was converted from a dask dataframe using `to_dask_array`.

**What you expected to happen**:

I expected to be able to compute the minimum date from the dask array. 

**Minimal Complete Verifiable Example**:

using `to_dask_array` raises an exception
```python
import pandas as pd
from datetime import date
import dask.dataframe as dd

dates_df = pd.Series(pd.date_range(date(2014,1,1),date(2015,1,1), freq=""M""))
dates_dd = dd.from_pandas(dates_df, npartitions=1)

dates_da = dates_dd.to_dask_array()
print(dates_da.min().compute())
```
`UFuncTypeError: ufunc 'add' cannot use operands with types dtype('<M8[ns]') and dtype('<M8[ns]')`

Using `from_array` works as expected
```python
import pandas as pd
from datetime import date
import dask.dataframe as dd

dates_df = pd.Series(pd.date_range(date(2014,1,1),date(2015,1,1), freq=""M""))

dates_da = dd.from_array(dates_df.values)
print(dates_da.min().compute())
```
`2014-01-31 00:00:00`

**Environment**:

- Dask version: 2.16.0
- Python version: 3.7.6
- Operating System: macOS Catalina 10.15.5
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/6354/timeline,,,kylejn27,7997504,MDQ6VXNlcjc5OTc1MDQ=,https://avatars.githubusercontent.com/u/7997504?v=4,,https://api.github.com/users/kylejn27,https://github.com/kylejn27,https://api.github.com/users/kylejn27/followers,https://api.github.com/users/kylejn27/following{/other_user},https://api.github.com/users/kylejn27/gists{/gist_id},https://api.github.com/users/kylejn27/starred{/owner}{/repo},https://api.github.com/users/kylejn27/subscriptions,https://api.github.com/users/kylejn27/orgs,https://api.github.com/users/kylejn27/repos,https://api.github.com/users/kylejn27/events{/privacy},https://api.github.com/users/kylejn27/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6354/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
323,https://api.github.com/repos/dask/dask/issues/6363,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6363/labels{/name},https://api.github.com/repos/dask/dask/issues/6363/comments,https://api.github.com/repos/dask/dask/issues/6363/events,https://github.com/dask/dask/issues/6363,649492589,MDU6SXNzdWU2NDk0OTI1ODk=,6363,Loading metadata slow for zarr archives with many objects stored in GCS,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,6,2020-07-02T01:20:14Z,2021-10-13T06:46:33Z,,NONE,,"<!-- Please do a quick search of existing issues to make sure that this has not been asked before. -->

I'm not sure if this topic would be more related to dask, zarr or xarray, apologies if this is not the correct place to post it.

Loading metadata / coordinates from a zarr archive (stored on GCS) with xarray to build a dask array could take relatively long for archives with large number of objects. As an example, below is part of the profiling output from loading a dask array (from the same GCS region) from an archive with around 5e6 objects. The most costly calls are those 40 calls (1 per data variable in the dataset) to [dask.array.core.slices_from_chunks](https://github.com/dask/dask/blob/master/dask/array/core.py#L168) and [dask.array.core.getem](https://github.com/dask/dask/blob/master/dask/array/core.py#L187) functions.

The total time in these calls usually vary between 5 and 20 sec for this dataset. These times can be greatly reduced (to be sub-second) by decreasing the overall number of objects in the archive (by increasing the chunk sizes). My question is whether these loading times need to scale with the number of objects in the zarr store, considering the metadata are consolidated and the actual coordinate variables are stored in one single chunk.

Thanks

```
         545613 function calls (538362 primitive calls) in 10.786 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
       40    3.694    0.092    3.715    0.093 /usr/local/lib/python3.8/dist-packages/dask/array/core.py:168(slices_from_chunks)
       40    3.163    0.079    3.163    0.079 /usr/local/lib/python3.8/dist-packages/dask/array/core.py:224(<listcomp>)
       40    1.928    0.048    8.827    0.221 /usr/local/lib/python3.8/dist-packages/dask/array/core.py:187(getem)
       93    1.408    0.015    1.408    0.015 {built-in method _openssl.SSL_read}
       40    0.103    0.003    8.986    0.225 /usr/local/lib/python3.8/dist-packages/dask/array/core.py:2670(from_array)
        3    0.064    0.021    0.065    0.022 /usr/local/lib/python3.8/dist-packages/zarr/core.py:1734(_decode_chunk)
      275    0.025    0.000    0.025    0.000 {built-in method marshal.loads}
       14    0.017    0.001    0.017    0.001 {method 'reduce' of 'numpy.ufunc' objects}
    86463    0.015    0.000    0.021    0.000 /usr/local/lib/python3.8/dist-packages/toolz/itertoolz.py:31(accumulate)
      669    0.010    0.000    0.023    0.000 {built-in method builtins.__build_class__}
```",,https://api.github.com/repos/dask/dask/issues/6363/timeline,,,rafa-guedes,7799184,MDQ6VXNlcjc3OTkxODQ=,https://avatars.githubusercontent.com/u/7799184?v=4,,https://api.github.com/users/rafa-guedes,https://github.com/rafa-guedes,https://api.github.com/users/rafa-guedes/followers,https://api.github.com/users/rafa-guedes/following{/other_user},https://api.github.com/users/rafa-guedes/gists{/gist_id},https://api.github.com/users/rafa-guedes/starred{/owner}{/repo},https://api.github.com/users/rafa-guedes/subscriptions,https://api.github.com/users/rafa-guedes/orgs,https://api.github.com/users/rafa-guedes/repos,https://api.github.com/users/rafa-guedes/events{/privacy},https://api.github.com/users/rafa-guedes/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6363/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
324,https://api.github.com/repos/dask/dask/issues/6380,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6380/labels{/name},https://api.github.com/repos/dask/dask/issues/6380/comments,https://api.github.com/repos/dask/dask/issues/6380/events,https://github.com/dask/dask/issues/6380,653673583,MDU6SXNzdWU2NTM2NzM1ODM=,6380,First class Future object,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,3,2020-07-09T00:18:32Z,2021-10-13T06:40:12Z,,MEMBER,,"Currently with Distributed we have [`Future`s]( https://distributed.dask.org/en/latest/api.html#future ) in that context. However there doesn't exist a first class `Future` object within Dask itself. It would be useful to have a first class `Future` object within Dask. This would enable a wider set of algorithms and provided some needed flexibility for various problems people run into today.

First having a `Future` object would be useful in cases where we want to submit some work to start and then construct later operations with the knowledge that these results will soon become available (one example might be writing these to disk). Second this can be a useful way to prioritize elements of a workflow where we know what we want to prioritize (like working with large chunks of memory first). Third can help in cases where we want to interleave work between subtasks (recentering, normalizing, binning, etc.). Fourth this can be useful when the results of tasks are needed to more informatively generate new work (working with unknown chunks, selection based on data values, etc.). Fifth this can be a useful way of cutting down on large task graph handling issues (this is something other distributed libraries use https://github.com/dask/dask/issues/3514#issuecomment-390502785 ). Sixth use cases that involve some form of iteration where the intermediate result needs to be checked to see if the task is done. There may be more ways this functionality could be used, but hopefully this provides some ideas on where/how it might help.

Additionally have gone through the issue tracker and identified issues/cases where this would either solve or help solve the underlying problem. This is not necessarily comprehensive. Also some issues may require more work on top of this. However in all cases this seems to provide a meaningful base to build on. Here's the list:

* https://github.com/dask/dask/issues/874
* https://github.com/dask/dask/issues/1519
* https://github.com/dask/dask/issues/2156 (at least practically)
* https://github.com/dask/dask/issues/3074 (useful for)
* https://github.com/dask/dask/issues/3255 (useful for)
* https://github.com/dask/dask/issues/3514
* https://github.com/dask/dask/issues/3587#issuecomment-396729211
* https://github.com/dask/dask/issues/3595#issuecomment-396971956
* https://github.com/dask/dask/issues/4156 (useful for)
* https://github.com/dask/dask/issues/4149 (useful for)
* https://github.com/dask/dask/issues/4544

Note this likely (though happy to be proven wrong) depends on moving to `concurrent.futures` as documented in issue ( https://github.com/dask/dask/issues/6220 ). May also need `secede` from PR ( https://github.com/dask/distributed/pull/471 ) and `rejoin` from PR ( https://github.com/dask/distributed/pull/1462 ).",,https://api.github.com/repos/dask/dask/issues/6380/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6380/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
325,https://api.github.com/repos/dask/dask/issues/6385,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6385/labels{/name},https://api.github.com/repos/dask/dask/issues/6385/comments,https://api.github.com/repos/dask/dask/issues/6385/events,https://github.com/dask/dask/issues/6385,654043957,MDU6SXNzdWU2NTQwNDM5NTc=,6385,"What should define a ""duck Dask Array""?","[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,11,2020-07-09T13:03:36Z,2021-10-13T05:52:11Z,,CONTRIBUTOR,,"As a part of supporting units with Dask in xarray, [work is being undertaken](https://github.com/hgrecco/pint/pull/1129) to implement the Dask collections interface on Pint Quantities to allow them to act as a ""duck Dask Array"" or ""Dask Array-like"" so that xarray can perform all its usual Dask-related functionality with a Pint Quantity in-between the xarray data structure and Dask Array (since, in the [generally accepted typecasting heirachy](https://pint.readthedocs.io/en/latest/numpy.html#Technical-Commentary), xarray wraps Pint and Pint wraps Dask, which allows for unit calculation at the construction rather than compute step). 

Given that most if not all of xarray's current Dask support is special cased based on checking for instances of Dask Arrays, the question that has arisen is [how should xarray check for a duck Dask Array](https://github.com/pydata/xarray/issues/4208)? @crusaderky [suggested](https://github.com/pydata/xarray/issues/4208#issuecomment-656068407) asking the Dask team for a formalized answer that xarray (and really any other library that would have types above Dask Array on the type casting hierarchy) could implement, so I wish to do so here.

Ideas that have been brought up in https://github.com/pydata/xarray/issues/4208 and other past xarray/pint issues include
- [having a non-None `chunks` attribute](https://github.com/pydata/xarray/issues/4208#issuecomment-655810311)
- [numpy-array-like AND has a chunks method AND the chunks method returns a tuple](https://github.com/pydata/xarray/issues/4208#issuecomment-656068407)
- [Having specifically `__array_function__` and `__dask_graph__`](https://github.com/pydata/xarray/issues/525#issuecomment-531603357)
- Having some amount of the Dask collection interface dunder methods (https://github.com/pydata/xarray/issues/4208#issuecomment-655820797, https://github.com/hgrecco/pint/issues/883#issuecomment-531691097)

xref https://github.com/pydata/xarray/issues/4208

cc @shoyer, @crusaderky, @keewis, @rpmanser",,https://api.github.com/repos/dask/dask/issues/6385/timeline,,,jthielen,3460034,MDQ6VXNlcjM0NjAwMzQ=,https://avatars.githubusercontent.com/u/3460034?v=4,,https://api.github.com/users/jthielen,https://github.com/jthielen,https://api.github.com/users/jthielen/followers,https://api.github.com/users/jthielen/following{/other_user},https://api.github.com/users/jthielen/gists{/gist_id},https://api.github.com/users/jthielen/starred{/owner}{/repo},https://api.github.com/users/jthielen/subscriptions,https://api.github.com/users/jthielen/orgs,https://api.github.com/users/jthielen/repos,https://api.github.com/users/jthielen/events{/privacy},https://api.github.com/users/jthielen/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6385/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
326,https://api.github.com/repos/dask/dask/issues/6386,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6386/labels{/name},https://api.github.com/repos/dask/dask/issues/6386/comments,https://api.github.com/repos/dask/dask/issues/6386/events,https://github.com/dask/dask/issues/6386,654208166,MDU6SXNzdWU2NTQyMDgxNjY=,6386,[DOC] Add docstring for split_out and split_every in dask groupby-aggregate API,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,3,2020-07-09T16:52:25Z,2021-10-13T06:39:08Z,,MEMBER,,"I think it might be helpful to add docstrings for `split_out` and `split_every` in the  dask groupby-aggregate API

We can probably add something 
```python
`split_out`:  Number of output results in group-by like aggergations (defaults to 1)
```
And use below for `split_every`
https://github.com/dask/dask/blob/9968a49bb4e9ae03d29110bbc5a41a4179636ab8/dask/array/reductions.py#L82-L93

Happy to do a pr if `split_every's` docstring above is correct  for group-by and we feel it's fine to add both in places where `split_every/split_out` is present. ",,https://api.github.com/repos/dask/dask/issues/6386/timeline,,,VibhuJawa,4837571,MDQ6VXNlcjQ4Mzc1NzE=,https://avatars.githubusercontent.com/u/4837571?v=4,,https://api.github.com/users/VibhuJawa,https://github.com/VibhuJawa,https://api.github.com/users/VibhuJawa/followers,https://api.github.com/users/VibhuJawa/following{/other_user},https://api.github.com/users/VibhuJawa/gists{/gist_id},https://api.github.com/users/VibhuJawa/starred{/owner}{/repo},https://api.github.com/users/VibhuJawa/subscriptions,https://api.github.com/users/VibhuJawa/orgs,https://api.github.com/users/VibhuJawa/repos,https://api.github.com/users/VibhuJawa/events{/privacy},https://api.github.com/users/VibhuJawa/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6386/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
327,https://api.github.com/repos/dask/dask/issues/6387,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6387/labels{/name},https://api.github.com/repos/dask/dask/issues/6387/comments,https://api.github.com/repos/dask/dask/issues/6387/events,https://github.com/dask/dask/issues/6387,654304819,MDU6SXNzdWU2NTQzMDQ4MTk=,6387,Use parquet metadata to get length,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,2,2020-07-09T19:44:29Z,2022-03-24T21:26:56Z,,MEMBER,,"`len(df)` is often the first thing that a user does when opening a new dataset. This value is stored in the global metadata (if it exists) and stored in the footers of each file in the dataset - and therefore should require no actual data loading. The length could also be found after filtering, if that filtering is applied partition-wise (e.g., a condition on one of the columns inferred from the directory structure).

Obviously, such an enhancement would have *no benefit* after any filtering (or merge, etc.) that depends on the data itself and is only useful as far as the row count can ever be useful.",,https://api.github.com/repos/dask/dask/issues/6387/timeline,,,martindurant,6042212,MDQ6VXNlcjYwNDIyMTI=,https://avatars.githubusercontent.com/u/6042212?v=4,,https://api.github.com/users/martindurant,https://github.com/martindurant,https://api.github.com/users/martindurant/followers,https://api.github.com/users/martindurant/following{/other_user},https://api.github.com/users/martindurant/gists{/gist_id},https://api.github.com/users/martindurant/starred{/owner}{/repo},https://api.github.com/users/martindurant/subscriptions,https://api.github.com/users/martindurant/orgs,https://api.github.com/users/martindurant/repos,https://api.github.com/users/martindurant/events{/privacy},https://api.github.com/users/martindurant/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6387/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
328,https://api.github.com/repos/dask/dask/issues/6388,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6388/labels{/name},https://api.github.com/repos/dask/dask/issues/6388/comments,https://api.github.com/repos/dask/dask/issues/6388/events,https://github.com/dask/dask/issues/6388,654307111,MDU6SXNzdWU2NTQzMDcxMTE=,6388,"When combining complex column selections on dataframes, join the selection and push down","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2020-07-09T19:48:48Z,2021-08-02T16:57:46Z,,MEMBER,,"We already have an example of column selection pushdown for loading columns from parquet.
- However, this selection fails for something complex like `df.col[df.x > 0 & df.y < 100 & df.y > 0]` which should only read three of the source columns, not all of them.
- We don't do this for other data types where it may be useful (CSV somewhat, ORC definitely, SQL yes but hard - others?)",,https://api.github.com/repos/dask/dask/issues/6388/timeline,,,martindurant,6042212,MDQ6VXNlcjYwNDIyMTI=,https://avatars.githubusercontent.com/u/6042212?v=4,,https://api.github.com/users/martindurant,https://github.com/martindurant,https://api.github.com/users/martindurant/followers,https://api.github.com/users/martindurant/following{/other_user},https://api.github.com/users/martindurant/gists{/gist_id},https://api.github.com/users/martindurant/starred{/owner}{/repo},https://api.github.com/users/martindurant/subscriptions,https://api.github.com/users/martindurant/orgs,https://api.github.com/users/martindurant/repos,https://api.github.com/users/martindurant/events{/privacy},https://api.github.com/users/martindurant/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6388/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
329,https://api.github.com/repos/dask/dask/issues/6400,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6400/labels{/name},https://api.github.com/repos/dask/dask/issues/6400/comments,https://api.github.com/repos/dask/dask/issues/6400/events,https://github.com/dask/dask/issues/6400,655240644,MDU6SXNzdWU2NTUyNDA2NDQ=,6400,HDFS remote data source refers to deprecated API,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,1,2020-07-11T16:43:40Z,2021-10-13T05:52:45Z,,CONTRIBUTOR,,"[Documentation regarding the HDFS integration](https://docs.dask.org/en/latest/remote-data-services.html#hadoop-file-system) appears to be using a now deprecated version of the [HDFS API for authentication](https://arrow.apache.org/docs/python/filesystems_deprecated.html#hadoop-file-system-hdfs): note the new API does not provide a `user` argument so I _guess_ the auth functionality may be different/more restrictive (possibly Kerberos only?) 

The documentation is obviously requiring reworking to depict this (I've fixed the link to point at the deprecated interface) but thought it might need review depending on how this component is implemented within dask itself, to remove support for the old API or allow usage of both depending on the integration requirements. 

Happy to look into it after I've finished my documentation review :-)",,https://api.github.com/repos/dask/dask/issues/6400/timeline,,,JimCircadian,731727,MDQ6VXNlcjczMTcyNw==,https://avatars.githubusercontent.com/u/731727?v=4,,https://api.github.com/users/JimCircadian,https://github.com/JimCircadian,https://api.github.com/users/JimCircadian/followers,https://api.github.com/users/JimCircadian/following{/other_user},https://api.github.com/users/JimCircadian/gists{/gist_id},https://api.github.com/users/JimCircadian/starred{/owner}{/repo},https://api.github.com/users/JimCircadian/subscriptions,https://api.github.com/users/JimCircadian/orgs,https://api.github.com/users/JimCircadian/repos,https://api.github.com/users/JimCircadian/events{/privacy},https://api.github.com/users/JimCircadian/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6400/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
330,https://api.github.com/repos/dask/dask/issues/6405,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6405/labels{/name},https://api.github.com/repos/dask/dask/issues/6405/comments,https://api.github.com/repos/dask/dask/issues/6405/events,https://github.com/dask/dask/pull/6405,655264338,MDExOlB1bGxSZXF1ZXN0NDQ3ODA2NTM3,6405,Allow the deferral of array.to_hdf5,[],open,False,,[],,6,2020-07-11T19:19:25Z,2021-09-27T15:24:00Z,,FIRST_TIME_CONTRIBUTOR,,"Attempted as a first issue.

The use of the context manager within the `.to_hdf5` prevents matching the behaviour exactly of the other save functions (eg. to_zarr) just passing through the `compute` flag through to the store operation,  so structured as a deferred call to the whole block. Might not be worth the special case for the benefit provides. 

- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask`


closes #1296",,https://api.github.com/repos/dask/dask/issues/6405/timeline,,,owena11,3437812,MDQ6VXNlcjM0Mzc4MTI=,https://avatars.githubusercontent.com/u/3437812?v=4,,https://api.github.com/users/owena11,https://github.com/owena11,https://api.github.com/users/owena11/followers,https://api.github.com/users/owena11/following{/other_user},https://api.github.com/users/owena11/gists{/gist_id},https://api.github.com/users/owena11/starred{/owner}{/repo},https://api.github.com/users/owena11/subscriptions,https://api.github.com/users/owena11/orgs,https://api.github.com/users/owena11/repos,https://api.github.com/users/owena11/events{/privacy},https://api.github.com/users/owena11/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6405/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6405,https://github.com/dask/dask/pull/6405,https://github.com/dask/dask/pull/6405.diff,https://github.com/dask/dask/pull/6405.patch,,,,,,,,,,,,,,,,,,,
331,https://api.github.com/repos/dask/dask/issues/6410,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6410/labels{/name},https://api.github.com/repos/dask/dask/issues/6410/comments,https://api.github.com/repos/dask/dask/issues/6410/events,https://github.com/dask/dask/issues/6410,656461267,MDU6SXNzdWU2NTY0NjEyNjc=,6410,Documentation for custom Aggregation does not cover NA edge case,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2020-07-14T09:15:49Z,2021-10-13T05:53:12Z,,NONE,,"Example on the Dask documentation:

```
>>> import itertools as it
>>> collect_list = dd.Aggregation(
...     name=""collect_list"",
...     chunk=lambda s: s.apply(list),
...     agg=lambda s0: s0.apply(lambda chunks: list(it.chain.from_iterable(chunks))),
... )
>>> df.groupby('g').agg(collect_list)
```

However, if the dataframe contains categories:

```python
>>> import dask.dataframe as dd; import pandas as pd
>>> import itertools as it
>>> df = pd.DataFrame().assign(index=[0, 0, 1, 1], values=[""a"", ""a"", ""b"", ""b""], ex=[1, 2, 3, 4]).astype({""values"": ""category""})
>>> ddf = dd.from_pandas(df, chunksize=2)
>>> collect_list = dd.Aggregation(
                     name=""collect_list"", chunk=lambda s: s.apply(list),
                     agg=lambda s0: s0.apply(lambda chunks: list(it.chain.from_iterable(chunks))))
>>> ddf.groupby([""index"", ""values""]).agg(collect_list)
TypeError
[...]
ValueError: Metadata inference failed in `_agg_finalize`.

You have supplied a custom function and Dask is unable to
determine the type of output that that function returns.

To resolve this please provide a meta= keyword.
The docstring of the Dask function you ran should have more information.

Original error is below:
------------------------
TypeError(""'float' object is not iterable"")
[...]
```

This can be solved by having a different aggregation function:

```
>>> def convert_to_list(c):
    if (c != c).all():   # c != c is a trick to find NaN values
        return [np.nan]
    f = [_ for _ in c if _ == _]  # Again, only select non-NaN values
    f = [_ if isinstance(_, list) else [_] for _ in f]
    return list(it.chain.from_iterable(f))

>>> collect_list = dd.Aggregation(
     name=""collect_list"", chunk=lambda s: s.apply(list),
     agg=lambda s0: s0.apply(lambda chunks: internal(chunks)))
>>> ddf.groupby([""index"", ""values""]).agg(collect_list).compute()
                  ex
index values
0     a       [1, 2]
      b        [nan]
1     a        [nan]
      b       [3, 4]
```

**As a more general note**, this kind of operation (passing the whole list of values per-group to the ""aggregation"" function) is a passage that is sometimes necessary in data analysis, and it would be good in my humble opinion that good examples on how to force Dask to pass the whole list of values to the final aggregation stage would be both easier and more prominent on the documentation.

As a user-case, I found this edge-case while trying to calculate the MAD on a column of a grouped dask.DataFrame (using the `scipy.stats.median_absolute_deviation` function). Having to implement a map-reduce version of this standard function is far less optimal than simply passing the list of values to the end-stage (as it happens in pandas in an equivalent scenario).

**Environment**: 
- Dask version: 2.17.2
- Python version: 3.7.6 | Conda
- Operating System:  WSL Ubuntu
- Install method (conda, pip, source): Conda
",,https://api.github.com/repos/dask/dask/issues/6410/timeline,,,lucventurini,8897821,MDQ6VXNlcjg4OTc4MjE=,https://avatars.githubusercontent.com/u/8897821?v=4,,https://api.github.com/users/lucventurini,https://github.com/lucventurini,https://api.github.com/users/lucventurini/followers,https://api.github.com/users/lucventurini/following{/other_user},https://api.github.com/users/lucventurini/gists{/gist_id},https://api.github.com/users/lucventurini/starred{/owner}{/repo},https://api.github.com/users/lucventurini/subscriptions,https://api.github.com/users/lucventurini/orgs,https://api.github.com/users/lucventurini/repos,https://api.github.com/users/lucventurini/events{/privacy},https://api.github.com/users/lucventurini/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6410/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
332,https://api.github.com/repos/dask/dask/issues/6419,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6419/labels{/name},https://api.github.com/repos/dask/dask/issues/6419/comments,https://api.github.com/repos/dask/dask/issues/6419/events,https://github.com/dask/dask/pull/6419,658812691,MDExOlB1bGxSZXF1ZXN0NDUwNzMyMTE0,6419,Use automatic chunking in from_zarr,[],open,False,,[],,8,2020-07-17T03:39:31Z,2021-03-08T20:19:46Z,,MEMBER,,"Previously we would use whatever chunking was present in the zarr array.
However storage formats often store smaller chunks than are ideal for
compute frameworks, leading in too many tasks that are too small.

Now we just let da.from_array handle this.  It already has logic to
choose a good chunksize that both respects the alignment within the
zarr array and the chunk size in configuration (usually 128 MiB by
default)

cc @alimanfoo @sofroniewn @tlambert03",,https://api.github.com/repos/dask/dask/issues/6419/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6419/reactions,2,1,0,0,0,0,0,1,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6419,https://github.com/dask/dask/pull/6419,https://github.com/dask/dask/pull/6419.diff,https://github.com/dask/dask/pull/6419.patch,,,,,,,,,,,,,,,,,,,
333,https://api.github.com/repos/dask/dask/issues/6440,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6440/labels{/name},https://api.github.com/repos/dask/dask/issues/6440/comments,https://api.github.com/repos/dask/dask/issues/6440/events,https://github.com/dask/dask/issues/6440,663565276,MDU6SXNzdWU2NjM1NjUyNzY=,6440,Switch from numpy.fft to scipy.fft?,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,15,2020-07-22T08:11:29Z,2020-07-31T21:08:19Z,,NONE,,"I noticed that the `dask` FFT wrapper internally uses `numpy`'s FFT.
Unless this is done to avoid a `scipy` dependency, I'd suggest switching to `scipy.fft` (not `scipy.fftpack`, which is now legacy) instead. 
The advantage of `scipy.fft` is that it is much faster than `numpy.fft` when transforming multi-D arrays (even if only one axis is transformed), because it uses vector instructions where available. In addition to standard FFTs it also provides DCTs, DSTs and Hartley transforms. Optional shared-memory parallelization is available, and there are dedicated functions for single-precision transforms.
",,https://api.github.com/repos/dask/dask/issues/6440/timeline,,,mreineck,898507,MDQ6VXNlcjg5ODUwNw==,https://avatars.githubusercontent.com/u/898507?v=4,,https://api.github.com/users/mreineck,https://github.com/mreineck,https://api.github.com/users/mreineck/followers,https://api.github.com/users/mreineck/following{/other_user},https://api.github.com/users/mreineck/gists{/gist_id},https://api.github.com/users/mreineck/starred{/owner}{/repo},https://api.github.com/users/mreineck/subscriptions,https://api.github.com/users/mreineck/orgs,https://api.github.com/users/mreineck/repos,https://api.github.com/users/mreineck/events{/privacy},https://api.github.com/users/mreineck/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6440/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
334,https://api.github.com/repos/dask/dask/issues/6448,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6448/labels{/name},https://api.github.com/repos/dask/dask/issues/6448/comments,https://api.github.com/repos/dask/dask/issues/6448/events,https://github.com/dask/dask/pull/6448,664100994,MDExOlB1bGxSZXF1ZXN0NDU1Mzk3NTEz,6448,Convert dataframes to bags with map_partitions,[],open,False,,[],,3,2020-07-22T23:03:42Z,2021-03-08T20:19:46Z,,MEMBER,,"cc @TomAugspurger 

- [ ] Tests added / passed
- [ ] Passes `black dask` / `flake8 dask`
",,https://api.github.com/repos/dask/dask/issues/6448/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6448/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6448,https://github.com/dask/dask/pull/6448,https://github.com/dask/dask/pull/6448.diff,https://github.com/dask/dask/pull/6448.patch,,,,,,,,,,,,,,,,,,,
335,https://api.github.com/repos/dask/dask/issues/6450,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6450/labels{/name},https://api.github.com/repos/dask/dask/issues/6450/comments,https://api.github.com/repos/dask/dask/issues/6450/events,https://github.com/dask/dask/issues/6450,664303504,MDU6SXNzdWU2NjQzMDM1MDQ=,6450,Issue reading range index from parquet files with fast parquet,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,11,2020-07-23T08:48:37Z,2021-10-13T05:56:05Z,,CONTRIBUTOR,,"**What happened**:

When reading a parquet file with a range index and fastparquet the index and its meta data seem to get corrupted. This leads to errors when trying to serialize the data later again. 

**What you expected to happen**:
I should be able to do a roundtrip of `dd.read_parquet(""file.par"").to_parquet(""file2.par"")` without any issue.

**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import dask.dataframe as dd
column = ""data""
df = pd.DataFrame(columns=[column], data=[(""42"",), ("""",), (""0"",), (""1"",), (""0.0"",)],)
df.index.name = ""index""
df.to_parquet(""test.par"")
print(df)
print(pd.read_parquet(""test.par""))

ddf_arrow = dd.read_parquet(""test.par"", engine=""pyarrow"")
print(ddf_arrow.compute()) # This actually prints the same dataframe
ddf_arrow.to_parquet(""test2.par"", engine=""pyarrow"") # This works as expected
ddf_arrow.to_parquet(""test2.par"", engine=""fastparquet"") # This fails saying TypeError: expected list of bytes

ddf = dd.read_parquet(""test.par"", engine=""fastparquet"") 
print(ddf.compute()) # This already prints the wrong indices
ddf.to_parquet(""test2.par"", engine=""fastparquet"") # This fails saying TypeError: expected list of bytes
ddf.to_parquet(""test2.par"", engine=""pyarrow"") # This works, but writes the wrong, new values for the index to disk
```

**Anything else we need to know?**:

I am not sure if that is solely a fastparquet bug. However, as it does not occur under pandas, I thought I post it here and not in the fastparquet repo.

**Environment**:

- Dask version: master, hash: 55445565c3746f97f2bc50d5628a484576cef90e
- fastparquet version: 0.4.1
- pyarrow version: 0.17.1
- Python version: 3.8.2
- Operating System: MacOS
- Install method (conda, pip, source): from source via pipenv
",,https://api.github.com/repos/dask/dask/issues/6450/timeline,,,jendrikjoe,9658781,MDQ6VXNlcjk2NTg3ODE=,https://avatars.githubusercontent.com/u/9658781?v=4,,https://api.github.com/users/jendrikjoe,https://github.com/jendrikjoe,https://api.github.com/users/jendrikjoe/followers,https://api.github.com/users/jendrikjoe/following{/other_user},https://api.github.com/users/jendrikjoe/gists{/gist_id},https://api.github.com/users/jendrikjoe/starred{/owner}{/repo},https://api.github.com/users/jendrikjoe/subscriptions,https://api.github.com/users/jendrikjoe/orgs,https://api.github.com/users/jendrikjoe/repos,https://api.github.com/users/jendrikjoe/events{/privacy},https://api.github.com/users/jendrikjoe/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6450/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
336,https://api.github.com/repos/dask/dask/issues/6474,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6474/labels{/name},https://api.github.com/repos/dask/dask/issues/6474/comments,https://api.github.com/repos/dask/dask/issues/6474/events,https://github.com/dask/dask/issues/6474,669540778,MDU6SXNzdWU2Njk1NDA3Nzg=,6474,dask implementation of np.interp,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,13,2020-07-31T08:06:07Z,2022-09-02T15:55:11Z,,MEMBER,,"@jakirkham and I were discussing a dask implementation of `np.interp` (not currently supported by dask: https://github.com/dask/dask/issues/2911), in the context of https://github.com/dask/dask-image/pull/137.

I looked into it today, and it seems that this is not quite as simple as it seemed (we thought we could just wrap `np.interp` with `map_overlap`) because of the [unify_chunks](https://github.com/dask/dask/blob/2e48623832110dd0f54368e01abd634e99e8ae44/dask/array/core.py#L3160) function called by dask `map_overlap`. No matter what chunk sizes you give the input arrays, dask can't unify them because they won't match by definition of `np.interp`

Does someone have a good idea for what I should be doing instead here?

More details:
`np.interp` takes three input arguments, and the first one can't be unified with the other two:
1. The x-values for the interpolated output
2. The original data x-values
3. The original data y-values

```python
import numpy as np
import dask.array as da
import matplotlib.pyplot as plt

# Interpolation with numpy
x = np.linspace(0, 10, 20)
y = np.sin(x)

interp_x = np.linspace(0, 10, 60)  # this array is a different length than the original data
result = np.interp(interp_x, x, y)

# visualise the original data (blue) and interpolated result (red)
plt.plot(x, y, 'bo')
plt.plot(interp_x, result, 'r+')
plt.show()

# Interpolation with dask
dask_x = da.from_array(x, chunks=5)
dask_y = da.from_array(y, chunks=5)

dask_interp_x = da.from_array(interp_x, chunks=5)  # doesn't matter what chunks is here, unify_chunks returns an error
dask_result = da.map_overlap(np.interp, dask_interp_x, dask_x, dask_y)  # ERROR
```
Depending on what `chunks=`, you get either an error that the chunks do not add up to the same value, or an error that the chunks do not add up to the same shape (eg: if `chunks=60` in the example above).

```python-traceback
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-58-1c1767ae78d8> in <module>
      2 dask_x2 = da.from_array(x2, chunks=5)
      3 dask_y = da.from_array(y, chunks=5)
----> 4 dask_out = da.map_overlap(np.interp, dask_x2, dask_x, dask_y)

~\anaconda3\envs\dask\lib\site-packages\dask\array\overlap.py in map_overlap(func, depth, boundary, trim, align_arrays, *args, **kwargs)
    695         # Reverse unification order to allow block broadcasting
    696         inds = [list(reversed(range(x.ndim))) for x in args]
--> 697         _, args = unify_chunks(*list(concat(zip(args, inds))), warn=False)
    698 
    699     for i, x in enumerate(args):

~\anaconda3\envs\dask\lib\site-packages\dask\array\core.py in unify_chunks(*args, **kwargs)
   3228             nameinds.append((a, ind))
   3229 
-> 3230     chunkss = broadcast_dimensions(nameinds, blockdim_dict, consolidate=common_blockdim)
   3231     nparts = np.prod(list(map(len, chunkss.values())))
   3232 

~\anaconda3\envs\dask\lib\site-packages\dask\blockwise.py in broadcast_dimensions(argpairs, numblocks, sentinels, consolidate)
    857 
    858     if consolidate:
--> 859         return toolz.valmap(consolidate, g2)
    860 
    861     if g2 and not set(map(len, g2.values())) == set([1]):

~\anaconda3\envs\dask\lib\site-packages\cytoolz\dicttoolz.pyx in cytoolz.dicttoolz.valmap()

~\anaconda3\envs\dask\lib\site-packages\cytoolz\dicttoolz.pyx in cytoolz.dicttoolz.valmap()

~\anaconda3\envs\dask\lib\site-packages\dask\array\core.py in common_blockdim(blockdims)
   3128 
   3129     if len(set(map(sum, non_trivial_dims))) > 1:
-> 3130         raise ValueError(""Chunks do not add up to same value"", blockdims)
   3131 
   3132     # We have multiple non-trivial chunks on this axis

ValueError: ('Chunks do not add up to same value', {(5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5), (5, 5, 5, 5)})

```

",,https://api.github.com/repos/dask/dask/issues/6474/timeline,,,GenevieveBuckley,30920819,MDQ6VXNlcjMwOTIwODE5,https://avatars.githubusercontent.com/u/30920819?v=4,,https://api.github.com/users/GenevieveBuckley,https://github.com/GenevieveBuckley,https://api.github.com/users/GenevieveBuckley/followers,https://api.github.com/users/GenevieveBuckley/following{/other_user},https://api.github.com/users/GenevieveBuckley/gists{/gist_id},https://api.github.com/users/GenevieveBuckley/starred{/owner}{/repo},https://api.github.com/users/GenevieveBuckley/subscriptions,https://api.github.com/users/GenevieveBuckley/orgs,https://api.github.com/users/GenevieveBuckley/repos,https://api.github.com/users/GenevieveBuckley/events{/privacy},https://api.github.com/users/GenevieveBuckley/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6474/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
337,https://api.github.com/repos/dask/dask/issues/6484,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6484/labels{/name},https://api.github.com/repos/dask/dask/issues/6484/comments,https://api.github.com/repos/dask/dask/issues/6484/events,https://github.com/dask/dask/issues/6484,672817422,MDU6SXNzdWU2NzI4MTc0MjI=,6484,Parquet reading/writing is non-deterministic for multi-index frames,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,3,2020-08-04T14:02:19Z,2021-10-13T06:04:59Z,,NONE,,"The way Dask DataFrames are read/written in Parquet seems to have changed in 2.22.0. I'm not sure if this change was intended or if you'll agree it's a bug, but for my particular use case it feels like a regression.

**What happened**:

When I write a multi-index Dask DataFrame to Parquet and then read it back, the sub-indices are sometimes in the wrong order. The order is non-deterministic and seems to be driven by the [Python hash seed](https://docs.python.org/3.3/using/cmdline.html#envvar-PYTHONHASHSEED).

(I'm aware that the Pandas MultiIndex is not supported in Dask, but this situation can arise after doing a `groupby` on multiple columns, which Dask will happily do. Maybe I just don't understand what usages are intended to be supported here. In my personal view, if Dask can't provide a deterministic index structure, it would much better to produce a warning or exception before doing something non-deterministic. It's natural to write to Pandas code that depends on the order of sub-indices and this code will now break non-deterministically.)

**What you expected to happen**:

On versions of Dask before 2.22.0, Dask would emit a warning and fail to load any index at all.

**Minimal Complete Verifiable Example**:

Here is a Pytest test that passes or fails non-deterministically:

```python
import dask.dataframe as dd
import pandas as pd

def test_dask_problem(tmpdir):
    # Construct a Dask DataFrame with a multi-index.
    raw_df = pd.DataFrame(
        columns=[""color"", ""shape""],
        data=[
            [""red"", ""square""],
            [""blue"", ""circle""],
        ],
    )
    dask_raw_df = dd.from_pandas(raw_df, npartitions=1)
    dask_counts_df = dask_raw_df.groupby([""color"", ""shape""]).size().to_frame(""count"")

    # Write it to Parquet, read it back, and convert it to Pandas.
    path = tmpdir / 'df.pq'
    dd.to_parquet(dask_counts_df, str(path), write_index=True)
    dask_counts_df_from_file = dd.read_parquet(str(path))
    counts_df_from_file = dask_counts_df_from_file.compute()

    # Check that the index structure is as expected.
    print(counts_df_from_file)
    assert counts_df_from_file.index.names == ('color', 'shape')
```

I can make it always pass or always fail by setting `PYTHONHASHSEED`:

`PYTHONHASHSEED=0 pytest -k test_dask_problem  # Always passes.`
`PYTHONHASHSEED=1 pytest -k test_dask_problem  # Always fails.`

**Anything else we need to know?**:

The reason this is a problem for me is that I work on a [framework](https://bionic.readthedocs.io/en/stable/) that (among other things) transparently caches Python objects to disk, somewhat like [joblib](https://joblib.readthedocs.io/en/latest/). We save Dask DataFrames as Parquet files, but when we load them we detect this warning and throw an exception instead of returning the loaded frame. From our point of view, it's much better to fail early than to introduce a subtle non-determinism deep inside our framework, because the resulting bugs will be extremely hard for the end user to track down. I don't love the current approach of watching for warnings and I'd be happy to learn of a better way to avoid this problem.

**Environment**:

- Dask version: 2.22.0
- Python version: 3.8.3
- Operating System: Mac OS 10.15.6 (19G73)
- Install method: pip

Thanks for reading!",,https://api.github.com/repos/dask/dask/issues/6484/timeline,,,jqmp,42037,MDQ6VXNlcjQyMDM3,https://avatars.githubusercontent.com/u/42037?v=4,,https://api.github.com/users/jqmp,https://github.com/jqmp,https://api.github.com/users/jqmp/followers,https://api.github.com/users/jqmp/following{/other_user},https://api.github.com/users/jqmp/gists{/gist_id},https://api.github.com/users/jqmp/starred{/owner}{/repo},https://api.github.com/users/jqmp/subscriptions,https://api.github.com/users/jqmp/orgs,https://api.github.com/users/jqmp/repos,https://api.github.com/users/jqmp/events{/privacy},https://api.github.com/users/jqmp/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6484/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
338,https://api.github.com/repos/dask/dask/issues/6506,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6506/labels{/name},https://api.github.com/repos/dask/dask/issues/6506/comments,https://api.github.com/repos/dask/dask/issues/6506/events,https://github.com/dask/dask/issues/6506,677834184,MDU6SXNzdWU2Nzc4MzQxODQ=,6506,Bypassing dask dependency management,[],open,False,,[],,2,2020-08-12T16:45:11Z,2020-08-26T18:31:25Z,,CONTRIBUTOR,,"We are trying to improve the resilience of one of our critical data pipelines by storing small, valuable task results in a `distributed.Queue` (could also be another temporary storage layer), which we retrieve at a later part of the execution.

By default, our graph looks something like this:
```
load_xyz -> store_xyz -> metadata_xyz > commit_xyz_abc
load_abc -> store_abc -> metadata_abc /
```

With the increased resilience, we could have 2 distinct graphs looking something like this:
```
load_xyz -> store_xyz -> metadata_xyz_q    # This stores the result in a distributed.Queue
load_abc -> store_abc -> metadata_abc_q   # This stores the result in a distributed.Queue

wait_for_q_fill -> commit_xyz_abc  # This fetches the results from the Queue and finishes execution
```
Here, `wait_for_q_fill`, still depends on the storage layer to be filled with the required keys from `metadata_xyz_q` and `metadata_abc_q`. However, the distinction is that we no longer keep any data related to `metadata_xyz`, `metadata_abc` at the workers' side.

Hence, the order of execution from the previous graph is still applicable, but the dependencies of the result from `metadata_*` to `commit` no longer apply. i.e. as long as `metadata_*_q` has finished successfully, dask can ""forget"" about feeding its result to any other task.

There's various ways this could be implemented, one could simply call compute on the graph up to `metadata_*_q`, and then run the `commit` graph; I've also looked into futures but it's not really applicable for our use case. I was hoping someone could give me some suggestions for having such an implementation more integrated with dask/distributed.",,https://api.github.com/repos/dask/dask/issues/6506/timeline,,,lr4d,44430780,MDQ6VXNlcjQ0NDMwNzgw,https://avatars.githubusercontent.com/u/44430780?v=4,,https://api.github.com/users/lr4d,https://github.com/lr4d,https://api.github.com/users/lr4d/followers,https://api.github.com/users/lr4d/following{/other_user},https://api.github.com/users/lr4d/gists{/gist_id},https://api.github.com/users/lr4d/starred{/owner}{/repo},https://api.github.com/users/lr4d/subscriptions,https://api.github.com/users/lr4d/orgs,https://api.github.com/users/lr4d/repos,https://api.github.com/users/lr4d/events{/privacy},https://api.github.com/users/lr4d/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6506/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
339,https://api.github.com/repos/dask/dask/issues/6511,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6511/labels{/name},https://api.github.com/repos/dask/dask/issues/6511/comments,https://api.github.com/repos/dask/dask/issues/6511/events,https://github.com/dask/dask/issues/6511,678688001,MDU6SXNzdWU2Nzg2ODgwMDE=,6511,Warn on da.empty usage ?,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2020-08-13T19:37:50Z,2021-10-14T19:47:12Z,,CONTRIBUTOR,,"See https://github.com/dask/dask/pull/6491#issuecomment-673601353 and later comments for background.

But roughly as dask array are immutable; usage of `empty()` beyond drop-in replacement of numpy are likely wrong and could/should be replaced by full/ones/zeroes which will also be more efficient once #6491 is merged.



",,https://api.github.com/repos/dask/dask/issues/6511/timeline,,,Carreau,335567,MDQ6VXNlcjMzNTU2Nw==,https://avatars.githubusercontent.com/u/335567?v=4,,https://api.github.com/users/Carreau,https://github.com/Carreau,https://api.github.com/users/Carreau/followers,https://api.github.com/users/Carreau/following{/other_user},https://api.github.com/users/Carreau/gists{/gist_id},https://api.github.com/users/Carreau/starred{/owner}{/repo},https://api.github.com/users/Carreau/subscriptions,https://api.github.com/users/Carreau/orgs,https://api.github.com/users/Carreau/repos,https://api.github.com/users/Carreau/events{/privacy},https://api.github.com/users/Carreau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6511/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
340,https://api.github.com/repos/dask/dask/issues/6519,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6519/labels{/name},https://api.github.com/repos/dask/dask/issues/6519/comments,https://api.github.com/repos/dask/dask/issues/6519/events,https://github.com/dask/dask/issues/6519,679586602,MDU6SXNzdWU2Nzk1ODY2MDI=,6519,Issue running a large number of embarrassingly parallel tasks ,[],open,False,,[],,7,2020-08-15T14:49:07Z,2022-10-27T19:16:05Z,,NONE,,"I am trying to run the following dask script stops and crashes with no errors. 
```
#!/usr/bin/env python

import time
import random
import numpy as np
import os
from dask.distributed import Client, progress
jobid=os.getenv('SLURM_JOBID')
client= Client(scheduler_file='scheduler_%s.json' %jobid,direct_to_workers=True)
print(client)

def sim(x):
    return np.linalg.inv(x)

N=1000000
C=15000
print(""Creating parameter set"")
input_params=np.random.randint(0, 100, size=(N,100, 100))
print(""Starting computation"")
futures = client.map(sim,input_params,batch_size=C)
print(""Futures length "",len(futures))
client.close()
```

Some information about the system and the SLURM jobscript to launch the above python script:
```
#!/bin/bash -l
#SBATCH --ntasks=64
#SBATCH --ntasks-per-node=32
#SBATCH --cpus-per-task=1
#SBATCH --partition=workq
#SBATCH --time=02:00:00

module load dask/2.22.0
srun -u --hint=nomultithread -n ${SLURM_NTASKS} --ntasks-per-node=${SLURM_NTASKS_PER_NODE} -c ${SLURM_CPUS_PER_TASK} dask-mpi --no-nanny --nthreads=${SLURM_CPUS_PER_TASK} --memory-limit='4GB' --local-directory=workers${SLURM_JOBID} --scheduler-file=scheduler_${SLURM_JOBID}.json --interface=ipogif0 --scheduler-port=6192 --dashboard-address=${node}:8787 &
```
The jobscript was submitted on CrayXC40 (--interface=ipogif0 for Cray Aries interconnect) but a similar test was also run on a non-Cray machine, (with --interface=ib0). I am launching dask-mpi on multiple nodes to increase the total memory (each node has 128 GB). With --memory-limit=4GB, I can see that Dask Dashboard shows me a total of ~ 4GB * 64 workers (223GB) memory. 

Version of software are as follows:


- Dask version: 2.22.0
- Python version: 3.8.0
- Operating System: Cray Linux Environment 7.01 ( also tested on a different machine with CentOS 7.7)
- Install method (conda, pip, source): pip install --no-cache-dir dask[complete] dask-mpi dask-jobqueue dask-ml
",,https://api.github.com/repos/dask/dask/issues/6519/timeline,,,mshaikh786,3212475,MDQ6VXNlcjMyMTI0NzU=,https://avatars.githubusercontent.com/u/3212475?v=4,,https://api.github.com/users/mshaikh786,https://github.com/mshaikh786,https://api.github.com/users/mshaikh786/followers,https://api.github.com/users/mshaikh786/following{/other_user},https://api.github.com/users/mshaikh786/gists{/gist_id},https://api.github.com/users/mshaikh786/starred{/owner}{/repo},https://api.github.com/users/mshaikh786/subscriptions,https://api.github.com/users/mshaikh786/orgs,https://api.github.com/users/mshaikh786/repos,https://api.github.com/users/mshaikh786/events{/privacy},https://api.github.com/users/mshaikh786/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6519/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
341,https://api.github.com/repos/dask/dask/issues/6520,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6520/labels{/name},https://api.github.com/repos/dask/dask/issues/6520/comments,https://api.github.com/repos/dask/dask/issues/6520/events,https://github.com/dask/dask/issues/6520,679616656,MDU6SXNzdWU2Nzk2MTY2NTY=,6520,np.asarray returns non-writable array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,19,2020-08-15T17:51:52Z,2021-10-13T07:12:48Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
Behaviour change in the last release (2.23.0): converting a dask array to a numpy array results in a non-writable array when it has been created with `np.zeros_like` of a dask array.

**What you expected to happen**:
The returned numpy array should be consistently writable (or not?), regardless if the dask array have been created with `da.arange` or `da.zeros`, for example.

**Minimal Complete Verifiable Example**:

```python
import numpy as np
import dask.array as da

dask_array = np.zeros_like(da.arange(20))
numpy_array = np.asarray(dask_array)
numpy_array[0] = 1
```
Error:
```python
Traceback (most recent call last):

  File ""<ipython-input-19-6eef1a4f1c7b>"", line 5, in <module>
    numpy_array[0] = 1

ValueError: assignment destination is read-only
```

The following example works fine:
```python
dask_array = da.arange(20)
numpy_array = np.asarray(dask_array)
numpy_array[0] = 1
```

Another example, which is not working with dask 0.23.0:
```python
dask_array = da.zeros((20))
numpy_array = np.asarray(dask_array)
numpy_array[0] = 1
```

**Anything else we need to know?**:

Checking the numpy flags, it seems that the numpy array is not writable anymore.

**Environment**:

- Dask version: 2.23.0
- Python version: 3.7
- Operating System: Fedora
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/6520/timeline,,,ericpre,11851990,MDQ6VXNlcjExODUxOTkw,https://avatars.githubusercontent.com/u/11851990?v=4,,https://api.github.com/users/ericpre,https://github.com/ericpre,https://api.github.com/users/ericpre/followers,https://api.github.com/users/ericpre/following{/other_user},https://api.github.com/users/ericpre/gists{/gist_id},https://api.github.com/users/ericpre/starred{/owner}{/repo},https://api.github.com/users/ericpre/subscriptions,https://api.github.com/users/ericpre/orgs,https://api.github.com/users/ericpre/repos,https://api.github.com/users/ericpre/events{/privacy},https://api.github.com/users/ericpre/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6520/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
342,https://api.github.com/repos/dask/dask/issues/6535,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6535/labels{/name},https://api.github.com/repos/dask/dask/issues/6535/comments,https://api.github.com/repos/dask/dask/issues/6535/events,https://github.com/dask/dask/issues/6535,682771979,MDU6SXNzdWU2ODI3NzE5Nzk=,6535,Group by Apply should operate on Dask dataframe instead of Pandas,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,6,2020-08-20T14:40:38Z,2021-09-15T19:55:16Z,,NONE,,"Group by apply currently appears to expect a pandas dataframe, however, this has limited usefullness in cases where the groupings can't fit in memory.

It would be better if apply could accept a dask dataframe (which can be cast down into a pandas dataframe in cases where you know that it will fit in memory).

Better yet, developing a concept of a nested dataframe would encapsulate this idea even better as it would be less destructive (though admittidly it is a bit more ambitious in scope).
",,https://api.github.com/repos/dask/dask/issues/6535/timeline,,,kyprifog,991756,MDQ6VXNlcjk5MTc1Ng==,https://avatars.githubusercontent.com/u/991756?v=4,,https://api.github.com/users/kyprifog,https://github.com/kyprifog,https://api.github.com/users/kyprifog/followers,https://api.github.com/users/kyprifog/following{/other_user},https://api.github.com/users/kyprifog/gists{/gist_id},https://api.github.com/users/kyprifog/starred{/owner}{/repo},https://api.github.com/users/kyprifog/subscriptions,https://api.github.com/users/kyprifog/orgs,https://api.github.com/users/kyprifog/repos,https://api.github.com/users/kyprifog/events{/privacy},https://api.github.com/users/kyprifog/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6535/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
343,https://api.github.com/repos/dask/dask/issues/6537,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6537/labels{/name},https://api.github.com/repos/dask/dask/issues/6537/comments,https://api.github.com/repos/dask/dask/issues/6537/events,https://github.com/dask/dask/issues/6537,683163173,MDU6SXNzdWU2ODMxNjMxNzM=,6537,DataFrame Groupby meta setting caused KeyError,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2020-08-20T23:54:43Z,2021-02-24T05:05:30Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as pd
import dask.array as np
import pandas

df=pd.from_pandas(pandas.DataFrame([[0,1],[0,2],[None,3],[20,4],[0,5]],columns=[""a"",""b""]), npartitions=2)

s=df.groupby([""a""])[""b""].apply(lambda x:x.drop_duplicates().sum(), meta=(None, ""int64""))
df2=s.rename(""xx"").reset_index()
df.merge(df2, ""outer"", on=[""a""])
```

**What happened**:
It complains key a is not found on df2

**What you expected to happen**:

The merge should work

**Anything else we need to know?**:

Without setting `meta`, the merge works, but it warned about type inference.
```
s=df.groupby([""a""])[""b""].apply(lambda x:x.drop_duplicates().sum())
```

The following workaround also works
```
import dask.dataframe as pd
import dask.array as np
import pandas

df=pd.from_pandas(pandas.DataFrame([[0,1],[0,2],[None,3],[20,4],[0,5]],columns=[""a"",""b""]), npartitions=2)

s=df.groupby([""a""])[""b""].apply(lambda x:x.drop_duplicates().sum(), meta=(None, ""int64""))
df2=s.rename(""xx"").to_frame()
df.merge(df2, ""outer"", left_on=[""a""], right_index=True)
```


**Environment**:

- Dask version: 2.22.0
- Python version: 3.6+
- Operating System: Linux
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/6537/timeline,,,goodwanghan,21092479,MDQ6VXNlcjIxMDkyNDc5,https://avatars.githubusercontent.com/u/21092479?v=4,,https://api.github.com/users/goodwanghan,https://github.com/goodwanghan,https://api.github.com/users/goodwanghan/followers,https://api.github.com/users/goodwanghan/following{/other_user},https://api.github.com/users/goodwanghan/gists{/gist_id},https://api.github.com/users/goodwanghan/starred{/owner}{/repo},https://api.github.com/users/goodwanghan/subscriptions,https://api.github.com/users/goodwanghan/orgs,https://api.github.com/users/goodwanghan/repos,https://api.github.com/users/goodwanghan/events{/privacy},https://api.github.com/users/goodwanghan/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6537/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
344,https://api.github.com/repos/dask/dask/issues/6538,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6538/labels{/name},https://api.github.com/repos/dask/dask/issues/6538/comments,https://api.github.com/repos/dask/dask/issues/6538/events,https://github.com/dask/dask/issues/6538,683168051,MDU6SXNzdWU2ODMxNjgwNTE=,6538,"DataFrame join, left on multiple keys, right on index is not working","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2020-08-21T00:09:17Z,2020-09-01T14:24:25Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as pd
import dask.array as np
import pandas

df=pd.from_pandas(pandas.DataFrame([[0,1,4],[0,1,5],[2,3,6]],columns=[""a"",""b"", ""c""]), npartitions=2)

s1=df.groupby([""a"",""b""])[""c""].apply(lambda x:x.drop_duplicates().sum(), meta=(""x"", ""int64""))
df.merge(s1.to_frame(), ""outer"", left_on=[""a"",""b""], right_index=True).compute()
```

**What happened**:

It complains:
```
ValueError: len(left_on) must equal the number of levels in the index of ""right""
```

**What you expected to happen**:

It should merge. If using pandas, this operation is fine


**Anything else we need to know?**:

No

**Environment**:

- Dask version: 0.22.0
- Python version: 3.6+
- Operating System: Linux
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/6538/timeline,,,goodwanghan,21092479,MDQ6VXNlcjIxMDkyNDc5,https://avatars.githubusercontent.com/u/21092479?v=4,,https://api.github.com/users/goodwanghan,https://github.com/goodwanghan,https://api.github.com/users/goodwanghan/followers,https://api.github.com/users/goodwanghan/following{/other_user},https://api.github.com/users/goodwanghan/gists{/gist_id},https://api.github.com/users/goodwanghan/starred{/owner}{/repo},https://api.github.com/users/goodwanghan/subscriptions,https://api.github.com/users/goodwanghan/orgs,https://api.github.com/users/goodwanghan/repos,https://api.github.com/users/goodwanghan/events{/privacy},https://api.github.com/users/goodwanghan/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6538/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
345,https://api.github.com/repos/dask/dask/issues/6541,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6541/labels{/name},https://api.github.com/repos/dask/dask/issues/6541/comments,https://api.github.com/repos/dask/dask/issues/6541/events,https://github.com/dask/dask/issues/6541,683959882,MDU6SXNzdWU2ODM5NTk4ODI=,6541,Partitions after `set_index`,[],open,False,,[],,4,2020-08-22T08:52:07Z,2020-08-22T20:47:12Z,,CONTRIBUTOR,,"Needless to say, thanks for this great package :-)
I am very sorry if this question was already asked - at least I could not find it (in this way):

I am using `set_index` to sort a dask dataframe. However, the generated partitions are not what I expected:

```python
import dask.dataframe as dd
import pandas as pd

# This is what I would expect
df = dd.from_pandas(pd.DataFrame({""a"": [1]*10 + [2]*10 + [3]*10}), npartitions=3)
df_sorted = df.set_index(""a"", drop=False)

for i in range(df_sorted.npartitions):
    print(df_sorted.get_partition(i).compute()) # prints [1...] [2...] [3...]

# This is not what I expected
df = dd.from_pandas(pd.DataFrame({""a"": [3]*10 + [2]*10 + [1]*10}), npartitions=3)
df_sorted = df.set_index(""a"", drop=False)

for i in range(df_sorted.npartitions):
    print(df_sorted.get_partition(i).compute()) # prints [ ] [1...] [2... 3...]
```
**What happened**:

The first part is as I expected: the resulting dataframe has partitions for the 1s, the 2s and the 3s after the sorting. They all have size 10.
In the second part however (after sorting), the first partition is empty, the second contains all the 1s (size 10) and the third all the 2s and 3s (size 20). 

I just would like to understand if this is expected behavior (and if yes, if you could give me a hint why this is preferred).

**Environment**:

- Dask version: current master
- Python version: 3.7.6
- Operating System: Ubuntu
- Install method (conda, pip, source): source
",,https://api.github.com/repos/dask/dask/issues/6541/timeline,,,nils-braun,6116188,MDQ6VXNlcjYxMTYxODg=,https://avatars.githubusercontent.com/u/6116188?v=4,,https://api.github.com/users/nils-braun,https://github.com/nils-braun,https://api.github.com/users/nils-braun/followers,https://api.github.com/users/nils-braun/following{/other_user},https://api.github.com/users/nils-braun/gists{/gist_id},https://api.github.com/users/nils-braun/starred{/owner}{/repo},https://api.github.com/users/nils-braun/subscriptions,https://api.github.com/users/nils-braun/orgs,https://api.github.com/users/nils-braun/repos,https://api.github.com/users/nils-braun/events{/privacy},https://api.github.com/users/nils-braun/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6541/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
346,https://api.github.com/repos/dask/dask/issues/6543,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6543/labels{/name},https://api.github.com/repos/dask/dask/issues/6543/comments,https://api.github.com/repos/dask/dask/issues/6543/events,https://github.com/dask/dask/issues/6543,684356856,MDU6SXNzdWU2ODQzNTY4NTY=,6543,DataFrame.repartition() fails if npartitions=len(df),[],open,False,,[],,5,2020-08-24T04:50:50Z,2020-08-28T20:05:23Z,,MEMBER,,"If I attempt to repartition a DataFrame such that every row becomes its own partition, a `ValueError` is raised.  (Such fine-grained partitioning can be useful when the DataFrame contains large objects, or during testing.)

```python
import numpy as np
import pandas as pd
import dask.dataframe as ddf

data = pd.DataFrame({'a': np.arange(16)})
df = ddf.from_pandas(data, chunksize=4)
df.repartition(npartitions=15)  # okay
df.repartition(npartitions=16)  # raises
```

```pytb
Traceback (most recent call last):
  File ""/tmp/test.py"", line 8, in <module>
    df.repartition(npartitions=16)
  File ""/opt/miniconda/envs/flyem/lib/python3.7/site-packages/dask/dataframe/core.py"", line 1184, in repartition
    return repartition_npartitions(self, npartitions)
  File ""/opt/miniconda/envs/flyem/lib/python3.7/site-packages/dask/dataframe/core.py"", line 5968, in repartition_npartitions
    return df.repartition(divisions=divisions)
  File ""/opt/miniconda/envs/flyem/lib/python3.7/site-packages/dask/dataframe/core.py"", line 1186, in repartition
    return repartition(self, divisions, force=force)
  File ""/opt/miniconda/envs/flyem/lib/python3.7/site-packages/dask/dataframe/core.py"", line 6065, in repartition
    df.divisions, divisions, df._name, tmp, out, force=force
  File ""/opt/miniconda/envs/flyem/lib/python3.7/site-packages/dask/dataframe/core.py"", line 5748, in repartition_divisions
    check_divisions(b)
  File ""/opt/miniconda/envs/flyem/lib/python3.7/site-packages/dask/dataframe/core.py"", line 5713, in check_divisions
    raise ValueError(msg)
ValueError: New division must be unique, except for the last element
```

<details>

<summary>Environment details</summary>

- Dask version: 2.23.0
- Python version: 3.7.8
- Operating System: Mac
- Install method (conda, pip, source): conda-forge

```
$ conda list | grep -E '^(python |dask)'
dask                      2.23.0                     py_0    conda-forge
dask-core                 2.23.0                     py_0    conda-forge
dask-jobqueue             0.7.1                      py_0    conda-forge
python                    3.7.8           hc9dea61_1_cpython    conda-forge
```

</details>
",,https://api.github.com/repos/dask/dask/issues/6543/timeline,,,stuarteberg,1655821,MDQ6VXNlcjE2NTU4MjE=,https://avatars.githubusercontent.com/u/1655821?v=4,,https://api.github.com/users/stuarteberg,https://github.com/stuarteberg,https://api.github.com/users/stuarteberg/followers,https://api.github.com/users/stuarteberg/following{/other_user},https://api.github.com/users/stuarteberg/gists{/gist_id},https://api.github.com/users/stuarteberg/starred{/owner}{/repo},https://api.github.com/users/stuarteberg/subscriptions,https://api.github.com/users/stuarteberg/orgs,https://api.github.com/users/stuarteberg/repos,https://api.github.com/users/stuarteberg/events{/privacy},https://api.github.com/users/stuarteberg/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6543/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
347,https://api.github.com/repos/dask/dask/issues/6550,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6550/labels{/name},https://api.github.com/repos/dask/dask/issues/6550/comments,https://api.github.com/repos/dask/dask/issues/6550/events,https://github.com/dask/dask/issues/6550,685529325,MDU6SXNzdWU2ODU1MjkzMjU=,6550,Callable correlation support,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2020-08-25T07:44:42Z,2020-09-02T12:35:02Z,,NONE,,"https://docs.dask.org/en/latest/dataframe-api.html#dask.dataframe.DataFrame.corr

Please support `callable` option for `DataFrame.corr`.

When I tried to run the callable function, the error shown as:
```
NotImplementedError: Only Pearson correlation has been implemented
```

Thank you!",,https://api.github.com/repos/dask/dask/issues/6550/timeline,,,jmkim,3622008,MDQ6VXNlcjM2MjIwMDg=,https://avatars.githubusercontent.com/u/3622008?v=4,,https://api.github.com/users/jmkim,https://github.com/jmkim,https://api.github.com/users/jmkim/followers,https://api.github.com/users/jmkim/following{/other_user},https://api.github.com/users/jmkim/gists{/gist_id},https://api.github.com/users/jmkim/starred{/owner}{/repo},https://api.github.com/users/jmkim/subscriptions,https://api.github.com/users/jmkim/orgs,https://api.github.com/users/jmkim/repos,https://api.github.com/users/jmkim/events{/privacy},https://api.github.com/users/jmkim/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6550/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
348,https://api.github.com/repos/dask/dask/issues/6562,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6562/labels{/name},https://api.github.com/repos/dask/dask/issues/6562/comments,https://api.github.com/repos/dask/dask/issues/6562/events,https://github.com/dask/dask/issues/6562,686515724,MDU6SXNzdWU2ODY1MTU3MjQ=,6562,pivot_table on a lazy Dask dataframe has significant performance cliffs,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,9,2020-08-26T18:07:18Z,2021-01-11T21:29:13Z,,NONE,,"
**What happened**:
Using pivot_table to try and convert a series of large vertically stored CSV files into a ""wide"" table, I've been running into memory limitation issues with pandas, so I turned to Dask. Dask has shown to have surprisingly poor performance when running pivot_table after read_csv (from 15 seconds to 10 minutes with the MCV below), with a fairly low CPU, Memory and Disk I/O usage, even though one would expect one of those three to be at maximum capacity.

Looking at the client's timing and profiling data, I found most of the runtime to be taken up by `pivot_table_count` (in purple) and `pivot_table_sum` (in green): 

![Capture-dask-overview](https://user-images.githubusercontent.com/516999/91332204-d4894580-e799-11ea-9e6c-d9282d552007.PNG)

Furthermore, most of both tasks' runtime was taken up by something to do with boxing dates, which are considered to be extension dtypes:

![Capture-dask-purple-flame](https://user-images.githubusercontent.com/516999/91332641-8294ef80-e79a-11ea-932f-3c14743e4127.PNG)
![Capture-dask-green-flame](https://user-images.githubusercontent.com/516999/91332648-84f74980-e79a-11ea-8009-f27f5ead1aec.PNG)

I'm not entirely sure what's causing these tasks to take so long (GIL contention, maybe?), but it's making pivot_table perform far worse than it should. The long yellow line on both flamegraphs is from a slow `is_unique` operation on the categorical column, so there's another similar performance problem there even if we remove the dates.

**What you expected to happen**:
The count and sum sections of the pivot aggregation should not be taking up as much of the computation's runtime as they currently are. Those unexpected performance cliffs are making Dask perform significantly worse than Pandas loading and manipulating each file one after the other, mostly because it appears to be unable to properly use the system resources for that operation and acting as a bottleneck for the entire task graph. Given how `pivot_table` appears to work, this could be impacting other `groupby` operations as well.

**Minimal Complete Verifiable Example**:

Creating data and testing performance in-memory:

```py
import pandas as pd
import numpy as np
import dask.dataframe as dd
big_matrix = np.zeros((500,50000))
pd_matrix = pd.DataFrame(data=big_matrix)
pd_matrix_v = pd_matrix.unstack().reset_index()
pd_matrix_v['level_0'] = pd.to_datetime(pd_matrix_v['level_0'] + 1_000_000_000, unit='s', origin='unix')
dask_matrix_v = dd.from_pandas(pd_matrix_v, npartitions=10)
dask_matrix_v = dask_matrix_v.categorize(columns='level_1')

# Fast (10-15s)
pivot_task = dd.reshape.pivot_table(dask_matrix_v, index='level_0', columns='level_1', values=0)
pivot_task.compute()

# Fast (10-15s)
pd_matrix_v.pivot_table(index='level_0', columns='level_1', values=0)

dd.to_csv(dask_matrix_v, ""./test.csv"")
```

Loading data from disk and testing performance for lazy dataframes:

```py
import pandas as pd
import dask.dataframe as dd
from dask.distributed import Client
client = Client() # For monitoring

dask_matrix_v = dd.read_csv(""./test.csv/*.part"", usecols=['level_0', 'level_1', '0'], dtype={'level_1': 'int32', '0': 'float32'}, parse_dates=['level_0'])
dask_matrix_v = dask_matrix_v.categorize(columns='level_1')

# Very slow (10 minutes)
dask_matrix_v = dd.reshape.pivot_table(dask_matrix_v, index='level_0', columns='level_1', values='0')
dask_matrix_v.compute()

# Just slow without parse_dates (3 minutes)
dask_matrix_v = dd.read_csv(""./test.csv/*.part"", usecols=['level_0', 'level_1', '0'], dtype={'level_0': 'object', 'level_1': 'int32', '0': 'float32'})

dask_matrix_v = dask_matrix_v.categorize(columns='level_1')
dask_matrix_v = dd.reshape.pivot_table(dask_matrix_v, index='level_0', columns='level_1', values='0')
dask_matrix_v.compute()
```

**Anything else we need to know?**:
Using the same example as above, this is the timing graph once the datetime values are are replaced by strings. There's still a bottleneck on the categorical axis causing `pivot_table_count` and `pivot_table_sum` to stand out (though not as much), but unlike the dates, this one can't be avoided since Dask's `pivot_table` implementation requires the `columns` axis to be categorized.
![Capture-dask-overview-dates-are-strings](https://user-images.githubusercontent.com/516999/91339653-c987e280-e7a4-11ea-86bf-9bcb4aa24046.PNG)


**Environment**:

- Dask version: 2.24.0
- Python version: 3.8.0
- Operating System: Windows 10
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/6562/timeline,,,sm-Fifteen,516999,MDQ6VXNlcjUxNjk5OQ==,https://avatars.githubusercontent.com/u/516999?v=4,,https://api.github.com/users/sm-Fifteen,https://github.com/sm-Fifteen,https://api.github.com/users/sm-Fifteen/followers,https://api.github.com/users/sm-Fifteen/following{/other_user},https://api.github.com/users/sm-Fifteen/gists{/gist_id},https://api.github.com/users/sm-Fifteen/starred{/owner}{/repo},https://api.github.com/users/sm-Fifteen/subscriptions,https://api.github.com/users/sm-Fifteen/orgs,https://api.github.com/users/sm-Fifteen/repos,https://api.github.com/users/sm-Fifteen/events{/privacy},https://api.github.com/users/sm-Fifteen/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6562/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
349,https://api.github.com/repos/dask/dask/issues/6565,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6565/labels{/name},https://api.github.com/repos/dask/dask/issues/6565/comments,https://api.github.com/repos/dask/dask/issues/6565/events,https://github.com/dask/dask/issues/6565,686957187,MDU6SXNzdWU2ODY5NTcxODc=,6565,dask.array.stack not handling scalar correctly,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2020-08-27T05:43:22Z,2020-09-01T21:44:43Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
I'm trying to create an dask array from a list of delayed calculated floats.

**What you expected to happen**:

No exception is thrown.

**Minimal Complete Verifiable Example**:

```python
import dask.array as da
import dask
import np

da.stack([da.from_delayed(dask.delayed(1.), dtype=float, shape=())]).compute()
```

The above code throws exception:
> Exception: TypeError(""'float' object is not subscriptable"")

while this code:
```python
import dask.array as da
import dask
import np

da.stack([da.from_delayed(dask.delayed(np.float64(1.)), dtype=np.float64, shape=())]).compute()
```
or 

```python
import dask.array as da
import dask
import np
da.from_delayed(dask.delayed(1.), dtype=float, shape=()).compute()
```

computes correctly.

**Anything else we need to know?**:
No.

**Environment**:

- Dask version: 2.24.0
- Python version: 3.7.5
- Operating System: Linux
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/6565/timeline,,,dovahcrow,998606,MDQ6VXNlcjk5ODYwNg==,https://avatars.githubusercontent.com/u/998606?v=4,,https://api.github.com/users/dovahcrow,https://github.com/dovahcrow,https://api.github.com/users/dovahcrow/followers,https://api.github.com/users/dovahcrow/following{/other_user},https://api.github.com/users/dovahcrow/gists{/gist_id},https://api.github.com/users/dovahcrow/starred{/owner}{/repo},https://api.github.com/users/dovahcrow/subscriptions,https://api.github.com/users/dovahcrow/orgs,https://api.github.com/users/dovahcrow/repos,https://api.github.com/users/dovahcrow/events{/privacy},https://api.github.com/users/dovahcrow/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6565/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
350,https://api.github.com/repos/dask/dask/issues/6566,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6566/labels{/name},https://api.github.com/repos/dask/dask/issues/6566/comments,https://api.github.com/repos/dask/dask/issues/6566/events,https://github.com/dask/dask/issues/6566,687401329,MDU6SXNzdWU2ODc0MDEzMjk=,6566,Change default quantiles implementation to use tdigest,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2020-08-27T17:04:18Z,2021-10-11T23:56:12Z,,MEMBER,,"The current quantiles implementation is a custom algorithm with no statistical analysis behind it. It was written to support efficient partitioning of data (which doesn't require as robust statistical guarantees), but was expanded to implement the `quantiles` method. Quantiles also supports a `method='tdigest'` implementation, that is much more statistically robust, and has a proof of accuracy bounds. This doesn't support quantiles on non-numeric data though.

Since users (rightfully) expect statistically sound defaults, we might want to consider switching to using `method='tdigest'` as the default for quantiles.

See #6551, #6564, #731.",,https://api.github.com/repos/dask/dask/issues/6566/timeline,,,jcrist,2783717,MDQ6VXNlcjI3ODM3MTc=,https://avatars.githubusercontent.com/u/2783717?v=4,,https://api.github.com/users/jcrist,https://github.com/jcrist,https://api.github.com/users/jcrist/followers,https://api.github.com/users/jcrist/following{/other_user},https://api.github.com/users/jcrist/gists{/gist_id},https://api.github.com/users/jcrist/starred{/owner}{/repo},https://api.github.com/users/jcrist/subscriptions,https://api.github.com/users/jcrist/orgs,https://api.github.com/users/jcrist/repos,https://api.github.com/users/jcrist/events{/privacy},https://api.github.com/users/jcrist/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6566/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
351,https://api.github.com/repos/dask/dask/issues/6574,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6574/labels{/name},https://api.github.com/repos/dask/dask/issues/6574/comments,https://api.github.com/repos/dask/dask/issues/6574/events,https://github.com/dask/dask/issues/6574,688531652,MDU6SXNzdWU2ODg1MzE2NTI=,6574,dask.delayed serialization ignores custom pickling for dataclasses,"[{'id': 1968982461, 'node_id': 'MDU6TGFiZWwxOTY4OTgyNDYx', 'url': 'https://api.github.com/repos/dask/dask/labels/delayed', 'name': 'delayed', 'color': '4f6edd', 'default': False, 'description': ''}]",open,False,,[],,3,2020-08-29T13:17:57Z,2021-10-14T14:26:38Z,,NONE,,`dask.delayed.unpack_collections` expands all dataclasses into their set of fields for serialization even when `__reduce__` is overridden.  Is this behavior configurable? Is this the intended behaviour?,,https://api.github.com/repos/dask/dask/issues/6574/timeline,,,mcguipat,29676113,MDQ6VXNlcjI5Njc2MTEz,https://avatars.githubusercontent.com/u/29676113?v=4,,https://api.github.com/users/mcguipat,https://github.com/mcguipat,https://api.github.com/users/mcguipat/followers,https://api.github.com/users/mcguipat/following{/other_user},https://api.github.com/users/mcguipat/gists{/gist_id},https://api.github.com/users/mcguipat/starred{/owner}{/repo},https://api.github.com/users/mcguipat/subscriptions,https://api.github.com/users/mcguipat/orgs,https://api.github.com/users/mcguipat/repos,https://api.github.com/users/mcguipat/events{/privacy},https://api.github.com/users/mcguipat/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6574/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
352,https://api.github.com/repos/dask/dask/issues/6575,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6575/labels{/name},https://api.github.com/repos/dask/dask/issues/6575/comments,https://api.github.com/repos/dask/dask/issues/6575/events,https://github.com/dask/dask/issues/6575,688541462,MDU6SXNzdWU2ODg1NDE0NjI=,6575,Add include_path_column to read_parquet,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,7,2020-08-29T14:18:00Z,2022-06-08T13:54:10Z,,CONTRIBUTOR,,"`include_path_column` [has already been added to read_csv](https://github.com/dask/dask/pull/3908/files) - excellent work!

Can we include a similar `include_path_column` option to the `read_parquet` method?",,https://api.github.com/repos/dask/dask/issues/6575/timeline,,,MrPowers,2722395,MDQ6VXNlcjI3MjIzOTU=,https://avatars.githubusercontent.com/u/2722395?v=4,,https://api.github.com/users/MrPowers,https://github.com/MrPowers,https://api.github.com/users/MrPowers/followers,https://api.github.com/users/MrPowers/following{/other_user},https://api.github.com/users/MrPowers/gists{/gist_id},https://api.github.com/users/MrPowers/starred{/owner}{/repo},https://api.github.com/users/MrPowers/subscriptions,https://api.github.com/users/MrPowers/orgs,https://api.github.com/users/MrPowers/repos,https://api.github.com/users/MrPowers/events{/privacy},https://api.github.com/users/MrPowers/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6575/reactions,3,3,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
353,https://api.github.com/repos/dask/dask/issues/6579,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6579/labels{/name},https://api.github.com/repos/dask/dask/issues/6579/comments,https://api.github.com/repos/dask/dask/issues/6579/events,https://github.com/dask/dask/pull/6579,688751583,MDExOlB1bGxSZXF1ZXN0NDc1OTM0OTQ5,6579,Pad symmetric reflect,[],open,False,,[],,10,2020-08-30T16:46:30Z,2021-03-14T16:34:01Z,,CONTRIBUTOR,,"Fixes  issue #6127 and adds the `reflect_type=""odd""` option to the `pad` method.

Performance is probably a little worse than it was before, since the array is reshaped multiple times.

- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask`
",,https://api.github.com/repos/dask/dask/issues/6579/timeline,,,mark-boer,12862013,MDQ6VXNlcjEyODYyMDEz,https://avatars.githubusercontent.com/u/12862013?v=4,,https://api.github.com/users/mark-boer,https://github.com/mark-boer,https://api.github.com/users/mark-boer/followers,https://api.github.com/users/mark-boer/following{/other_user},https://api.github.com/users/mark-boer/gists{/gist_id},https://api.github.com/users/mark-boer/starred{/owner}{/repo},https://api.github.com/users/mark-boer/subscriptions,https://api.github.com/users/mark-boer/orgs,https://api.github.com/users/mark-boer/repos,https://api.github.com/users/mark-boer/events{/privacy},https://api.github.com/users/mark-boer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6579/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6579,https://github.com/dask/dask/pull/6579,https://github.com/dask/dask/pull/6579.diff,https://github.com/dask/dask/pull/6579.patch,,,,,,,,,,,,,,,,,,,
354,https://api.github.com/repos/dask/dask/issues/6587,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6587/labels{/name},https://api.github.com/repos/dask/dask/issues/6587/comments,https://api.github.com/repos/dask/dask/issues/6587/events,https://github.com/dask/dask/issues/6587,691066545,MDU6SXNzdWU2OTEwNjY1NDU=,6587,"Unable to write parquet with ""empty"" categorical column with pyarrow engine","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,23,2020-09-02T14:24:04Z,2022-04-08T15:24:29Z,,NONE,,"I encountered an issue when working on a concat involving multiples files.
It seems that the issue happens also when applied on only one file with a partition containing a categorical column with no values.

Maybe this issue is linked : [Issue 6243](https://github.com/dask/dask/issues/6243)
If I am not mistaken, it worked with Pyarrow 0.17.1

```python
import dask.dataframe as dd
import pandas as pd

names = [ 'name']
address = names

df1 = dd.from_pandas(pd.DataFrame({'name':names}), npartitions=1)
df2 = dd.from_pandas(pd.DataFrame({'address':address}), npartitions=1)
df1['name'] = df1['name'].astype('category')

df = dd.concat([df1, df2])
del df['address']

df.to_parquet('does_not_work')
```

The error that is raised : 

```
RuntimeError                              Traceback (most recent call last)
/opt/conda/lib/python3.8/site-packages/dask/dataframe/io/parquet/arrow.py in _append_row_groups(metadata, md)
     33     try:
---> 34         metadata.append_row_groups(md)
     35     except RuntimeError as err:

/opt/conda/lib/python3.8/site-packages/pyarrow/_parquet.pyx in pyarrow._parquet.FileMetaData.append_row_groups()

RuntimeError: AppendRowGroups requires equal schemas.

During handling of the above exception, another exception occurred:

RuntimeError                              Traceback (most recent call last)
<ipython-input-46-4faae0e6b3fa> in <module>
     12 del df['address']
     13 
---> 14 df.to_parquet('does_not_work')

/opt/conda/lib/python3.8/site-packages/dask/dataframe/core.py in to_parquet(self, path, *args, **kwargs)
   3948         from .io import to_parquet
   3949 
-> 3950         return to_parquet(self, path, *args, **kwargs)
   3951 
   3952     @derived_from(pd.DataFrame)

/opt/conda/lib/python3.8/site-packages/dask/dataframe/io/parquet/core.py in to_parquet(df, path, engine, compression, write_index, append, ignore_divisions, partition_on, storage_options, write_metadata_file, compute, compute_kwargs, schema, **kwargs)
    506         if compute_kwargs is None:
    507             compute_kwargs = dict()
--> 508         out = out.compute(**compute_kwargs)
    509     return out
    510 

/opt/conda/lib/python3.8/site-packages/dask/base.py in compute(self, **kwargs)
    165         dask.base.compute
    166         """"""
--> 167         (result,) = compute(self, traverse=False, **kwargs)
    168         return result
    169 

/opt/conda/lib/python3.8/site-packages/dask/base.py in compute(*args, **kwargs)
    445         postcomputes.append(x.__dask_postcompute__())
    446 
--> 447     results = schedule(dsk, keys, **kwargs)
    448     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    449 

/opt/conda/lib/python3.8/site-packages/dask/threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     74                 pools[thread][num_workers] = pool
     75 
---> 76     results = get_async(
     77         pool.apply_async,
     78         len(pool._pool),

/opt/conda/lib/python3.8/site-packages/dask/local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    484                         _execute_task(task, data)  # Re-execute locally
    485                     else:
--> 486                         raise_exception(exc, tb)
    487                 res, worker_id = loads(res_info)
    488                 state[""cache""][key] = res

/opt/conda/lib/python3.8/site-packages/dask/local.py in reraise(exc, tb)
    314     if exc.__traceback__ is not tb:
    315         raise exc.with_traceback(tb)
--> 316     raise exc
    317 
    318 

/opt/conda/lib/python3.8/site-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    220     try:
    221         task, data = loads(task_info)
--> 222         result = _execute_task(task, data)
    223         id = get_id()
    224         result = dumps((result, id))

/opt/conda/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/opt/conda/lib/python3.8/site-packages/dask/utils.py in apply(func, args, kwargs)
     27 def apply(func, args, kwargs=None):
     28     if kwargs:
---> 29         return func(*args, **kwargs)
     30     else:
     31         return func(*args)

/opt/conda/lib/python3.8/site-packages/dask/dataframe/io/parquet/arrow.py in write_metadata(parts, fmd, fs, path, append, **kwargs)
   1034                 i_start = 1
   1035             for i in range(i_start, len(parts)):
-> 1036                 _append_row_groups(_meta, parts[i][0][""meta""])
   1037             with fs.open(metadata_path, ""wb"") as fil:
   1038                 _meta.write_metadata_file(fil)

/opt/conda/lib/python3.8/site-packages/dask/dataframe/io/parquet/arrow.py in _append_row_groups(metadata, md)
     35     except RuntimeError as err:
     36         if ""requires equal schemas"" in str(err):
---> 37             raise RuntimeError(
     38                 ""Schemas are inconsistent, try using ""
     39                 '`to_parquet(..., schema=""infer"")`, or pass an explicit '

RuntimeError: Schemas are inconsistent, try using `to_parquet(..., schema=""infer"")`, or pass an explicit pyarrow schema.
``` 

**Environment**:

- Dask version: 2.24.0
- Pyarrow version: 1.0.1
- Python version: 3.8
- Operating System: Dask-Dev image
- Install method (conda, pip, source) : Dask-Dev image",,https://api.github.com/repos/dask/dask/issues/6587/timeline,,,odovad,3889145,MDQ6VXNlcjM4ODkxNDU=,https://avatars.githubusercontent.com/u/3889145?v=4,,https://api.github.com/users/odovad,https://github.com/odovad,https://api.github.com/users/odovad/followers,https://api.github.com/users/odovad/following{/other_user},https://api.github.com/users/odovad/gists{/gist_id},https://api.github.com/users/odovad/starred{/owner}{/repo},https://api.github.com/users/odovad/subscriptions,https://api.github.com/users/odovad/orgs,https://api.github.com/users/odovad/repos,https://api.github.com/users/odovad/events{/privacy},https://api.github.com/users/odovad/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6587/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
355,https://api.github.com/repos/dask/dask/issues/6606,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6606/labels{/name},https://api.github.com/repos/dask/dask/issues/6606/comments,https://api.github.com/repos/dask/dask/issues/6606/events,https://github.com/dask/dask/issues/6606,695550695,MDU6SXNzdWU2OTU1NTA2OTU=,6606,Dot graph manipulation,[],open,False,,[],,4,2020-09-08T05:06:16Z,2021-10-13T06:59:46Z,,NONE,,"I'd like to be able to get the dot graph directly so I can make use of the `g` object from graphviz.

I see the function `dask.dot.to_graphviz`. However I think it would be nice to be able to use `dask.visualize` to also return an in-memory construct rather than writing directly to a file. And I also think that should be generalized to be able to take a file descriptor so one can also write it directly to a IO object.

The other thing is that `visualize()` method has alot of logic to optimize or even construct the `dsk` object:

```
*     dsks = []
      args3 = []
      for arg in args:
          if isinstance(arg, (list, tuple, set)):
              for a in arg:
                  if isinstance(a, Mapping):
*                     dsks.append(a)
                  if is_dask_collection(a):
                      args3.append(a)
          else:
              if isinstance(arg, Mapping):
*                 dsks.append(arg)
              if is_dask_collection(arg):
                  args3.append(arg)
  
*     dsk = dict(collections_to_dsk(args3, optimize_graph=optimize_graph))
*     for d in dsks:
*         dsk.update(d)
``` 

If I use `dask.dot.to_graphviz` I'd have to do that manually. I think `dask.visualize` could expose this as well.

My ultimate goal is to be able to make use of the new formats: https://github.com/xflr6/graphviz/blob/master/graphviz/backend.py#L24-L62",,https://api.github.com/repos/dask/dask/issues/6606/timeline,,,CMCDragonkai,640797,MDQ6VXNlcjY0MDc5Nw==,https://avatars.githubusercontent.com/u/640797?v=4,,https://api.github.com/users/CMCDragonkai,https://github.com/CMCDragonkai,https://api.github.com/users/CMCDragonkai/followers,https://api.github.com/users/CMCDragonkai/following{/other_user},https://api.github.com/users/CMCDragonkai/gists{/gist_id},https://api.github.com/users/CMCDragonkai/starred{/owner}{/repo},https://api.github.com/users/CMCDragonkai/subscriptions,https://api.github.com/users/CMCDragonkai/orgs,https://api.github.com/users/CMCDragonkai/repos,https://api.github.com/users/CMCDragonkai/events{/privacy},https://api.github.com/users/CMCDragonkai/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6606/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
356,https://api.github.com/repos/dask/dask/issues/6614,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6614/labels{/name},https://api.github.com/repos/dask/dask/issues/6614/comments,https://api.github.com/repos/dask/dask/issues/6614/events,https://github.com/dask/dask/issues/6614,697153552,MDU6SXNzdWU2OTcxNTM1NTI=,6614,to_parquet fails when writing with index and append=True,[],open,False,,[],,7,2020-09-09T20:58:27Z,2020-11-11T21:46:06Z,,NONE,,"I am trying to incrementally write a parquet file (or, more acurately, a parquet directory) with multiple calls to `to_parquet` with `append=True`. This fails when the data frame has an index.

To reproduce run the following code:

```python
import pandas as pd
import numpy as np
from dask import dataframe as dd

n = 2000
df = pd.DataFrame({'value': np.random.normal(size=n)}, index=pd.Index(np.arange(n), name='id'))

append = False
for i in range(0, n, 10):
    part = dd.from_pandas(df.loc[i:i+10], npartitions=1)
    part.to_parquet('test.parquet', append=append, engine='fastparquet', compression='gzip')
    append = True

```

I get the following error:

```
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-1-5ca192e15a75> in <module>
      9 for i in range(0, n, 10):
     10     part = dd.from_pandas(df.loc[i:i+10], npartitions=1)
---> 11     part.to_parquet('test.parquet', append=append, engine='fastparquet', compression='gzip')
     12     append = True

~/.pyenv/versions/3.8.5/lib/python3.8/site-packages/dask/dataframe/core.py in to_parquet(self, path, *args, **kwargs)
   3945         from .io import to_parquet
   3946 
-> 3947         return to_parquet(self, path, *args, **kwargs)
   3948 
   3949     @derived_from(pd.DataFrame)

~/.pyenv/versions/3.8.5/lib/python3.8/site-packages/dask/dataframe/io/parquet/core.py in to_parquet(df, path, engine, compression, write_index, append, ignore_divisions, partition_on, storage_options, write_metadata_file, compute, compute_kwargs, **kwargs)
    440     # Engine-specific initialization steps to write the dataset.
    441     # Possibly create parquet metadata, and load existing stuff if appending
--> 442     meta, i_offset = engine.initialize_write(
    443         df,
    444         fs,

~/.pyenv/versions/3.8.5/lib/python3.8/site-packages/dask/dataframe/io/parquet/fastparquet.py in initialize_write(cls, df, fs, path, append, partition_on, ignore_divisions, division_info, **kwargs)
    562             if not ignore_divisions:
    563                 minmax = fastparquet.api.sorted_partitioned_columns(pf)
--> 564                 old_end = minmax[index_cols[0]][""max""][-1]
    565                 divisions = division_info[""divisions""]
    566                 if divisions[0] < old_end:

KeyError: 'id'
```

**Environment**:

- Dask version: 2.23.0
- Pandas version: 1.1.0
- fastparquet version: 0.4.1
- Python version: 3.8.5
- Operating System: Mac OS X
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/6614/timeline,,,mwiebusch78,4977570,MDQ6VXNlcjQ5Nzc1NzA=,https://avatars.githubusercontent.com/u/4977570?v=4,,https://api.github.com/users/mwiebusch78,https://github.com/mwiebusch78,https://api.github.com/users/mwiebusch78/followers,https://api.github.com/users/mwiebusch78/following{/other_user},https://api.github.com/users/mwiebusch78/gists{/gist_id},https://api.github.com/users/mwiebusch78/starred{/owner}{/repo},https://api.github.com/users/mwiebusch78/subscriptions,https://api.github.com/users/mwiebusch78/orgs,https://api.github.com/users/mwiebusch78/repos,https://api.github.com/users/mwiebusch78/events{/privacy},https://api.github.com/users/mwiebusch78/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6614/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
357,https://api.github.com/repos/dask/dask/issues/6627,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6627/labels{/name},https://api.github.com/repos/dask/dask/issues/6627/comments,https://api.github.com/repos/dask/dask/issues/6627/events,https://github.com/dask/dask/pull/6627,699492202,MDExOlB1bGxSZXF1ZXN0NDg1MjI3NzMx,6627,add support for nlargest in SeriesGroupBy,[],open,False,,[],,23,2020-09-11T16:09:25Z,2022-03-11T23:20:16Z,,CONTRIBUTOR,,"- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask`

Closes https://github.com/dask/dask/issues/6161

The test fails for a very minor reason, I could use some help there.
",,https://api.github.com/repos/dask/dask/issues/6627/timeline,,,madhur-tandon,20173739,MDQ6VXNlcjIwMTczNzM5,https://avatars.githubusercontent.com/u/20173739?v=4,,https://api.github.com/users/madhur-tandon,https://github.com/madhur-tandon,https://api.github.com/users/madhur-tandon/followers,https://api.github.com/users/madhur-tandon/following{/other_user},https://api.github.com/users/madhur-tandon/gists{/gist_id},https://api.github.com/users/madhur-tandon/starred{/owner}{/repo},https://api.github.com/users/madhur-tandon/subscriptions,https://api.github.com/users/madhur-tandon/orgs,https://api.github.com/users/madhur-tandon/repos,https://api.github.com/users/madhur-tandon/events{/privacy},https://api.github.com/users/madhur-tandon/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6627/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6627,https://github.com/dask/dask/pull/6627,https://github.com/dask/dask/pull/6627.diff,https://github.com/dask/dask/pull/6627.patch,,,,,,,,,,,,,,,,,,,
358,https://api.github.com/repos/dask/dask/issues/6635,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6635/labels{/name},https://api.github.com/repos/dask/dask/issues/6635/comments,https://api.github.com/repos/dask/dask/issues/6635/events,https://github.com/dask/dask/issues/6635,701073845,MDU6SXNzdWU3MDEwNzM4NDU=,6635,construction of and interactions between different types of nested duck arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,2,2020-09-14T13:01:08Z,2021-10-14T04:26:27Z,,CONTRIBUTOR,,"Part of the discussion in #5329. I'm opening this issue to make the discussion on this topic a bit more focused.

As mentioned in https://github.com/dask/dask/issues/5329#issuecomment-691992501, we need to find a way to
- make sure that nesting duck arrays are always nested in the same way (e.g. that `pint(dask(numpy))` is chosen over `dask(pint(numpy))`)
- decide which duck array should implement interactions with another duck array (which is important to make sure commutative operations are actually commutative)

Parts of this have already been discussed in #6393.

---

To solve both of these issues, the type hierarchy from hgrecco/pint#845 could be used, but we'd still need to figure out how to compare within that hierarchy, and we'd probably have to maintain a package that collects the relationships between different packages.

Similarly, we could have duck arrays maintain a list of duck arrays they *can* wrap. This is still pretty static and might grow too much for packages that are fairly high in the type hierarchy, but would allow to granularly control the interaction with other duck arrays.

In #6393, it was suggested to divide duck arrays into categories and then have duck arrays in categories with a higher number take care of those in a category with a lower number. However, this breaks down as soon as you have duck arrays that belong to multiple categories (or have two duck arrays that belong to the same category wrap each other), and adding new categories is difficult (at least for numeric numbers).

Using that idea, we could have duck arrays declare a tuple of categories they belong to and then a tuple of categories they can wrap. We could then compute a set operation to decide which is wrapped, but this still breaks down for coarse categories (duck arrays in the same category wrapping each other) and circular graphs (i.e. A is in categories `x` and `z` and can wrap `y` while `B` is in category `y` and can wrap `x`)  not sure if that's an issue?
",,https://api.github.com/repos/dask/dask/issues/6635/timeline,,,keewis,14808389,MDQ6VXNlcjE0ODA4Mzg5,https://avatars.githubusercontent.com/u/14808389?v=4,,https://api.github.com/users/keewis,https://github.com/keewis,https://api.github.com/users/keewis/followers,https://api.github.com/users/keewis/following{/other_user},https://api.github.com/users/keewis/gists{/gist_id},https://api.github.com/users/keewis/starred{/owner}{/repo},https://api.github.com/users/keewis/subscriptions,https://api.github.com/users/keewis/orgs,https://api.github.com/users/keewis/repos,https://api.github.com/users/keewis/events{/privacy},https://api.github.com/users/keewis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6635/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
359,https://api.github.com/repos/dask/dask/issues/6636,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6636/labels{/name},https://api.github.com/repos/dask/dask/issues/6636/comments,https://api.github.com/repos/dask/dask/issues/6636/events,https://github.com/dask/dask/issues/6636,701076438,MDU6SXNzdWU3MDEwNzY0Mzg=,6636,calling methods on wrapped duck arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,2,2020-09-14T13:03:47Z,2021-10-14T04:26:44Z,,CONTRIBUTOR,,"Part of the discussion in #5329. I'm opening this issue to make the discussion on this topic a bit more focused.

As mentioned in #5329 (comment), we need to find a way to
- call methods on wrapped arrays. e.g. with `pint(dask(sparse))`, how do we call `to_dense` and get a `pint(dask(numpy))`, without having `dask` know about `sparse`?

---

To solve this, at the moment `pint` will pass through attribute access for methods it doesn't know. This has a few issues: these methods will remove the nesting (which might sometimes be intended), and it is easy to shadow methods (e.g. a duck array might declare a `magnitude` method).

Instead, we could use type accessors: `arr.sparse.to_dense()` would convert a `pint(dask(sparse))` array to `pint(dask(numpy))` by calling `self._data.sparse.to_dense()` until the name is the name of the type / library. Deciding if the nesting was intentionally removed is pretty difficult, though: maybe only if the result is not a duck array?
This is very explicit, but it involves `__getattr__` to be truly dynamic and might be shadowed by any of the duck array. So I guess to avoid the `__getattr__` magic, and to minimize the attribute shadowing, we could use a method with a string parameter: `arr.array_method(""sparse"").to_dense()` (I'm sure we can come up with a better name).",,https://api.github.com/repos/dask/dask/issues/6636/timeline,,,keewis,14808389,MDQ6VXNlcjE0ODA4Mzg5,https://avatars.githubusercontent.com/u/14808389?v=4,,https://api.github.com/users/keewis,https://github.com/keewis,https://api.github.com/users/keewis/followers,https://api.github.com/users/keewis/following{/other_user},https://api.github.com/users/keewis/gists{/gist_id},https://api.github.com/users/keewis/starred{/owner}{/repo},https://api.github.com/users/keewis/subscriptions,https://api.github.com/users/keewis/orgs,https://api.github.com/users/keewis/repos,https://api.github.com/users/keewis/events{/privacy},https://api.github.com/users/keewis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6636/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
360,https://api.github.com/repos/dask/dask/issues/6637,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6637/labels{/name},https://api.github.com/repos/dask/dask/issues/6637/comments,https://api.github.com/repos/dask/dask/issues/6637/events,https://github.com/dask/dask/issues/6637,701078796,MDU6SXNzdWU3MDEwNzg3OTY=,6637,reprs of nested duck arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,0,2020-09-14T13:05:43Z,2021-10-14T04:26:53Z,,CONTRIBUTOR,,"Part of the discussion in #5329. I'm opening this issue to make the discussion on this topic a bit more focused.

As mentioned in #5329 (comment), we need to find a way to
- construct a `repr` that includes the metadata from all levels of nesting?

---

Simply including the repr of the wrapped array usually results in reprs that are way too long, so instead we could introduce a protocol (or method) that returns a mapping of type names to metadata, and a function to call that protocol. If a duck array does not implement the protocol, the default would be to return `{typename: {}}`.
For example calling `repr(arr)` where `arr` is a `xarray(pint(dask(sparse)))` would make `xarray` call the data's `__metadata__` and use that to construct it's `repr`. This could be something like
```python
def __metadata__(self):
    wrapped_metadata = self._data.__metadata__()
    metadata = {
        ""a"": str(self.a),
        ""b"": str(self.b),
    }
    # or something like {**wrapped_metadata, **{type(self).__qualname__: metadata}
    return wrapped_metadata | {type(self).__qualname__: metadata}
```

In the example, the result of the first call could be something like:
```python
{
    ""sparse.COO"": {""shape"": (30, 1000), ""dtype"": ""float64"", ""nnz"": 768, ""fill_value"": 0},
    ""dask.array.Array"": {""chunks"": (10, 100), ""shape"": (30, 1000), ""dtype"": ""float64""},
    ""pint.Quantity"": {""units"": ""m"", ""shape"": (30, 1000), ""dtype"": ""float64""},
}
```
with that, `xarray` could either manually format the `repr` or use a helper function (which should probably have a `max_width` parameter).

This doesn't work for duck arrays wrapping more than a single duck array, though. Also, I'm not sure if the type name should be the type's `__qualname__`, and if `shape` and `dtype`, which every duck array has to implement as properties, should be included.

xref pydata/xarray#4324, pydata/xarray#4248",,https://api.github.com/repos/dask/dask/issues/6637/timeline,,,keewis,14808389,MDQ6VXNlcjE0ODA4Mzg5,https://avatars.githubusercontent.com/u/14808389?v=4,,https://api.github.com/users/keewis,https://github.com/keewis,https://api.github.com/users/keewis/followers,https://api.github.com/users/keewis/following{/other_user},https://api.github.com/users/keewis/gists{/gist_id},https://api.github.com/users/keewis/starred{/owner}{/repo},https://api.github.com/users/keewis/subscriptions,https://api.github.com/users/keewis/orgs,https://api.github.com/users/keewis/repos,https://api.github.com/users/keewis/events{/privacy},https://api.github.com/users/keewis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6637/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
361,https://api.github.com/repos/dask/dask/issues/6649,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6649/labels{/name},https://api.github.com/repos/dask/dask/issues/6649/comments,https://api.github.com/repos/dask/dask/issues/6649/events,https://github.com/dask/dask/issues/6649,703533521,MDU6SXNzdWU3MDM1MzM1MjE=,6649,Strange behaviour in map_blocks when using empty chunks,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2020-09-17T12:15:15Z,2021-10-14T04:23:56Z,,MEMBER,,"**What happened**:
While playing around with rechunking and `map_blocks` I started getting results which I couldn't readily explain. Specifically, the way empty chunks get handled in a `map_blocks` call (and probably in `blockwise`) after a `rechunk` seems to generate very peculiar results. 

**What you expected to happen**:
I would expect empty chunks to be passed in as an empty array or `None`.

**Minimal Complete Verifiable Example**:

```python
import dask.array as da

a = da.ones(5)
b = a.rechunk({0: (0, 5, 0)})
c = b.map_blocks(lambda x: x, dtype=int)

print(c.compute())
# ['1.0' '1.0' '1.0' '1.0' '1.0'
#  'rechunk-merge-6fad39db5dc73de6e4bc404c4ae4dbbb' '1'
#  'rechunk-merge-6fad39db5dc73de6e4bc404c4ae4dbbb' '2']
```

**Anything else we need to know?**:
The above would not be all that surprising if the numerical values were between the task names - that would at least suggest that the chunks were correctly aligned with the task, e.g.:
```python
# ['rechunk-merge-6fad39db5dc73de6e4bc404c4ae4dbbb' '0'
#  '1.0' '1.0' '1.0' '1.0' '1.0'
#  'rechunk-merge-6fad39db5dc73de6e4bc404c4ae4dbbb' '2']
```
I was attempting to use this behaviour to manufacture chunks in cases where the input is sparse and you don't necessarily have data in every chunk. I also appreciate that this might not be the best way of doing things, but I found this result interesting and confusing enough to maybe flag as a bug.

**Environment**:

- Dask version: 2.26.0
- Python version: 3.6.9
- Operating System: Pop!_OS 18.04 LTS
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/6649/timeline,,,JSKenyon,6582745,MDQ6VXNlcjY1ODI3NDU=,https://avatars.githubusercontent.com/u/6582745?v=4,,https://api.github.com/users/JSKenyon,https://github.com/JSKenyon,https://api.github.com/users/JSKenyon/followers,https://api.github.com/users/JSKenyon/following{/other_user},https://api.github.com/users/JSKenyon/gists{/gist_id},https://api.github.com/users/JSKenyon/starred{/owner}{/repo},https://api.github.com/users/JSKenyon/subscriptions,https://api.github.com/users/JSKenyon/orgs,https://api.github.com/users/JSKenyon/repos,https://api.github.com/users/JSKenyon/events{/privacy},https://api.github.com/users/JSKenyon/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6649/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
362,https://api.github.com/repos/dask/dask/issues/6659,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6659/labels{/name},https://api.github.com/repos/dask/dask/issues/6659/comments,https://api.github.com/repos/dask/dask/issues/6659/events,https://github.com/dask/dask/issues/6659,706226755,MDU6SXNzdWU3MDYyMjY3NTU=,6659,Merge returns duplicate indices,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,6,2020-09-22T09:40:14Z,2021-02-05T15:35:39Z,,NONE,,"When merging a dask dataframe, the resulting index is duplicated - seems to be because of the number of partitions. See example below:

```python
import pandas as pd
import dask.dataframe as dd

a = dd.from_pandas(pd.DataFrame({'a': [1,2,3,4]}), npartitions=2)
b = pd.DataFrame({'a': [1,2,3,4], 'b': [2,3,4,5]})

a.merge(b, on='a').compute()
```
Returns

|   | a | b |
|---|---|---|
| 0 | 1 | 2 |
| 1 | 2 | 3 |
| 0 | 3 | 4 |
| 1 | 4 | 5 |

**Environment**:

- Dask version: 2.27.0
- Python version: 3.8.5
- Operating System: Mac OS
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/6659/timeline,,,tadej-redstone,69796623,MDQ6VXNlcjY5Nzk2NjIz,https://avatars.githubusercontent.com/u/69796623?v=4,,https://api.github.com/users/tadej-redstone,https://github.com/tadej-redstone,https://api.github.com/users/tadej-redstone/followers,https://api.github.com/users/tadej-redstone/following{/other_user},https://api.github.com/users/tadej-redstone/gists{/gist_id},https://api.github.com/users/tadej-redstone/starred{/owner}{/repo},https://api.github.com/users/tadej-redstone/subscriptions,https://api.github.com/users/tadej-redstone/orgs,https://api.github.com/users/tadej-redstone/repos,https://api.github.com/users/tadej-redstone/events{/privacy},https://api.github.com/users/tadej-redstone/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6659/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
363,https://api.github.com/repos/dask/dask/issues/6672,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6672/labels{/name},https://api.github.com/repos/dask/dask/issues/6672/comments,https://api.github.com/repos/dask/dask/issues/6672/events,https://github.com/dask/dask/issues/6672,709093997,MDU6SXNzdWU3MDkwOTM5OTc=,6672,Dask Array's NEP-13 and NEP-18 protocols should use common utils,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2020-09-25T16:39:55Z,2022-08-25T18:19:46Z,,MEMBER,,"`NEP-{13, 18}` could and should use common codebase where possible. This issue is a follow up from https://github.com/dask/dask/pull/6632#issuecomment-697869991.

For example:
 * `chunk_types` has both `is_valid_chunk_type` (NEP-18) and `is_valid_array_chunk` (NEP-13), this could be simplified and consolidated
 * `__array_function__` (NEP-18) should probably generalise `_should_delegate` and both `__array_ufunc__` (NEP-13) and `__array_function__` (NEP-18) should just use general `_should_delegate`

**Environment**:

- Dask version: 2.17.0/master",,https://api.github.com/repos/dask/dask/issues/6672/timeline,,,ravwojdyla,1419010,MDQ6VXNlcjE0MTkwMTA=,https://avatars.githubusercontent.com/u/1419010?v=4,,https://api.github.com/users/ravwojdyla,https://github.com/ravwojdyla,https://api.github.com/users/ravwojdyla/followers,https://api.github.com/users/ravwojdyla/following{/other_user},https://api.github.com/users/ravwojdyla/gists{/gist_id},https://api.github.com/users/ravwojdyla/starred{/owner}{/repo},https://api.github.com/users/ravwojdyla/subscriptions,https://api.github.com/users/ravwojdyla/orgs,https://api.github.com/users/ravwojdyla/repos,https://api.github.com/users/ravwojdyla/events{/privacy},https://api.github.com/users/ravwojdyla/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6672/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
364,https://api.github.com/repos/dask/dask/issues/6673,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6673/labels{/name},https://api.github.com/repos/dask/dask/issues/6673/comments,https://api.github.com/repos/dask/dask/issues/6673/events,https://github.com/dask/dask/issues/6673,709106248,MDU6SXNzdWU3MDkxMDYyNDg=,6673,Dask Array's NEP-13 should delegate to __array_ufunc__,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2020-09-25T16:53:14Z,2022-08-25T18:19:10Z,,MEMBER,,"Dask Array's binops (`__add__` etc) should delegate to `__array_ufunc__`. This issue is a follow up from https://github.com/dask/dask/pull/6632#issuecomment-697869991.

This kind of routing from binops to `__array_ufunc__` is the [recommended solution from NEP-13](https://numpy.org/neps/nep-0013-ufunc-overrides.html#recommendations-for-implementing-binary-operations). Right now for example (`arr` is a Dask Array) `np.add(arr, x)` and `arr + x` uses slightly different code path, which introduces a chance for bugs, inconsistencies etc. To be clear, in the example above `np.add(arr, x)` is routing via NEP-13's `__array_ufunc__`, whilst `arr + x` is routing via python's `__add__`, and `__add__` doesn't delegate to `__array_ufunc__`, which I would argue it should.

A solution to this would be to just implement the suggested NEP-13 routing via `__array_ufunc__` and make sure that `__array_ufunc__` properly handles delegations from binops.

**Environment**:

- Dask version: 2.27.0/master
",,https://api.github.com/repos/dask/dask/issues/6673/timeline,,,ravwojdyla,1419010,MDQ6VXNlcjE0MTkwMTA=,https://avatars.githubusercontent.com/u/1419010?v=4,,https://api.github.com/users/ravwojdyla,https://github.com/ravwojdyla,https://api.github.com/users/ravwojdyla/followers,https://api.github.com/users/ravwojdyla/following{/other_user},https://api.github.com/users/ravwojdyla/gists{/gist_id},https://api.github.com/users/ravwojdyla/starred{/owner}{/repo},https://api.github.com/users/ravwojdyla/subscriptions,https://api.github.com/users/ravwojdyla/orgs,https://api.github.com/users/ravwojdyla/repos,https://api.github.com/users/ravwojdyla/events{/privacy},https://api.github.com/users/ravwojdyla/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6673/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
365,https://api.github.com/repos/dask/dask/issues/6691,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6691/labels{/name},https://api.github.com/repos/dask/dask/issues/6691/comments,https://api.github.com/repos/dask/dask/issues/6691/events,https://github.com/dask/dask/issues/6691,712637403,MDU6SXNzdWU3MTI2Mzc0MDM=,6691,Support from_pandas with known divisions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2020-10-01T08:52:00Z,2023-09-29T09:29:40Z,,NONE,,"It can be beneficial to create a distributed dataframe from an in-memory one with known divisions.

```python
from dask import dataframe as dd
import pandas as pd

df = pd.DataFrame({'a': [1,2,3], 'b': [11,22,33]})
ddf = dd.from_pandas(df, divisions=[0, 1, 2, 2])

>>> ddf.npartitions
3

>>> ddf.divisions
(0, 1, 2, 2)

>>> ddf.partitions[1].compute()
   a   b
1  2  22
```

One use case is when you want to save to disk in-memory data in a partitioned format, such that it will be exactly aligned to existing partitioned data, thus enabling efficient one-to-one merge operations.",,https://api.github.com/repos/dask/dask/issues/6691/timeline,,,syagev,5247438,MDQ6VXNlcjUyNDc0Mzg=,https://avatars.githubusercontent.com/u/5247438?v=4,,https://api.github.com/users/syagev,https://github.com/syagev,https://api.github.com/users/syagev/followers,https://api.github.com/users/syagev/following{/other_user},https://api.github.com/users/syagev/gists{/gist_id},https://api.github.com/users/syagev/starred{/owner}{/repo},https://api.github.com/users/syagev/subscriptions,https://api.github.com/users/syagev/orgs,https://api.github.com/users/syagev/repos,https://api.github.com/users/syagev/events{/privacy},https://api.github.com/users/syagev/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6691/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
366,https://api.github.com/repos/dask/dask/issues/6698,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6698/labels{/name},https://api.github.com/repos/dask/dask/issues/6698/comments,https://api.github.com/repos/dask/dask/issues/6698/events,https://github.com/dask/dask/issues/6698,713211895,MDU6SXNzdWU3MTMyMTE4OTU=,6698,Add dataframe method: duplicated(),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2020-10-01T21:59:35Z,2021-10-14T04:16:21Z,,CONTRIBUTOR,,"I did a quick search and apart from the open issue that lists all dataframe methods that are implemented and missing in dask, I didn't find anything specific.

I just wanted to voice my interest in adding the `duplicated`-method to dask dataframes. However, I am not sure what would be involved in adding this and hence I am opening this issue to get the conversation started. 

Please feel free to close this issue in case this shouldn't be discussed in this issue.",,https://api.github.com/repos/dask/dask/issues/6698/timeline,,,jborchma,20072839,MDQ6VXNlcjIwMDcyODM5,https://avatars.githubusercontent.com/u/20072839?v=4,,https://api.github.com/users/jborchma,https://github.com/jborchma,https://api.github.com/users/jborchma/followers,https://api.github.com/users/jborchma/following{/other_user},https://api.github.com/users/jborchma/gists{/gist_id},https://api.github.com/users/jborchma/starred{/owner}{/repo},https://api.github.com/users/jborchma/subscriptions,https://api.github.com/users/jborchma/orgs,https://api.github.com/users/jborchma/repos,https://api.github.com/users/jborchma/events{/privacy},https://api.github.com/users/jborchma/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6698/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
367,https://api.github.com/repos/dask/dask/issues/6703,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6703/labels{/name},https://api.github.com/repos/dask/dask/issues/6703/comments,https://api.github.com/repos/dask/dask/issues/6703/events,https://github.com/dask/dask/issues/6703,714834040,MDU6SXNzdWU3MTQ4MzQwNDA=,6703,Support for more dataframe correlation methods?,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,4,2020-10-05T13:19:01Z,2020-10-20T15:52:03Z,,NONE,,"For a while the dask documentation says that for the `corr` method supports Spearman, Kendall, and Pearson (see https://docs.dask.org/en/latest/dataframe-api.html#dask.dataframe.DataFrame.corr).
However, if you try anything else you get `NotImplementedError: Only Pearson correlation has been implemented`.

Any ETA when this is getting added?

Bonus: the `split_every` argument is not documented and this one is not in the Pandas API.",,https://api.github.com/repos/dask/dask/issues/6703/timeline,,,lfdversluis,3618917,MDQ6VXNlcjM2MTg5MTc=,https://avatars.githubusercontent.com/u/3618917?v=4,,https://api.github.com/users/lfdversluis,https://github.com/lfdversluis,https://api.github.com/users/lfdversluis/followers,https://api.github.com/users/lfdversluis/following{/other_user},https://api.github.com/users/lfdversluis/gists{/gist_id},https://api.github.com/users/lfdversluis/starred{/owner}{/repo},https://api.github.com/users/lfdversluis/subscriptions,https://api.github.com/users/lfdversluis/orgs,https://api.github.com/users/lfdversluis/repos,https://api.github.com/users/lfdversluis/events{/privacy},https://api.github.com/users/lfdversluis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6703/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
368,https://api.github.com/repos/dask/dask/issues/6705,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6705/labels{/name},https://api.github.com/repos/dask/dask/issues/6705/comments,https://api.github.com/repos/dask/dask/issues/6705/events,https://github.com/dask/dask/issues/6705,715081263,MDU6SXNzdWU3MTUwODEyNjM=,6705,Nested parallel processes: how to handle them?,[],open,False,,[],,15,2020-10-05T18:54:30Z,2020-12-16T19:43:54Z,,NONE,,"I couldn't find any satisfactory question (and answer) either in the opened issues or on stackoverflow, so I thought I might as well open an issue myself.

I'll illustrate the problem with my use-case (which is oversimplified below).

1. My dataset contains 30 observations which I divide in 3 subsamples of 10 observation each.
(the real dataset is much bigger and the number of subsamples is much higher)

```
>>> print(len(X))
>>> 30

     subsample1            subsample2            subsample3 
x x x x x x x x x x | x x x x x x x x x x | x x x x x x x x x x | 
0 1 2 3 4 5 6 7 8 9 | 0 1 2 3 4 5 6 7 8 9 | 0 1 2 3 4 5 6 7 8 9 | 

```

2. For each subsample I train a model which needs to be tuned via cross-validation, for example using `GridSearchCV` or `HyperbandSearchCV`. 
Say that I want to validate the `l1` penalty of a `Lasso` regressor using a grid of 50 points, such that I train 50 models for every subsample.

```
from dask import compute, delayed
from dask_ml.model_selection import GridSearchCV
from sklearn.linear_model import Lasso

reg = Lasso()
param_space = np.logspace(1, -9, num=50)
param_grid ={'alpha': param_space}
model = GridSearchCV(reg)
```

In this case the schema would look something like:

```          
              | model0
              | model1
subsample1 -> | ...
              | model49
------------------------
              | model0
              | model1
subsample2 -> | ...
              | model49
------------------------
              | model0
              | model1
subsample3 -> | ...
              | model49
```


As I said, in the real world application I have more than 100 subsamples on which I cross validate the model by training 50 different hyperparameter combinations for each subsample.

I could easily write a code like this:

```
from dask import compute, delayed
from . import load_data, get_subsample

X, y = load_dada()  # load_data is an imaginary function for loading the data
n_subsamples = 100

results = []
for subsample in range(n_subsamples):
    X_train, y_train = get_subsample(X, y, subsample)  # get_subsample is an imaginary function which slices X and y
    results.append(delayed(model.fit)(X_train, y_train))
results = compute(*results)
```

To summarize:
1. Since I parallelized computations across subsamples `dask` is spawning one process for each subsample. 
2. Since within each subsample I use `GridSearchCV`, which also makes use of multiprocessing, this will also try to spawn processes within the process.

In this case we could talk about nested processes.
My questions are:
1. How does dask handle this? If it doesn't handle it already, should it be able to?
2. Is this a bad design and does not have anything to do with dask in the first place?

Many thanks

",,https://api.github.com/repos/dask/dask/issues/6705/timeline,,,gioxc88,41852601,MDQ6VXNlcjQxODUyNjAx,https://avatars.githubusercontent.com/u/41852601?v=4,,https://api.github.com/users/gioxc88,https://github.com/gioxc88,https://api.github.com/users/gioxc88/followers,https://api.github.com/users/gioxc88/following{/other_user},https://api.github.com/users/gioxc88/gists{/gist_id},https://api.github.com/users/gioxc88/starred{/owner}{/repo},https://api.github.com/users/gioxc88/subscriptions,https://api.github.com/users/gioxc88/orgs,https://api.github.com/users/gioxc88/repos,https://api.github.com/users/gioxc88/events{/privacy},https://api.github.com/users/gioxc88/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6705/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
369,https://api.github.com/repos/dask/dask/issues/6709,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6709/labels{/name},https://api.github.com/repos/dask/dask/issues/6709/comments,https://api.github.com/repos/dask/dask/issues/6709/events,https://github.com/dask/dask/issues/6709,715976796,MDU6SXNzdWU3MTU5NzY3OTY=,6709,dask.array slice with da.from_array([0]) has incorrect shape,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2020-10-06T19:49:50Z,2020-10-07T06:53:49Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
I found an example of dask.array slice that has has incorrect shape assigned. 
Although compute works correctly, the mismatch causes problems. 
E.g. when I try to create another array with same chunks without computing the original one.

**What you expected to happen**:
- In following example ``trouble_slice.shape`` and ``trouble_slice.compute().shape`` should be the same.
- The ``da.from_array([[4, 4, 4]], chunks=trouble_slice.chunks)`` should work without raising ``ValueError``

**Minimal Complete Verifiable Example**:

```python
import dask.array as da

arr = da.from_array([[1, 2, 3], [4, 5, 6]])

# expected behavior
# shape match when I slice with [1]
ok_slice = arr[da.from_array([1])]
print(ok_slice.shape)  # (1, 3)
print(ok_slice.compute().shape)  # (1, 3)
# no problem creating another array of expected shape with same chunks
da.from_array([[4, 4, 4]], chunks=ok_slice.chunks)

print('--------------')

# what went wrong
# shape mismatch when I slice with [0]
trouble_slice = arr[da.from_array([0])]
print(trouble_slice.shape)  # (2, 3)
print(trouble_slice.compute().shape)  # (1, 3)
# probably due to shape mismatch demonstrated above following raises
# ValueError: Chunks do not add up to shape. Got chunks=((2,), (3,)), shape=(1, 3)
da.from_array([[4, 4, 4]], chunks=trouble_slice.chunks)

```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2.29.0
- Python version: 3.7.5
- Operating System: Ubuntu
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/6709/timeline,,,mgfinch,6044030,MDQ6VXNlcjYwNDQwMzA=,https://avatars.githubusercontent.com/u/6044030?v=4,,https://api.github.com/users/mgfinch,https://github.com/mgfinch,https://api.github.com/users/mgfinch/followers,https://api.github.com/users/mgfinch/following{/other_user},https://api.github.com/users/mgfinch/gists{/gist_id},https://api.github.com/users/mgfinch/starred{/owner}{/repo},https://api.github.com/users/mgfinch/subscriptions,https://api.github.com/users/mgfinch/orgs,https://api.github.com/users/mgfinch/repos,https://api.github.com/users/mgfinch/events{/privacy},https://api.github.com/users/mgfinch/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6709/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
370,https://api.github.com/repos/dask/dask/issues/6732,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6732/labels{/name},https://api.github.com/repos/dask/dask/issues/6732/comments,https://api.github.com/repos/dask/dask/issues/6732/events,https://github.com/dask/dask/issues/6732,720466563,MDU6SXNzdWU3MjA0NjY1NjM=,6732,HighlevelGraph refactor performance regressions,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,3,2020-10-13T15:58:59Z,2021-10-14T04:10:18Z,,MEMBER,,"https://pandas.pydata.org/speed/dask/#regressions?sort=1&dir=desc turns up some performance regressions related to the recent HLG refactor.

* https://pandas.pydata.org/speed/dask/#array.BlockInfoSingleton.time_optimize_singleton?python=3.7&commits=d4447e77
* https://pandas.pydata.org/speed/dask/#order.OrderRechunkTranspose.time_order_rechunk_transpose?python=3.7&commits=d4447e77
* https://pandas.pydata.org/speed/dask/#array.Blockwise.time_make_blockwise_graph?python=3.7&commits=d4447e77A
* https://pandas.pydata.org/speed/dask/#array.Slicing.time_slice_slice_head?python=3.7&commits=d4447e77 (partly fixed)
* https://pandas.pydata.org/speed/dask/#array.Slicing.time_slice_slice_tail?python=3.7&commits=d4447e77 (partly fixed)
* https://pandas.pydata.org/speed/dask/#array.BlockInfoSingleton.time_optimize_singleton?python=3.7&commits=d4447e77
* https://pandas.pydata.org/speed/dask/#array.Slicing.time_slice_int_tail?python=3.7&commits=d4447e77 (partly fixed)
* https://pandas.pydata.org/speed/dask/#array.Slicing.time_slice_int_head?python=3.7&commits=d4447e77 (partly fixed)

Some slowdown is likely to be expected, but I haven't taken the time to look into it yet. @madsbk or @jrbourbeau do you have a chance to glance through the benchmarks at https://github.com/dask/dask-benchmarks to see if any are concerning?",,https://api.github.com/repos/dask/dask/issues/6732/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6732/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
371,https://api.github.com/repos/dask/dask/issues/6743,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6743/labels{/name},https://api.github.com/repos/dask/dask/issues/6743/comments,https://api.github.com/repos/dask/dask/issues/6743/events,https://github.com/dask/dask/pull/6743,724084508,MDExOlB1bGxSZXF1ZXN0NTA1NTMwMTMz,6743,Pass through supported pandas reader parameters in signatures,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,6,2020-10-18T19:50:57Z,2021-08-25T17:36:47Z,,CONTRIBUTOR,,"- [X] Tests added / passed
- [X] Passes `black dask` / `flake8 dask`

~This PR makes use of an optional dependency on [fastcore](https://fastcore.fast.ai/) to pass through supported parameters of pandas readers (read_csv, etc) in the corresponding dask dataframe function signature.~

~The optional dependency `fastcore` is small, smaller than even `toolz` as a point of reference.~

~If this PR is acceptable, I will also try to get fastcore on conda-forge.~

Hopefully others will find this as awesome as I do:
![image](https://user-images.githubusercontent.com/42480289/96378352-fa571900-1150-11eb-9491-ea80e7efb773.png)


EDIT:
Removed optional dependency based on review feedback.",,https://api.github.com/repos/dask/dask/issues/6743/timeline,,,brl0,42480289,MDQ6VXNlcjQyNDgwMjg5,https://avatars.githubusercontent.com/u/42480289?v=4,,https://api.github.com/users/brl0,https://github.com/brl0,https://api.github.com/users/brl0/followers,https://api.github.com/users/brl0/following{/other_user},https://api.github.com/users/brl0/gists{/gist_id},https://api.github.com/users/brl0/starred{/owner}{/repo},https://api.github.com/users/brl0/subscriptions,https://api.github.com/users/brl0/orgs,https://api.github.com/users/brl0/repos,https://api.github.com/users/brl0/events{/privacy},https://api.github.com/users/brl0/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6743/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6743,https://github.com/dask/dask/pull/6743,https://github.com/dask/dask/pull/6743.diff,https://github.com/dask/dask/pull/6743.patch,,,,,,,,,,,,,,,,,,,
372,https://api.github.com/repos/dask/dask/issues/6746,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6746/labels{/name},https://api.github.com/repos/dask/dask/issues/6746/comments,https://api.github.com/repos/dask/dask/issues/6746/events,https://github.com/dask/dask/pull/6746,724623358,MDExOlB1bGxSZXF1ZXN0NTA1OTc4NTIw,6746,Handle non-uniform chunks when spliting indices,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2020-10-19T13:44:15Z,2021-03-08T20:19:50Z,,MEMBER,,"xref https://github.com/pydata/xarray/issues/4428#issuecomment-712066302.

We previously only handled the case where chunksizes were uniform on the
non-indexing axis. This updates the logic to warn when the size of the
largest chunk created exceeds the threshold.",,https://api.github.com/repos/dask/dask/issues/6746/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6746/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6746,https://github.com/dask/dask/pull/6746,https://github.com/dask/dask/pull/6746.diff,https://github.com/dask/dask/pull/6746.patch,,,,,,,,,,,,,,,,,,,
373,https://api.github.com/repos/dask/dask/issues/6762,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6762/labels{/name},https://api.github.com/repos/dask/dask/issues/6762/comments,https://api.github.com/repos/dask/dask/issues/6762/events,https://github.com/dask/dask/issues/6762,727074147,MDU6SXNzdWU3MjcwNzQxNDc=,6762,memory leak using Dask DataFrame,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,4,2020-10-22T05:59:34Z,2021-10-13T07:06:11Z,,MEMBER,," hello from Chicago!

### What happened:

Running a very small workflow that created a Dask DataFrame with `dd.read_csv()`, then `persist()`ed it, then called `.compute()` on it, a substantial amount of memory was not freed in the cluster.

This memory was not freed even after removing the client that ran the workflow and all references to the Dask DataFrame (by restarting the Jupyter notebook kernel in the notebook client code runs from).

For a workflow that had peak memory usage around 10GB, I observed increasing memory usage across runs. The values below are memory usage in the cluster after restarting the kernel in the client notebook.

* cluster startup: 101.7  MB
* after run 1:  2.45 GB
* after run 2: 2.87 GB
* after run 3: 3.05  GB

### What you expected to happen:

Based on my previous experience and the documentation in https://distributed.dask.org/en/latest/memory.html#managing-memory, I expected that any memory allocated for some tasks would be freed after those tasks completed and all client references to those tasks' results were removed.

### Minimal Complete Verifiable Example:

I found that the easiest way I could reproduce this was with [`dask_cloudprovider.FargateCluster`](https://cloudprovider.dask.org/en/latest/#fargate-ecs), but I did observe the same behavior on a [`dask_kubernetes.KubeCluster`](https://kubernetes.dask.org/en/latest/kubecluster.html).

1. create a `conda` environment and Jupyter kernel to work in
<details><summary>env.yml (click me)</summary>

```yaml
name: daskdev
channels:
  - defaults
dependencies:
  - argon2-cffi=20.1.0
  - async_generator=1.10
  - attrs=20.2.0
  - backcall=0.2.0
  - bleach=3.2.1
  - ca-certificates
  - certifi=2020.6.20
  - cffi=1.14.3
  - decorator=4.4.2
  - defusedxml=0.6.0
  - entrypoints=0.3
  - ipykernel=5.3.4
  - ipython=7.18.1
  - ipython_genutils=0.2.0
  - jedi=0.17.2
  - jinja2=2.11.2
  - jsonschema=3.2.0
  - jupyter_client=6.1.7
  - jupyter_core=4.6.3
  - jupyterlab_pygments=0.1.2
  - libedit=3.1.20191231
  - libffi=3.3
  - libsodium=1.0.18
  - markupsafe=1.1.1
  - mistune=0.8.4
  - nb_conda_kernels
  - nbclient=0.5.1
  - nbconvert=6.0.7
  - nbformat=5.0.8
  - ncurses=6.2
  - nest-asyncio=1.4.1
  - notebook=6.1.4
  - openssl=1.1.1h
  - packaging=20.4
  - pandoc=2.11
  - pandocfilters=1.4.2
  - parso=0.7.0
  - pexpect=4.8.0
  - pickleshare=0.7.5
  - pip=20.2.4
  - prometheus_client=0.8.0
  - prompt-toolkit=3.0.8
  - ptyprocess=0.6.0
  - pycparser=2.20
  - pygments=2.7.1
  - pyparsing=2.4.7
  - pyrsistent=0.17.3
  - python=3.8.5
  - python-dateutil=2.8.1
  - pyzmq=19.0.2
  - readline=8.0
  - send2trash=1.5.0
  - setuptools=50.3.0
  - six=1.15.0
  - sqlite=3.33.0
  - terminado=0.9.1
  - testpath=0.4.4
  - tk=8.6.10
  - tornado=6.0.4
  - traitlets=5.0.5
  - wcwidth=0.2.5
  - webencodings=0.5.1
  - wheel=0.35.1
  - xz=5.2.5
  - zeromq=4.3.3
  - zipp=3.3.1
  - zlib=1.2.11
  - pip:
    - adal==1.2.5
    - aiobotocore==1.1.2
    - aiohttp==3.6.3
    - aioitertools==0.7.0
    - applicationinsights==0.11.9
    - async-timeout==3.0.1
    - azure-common==1.1.25
    - azure-core==1.8.2
    - azure-graphrbac==0.61.1
    - azure-identity==1.4.1
    - azure-mgmt-authorization==0.61.0
    - azure-mgmt-containerregistry==2.8.0
    - azure-mgmt-keyvault==2.2.0
    - azure-mgmt-resource==10.2.0
    - azure-mgmt-storage==11.2.0
    - azureml-automl-core==1.16.0
    - azureml-core==1.16.0.post1
    - azureml-dataprep==2.3.4
    - azureml-dataprep-native==23.0.0
    - azureml-dataprep-rslex==1.1.3
    - azureml-dataset-runtime==1.16.0
    - azureml-pipeline==1.16.0
    - azureml-pipeline-core==1.16.0
    - azureml-pipeline-steps==1.16.0
    - azureml-sdk==1.16.0
    - azureml-telemetry==1.16.0
    - azureml-train==1.16.0
    - azureml-train-automl-client==1.16.0
    - azureml-train-core==1.16.0
    -     azureml-train-restclients-hyperdrive==1.16.0
    - backports-tempfile==1.0
    - backports-weakref==1.0.post1
    - blosc==1.9.2
    - botocore==1.17.44
    - chardet==3.0.4
    - click==7.1.2
    - cloudpickle==1.6.0
    - contextlib2==0.6.0.post1
    - cryptography==3.1.1
    - dask==2.30.0
    - dask-cloudprovider==0.4.1
    - dask-glm==0.2.0
    - dask-ml==1.6.0
    - distributed==2.30.0
    - distro==1.5.0
    - docker==4.3.1
    - docutils==0.15.2
    - dotnetcore2==2.1.17
    - fsspec==0.8.4
    - fusepy==3.0.1
    - heapdict==1.0.1
    - idna==2.10
    - isodate==0.6.0
    - jeepney==0.4.3
    - jmespath==0.10.0
    - joblib==0.17.0
    - jsonpickle==1.4.1
    - llvmlite==0.34.0
    - lz4==3.1.0
    - msal==1.5.1
    - msal-extensions==0.2.2
    - msgpack==1.0.0
    - msrest==0.6.19
    - msrestazure==0.6.4
    - multidict==4.7.6
    - multipledispatch==0.6.0
    - ndg-httpsclient==0.5.1
    - numba==0.51.2
    - numpy==1.19.0
    - oauthlib==3.1.0
    - pandas==1.1.0
    - pathspec==0.8.0
    - portalocker==1.7.1
    - psutil==5.7.2
    - pyarrow==1.0.1
    - pyasn1==0.4.8
    - pyjwt==1.7.1
    - pyopenssl==19.1.0
    - pytz==2020.1
    - pyyaml==5.3.1
    - requests==2.24.0
    - requests-oauthlib==1.3.0
    - ruamel-yaml==0.16.12
    - ruamel-yaml-clib==0.2.2
    - s3fs==0.5.1
    - scikit-learn==0.23.2
    - scipy==1.5.3
    - secretstorage==3.1.2
    - sortedcontainers==2.2.2
    - tblib==1.7.0
    - threadpoolctl==2.1.0
    - toolz==0.11.1
    - typing-extensions==3.7.4.3
    - urllib3==1.25.11
    - websocket-client==0.57.0
    - wrapt==1.12.1
    - yarl==1.5.1
    - zict==2.0.0
```

</details>

```shell
conda env create --name daskdev --file env.yml
source activate daskdev
conda install -y nb_conda_kernels
python -m ipykernel install \
    --user \
    --name daskdev \
    --display-name ""Python (daskdev)""
```

2. [authenticate with AWS](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html#cli-configure-quickstart-creds), then start run Jupyter Lab
    ```shell
    jupyter lab
    ```

3. start up a new notebook using that kernel you just created.

```python
from dask_cloudprovider import FargateCluster

# valid memory + vcpu combinations:
# * https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-cpu-memory-error.html
cluster = FargateCluster(
    image=""daskdev/dask:2.30.0"",
    worker_mem=30720,
    scheduler_mem=30720,
    scheduler_cpu=4096,
    n_workers=1,
    fargate_use_private_ip=False,
    scheduler_timeout=""45 minutes"",
    environment={
        ""EXTRA_PIP_PACKAGES"": ""s3fs""
    }
)

print(cluster.dashboard_link)
print(cluster.scheduler_address)
```

4. Open a new browser window with the result of `print(cluster.dashboard_link)`. Keep it open.
    * record the current memory usage in the cluster. It will probably be on the order of 100 MB
    * ![image](https://user-images.githubusercontent.com/7608904/96830511-27c9ee00-1401-11eb-8228-9c2c38c6aed8.png)

5. Copy the output of `print(cluster.scheduler_address)`. You'll need it in the next step.
6. in another notebook using the kernel created in step 1, run this code (after pasting in the scheduler address)

```python
import dask.dataframe as dd
from dask.distributed import Client, wait

scheduler_address = # PASTE result of cluster.scheduler_address from other noteboook
client = Client(address=scheduler_address)

def get_data_frame():
    ddf = dd.read_csv(
        urlpath=""s3://nyc-tlc/trip data/yellow_tripdata_2018-1*.csv"",
        storage_options={'anon': True}
    )
   ddf = ddf.persist()
    _ = wait(ddf)
    return ddf

def summarize(ddf):
    computed = ddf.compute()
    print(computed.describe())

ddf = get_data_frame()
summarize(ddf)
```

7. When `summarize()` finishes running successfully, restart this notebook's kernel. Return to the Dask dashboard, refresh the page (just to be safe), and record the memory usage in the cluster.
8. Repeat steps 5-6 several times. You should see that after each kernel restart on the client notebook, the cluster has higher memory utilization than it did after the previous restart.

Doing this, I observed the following pattern of memory usage:

* cluster startup: 101.7  MB
* after run 1:  2.45 GB
* after run 2: 2.87 GB
* after run  3: 3.05  GB

The peak memory usage I observed while running the example code was around 10GB, so around 3GB being leaked seems noteworthy.

### Anything else we need to know?

I originally started investigating this today because I was running a workload with [`prefect`'s `DaskExecutor`](https://github.com/PrefectHQ/prefect/blob/ebbec05019f054dd80d64cd12750368002aa9fa0/src/prefect/engine/executors/dask.py) and noticed that each run had less memory available to it than the previous one. After coming up with the reproducible example in this issue, I've convinced myself that the problem I saw has nothing to do with how `prefect` does its Dask stuff.

I did try to do my due diligence looking for other reports of this issue. There are many similar ones, but I didn't see any that involved `s3fs` (which mine indirectly does because it uses `DataFrame.read_csv()`) or which use `DataFrame.persist()`. Related issues that I found:

* https://github.com/dask/dask/issues/3247
* https://github.com/dask/dask/issues/3530
* https://github.com/dask/dask/issues/5864
* https://github.com/dask/dask/issues/6486
* https://github.com/dask/distributed/issues/2068
* https://github.com/dask/distributed/issues/2757
* https://github.com/dask/distributed/issues/3103
* https://github.com/dask/distributed/issues/3201
* https://stackoverflow.com/questions/64046973/dask-memory-leakage-issue-with-json-and-requests/

I did also consult [""Managing Memory""](https://distributed.dask.org/en/latest/memory.html) from the Dask docs and found that VERY helpful!

### Environment:

See the `env.yml` I provided above for the client environment. The scheduler + workers in my example ran in containers using the `daskdev/dask:2.30.0` docker image.

- Dask version:
    - `dask` 2.30.0
    - `distributed` 2.30.0
    - `s3fs` 0.5.1
    - `dask-cloudprovider` 0.4.1
- Python version:
    - 3.8
- Operating System:
    - client on macOS 10.14.6, scheduler and workers in daskdev/dask:2.30.0` image.
- Install method (conda, pip, source):
    - `pip`

<hr>

Thanks for your time and consideration!",,https://api.github.com/repos/dask/dask/issues/6762/timeline,,,jameslamb,7608904,MDQ6VXNlcjc2MDg5MDQ=,https://avatars.githubusercontent.com/u/7608904?v=4,,https://api.github.com/users/jameslamb,https://github.com/jameslamb,https://api.github.com/users/jameslamb/followers,https://api.github.com/users/jameslamb/following{/other_user},https://api.github.com/users/jameslamb/gists{/gist_id},https://api.github.com/users/jameslamb/starred{/owner}{/repo},https://api.github.com/users/jameslamb/subscriptions,https://api.github.com/users/jameslamb/orgs,https://api.github.com/users/jameslamb/repos,https://api.github.com/users/jameslamb/events{/privacy},https://api.github.com/users/jameslamb/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6762/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
374,https://api.github.com/repos/dask/dask/issues/6790,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6790/labels{/name},https://api.github.com/repos/dask/dask/issues/6790/comments,https://api.github.com/repos/dask/dask/issues/6790/events,https://github.com/dask/dask/issues/6790,734891398,MDU6SXNzdWU3MzQ4OTEzOTg=,6790,Master branch returns nan shape when chunktype=xarray.DataArray,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2020-11-02T22:54:55Z,2021-08-15T12:18:23Z,,CONTRIBUTOR,,"**What happened**:

The Satpy project has a travis environment that installs unstable (master branch) versions of dask, xarray, and a couple other libraries. That environment has been failing for at least a couple weeks and I finally had time to track down the issue. Something in xarray or dask master branches is causing an odd use case to return arrays with `nan` in the shape when previously they didn't. The overall use case I think is an accident in one of our unit tests (described below), but the point is that it is failing now because of some change so while I could fix our test I thought I'd make you all aware of this.

**What you expected to happen**:

Dask should produce a known chunk size regardless of chunktype. Like I said though, this is kind of an odd use case.

**Minimal Complete Verifiable Example**:

```python
import xarray as xr
import dask.array as da
import numpy as np

dask_arr = da.zeros((300, 10), dtype=np.float32, chunks=(300, 10))
data_arr = xr.DataArray(dask_arr)
print(da.from_array(data_arr) == 1.7e38)

# result with current dask and xarray master branches (or master of last couple weeks or months even)
# dask.array<eq, shape=(nan, 0), dtype=bool, chunksize=(nan, 0), chunktype=numpy.ndarray>
# result from dask 2.15.0, xarray 0.16.1
# dask.array<eq, shape=(300, 10), dtype=bool, chunksize=(300, 10), chunktype=xarray.DataArray>
```

**Environment**:

- Dask version: See above
- Python version: 3.7 and 3.8 at least
- Operating System: Ubuntu/PopOS
- Install method (conda, pip, source): conda using conda-forge
",,https://api.github.com/repos/dask/dask/issues/6790/timeline,,,djhoese,1828519,MDQ6VXNlcjE4Mjg1MTk=,https://avatars.githubusercontent.com/u/1828519?v=4,,https://api.github.com/users/djhoese,https://github.com/djhoese,https://api.github.com/users/djhoese/followers,https://api.github.com/users/djhoese/following{/other_user},https://api.github.com/users/djhoese/gists{/gist_id},https://api.github.com/users/djhoese/starred{/owner}{/repo},https://api.github.com/users/djhoese/subscriptions,https://api.github.com/users/djhoese/orgs,https://api.github.com/users/djhoese/repos,https://api.github.com/users/djhoese/events{/privacy},https://api.github.com/users/djhoese/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6790/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
375,https://api.github.com/repos/dask/dask/issues/6800,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6800/labels{/name},https://api.github.com/repos/dask/dask/issues/6800/comments,https://api.github.com/repos/dask/dask/issues/6800/events,https://github.com/dask/dask/issues/6800,736236570,MDU6SXNzdWU3MzYyMzY1NzA=,6800,`concurrent.futures._base.CancelledError` with `KubeCluster`.,[],open,False,,[],,9,2020-11-04T16:08:19Z,2020-11-04T19:26:48Z,,CONTRIBUTOR,,"The issue is reproducible on GKE using `KubeCluster`.  With `LocalCluster` it works fine.

``` python
from dask_kubernetes import KubeCluster
from dask.distributed import Client
import distributed
import numpy as np
import dask
import dask.array as da
dask.config.set({""kubernetes.scheduler-service-type"": ""LoadBalancer"",
                 ""kubernetes.scheduler-service-wait-timeout"": 360,
                 ""distributed.comm.timeouts.connect"": 360})
kRows = 1000
kCols = 10

def test_dask_missing_value_reg():
    cluster = KubeCluster.from_yaml('worker-spec.yaml', deploy_mode='remote')
    n_workers = 2
    cluster.scale(n_workers)
    with Client(cluster) as client:
        y = da.random.randint(0, 3, size=20)
        y.rechunk(20)
        y = client.compute(y)
        print('client.futures:', client.futures)

        def _gather_fn(i):
            c = distributed.get_client()  # `c.futures` is empty here, not sure if it's expected.
            m = c.gather(y)  # Just for demonstrating the issue, in practice I'm trying to gather a list of partitions local to current worker.
            return m

        futures = client.map(_gather_fn, [i for i in range(n_workers)])
        results = client.gather(futures)

test_dask_missing_value_reg()
```
worker-spec.yaml:
``` yaml
kind: Pod
metadata:
    labels:
        foo: bar
spec:
    restartPolicy: Never
    containers:
      - image: gcr.io/path
        imagePullPolicy: IfNotPresent
        args: [dask-worker, $(DASK_SCHEDULER_ADDRESS)]
        name: xgboost-testing
        resources:
          limits:
            cpu: ""2""
            memory: 2G
            nvidia.com/gpu: 1
          requests:
            cpu: ""2""
            memory: 2G
```


**What happened**:
```
raceback (most recent call last):
  File ""test.py"", line 31, in <module>
    test_dask_missing_value_reg()
  File ""test.py"", line 29, in test_dask_missing_value_reg
    results = client.gather(futures)
  File ""/home/jiaming/.anaconda/envs/dask_386/lib/python3.8/site-packages/distributed/client.py"", line 1986, in gather
    return self.sync(
  File ""/home/jiaming/.anaconda/envs/dask_386/lib/python3.8/site-packages/distributed/client.py"", line 832, in sync
    return sync(
  File ""/home/jiaming/.anaconda/envs/dask_386/lib/python3.8/site-packages/distributed/utils.py"", line 340, in sync
    raise exc.with_traceback(tb)
  File ""/home/jiaming/.anaconda/envs/dask_386/lib/python3.8/site-packages/distributed/utils.py"", line 324, in f
    result[0] = yield future
  File ""/home/jiaming/.anaconda/envs/dask_386/lib/python3.8/site-packages/tornado/gen.py"", line 735, in run
    value = future.result()
  File ""/home/jiaming/.anaconda/envs/dask_386/lib/python3.8/site-packages/distributed/client.py"", line 1851, in _gather
    raise exception.with_traceback(traceback)
  File ""test.py"", line 25, in _gather_fn
    m = c.gather(y)
  File ""/opt/conda/envs/rapids/lib/python3.8/site-packages/distributed/client.py"", line 1986, in gather
  File ""/opt/conda/envs/rapids/lib/python3.8/site-packages/distributed/client.py"", line 832, in sync
  File ""/opt/conda/envs/rapids/lib/python3.8/site-packages/distributed/utils.py"", line 340, in sync
  File ""/opt/conda/envs/rapids/lib/python3.8/site-packages/distributed/utils.py"", line 324, in f
  File ""/opt/conda/envs/rapids/lib/python3.8/site-packages/tornado/gen.py"", line 735, in run
  File ""/opt/conda/envs/rapids/lib/python3.8/site-packages/distributed/client.py"", line 1852, in _gather
concurrent.futures._base.CancelledError: finalize-1cfb637ec3c9e47e96a9af1bb62f84bc

```

- Dask version:
```
>>> dask.__version__
'2.30.0'
```
- Python version:
```
Python 3.8.6
```
- Operating System:
Ubuntu 20.04

- Install method (conda, pip, source):
conda",,https://api.github.com/repos/dask/dask/issues/6800/timeline,,,trivialfis,16746409,MDQ6VXNlcjE2NzQ2NDA5,https://avatars.githubusercontent.com/u/16746409?v=4,,https://api.github.com/users/trivialfis,https://github.com/trivialfis,https://api.github.com/users/trivialfis/followers,https://api.github.com/users/trivialfis/following{/other_user},https://api.github.com/users/trivialfis/gists{/gist_id},https://api.github.com/users/trivialfis/starred{/owner}{/repo},https://api.github.com/users/trivialfis/subscriptions,https://api.github.com/users/trivialfis/orgs,https://api.github.com/users/trivialfis/repos,https://api.github.com/users/trivialfis/events{/privacy},https://api.github.com/users/trivialfis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6800/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
376,https://api.github.com/repos/dask/dask/issues/6805,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6805/labels{/name},https://api.github.com/repos/dask/dask/issues/6805/comments,https://api.github.com/repos/dask/dask/issues/6805/events,https://github.com/dask/dask/issues/6805,736486549,MDU6SXNzdWU3MzY0ODY1NDk=,6805,Client() control scope of resources,[],open,False,,[],,4,2020-11-04T23:17:31Z,2020-11-05T20:18:08Z,,NONE,,"Currently I cannot see way to manage both GPUs and CPUs using dask ""resources"".

Suppose I have 2 machines each with 1 GPU and 8 cores.  I can set labels for GPU and CPU counts, but dask_cudf/RAPIDS side requires 1 worker/GPU.  But then for any CPU tasks I am suddenly forced to having 1 worker process for an entire node.  I can set nthreads to all cores divided by number of GPUs.  For numpy/panda/scipy things that release GIL that might be kinda ok, but as docs say this is not optimal if something does not release GIL as threads become useless except for I/O.

If I try to add extra workers *just* for CPU resources and have other workers *just* for GPU resources, this does not work either.  Packages like xgboost automatically consume all workers, as the only way to restrict resources currently is to use .compute() or client.submit, but the *client* itself cannot be restricted it seems.  One hits:  https://github.com/dmlc/xgboost/issues/6344  because of this.  If I could call Client() with a ""resources="" argument so any use of that client would be using limited resources like .compute, .submit, then that would work.  But AFAIK, I see no such possibility even though would be more general that current scheme of only allowing for .compute, .submit, etc.

I can use 2 schedulers for each type of resource, but that defeats purpose of scheduling and resource management.  E.g. I know that xgboost is pretty efficient using only GPU and not CPU, so I could run CPU and GPU at same time roughly.  But other packages like lightgbm use alot of CPU even when running on GPU, so such a split of scheduling would drag system to crawl with other dask tasks.

Basically, request is for Client() itself to consume resources requests to limit scope of all dask tasks, not just ones that take explicit resources like .compute, client.submit since often we do not use dask in such a fine-grained way, like for xgboost package we have no such control.

",,https://api.github.com/repos/dask/dask/issues/6805/timeline,,,pseudotensor,2249614,MDQ6VXNlcjIyNDk2MTQ=,https://avatars.githubusercontent.com/u/2249614?v=4,,https://api.github.com/users/pseudotensor,https://github.com/pseudotensor,https://api.github.com/users/pseudotensor/followers,https://api.github.com/users/pseudotensor/following{/other_user},https://api.github.com/users/pseudotensor/gists{/gist_id},https://api.github.com/users/pseudotensor/starred{/owner}{/repo},https://api.github.com/users/pseudotensor/subscriptions,https://api.github.com/users/pseudotensor/orgs,https://api.github.com/users/pseudotensor/repos,https://api.github.com/users/pseudotensor/events{/privacy},https://api.github.com/users/pseudotensor/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6805/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
377,https://api.github.com/repos/dask/dask/issues/6811,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6811/labels{/name},https://api.github.com/repos/dask/dask/issues/6811/comments,https://api.github.com/repos/dask/dask/issues/6811/events,https://github.com/dask/dask/issues/6811,737252268,MDU6SXNzdWU3MzcyNTIyNjg=,6811,Pandas & Dask mean/std result disperancy for timedelta columns,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2020-11-05T20:41:19Z,2021-09-16T14:20:52Z,,NONE,,"Two things dask does differently when computing std and mean for timedelta columns.

For dataframe timedelta columns are dropped and for series different dtype is returned (float64 or numpy.timedelta64, while in pandas it's Timedelta).

Example:

```python
import pandas as pd
import dask.dataframe as dd
import numpy as np

df = pd.DataFrame({""a"": [np.timedelta64(1, 'D'), 
np.timedelta64(2, 'D'), 
np.timedelta64(3, 'D')], ""b"": [1,2,3]})
ddf = dd.from_pandas(df, 2)
 
df.mean()
a    2 days 00:00:00
b                  2
dtype: object

ddf.mean().compute()
b    2.0
dtype: float64

df.std()
a    1 days 00:00:00
b                  1
dtype: object

ddf.std().compute()
a    8.640000e+13
b    1.000000e+00
dtype: float64
 
df.a.mean()
Timedelta('2 days 00:00:00')

ddf.a.mean().compute()
numpy.timedelta64(172800000000000, 'ns')

df.a.std()
Timedelta('1 days 00:00:00')

ddf.a.std().compute()
86400000000000.0
```

",,https://api.github.com/repos/dask/dask/issues/6811/timeline,,,duboviy,6747643,MDQ6VXNlcjY3NDc2NDM=,https://avatars.githubusercontent.com/u/6747643?v=4,,https://api.github.com/users/duboviy,https://github.com/duboviy,https://api.github.com/users/duboviy/followers,https://api.github.com/users/duboviy/following{/other_user},https://api.github.com/users/duboviy/gists{/gist_id},https://api.github.com/users/duboviy/starred{/owner}{/repo},https://api.github.com/users/duboviy/subscriptions,https://api.github.com/users/duboviy/orgs,https://api.github.com/users/duboviy/repos,https://api.github.com/users/duboviy/events{/privacy},https://api.github.com/users/duboviy/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6811/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
378,https://api.github.com/repos/dask/dask/issues/6812,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6812/labels{/name},https://api.github.com/repos/dask/dask/issues/6812/comments,https://api.github.com/repos/dask/dask/issues/6812/events,https://github.com/dask/dask/issues/6812,737301775,MDU6SXNzdWU3MzczMDE3NzU=,6812,Better error message for `to_csv` with distributed worker and non-local filesystem,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,7,2020-11-05T22:06:10Z,2021-09-20T16:56:50Z,,MEMBER,,"I just ran into an issue when trying to use `to_csv` with distributed workers that don't share a file system. I shouldn't have been surprised that writing to a local file system from a distributed worker doesn't work. It shouldn't work. But the error I got was just a `File Not Found` error. That brought me to:https://github.com/dask/dask/issues/2656#issuecomment-343903868 - which was the answer. 

I am wondering if dask might serve a more informative error in these (maybe) typical failure cases just to point people in the right direction. Does that seem reasonable?",,https://api.github.com/repos/dask/dask/issues/6812/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6812/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
379,https://api.github.com/repos/dask/dask/issues/6822,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6822/labels{/name},https://api.github.com/repos/dask/dask/issues/6822/comments,https://api.github.com/repos/dask/dask/issues/6822/events,https://github.com/dask/dask/issues/6822,739308365,MDU6SXNzdWU3MzkzMDgzNjU=,6822,`svd_compressed` should not assume convergence error with nan inputs,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2020-11-09T19:37:46Z,2021-10-14T05:29:09Z,,MEMBER,,"The `svd_compressed` function currently reports a convergence error if inputs are nan some of the time and in other cases returns all nan results.  Examples:

```python
import dask.array as da
import numpy as np

x = da.array([
    [1, 2, 3],
    [1, -2, 8],
    [0, 3, 1],
])
da.linalg.svd_compressed(x, k=2, n_power_iter=0)[0].compute()
# This is fine 

x = da.array([
    [1, 2, 3],
    [1, -2, 8],
    [0, 3, np.nan],
])
da.linalg.svd_compressed(x, k=2, n_power_iter=0)[0].compute()
LinAlgError: SVD did not converge

x = da.array([
    [1, 2],
    [1, -2],
    [0, np.nan],
])
da.linalg.svd_compressed(x, k=2, n_power_iter=0)[0].compute()
array([[nan, nan],
       [nan, nan],
       [nan, nan]])
```

It would be ideal if this error indicated the issue more directly, possibly with scikit-learn-like messages (e.g. ""Input contains NaN, infinity or a value too large for dtype"").  Deferred errors/assertions (https://github.com/dask/dask/issues/97#issuecomment-646117043) would be helpful for that.

A shorter term fix would be to at least update the `LinAlgError` message to note that nan/inf inputs may be responsible.  

",,https://api.github.com/repos/dask/dask/issues/6822/timeline,,,eric-czech,6130352,MDQ6VXNlcjYxMzAzNTI=,https://avatars.githubusercontent.com/u/6130352?v=4,,https://api.github.com/users/eric-czech,https://github.com/eric-czech,https://api.github.com/users/eric-czech/followers,https://api.github.com/users/eric-czech/following{/other_user},https://api.github.com/users/eric-czech/gists{/gist_id},https://api.github.com/users/eric-czech/starred{/owner}{/repo},https://api.github.com/users/eric-czech/subscriptions,https://api.github.com/users/eric-czech/orgs,https://api.github.com/users/eric-czech/repos,https://api.github.com/users/eric-czech/events{/privacy},https://api.github.com/users/eric-czech/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6822/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
380,https://api.github.com/repos/dask/dask/issues/6827,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6827/labels{/name},https://api.github.com/repos/dask/dask/issues/6827/comments,https://api.github.com/repos/dask/dask/issues/6827/events,https://github.com/dask/dask/issues/6827,740391973,MDU6SXNzdWU3NDAzOTE5NzM=,6827,Should Dask drop partition columns when writing to parquet with partition_by?,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,2,2020-11-11T02:13:00Z,2021-10-14T05:27:24Z,,NONE,,"In Spark and I believe Pandas, when you partition by a field and write to parquet, it drops the partition column since the folder path now contains the field data. 

When I write to parquet using the below code, the correct parquet folders are created (i.e. name=XXXX), but the parquet files also have the name field which is the column I partitioned on.  How can I use to_parquet to also drop the partition_on column? 

df.to_parquet(f""s3://data"", engine=""pyarrow"", compression=""snappy"", partition_on=['name'])

Seems like the code on github is supposed to drop the partition column: 
![image](https://user-images.githubusercontent.com/35536427/98756848-36f8e780-2380-11eb-8ee6-f533d055a8f2.png)


- Dask version: 2.20.0
- Python version: 3.8
- Operating System: Debian
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/6827/timeline,,,eric-valente,35536427,MDQ6VXNlcjM1NTM2NDI3,https://avatars.githubusercontent.com/u/35536427?v=4,,https://api.github.com/users/eric-valente,https://github.com/eric-valente,https://api.github.com/users/eric-valente/followers,https://api.github.com/users/eric-valente/following{/other_user},https://api.github.com/users/eric-valente/gists{/gist_id},https://api.github.com/users/eric-valente/starred{/owner}{/repo},https://api.github.com/users/eric-valente/subscriptions,https://api.github.com/users/eric-valente/orgs,https://api.github.com/users/eric-valente/repos,https://api.github.com/users/eric-valente/events{/privacy},https://api.github.com/users/eric-valente/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6827/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
381,https://api.github.com/repos/dask/dask/issues/6828,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6828/labels{/name},https://api.github.com/repos/dask/dask/issues/6828/comments,https://api.github.com/repos/dask/dask/issues/6828/events,https://github.com/dask/dask/issues/6828,740506724,MDU6SXNzdWU3NDA1MDY3MjQ=,6828,Memory surge with da.unique,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,11,2020-11-11T06:35:09Z,2021-03-27T04:08:30Z,,CONTRIBUTOR,,"**What happened**:

I am porting some skimage functionality to dask for histogram matching.  The code seems to work correctly for small examples and unit tests, so I believe it is coded correctly (famous last words, I know).  However, when performing a moderate-sized task, the dask version is goes slow and uses a lot of memory.  The numpy version operates with no such issues on the same data.

**What you expected to happen**:

On a single-chunk moderate example, numpy and dask should give the same performance.  Likely, there is some subtlety to dask I do not appreciate here.

**Minimal Complete Verifiable Example**:

```python

# Numpy code
# Copied for skimage.exposure.histogram_matching.py for comparison
def np_match(source, template, dtype=np.uint16):
    _, src_unique_indices, src_counts = np.unique(source.ravel(), return_inverse=True, return_counts=True)

    tmpl_values, tmpl_counts = np.unique(template.ravel(), return_counts=True)

    src_quantiles = np.cumsum(src_counts) / source.size
    tmpl_quantiles = np.cumsum(tmpl_counts) / template.size

    interp_a_values = np.interp(src_quantiles, tmpl_quantiles, tmpl_values).astype(dtype)

    return interp_a_values[src_unique_indices].reshape(source.shape)

```

```python
# Dask port

def _interpolate(src_quantiles, tmpl_quantiles, tmpl_values, dtype):
    return np.interp(src_quantiles, tmpl_quantiles, tmpl_values).astype(dtype)

def da_match(source, template, dtype=np.uint16):
    _, src_unique_indices, src_counts = da.unique(source.ravel(), return_inverse=True, return_counts=True)

    tmpl_values, tmpl_counts = da.unique(template.ravel(), return_counts=True)

    src_quantiles = da.cumsum(src_counts) / source.size
    tmpl_quantiles = da.cumsum(tmpl_counts) / template.size

    # Debugging here and computing any of the above variables is fast, as expected.  It's this next step,
    # passing the delayed into the map_blocks, which seems to trigger an issue.
    # (Yes, I do understand this is a bottleneck in the graph, and must only use int16 or smaller dtypes.)
    interp_a_values = dask.delayed(_interpolate)(src_quantiles, tmpl_quantiles, tmpl_values, dtype)
    interp_a_values = da.from_delayed(interp_a_values, dtype=dtype, shape=(np.nan, ))  # shape is src_quantiles.shape
    
    def lookup(chunk, values):
        return values[chunk]
    
    result = src_unique_indices.map_blocks(lookup, values=interp_a_values, dtype=interp_a_values.dtype)
    
    return result.reshape(source.shape)
```

Test case:
```python
chn0 = np.random.randint(0, 500, (63, 300, 300), dtype=np.uint16)
chn1 = np.random.randint(0, 500, (63, 300, 300), dtype=np.uint16)

result_np = np_match(chn0, chn1)  # sub-second, no noticable memory usage

result_da = da_match(da.from_array(chn0), da.from_array(chn1)).compute()  # 11 seconds, 50GB
```

**Anything else we need to know?**:

I have experimented with passing a delayed shape to `from_delayed` and using the meta keyword in `map_blocks`.

**Environment**:

- Dask version: 2.30.0
- Python version: 3.8.5
- Operating System: Ubuntu 20.4
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/6828/timeline,,,chrisroat,1053153,MDQ6VXNlcjEwNTMxNTM=,https://avatars.githubusercontent.com/u/1053153?v=4,,https://api.github.com/users/chrisroat,https://github.com/chrisroat,https://api.github.com/users/chrisroat/followers,https://api.github.com/users/chrisroat/following{/other_user},https://api.github.com/users/chrisroat/gists{/gist_id},https://api.github.com/users/chrisroat/starred{/owner}{/repo},https://api.github.com/users/chrisroat/subscriptions,https://api.github.com/users/chrisroat/orgs,https://api.github.com/users/chrisroat/repos,https://api.github.com/users/chrisroat/events{/privacy},https://api.github.com/users/chrisroat/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6828/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
382,https://api.github.com/repos/dask/dask/issues/6833,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6833/labels{/name},https://api.github.com/repos/dask/dask/issues/6833/comments,https://api.github.com/repos/dask/dask/issues/6833/events,https://github.com/dask/dask/issues/6833,742083076,MDU6SXNzdWU3NDIwODMwNzY=,6833,Massive memory (100GB) used by dask-scheduler,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,31,2020-11-13T02:51:46Z,2021-10-14T05:24:50Z,,NONE,,"Using rapids 0.14 with dask 2.17.0 python 3.6, conda, Ubuntu 16.04

I'm running xgboost using dask on GPUs.  I do:

1) convert in-memory numpy frame -> dask distributed frame using from_array()
2) chunk the frames sufficiently for every worker (here 3 nodes, 2 GPUs/node each) has data as required so xgboost does not hang
3) Run dataset like 5M rows x 10 columns of airlines data

Notes:
1) Every time 1-3 is done it is in an isolate fork that dies at end of the fit.  So whatever instances of client etc. are destroyed.  Nothing remains on GPU, nothing remains in a process since it's gone.  So I don't believe I need a client.close() call.
2) Even though these forks are gone, within the code I'm always using client as a context manager within a `with` statement.  So again shouldn't need a client.close() call or something like that.

I see my application use reasonable amount of memory based upon that dataset.  I see workers using not much memory at all, like 2-3%.

However, the dask-scheduler is using 70% of my 128GB system!  I don't understand how/why since the scheduler shouldn't hold data as far as I understand.  Perhaps the above sequence of sending dask frame to xgboost is a problem, but it would be odd that task graph is forced to hold data.

Even if a single graph held data, which is already a problem, there's no way 90GB are needed to hold the data involved, so it's like there is repeatedly old data being stored.

![image](https://user-images.githubusercontent.com/2249614/99022254-35adf300-2517-11eb-837a-2e750940c7dc.png)

I don't have code to share to repro since it's not easy to extract, but I'm hoping still for ideas.  I will work on a repro, but any fixes/ideas would be good.


",,https://api.github.com/repos/dask/dask/issues/6833/timeline,,,pseudotensor,2249614,MDQ6VXNlcjIyNDk2MTQ=,https://avatars.githubusercontent.com/u/2249614?v=4,,https://api.github.com/users/pseudotensor,https://github.com/pseudotensor,https://api.github.com/users/pseudotensor/followers,https://api.github.com/users/pseudotensor/following{/other_user},https://api.github.com/users/pseudotensor/gists{/gist_id},https://api.github.com/users/pseudotensor/starred{/owner}{/repo},https://api.github.com/users/pseudotensor/subscriptions,https://api.github.com/users/pseudotensor/orgs,https://api.github.com/users/pseudotensor/repos,https://api.github.com/users/pseudotensor/events{/privacy},https://api.github.com/users/pseudotensor/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6833/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
383,https://api.github.com/repos/dask/dask/issues/6835,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6835/labels{/name},https://api.github.com/repos/dask/dask/issues/6835/comments,https://api.github.com/repos/dask/dask/issues/6835/events,https://github.com/dask/dask/issues/6835,742439529,MDU6SXNzdWU3NDI0Mzk1Mjk=,6835,Improve randomized SVD support,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,8,2020-11-13T13:11:58Z,2021-10-14T05:29:00Z,,MEMBER,,"The current randomized SVD implementation is based on [Halko 2011](https://arxiv.org/abs/0909.4061) (algorithm 4.3).

Many randomized SVD algorithms have been developed or described well since then, and the improvements in accuracy and/or efficiency from them may be worth trying to implement.

Here is a list of candidate algorithms that could be worth considering, primarily from @RogerMoens and a list @hammer started:

- Algorithm 4.4 of Halko 2011 
  - This extends 4.3 to use QR decomp in the power iteration, which can decrease round-off error
- [Algorithm 971: An Implementation of a Randomized Algorithm for Principal Component Analysis](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5625842/) (Li and Tygert et al. 2017)
    - This discusses using LU rather than QR decomp in the iteration, which is more efficient
    - @RogerMoens may already be working on this as outlined in https://github.com/dask/dask/issues/6757#issuecomment-721818125
- [Randomized algorithms for distributed computation of principal component analysis and singular value decomposition](https://arxiv.org/pdf/1612.08709.pdf) (Li and Tygert et al. 2018)
    - This paper focuses on Spark implementations, which could make for a useful contrast
    - It concludes that ""Carefully honed algorithms yield results that are uniformly superior to those of the stock, deterministic implementations in Spark"", though it's not clear to me how much ""honing"" is necessary
    - It suggests replacing standard gaussian projection matrices with chained DFT matrices (to make them orthogonal presumably?)
    - It builds SVD for arbitrary matrices based on algorithms for tall-skinny matrices (like the current dask implementations)
    - It mentions that Spark's default TSQR is not numerically stable for rank-deficient matrices -- I wonder if dask.linalg.tsqr is?
    - It also mentions that Spark will ""without warning return left singular vectors that are far from numerically orthonormal"" but ""a significantly burnished randomized implementation generates left singular vectors that are numerically orthonormal to nearly the machine precision"", which may have implications for our tests like https://github.com/dask/dask/blob/aeb78158cedd30c640ecb26581b073db53222628/dask/array/tests/test_linalg.py#L478
- [Computing rank-revealing factorizations of matrices stored out-of-core](https://arxiv.org/pdf/2002.06960.pdf) (Heavner and Martinsson 2020) 
    - As @hammer points out, this is new work from Per-Gunnar Martinsson, who advised on Nathan Halko's PhD 
    - There are two methods described here:
        - > The first is a blocked version of column pivoted Householder QR, organized as a left-looking method to minimize the number of write operations (which are more expensive than read operations on a spinning disk drive)
        - > The second method results in a so called UTV factorization which expresses a matrix A as A = UT V  where U and V are unitary, and T is triangular. 
    - Unlike the 2018 Tygert paper, this defines algorithms that do not build on tall-skinny QR decompositions
- [A Survey of Singular Value Decomposition Methods for Distributed Tall/Skinny Data](https://arxiv.org/pdf/2009.00761.pdf) (Schmidt 2020)
    - Mentioned by @RogerMoens at https://github.com/dask/dask/issues/6757#issuecomment-726667241
    - Compares MPI algorithms for tall skinny SVD
    - Discusses high level differences between MapReduce (via Spark) and MPI implementations

This should be a good place to track anything we find relating to benchmarking, approximation error, characterizing input matrix constraints, algorithm limitations/improvements, etc.  ",,https://api.github.com/repos/dask/dask/issues/6835/timeline,,,eric-czech,6130352,MDQ6VXNlcjYxMzAzNTI=,https://avatars.githubusercontent.com/u/6130352?v=4,,https://api.github.com/users/eric-czech,https://github.com/eric-czech,https://api.github.com/users/eric-czech/followers,https://api.github.com/users/eric-czech/following{/other_user},https://api.github.com/users/eric-czech/gists{/gist_id},https://api.github.com/users/eric-czech/starred{/owner}{/repo},https://api.github.com/users/eric-czech/subscriptions,https://api.github.com/users/eric-czech/orgs,https://api.github.com/users/eric-czech/repos,https://api.github.com/users/eric-czech/events{/privacy},https://api.github.com/users/eric-czech/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6835/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
384,https://api.github.com/repos/dask/dask/issues/6843,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6843/labels{/name},https://api.github.com/repos/dask/dask/issues/6843/comments,https://api.github.com/repos/dask/dask/issues/6843/events,https://github.com/dask/dask/pull/6843,743256300,MDExOlB1bGxSZXF1ZXN0NTIxMTk1MTI3,6843,feat: use blake3 for byte hashing,[],open,False,,[],,4,2020-11-15T13:23:53Z,2021-03-08T20:19:51Z,,CONTRIBUTOR,,"This is using blake3, which is a multithreaded hasher: 
https://github.com/BLAKE3-team/BLAKE3

It's 5x faster on a 32core machine than cityhash, 2x faster on a quadcore than xxhash.

Python binding (pypi wheel available)
https://github.com/oconnor663/blake3-py
Conda-forge in the pipeline:
https://github.com/conda-forge/staged-recipes/pull/12703

Might be an interesting hasher, I'm using this in Vaex, but I prefer to use the dask machinery, without losing the blake3 performance.",,https://api.github.com/repos/dask/dask/issues/6843/timeline,,,maartenbreddels,1765949,MDQ6VXNlcjE3NjU5NDk=,https://avatars.githubusercontent.com/u/1765949?v=4,,https://api.github.com/users/maartenbreddels,https://github.com/maartenbreddels,https://api.github.com/users/maartenbreddels/followers,https://api.github.com/users/maartenbreddels/following{/other_user},https://api.github.com/users/maartenbreddels/gists{/gist_id},https://api.github.com/users/maartenbreddels/starred{/owner}{/repo},https://api.github.com/users/maartenbreddels/subscriptions,https://api.github.com/users/maartenbreddels/orgs,https://api.github.com/users/maartenbreddels/repos,https://api.github.com/users/maartenbreddels/events{/privacy},https://api.github.com/users/maartenbreddels/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6843/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6843,https://github.com/dask/dask/pull/6843,https://github.com/dask/dask/pull/6843.diff,https://github.com/dask/dask/pull/6843.patch,,,,,,,,,,,,,,,,,,,
385,https://api.github.com/repos/dask/dask/issues/6844,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6844/labels{/name},https://api.github.com/repos/dask/dask/issues/6844/comments,https://api.github.com/repos/dask/dask/issues/6844/events,https://github.com/dask/dask/pull/6844,743314299,MDExOlB1bGxSZXF1ZXN0NTIxMjM3MjY1,6844,fix: tokenize / hash collision between list/set/dict/range possible,[],open,False,,[],,3,2020-11-15T18:23:37Z,2021-03-08T20:19:51Z,,CONTRIBUTOR,,"Hi,

Not 100% if a feature or a bug, but this may lead to strange results if results depend on the type of the argument.
`range` did not have any issues, but it may collide with 3rd party libraries doing the same normalization, so I thought it is saver to prefix that with the type name as well.

cheers,

Maarten Breddels",,https://api.github.com/repos/dask/dask/issues/6844/timeline,,,maartenbreddels,1765949,MDQ6VXNlcjE3NjU5NDk=,https://avatars.githubusercontent.com/u/1765949?v=4,,https://api.github.com/users/maartenbreddels,https://github.com/maartenbreddels,https://api.github.com/users/maartenbreddels/followers,https://api.github.com/users/maartenbreddels/following{/other_user},https://api.github.com/users/maartenbreddels/gists{/gist_id},https://api.github.com/users/maartenbreddels/starred{/owner}{/repo},https://api.github.com/users/maartenbreddels/subscriptions,https://api.github.com/users/maartenbreddels/orgs,https://api.github.com/users/maartenbreddels/repos,https://api.github.com/users/maartenbreddels/events{/privacy},https://api.github.com/users/maartenbreddels/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6844/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/6844,https://github.com/dask/dask/pull/6844,https://github.com/dask/dask/pull/6844.diff,https://github.com/dask/dask/pull/6844.patch,,,,,,,,,,,,,,,,,,,
386,https://api.github.com/repos/dask/dask/issues/6857,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6857/labels{/name},https://api.github.com/repos/dask/dask/issues/6857/comments,https://api.github.com/repos/dask/dask/issues/6857/events,https://github.com/dask/dask/issues/6857,746564794,MDU6SXNzdWU3NDY1NjQ3OTQ=,6857,Support for lazy dask.array.stats.distributions arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2020-11-19T13:02:30Z,2021-10-14T05:22:23Z,,MEMBER,,"It would be helpful if the scipy.stats.distributions ufuncs for common distributions were implemented in dask, e.g.:

```python
from dask.array import stats
import dask.array as da
x = da.asarray([-1, 0, 1])

# Current result
type(stats.distributions.norm.pdf(x)) # -> numpy.ndarray

# Desired result
type(stats.distributions.norm.pdf(x)) # -> dask.array.core.Array
```

Using a workaround like `da.map_blocks(stats.distributions.norm.pdf, x)` is simple enough, but wrapping this within dask would be more convenient.",,https://api.github.com/repos/dask/dask/issues/6857/timeline,,,eric-czech,6130352,MDQ6VXNlcjYxMzAzNTI=,https://avatars.githubusercontent.com/u/6130352?v=4,,https://api.github.com/users/eric-czech,https://github.com/eric-czech,https://api.github.com/users/eric-czech/followers,https://api.github.com/users/eric-czech/following{/other_user},https://api.github.com/users/eric-czech/gists{/gist_id},https://api.github.com/users/eric-czech/starred{/owner}{/repo},https://api.github.com/users/eric-czech/subscriptions,https://api.github.com/users/eric-czech/orgs,https://api.github.com/users/eric-czech/repos,https://api.github.com/users/eric-czech/events{/privacy},https://api.github.com/users/eric-czech/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6857/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
387,https://api.github.com/repos/dask/dask/issues/6861,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6861/labels{/name},https://api.github.com/repos/dask/dask/issues/6861/comments,https://api.github.com/repos/dask/dask/issues/6861/events,https://github.com/dask/dask/issues/6861,746685163,MDU6SXNzdWU3NDY2ODUxNjM=,6861,Could dictionaries returned by dask.config.get also be config objects,"[{'id': 1012929478, 'node_id': 'MDU6TGFiZWwxMDEyOTI5NDc4', 'url': 'https://api.github.com/repos/dask/dask/labels/config', 'name': 'config', 'color': '1586c0', 'default': False, 'description': ''}]",open,False,,[],,5,2020-11-19T15:29:43Z,2020-11-20T15:35:30Z,,MEMBER,,"Assuming we have the following config.

```yaml
# ~/.config/dask/foo.yaml
foo:
  bar:
    baz: ""hello""
```

I can access the deepest nested object with `dask.config.get`.

```python
>>> import dask.config
>>> dask.config.get(""foo.bar.baz"")
'hello'
```

However if I do this in two steps it is not possible because the return value is a regular Python dictionary.

```python
>>> import dask.config
>>> foo = dask.config.get(""foo"")
>>> foo.get(""bar.baz"")
None
```

Instead I must use `dask.config.get` again and pass foo back in.

```python
>>> dask.config.get(""bar.baz"", config=foo)
'hello'
```

It would be nice if when the result for `dask.config.get` is a dictionary then instead it returns something which has the same behaviour.",,https://api.github.com/repos/dask/dask/issues/6861/timeline,,,jacobtomlinson,1610850,MDQ6VXNlcjE2MTA4NTA=,https://avatars.githubusercontent.com/u/1610850?v=4,,https://api.github.com/users/jacobtomlinson,https://github.com/jacobtomlinson,https://api.github.com/users/jacobtomlinson/followers,https://api.github.com/users/jacobtomlinson/following{/other_user},https://api.github.com/users/jacobtomlinson/gists{/gist_id},https://api.github.com/users/jacobtomlinson/starred{/owner}{/repo},https://api.github.com/users/jacobtomlinson/subscriptions,https://api.github.com/users/jacobtomlinson/orgs,https://api.github.com/users/jacobtomlinson/repos,https://api.github.com/users/jacobtomlinson/events{/privacy},https://api.github.com/users/jacobtomlinson/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6861/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
388,https://api.github.com/repos/dask/dask/issues/6865,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6865/labels{/name},https://api.github.com/repos/dask/dask/issues/6865/comments,https://api.github.com/repos/dask/dask/issues/6865/events,https://github.com/dask/dask/issues/6865,746804452,MDU6SXNzdWU3NDY4MDQ0NTI=,6865,add dask.dataframe.read_feather like pandas one,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,4,2020-11-19T17:58:44Z,2021-03-25T17:05:25Z,,NONE,,"Pandas has `read_feather` function, it would be useful to have that in `dask.dataframe` so it will be serving better as drop-in replacement for code that meant to read feather/arrow format.",,https://api.github.com/repos/dask/dask/issues/6865/timeline,,,jangorecki,3627377,MDQ6VXNlcjM2MjczNzc=,https://avatars.githubusercontent.com/u/3627377?v=4,,https://api.github.com/users/jangorecki,https://github.com/jangorecki,https://api.github.com/users/jangorecki/followers,https://api.github.com/users/jangorecki/following{/other_user},https://api.github.com/users/jangorecki/gists{/gist_id},https://api.github.com/users/jangorecki/starred{/owner}{/repo},https://api.github.com/users/jangorecki/subscriptions,https://api.github.com/users/jangorecki/orgs,https://api.github.com/users/jangorecki/repos,https://api.github.com/users/jangorecki/events{/privacy},https://api.github.com/users/jangorecki/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6865/reactions,1,0,0,0,0,0,0,0,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
389,https://api.github.com/repos/dask/dask/issues/6868,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6868/labels{/name},https://api.github.com/repos/dask/dask/issues/6868/comments,https://api.github.com/repos/dask/dask/issues/6868/events,https://github.com/dask/dask/issues/6868,747618370,MDU6SXNzdWU3NDc2MTgzNzA=,6868,`astype()` calls trigger redundant computation when the type is already set,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2020-11-20T16:22:34Z,2021-01-07T08:22:27Z,,CONTRIBUTOR,,"Currently, when I call `df.astype({'x':'int'})` on a dataframe where the column `x` is already an `int`, dask still schedules the task (and it still remains after calling `dask.optimize(df)`)

Based on a reading of dask/dataframe/core.pys definition of `astype()`, I cant see any reason there couldnt be a quick check against types that are already correct and dont need to be cast - am I missing something?

https://github.com/dask/dask/blob/ff3ea6c74e8736a5823d648defcf9164f083d266/dask/dataframe/core.py#L2415-L2436

If my understanding is correct, I'd love to open up a PR with this quick optimisation.",,https://api.github.com/repos/dask/dask/issues/6868/timeline,,,KrishanBhasin,8904718,MDQ6VXNlcjg5MDQ3MTg=,https://avatars.githubusercontent.com/u/8904718?v=4,,https://api.github.com/users/KrishanBhasin,https://github.com/KrishanBhasin,https://api.github.com/users/KrishanBhasin/followers,https://api.github.com/users/KrishanBhasin/following{/other_user},https://api.github.com/users/KrishanBhasin/gists{/gist_id},https://api.github.com/users/KrishanBhasin/starred{/owner}{/repo},https://api.github.com/users/KrishanBhasin/subscriptions,https://api.github.com/users/KrishanBhasin/orgs,https://api.github.com/users/KrishanBhasin/repos,https://api.github.com/users/KrishanBhasin/events{/privacy},https://api.github.com/users/KrishanBhasin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6868/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
390,https://api.github.com/repos/dask/dask/issues/6869,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6869/labels{/name},https://api.github.com/repos/dask/dask/issues/6869/comments,https://api.github.com/repos/dask/dask/issues/6869/events,https://github.com/dask/dask/issues/6869,747641463,MDU6SXNzdWU3NDc2NDE0NjM=,6869,Test Xarray workloads against new high level graph work,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,10,2020-11-20T16:54:29Z,2021-10-14T04:32:03Z,,MEMBER,,"We've been working on moving high level graphs directly to the scheduler.  This should significantly reduce overhead when submitting large graphs.  So far our benchmark workloads have been dataframe workloads.  We should diversify.  

The other main group that often speaks up about task scheduling overhead is the Xarray/Pangeo group, which also handles very large graphs.  It would be useful to establish a workload to optimize that is both representative of task-overhead-sensitive workloads and also simple and easy to run on a laptop or distributed system (we may only see some things when running at scale).  

cc @rabernat if you can point folks to something simple

cc @ian-r-rose this might be an interesting topic for you to engage on.  ",,https://api.github.com/repos/dask/dask/issues/6869/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6869/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
391,https://api.github.com/repos/dask/dask/issues/6884,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6884/labels{/name},https://api.github.com/repos/dask/dask/issues/6884/comments,https://api.github.com/repos/dask/dask/issues/6884/events,https://github.com/dask/dask/issues/6884,749589639,MDU6SXNzdWU3NDk1ODk2Mzk=,6884,Very uneven load distribution,[],open,False,,[],,10,2020-11-24T10:41:08Z,2022-03-28T21:51:44Z,,NONE,,"This issue is similar to [this issue](https://github.com/dask/dask/issues/5158). I have a setup as described in [this SO post](https://stackoverflow.com/questions/64911735/dask-scheduler-empty-graph-not-showing). But the essence is:

```python
from dask.distributed import Client
import dask
from tasks import task1, task2, task3
from conf import con

def runall(**kwargs):
    print(""done"")


def task(table_name, depends_on=None):
    df = pd.read_sql(con=con, query=f""select * from {table_name}"") # read some data from sql, depends on the table how much it is.
    out = df.mean() # some computation of varying expense
    out.to_sql(con=con) 
    return True

def etl():
    client = Client()

    tasks = {}
    tasks['task1'] = dask.delayed(task)('table_1')
    tasks['task2'] = dask.delayed(task)('table_2')
    tasks['task3'] = dask.delayed(task)('table_3', depends_on=tasks['task2'])

     out = dask.delayed(runall)(**tasks)
     out.compute()

```
I've used pandas read and write to sql here,  but in reality these are highly custom functions for talking to oracle and other sql dbs with upserts and what not. They are as fast as sql can be, so there is no gain from switching to the dask dataframe loading style. In the long run we are looking at using parquet or similar but for now this is not an option.

The issue is that all work concentrates on one worker. How can the workers be encouraged to steal from each other. In this case task3 can operate on another worker as the output of task 2 is actually minimal, just a bool to confirm it worked (This can be removed if it solves the problem, I haven't found that it does though).

If not stealing, how else can more equal sharing be encouraged? I don't really want to go and assign tasks to workers as the docs seam to discourage it and it introduces a brittleness that I don't desire.

- Dask version: dask==2.30.0
- Python version: 3.7
- Operating System: python:3.7 Docker image derivative, running on Oracle enterprise linux
- Install method (conda, pip, source): from pip
",,https://api.github.com/repos/dask/dask/issues/6884/timeline,,,icfly2,7895513,MDQ6VXNlcjc4OTU1MTM=,https://avatars.githubusercontent.com/u/7895513?v=4,,https://api.github.com/users/icfly2,https://github.com/icfly2,https://api.github.com/users/icfly2/followers,https://api.github.com/users/icfly2/following{/other_user},https://api.github.com/users/icfly2/gists{/gist_id},https://api.github.com/users/icfly2/starred{/owner}{/repo},https://api.github.com/users/icfly2/subscriptions,https://api.github.com/users/icfly2/orgs,https://api.github.com/users/icfly2/repos,https://api.github.com/users/icfly2/events{/privacy},https://api.github.com/users/icfly2/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6884/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
392,https://api.github.com/repos/dask/dask/issues/6904,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6904/labels{/name},https://api.github.com/repos/dask/dask/issues/6904/comments,https://api.github.com/repos/dask/dask/issues/6904/events,https://github.com/dask/dask/issues/6904,753080690,MDU6SXNzdWU3NTMwODA2OTA=,6904,Dask-ML: Error when fitting K-means model,[],open,False,,[],,4,2020-11-30T01:56:35Z,2020-12-01T15:59:16Z,,NONE,,"**What happened**:

I am following along to this example workbook [here
](https://github.com/dask/dask-examples/blob/master/machine-learning/training-on-large-datasets.ipynb) The only difference is that I am using a remote Dask Cluster on Kubernetes. When I try to fit the model on the training data, my workers are killed.

**What you expected to happen**:

I expected the K-means model to be fitted on the training data and this outputted as the result:

```
KMeans(init_max_iter=2, n_clusters=3, oversampling_factor=10)
```

**Minimal Complete Verifiable Example**:

```python
# connect to dask-gateway proxy
auth = BasicAuth(password=secrets['dask_gateway_secret'])
gateway = Gateway(
    address=""http://<PROXY_ADDRESS>:80"",
    auth=auth
)

options = gateway.cluster_options()
cluster = gateway.new_cluster(options)
cluster.scale(10)
client = cluster.get_client()

X, y = dask_ml.datasets.make_blobs(n_samples=100000,
                                   chunks=10000,
                                   random_state=0,
                                   centers=3
                                  )
X = X.persist()
km = dask_ml.cluster.KMeans(n_clusters=3, init_max_iter=2, oversampling_factor=10)
km.fit(X)
```

I get this error:

```
KilledWorker: (""('from-value-getitem-concatenate-1a4b8dfc0f7e2576373f60d4ed2284da', 1, 0)"", <Worker 'tls://10.76.20.7:41413', name: dask-worker-9cdced85e7b94e3d8c8aec65c019ced0-qtp6v, memory: 0, processing: 11>)
```

From the Kubernetes logs of the dask workers, there seems to be some serialization problem with the pickle protocol 

```
distributed.protocol.pickle - INFO - Failed to deserialize b""\x80\x04\x95n\x06\x00\x00\x00\x00\x00\x00(\x8c\x11dask.optimization\x94\x8c\x10SubgraphCallable\x94\x93\x94(}\x94(\x8c.centers_dense-8908a0302f0a8b5549b4350c5b4986cb\x94\x8c5astype-centers_dense-8908a0302f0a8b5549b4350c5b4986cb\x94h\x05(\x8c\x14numba.core.serialize\x94\x8c\x12_rebuild_reduction\x94\x93\x94(\x8c\x13numba.core.registry\x94\x8c\rCPUDispatcher\x94\x93\x94\x8c$5890b4f0-32c0-11eb-820d-4201ac1e07dd\x94(K\x04C\x04B\r\r\n\x94Bt\x01\x00\x00\xe3\x03\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x08\x00\x00\x00C\x00\x00\x00sp\x00\x00\x00|\x00j\x00d\x01\x19\x00}\x03|\x00j\x00d\x02\x19\x00}\x04t\x01j\x02|\x02|\x04f\x02t\x01j\x03d\x03\x8d\x02}\x05xBt\x04|\x03\x83\x01D\x00]6}\x06x0t\x04|\x04\x83\x01D\x00]$}\x07|\x05|\x01|\x06\x19\x00|\x07f\x02\x05\x00\x19\x00|\x00|\x06|\x07f\x02\x19\x007\x00\x03\x00<\x00q@W\x00q2W\x00|\x05S\x00)\x04N\xe9\x00\x00\x00\x00\xe9\x01\x00\x00\x00)\x01\xda\x05dtype)\x05\xda\x05shape\xda\x02np\xda\x05zeros\xda\x07float64\xda\x05range)\x08\xda\x01X\xda\x06labels\xda\nn_clusters\xda\tn_samples\xda\nn_features\xda\x07centers\xda\x01i\xda\x01j\xa9\x00r\x11\x00\x00\x00\xfaA/opt/conda/lib/python3.7/site-packages/dask_ml/cluster/k_means.py\xda\x0e_centers_denseE\x02\x00\x00s\x0e\x00\x00\x00\x00\x02\n\x01\n\x01\x14\x02\x0e\x01\x0e\x01(\x02\x94\x87\x94}\x94(\x8c\x02np\x94h\x06\x8c\x0f_rebuild_module\x94\x93\x94\x8c\x05numpy\x94\x85\x94R\x94\x8c\x05range\x94\x8c\x08builtins\x94\x8c\x05range\x94\x93\x94\x8c\x08__name__\x94\x8c\x17dask_ml.cluster.k_means\x94u\x8c\x0e_centers_dense\x94Nt\x94}\x94}\x94(\x8c\x05nogil\x94\x88\x8c\x08fastmath\x94\x88\x8c\x08nopython\x94\x88\x8c\x0bboundscheck\x94\x89u\x8c\x06direct\x94\x88]\x94t\x94R\x94\x8c\x02_0\x94(\x8c\ndask.utils\x94\x8c\x05apply\x94\x93\x94\x8c\x10dask.array.chunk\x94\x8c\x06astype\x94\x93\x94]\x94\x8c\x02_2\x94ah\x18\x8c\x04dict\x94\x93\x94]\x94]\x94(\x8c\x0castype_dtype\x94h\x14\x8c\x05dtype\x94\x93\x94\x8c\x02i4\x94\x89\x88\x87\x94R\x94(K\x03\x8c\x01<\x94NNNJ\xff\xff\xff\xffJ\xff\xff\xff\xffK\x00t\x94bea\x86\x94t\x94\x8c\x02_1\x94t\x94uh\x04(\x8c\x02_0\x94\x8c\x02_1\x94\x8c\x02_2\x94\x8c6('concatenate-6a3e052d16683f6d74278c3e2a96e5ce', 3, 0)\x94t\x94\x8c\x11subgraph_callable\x94t\x94R\x94\x8c6('concatenate-6a3e052d16683f6d74278c3e2a96e5ce', 3, 0)\x94K\x03\x8c\t_operator\x94\x8c\x07getitem\x94\x93\x94(h,\x8c\x18sklearn.metrics.pairwise\x94\x8c\x1dpairwise_distances_argmin_min\x94\x93\x94]\x94(\x8c6('concatenate-6a3e052d16683f6d74278c3e2a96e5ce', 3, 0)\x94\x8c\x15numpy.core.multiarray\x94\x8c\x0c_reconstruct\x94\x93\x94h\x14\x8c\x07ndarray\x94\x93\x94K\x00\x85\x94C\x01b\x94\x87\x94R\x94(K\x01K\x03K\x02\x86\x94h8\x8c\x02f8\x94\x89\x88\x87\x94R\x94(K\x03h<NNNJ\xff\xff\xff\xffJ\xff\xff\xff\xffK\x00t\x94b\x89C0:\x12\xe3hTB\xfb\xbf\\\x8e\xb8\x0f5?\x0b@\x9d\x1au\xddIw\x08@<H]rX\xb8\xea?\xad(\x9f\x8a85\xee?\x10d\xacW\x87.\x10@\x94t\x94beh3]\x94(]\x94(\x8c\x06metric\x94\x8c\teuclidean\x94e]\x94(\x8c\rmetric_kwargs\x94h3]\x94]\x94(\x8c\x07squared\x94\x88ea\x86\x94ee\x86\x94t\x94K\x00\x87\x94\x8c6('concatenate-6a3e052d16683f6d74278c3e2a96e5ce', 3, 0)\x94t\x94.""
Traceback (most recent call last):
  File ""/opt/conda/lib/python3.7/site-packages/distributed/protocol/pickle.py"", line 75, in loads
    return pickle.loads(x)
  File ""/opt/conda/lib/python3.7/site-packages/numba/core/serialize.py"", line 40, in _rebuild_reduction
    return cls._rebuild(*args)
  File ""/opt/conda/lib/python3.7/site-packages/numba/core/dispatcher.py"", line 787, in _rebuild
    self = cls(py_func, locals, targetoptions, impl_kind)
  File ""/opt/conda/lib/python3.7/site-packages/numba/core/dispatcher.py"", line 710, in __init__
    pysig = utils.pysignature(py_func)
  File ""/opt/conda/lib/python3.7/inspect.py"", line 3083, in signature
    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)
  File ""/opt/conda/lib/python3.7/inspect.py"", line 2833, in from_callable
    follow_wrapper_chains=follow_wrapped)
  File ""/opt/conda/lib/python3.7/inspect.py"", line 2208, in _signature_from_callable
    raise TypeError('{!r} is not a callable object'.format(obj))
TypeError: ((4, b'B\r\r\n', b'\xe3\x03\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x08\x00\x00\x00C\x00\x00\x00sp\x00\x00\x00|\x00j\x00d\x01\x19\x00}\x03|\x00j\x00d\x02\x19\x00}\x04t\x01j\x02|\x02|\x04f\x02t\x01j\x03d\x03\x8d\x02}\x05xBt\x04|\x03\x83\x01D\x00]6}\x06x0t\x04|\x04\x83\x01D\x00]$}\x07|\x05|\x01|\x06\x19\x00|\x07f\x02\x05\x00\x19\x00|\x00|\x06|\x07f\x02\x19\x007\x00\x03\x00<\x00q@W\x00q2W\x00|\x05S\x00)\x04N\xe9\x00\x00\x00\x00\xe9\x01\x00\x00\x00)\x01\xda\x05dtype)\x05\xda\x05shape\xda\x02np\xda\x05zeros\xda\x07float64\xda\x05range)\x08\xda\x01X\xda\x06labels\xda\nn_clusters\xda\tn_samples\xda\nn_features\xda\x07centers\xda\x01i\xda\x01j\xa9\x00r\x11\x00\x00\x00\xfaA/opt/conda/lib/python3.7/site-packages/dask_ml/cluster/k_means.py\xda\x0e_centers_denseE\x02\x00\x00s\x0e\x00\x00\x00\x00\x02\n\x01\n\x01\x14\x02\x0e\x01\x0e\x01(\x02'), {'np': <module 'numpy' from '/opt/conda/lib/python3.7/site-packages/numpy/__init__.py'>, 'range': <class 'range'>, '__name__': 'dask_ml.cluster.k_means'}, '_centers_dense', None) is not a callable object
```

**Anything else we need to know?**:

No version differences between the python packages on my client and that of my dask workers. 
When I created a dask cluster on my local machine, there are no issues. 

**Environment**:

- Dask version: 2.30
- Distributed version: 2.30.1
- Python version: 3.7.8
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/6904/timeline,,,rileyhun,20649466,MDQ6VXNlcjIwNjQ5NDY2,https://avatars.githubusercontent.com/u/20649466?v=4,,https://api.github.com/users/rileyhun,https://github.com/rileyhun,https://api.github.com/users/rileyhun/followers,https://api.github.com/users/rileyhun/following{/other_user},https://api.github.com/users/rileyhun/gists{/gist_id},https://api.github.com/users/rileyhun/starred{/owner}{/repo},https://api.github.com/users/rileyhun/subscriptions,https://api.github.com/users/rileyhun/orgs,https://api.github.com/users/rileyhun/repos,https://api.github.com/users/rileyhun/events{/privacy},https://api.github.com/users/rileyhun/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6904/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
393,https://api.github.com/repos/dask/dask/issues/6910,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6910/labels{/name},https://api.github.com/repos/dask/dask/issues/6910/comments,https://api.github.com/repos/dask/dask/issues/6910/events,https://github.com/dask/dask/issues/6910,753791687,MDU6SXNzdWU3NTM3OTE2ODc=,6910,"Dask changes decorated class module to ""types"" after calling compute making it impossible to pickle the object",[],open,False,,[],,4,2020-11-30T20:49:20Z,2020-12-01T21:50:36Z,,NONE,,"It was very difficult to find a minimal reproducible example because I was not sure what was causing the issue. 
But now I am sure it is the class decorator because if I remove it the problem is gone.
As you can see in the code below I have a decorated class called `MyClass` and an instance on that class called `my_object`.
Finally have a function called `my_function` which takes the object as input and returns the object itself.
Then I call `compute` in a for loop and gather the results.
Well, before calling compute `MyClass.__module__` is `__main__` but for who knows what mysterious reason after calling compute `MyClass.__module__` is `types` and I am not able to pickle the results unless I manually change the module back to `__main__`. 

This is impacting some production code I have, therefore I would really appreciate even the smallest hint on what could be the cause of this.
Many thanks
Gio 

```
from dask import compute, delayed
from dask.distributed import Client

client = Client()


def class_decorator(klass):
    class Wrapper(klass):

        def new(self):
            return 1

    Wrapper.__qualname__ = klass.__name__
    Wrapper.__name__ = klass.__name__
    return Wrapper


@class_decorator
class MyClass:
    def __init__(self):
        pass


def my_function(obj):
    return obj


my_object = MyClass()
results = []

for i in range(2):
    results.append(delayed(my_function)(my_object))

print('before', MyClass.__module__)
results = compute(*results)
print('after', MyClass.__module__)
print('after', results[0].__module__)
```",,https://api.github.com/repos/dask/dask/issues/6910/timeline,,,gioxc88,41852601,MDQ6VXNlcjQxODUyNjAx,https://avatars.githubusercontent.com/u/41852601?v=4,,https://api.github.com/users/gioxc88,https://github.com/gioxc88,https://api.github.com/users/gioxc88/followers,https://api.github.com/users/gioxc88/following{/other_user},https://api.github.com/users/gioxc88/gists{/gist_id},https://api.github.com/users/gioxc88/starred{/owner}{/repo},https://api.github.com/users/gioxc88/subscriptions,https://api.github.com/users/gioxc88/orgs,https://api.github.com/users/gioxc88/repos,https://api.github.com/users/gioxc88/events{/privacy},https://api.github.com/users/gioxc88/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6910/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
394,https://api.github.com/repos/dask/dask/issues/6928,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6928/labels{/name},https://api.github.com/repos/dask/dask/issues/6928/comments,https://api.github.com/repos/dask/dask/issues/6928/events,https://github.com/dask/dask/issues/6928,756551821,MDU6SXNzdWU3NTY1NTE4MjE=,6928,Document annotation interaction with distributed SchedulerPlugins,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,3,2020-12-03T20:12:03Z,2021-08-11T22:20:48Z,,MEMBER,,"Currently, the method for specifying annotations is [documented](https://docs.dask.org/en/latest/api.html?highlight=annotate#dask.annotate), but their interaction with [distributed SchedulerPlugins](https://distributed.dask.org/en/latest/plugins.html?highlight=SchedulerPlugin#distributed.diagnostics.plugin.SchedulerPlugin) is not.

It would be useful to demonstrate some simple (but powerful) interaction use cases. 

I'd like to take this on as I'll be working with SchedulerPlugins over the next while.",,https://api.github.com/repos/dask/dask/issues/6928/timeline,,,sjperkins,3530212,MDQ6VXNlcjM1MzAyMTI=,https://avatars.githubusercontent.com/u/3530212?v=4,,https://api.github.com/users/sjperkins,https://github.com/sjperkins,https://api.github.com/users/sjperkins/followers,https://api.github.com/users/sjperkins/following{/other_user},https://api.github.com/users/sjperkins/gists{/gist_id},https://api.github.com/users/sjperkins/starred{/owner}{/repo},https://api.github.com/users/sjperkins/subscriptions,https://api.github.com/users/sjperkins/orgs,https://api.github.com/users/sjperkins/repos,https://api.github.com/users/sjperkins/events{/privacy},https://api.github.com/users/sjperkins/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6928/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
395,https://api.github.com/repos/dask/dask/issues/6935,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6935/labels{/name},https://api.github.com/repos/dask/dask/issues/6935/comments,https://api.github.com/repos/dask/dask/issues/6935/events,https://github.com/dask/dask/issues/6935,757239139,MDU6SXNzdWU3NTcyMzkxMzk=,6935,da.histogram returns unexpected results with weights containing NaN,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2020-12-04T16:39:46Z,2020-12-07T17:36:59Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
`da.histogram` doesn't cope with `np.nan` values in the `weights` array. In fact, any bin coming after a bin containing a NaN weight is filled with NaN. 

**What you expected to happen**:
Empty bins to keep being 0, bins with NaN weights to be NaN (see output of same computation with Numpy). 

**Minimal Complete Verifiable Example**:

```python
import numpy as np
import dask.array as da

indxs = np.array([2, 2, 3, 3, 7, 7])
data = np.array([1, 2, np.nan, 5, 10, 15])
s, _ = np.histogram(indxs, bins=10, range=(0,10), weights=data, density=False)
print(""numpy: "", s)

indxs = da.from_array(indxs)
data = da.from_array(data)
s, _ = da.histogram(indxs, bins=10, range=(0,10), weights=data, density=False)
print(""dask: "", s.compute())
```
This outputs:
```
numpy:  [ 0.  0.  3. nan  0.  0.  0. 25.  0.  0.]
dask:  [ 0.  0.  3. nan nan nan nan nan nan nan]
```

**Environment**:

- Dask version: 2.30.0
- Python version: 3.7.8
- Operating System: RHEL 7.8
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/6935/timeline,,,ameraner,49722768,MDQ6VXNlcjQ5NzIyNzY4,https://avatars.githubusercontent.com/u/49722768?v=4,,https://api.github.com/users/ameraner,https://github.com/ameraner,https://api.github.com/users/ameraner/followers,https://api.github.com/users/ameraner/following{/other_user},https://api.github.com/users/ameraner/gists{/gist_id},https://api.github.com/users/ameraner/starred{/owner}{/repo},https://api.github.com/users/ameraner/subscriptions,https://api.github.com/users/ameraner/orgs,https://api.github.com/users/ameraner/repos,https://api.github.com/users/ameraner/events{/privacy},https://api.github.com/users/ameraner/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6935/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
396,https://api.github.com/repos/dask/dask/issues/6956,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6956/labels{/name},https://api.github.com/repos/dask/dask/issues/6956/comments,https://api.github.com/repos/dask/dask/issues/6956/events,https://github.com/dask/dask/issues/6956,762291307,MDU6SXNzdWU3NjIyOTEzMDc=,6956,Dask worker tasks allocation,"[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}]",open,False,,[],,5,2020-12-11T12:17:01Z,2021-08-11T22:04:44Z,,NONE,,"By default, looks like dask would distribute tasks at the time when they are submitted. If we have a task run time depends on input and some input may cause the task run much longer than other, we may end up with all long running tasks assigned to one worker. Here is an example to illustrate the issue: 

```
import time
from distributed import Client, wait


def uneven_task(num):
    """"""If num is odd number, it will take much longer to complete""""""
    print(f""Running task {num}"")
    if num % 2 != 0:
        time.sleep(num*100)
    print(f""Task {num} has finished. Worker is free."")


if __name__ == ""__main__"":
    client = Client(address=""xx.xxx.xx.xx:8786"")
    futures = []
    for i in range(10):
        future = client.submit(uneven_task, i, priority=1)
        futures.append(future)

    wait(futures)
```
2 workers started. 10 tasks submitted. Odd number input will lead to a long task, but even number task will be quick. I can see all 5 short tasks allocate to one worker and the other 5 long running tasks all allocate to the other workers. 
![image](https://user-images.githubusercontent.com/31155357/101902515-aeea4580-3baa-11eb-8f41-0a2463023fa0.png)

Is there any way we can config dask only assign task when worker is free instead of allocate them at the time when tasks are submitted?",,https://api.github.com/repos/dask/dask/issues/6956/timeline,,,ben10he,31155357,MDQ6VXNlcjMxMTU1MzU3,https://avatars.githubusercontent.com/u/31155357?v=4,,https://api.github.com/users/ben10he,https://github.com/ben10he,https://api.github.com/users/ben10he/followers,https://api.github.com/users/ben10he/following{/other_user},https://api.github.com/users/ben10he/gists{/gist_id},https://api.github.com/users/ben10he/starred{/owner}{/repo},https://api.github.com/users/ben10he/subscriptions,https://api.github.com/users/ben10he/orgs,https://api.github.com/users/ben10he/repos,https://api.github.com/users/ben10he/events{/privacy},https://api.github.com/users/ben10he/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6956/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
397,https://api.github.com/repos/dask/dask/issues/6963,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6963/labels{/name},https://api.github.com/repos/dask/dask/issues/6963/comments,https://api.github.com/repos/dask/dask/issues/6963/events,https://github.com/dask/dask/issues/6963,765285429,MDU6SXNzdWU3NjUyODU0Mjk=,6963,Machine-level scheduling,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,2,2020-12-13T11:07:28Z,2021-10-14T06:15:21Z,,NONE,,"The abstraction of a distributed worker, which is totally detached from the physical machine on which it runs is awesome in the capability it adds to seamlessly move the same code from single-core > multi-core > multi-machine. However, it does present some significant limitations.

A notable example is that when the majority of the work is GIL-intensive (i.e. does not free-up the GIL very often), then the best-practice is to run workers with `nthreads=1`. In the distributed setting this means that multiple workers are spawned on each machine in the cluster and there is no good way to manage their shared resources - most importantly RAM, and network bandwidth. Workarounds using [locks or resources](https://stackoverflow.com/questions/45915267/dask-worker-resources-for-distributed-workers) fall short since the scheduler is blind to workers residing on the same machine, hence it's unable to make ""smart"" choices w.r.t them.

Allowing resources to be specified **accross** multiple workers could provide a very flexible yet simple solution. ",,https://api.github.com/repos/dask/dask/issues/6963/timeline,,,syagev,5247438,MDQ6VXNlcjUyNDc0Mzg=,https://avatars.githubusercontent.com/u/5247438?v=4,,https://api.github.com/users/syagev,https://github.com/syagev,https://api.github.com/users/syagev/followers,https://api.github.com/users/syagev/following{/other_user},https://api.github.com/users/syagev/gists{/gist_id},https://api.github.com/users/syagev/starred{/owner}{/repo},https://api.github.com/users/syagev/subscriptions,https://api.github.com/users/syagev/orgs,https://api.github.com/users/syagev/repos,https://api.github.com/users/syagev/events{/privacy},https://api.github.com/users/syagev/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6963/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
398,https://api.github.com/repos/dask/dask/issues/6983,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/6983/labels{/name},https://api.github.com/repos/dask/dask/issues/6983/comments,https://api.github.com/repos/dask/dask/issues/6983/events,https://github.com/dask/dask/issues/6983,769338602,MDU6SXNzdWU3NjkzMzg2MDI=,6983,"""Event loop was unresponsive in Worker"" during df.set_index","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2020-12-16T23:13:22Z,2021-10-14T06:13:25Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:

I'm trying to call df.set_index on a large dataframe (10GB, with 64GiB RAM) and am seeing lots of errors, followed by Dask worker crashes and restarts. At first, I see 100% CPU usage, then close to 0% CPU with some disk writes from Dask workers (which I assume is spilling to disk), then many errors like this:
```
distributed.core - INFO - Event loop was unresponsive in Worker for 7.13s.  This is often caused by long-running GIL-holding functions or moving large chunks of data. This can cause timeouts and instability.
```

Eventually, the workers seem to get repeatedly killed and restarted, and I think the script is not making any progress.

I tried also experimenting with the number of partitions (10, 20, 50). With fewer partitions, I get this error instead (also eventually crashes):

```
distributed.worker - WARNING - Memory use is high but worker has no data to store to disk.  Perhaps some other process is leaking memory?  Process memory: 3.25 GB -- Worker memory limit: 4.12 GB
```

**What you expected to happen**: I thought this would spill to disk if needed, but wasn't expecting the crashes. It's possible this would have finished successfully after some time, but it seemed like no progress was being made (I killed it after several minutes).

**Minimal Complete Verifiable Example**: [Here](https://gist.github.com/stephanie-wang/842669be51a263e5637c0e5ba0236132) is a minimal script that reproduces the issue. It uses Dask to generate one file per partition, then calls `df.set_index().compute()`.
Run this script with `python dask_sort.py --nbytes 10_000_000_000` (sort 10GB of data, 100 partitions of 100MB each).

**Anything else we need to know?**: 

**Environment**:

- Dask version: 2.23 (Dask.distributed, dask-worker with --nprocs 16 --nthreads 1)
- Python version: 3.6
- Operating System: Ubuntu 18.04, Ubuntu 18.04, 16 CPU, 64GiB RAM.
- Install method (conda, pip, source): pip

I'm not sure if this is the right place for this, or if something is wrong with my setup. Please let me know if so!",,https://api.github.com/repos/dask/dask/issues/6983/timeline,,,stephanie-wang,2560516,MDQ6VXNlcjI1NjA1MTY=,https://avatars.githubusercontent.com/u/2560516?v=4,,https://api.github.com/users/stephanie-wang,https://github.com/stephanie-wang,https://api.github.com/users/stephanie-wang/followers,https://api.github.com/users/stephanie-wang/following{/other_user},https://api.github.com/users/stephanie-wang/gists{/gist_id},https://api.github.com/users/stephanie-wang/starred{/owner}{/repo},https://api.github.com/users/stephanie-wang/subscriptions,https://api.github.com/users/stephanie-wang/orgs,https://api.github.com/users/stephanie-wang/repos,https://api.github.com/users/stephanie-wang/events{/privacy},https://api.github.com/users/stephanie-wang/received_events,User,False,https://api.github.com/repos/dask/dask/issues/6983/reactions,0,0,0,0,0,0,0,0,0,stephanie-wang,2560516.0,MDQ6VXNlcjI1NjA1MTY=,https://avatars.githubusercontent.com/u/2560516?v=4,,https://api.github.com/users/stephanie-wang,https://github.com/stephanie-wang,https://api.github.com/users/stephanie-wang/followers,https://api.github.com/users/stephanie-wang/following{/other_user},https://api.github.com/users/stephanie-wang/gists{/gist_id},https://api.github.com/users/stephanie-wang/starred{/owner}{/repo},https://api.github.com/users/stephanie-wang/subscriptions,https://api.github.com/users/stephanie-wang/orgs,https://api.github.com/users/stephanie-wang/repos,https://api.github.com/users/stephanie-wang/events{/privacy},https://api.github.com/users/stephanie-wang/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
399,https://api.github.com/repos/dask/dask/issues/7015,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7015/labels{/name},https://api.github.com/repos/dask/dask/issues/7015/comments,https://api.github.com/repos/dask/dask/issues/7015/events,https://github.com/dask/dask/issues/7015,775511000,MDU6SXNzdWU3NzU1MTEwMDA=,7015,"""Gaps in blk ref_locs"" error during join on categorical column","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2020-12-28T17:39:13Z,2021-01-05T16:41:30Z,,NONE,,"**What happened**:

Confusing error that does not provide really any useful information for user, and seems more like an internal error.

**What you expected to happen**:

No error, join computed successfully. Eventually an error which is more meaningful.

**Minimal Complete Verifiable Example**:

I tried to provide minimal example but it does work properly on a 2-3 rows datasets. Below code generates 0.5 GB dataset.

```sh
wget https://raw.githubusercontent.com/h2oai/db-benchmark/f9a6ce54db7d7b6cdab0780306c990f197a5e3e0/_data/join-datagen.R
Rscript join-datagen.R 1e7 0 5 0
python
```

Reproduce error
```py
import dask as dk
import dask.dataframe as dd
from dask import distributed
client = distributed.Client(processes=True, silence_logs=logging.ERROR)
dk.config.set({""optimization.fuse.ave-width"": 20})
dk.__version__
#'2020.12.0'
x = dd.read_csv('J1_1e7_NA_5_0.csv', dtype={'id1':'Int32','id2':'Int32','id3':'Int32','id4':'category','id5':'category','id6':'category','v1':'float64'}).persist()
medium = dd.read_csv('J1_1e7_1e4_5_0.csv', dtype={'id1':'Int32','id2':'Int32','id4':'category','id5':'category','v2':'float64'}).persist()
ans = x.merge(medium, on='id5').compute()
```
```
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/dask/base.py"", line 279, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/dask/base.py"", line 567, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/dask/threaded.py"", line 84, in get
    **kwargs
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/dask/local.py"", line 486, in get_async
    raise_exception(exc, tb)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/dask/local.py"", line 316, in reraise
    raise exc
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/dask/local.py"", line 222, in execute_task
    result = _execute_task(task, data)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/dask/core.py"", line 121, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/dask/utils.py"", line 30, in apply
    return func(*args, **kwargs)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/dask/dataframe/multi.py"", line 274, in merge_chunk
    out = lhs.merge(rhs, *args, **kwargs)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/frame.py"", line 7963, in merge
    validate=validate,
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/reshape/merge.py"", line 87, in merge
    validate=validate,
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/reshape/merge.py"", line 652, in __init__
    ) = self._get_merge_keys()
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/reshape/merge.py"", line 1063, in _get_merge_
keys
    self.right = self.right._drop_labels_or_levels(right_drop)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/generic.py"", line 1646, in _drop_labels_or_l
evels
    dropped.drop(labels_to_drop, axis=1, inplace=True)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/frame.py"", line 4174, in drop
    errors=errors,
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/generic.py"", line 3889, in drop
    obj = obj._drop_axis(labels, axis, level=level, errors=errors)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/generic.py"", line 3924, in _drop_axis
    result = self.reindex(**{axis_name: new_axis})
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/util/_decorators.py"", line 309, in wrapper
    return func(*args, **kwargs)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/frame.py"", line 4036, in reindex
    return super().reindex(**kwargs)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/generic.py"", line 4464, in reindex
    axes, level, limit, tolerance, method, fill_value, copy
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/frame.py"", line 3877, in _reindex_axes
    columns, method, copy, level, fill_value, limit, tolerance
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/frame.py"", line 3925, in _reindex_columns
    allow_dups=False,
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/generic.py"", line 4532, in _reindex_with_ind
exers
    copy=copy,
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/internals/managers.py"", line 1291, in reinde
x_indexer
    new_blocks = self._slice_take_blocks_ax0(indexer, fill_value=fill_value)
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/internals/managers.py"", line 1371, in _slice
_take_blocks_ax0
    self.blknos, slobj, fill_value=-1, allow_fill=allow_fill
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/internals/managers.py"", line 175, in blknos
    self._rebuild_blknos_and_blklocs()
  File ""/home/jan/git/db-benchmark/dask/py-dask/lib/python3.6/site-packages/pandas/core/internals/managers.py"", line 254, in _rebuil
d_blknos_and_blklocs
    raise AssertionError(""Gaps in blk ref_locs"")
AssertionError: Gaps in blk ref_locs
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2020.12.0
- Python version: 3.6
- Operating System: Linux
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/7015/timeline,,,jangorecki,3627377,MDQ6VXNlcjM2MjczNzc=,https://avatars.githubusercontent.com/u/3627377?v=4,,https://api.github.com/users/jangorecki,https://github.com/jangorecki,https://api.github.com/users/jangorecki/followers,https://api.github.com/users/jangorecki/following{/other_user},https://api.github.com/users/jangorecki/gists{/gist_id},https://api.github.com/users/jangorecki/starred{/owner}{/repo},https://api.github.com/users/jangorecki/subscriptions,https://api.github.com/users/jangorecki/orgs,https://api.github.com/users/jangorecki/repos,https://api.github.com/users/jangorecki/events{/privacy},https://api.github.com/users/jangorecki/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7015/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
400,https://api.github.com/repos/dask/dask/issues/7036,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7036/labels{/name},https://api.github.com/repos/dask/dask/issues/7036/comments,https://api.github.com/repos/dask/dask/issues/7036/events,https://github.com/dask/dask/issues/7036,780757353,MDU6SXNzdWU3ODA3NTczNTM=,7036,Graph optimization loses annotations,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,5,2021-01-06T18:25:20Z,2022-03-11T06:23:09Z,,MEMBER,,"Came across this when working on https://github.com/dask/distributed/pull/4347 . The new annotations machinery is attached to high level graph `Layer`s. However, in the optimization step, layers can be rewritten, and new layers can lose their annotations. This can especially cause unintended effects when these annotation affect scheduling/execution (as is the case when specifying workers, priority, retries, etc).

A MWE that reproduces the issue on dask `master`:

```python
import dask
import dask.array as da

with dask.annotate(foo=""bar""):
    a = da.ones((1,1))
    
print(a.__dask_graph__().layers[a.name].annotations)
aa, = dask.optimize(a)
print(aa.__dask_graph__().layers[aa.name].annotations)
```
produces
```
{'foo': 'bar'}
None
```

Perhaps @sjperkins or @rjzamora may have some insight into the best fix here (it looks like @sjperkins may have [come across this before](https://github.com/dask/distributed/blob/eeb411e37f6ce754b800358462bf6c2a8a37f437/distributed/protocol/tests/test_highlevelgraph.py#L148-L149)?)
",,https://api.github.com/repos/dask/dask/issues/7036/timeline,,,ian-r-rose,5728311,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7036/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
401,https://api.github.com/repos/dask/dask/issues/7050,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7050/labels{/name},https://api.github.com/repos/dask/dask/issues/7050/comments,https://api.github.com/repos/dask/dask/issues/7050/events,https://github.com/dask/dask/issues/7050,782680417,MDU6SXNzdWU3ODI2ODA0MTc=,7050,Validate the new matmul works and scales well on cupy and sparse,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}]",open,False,,[],,6,2021-01-09T20:33:37Z,2021-03-15T16:45:33Z,,MEMBER,,"Validate the new matmul implementation from #7000 works and scales well on cupy and sparse blocks.

_Originally posted by @ravwojdyla in https://github.com/dask/dask/issues/7000#issuecomment-757363174_",,https://api.github.com/repos/dask/dask/issues/7050/timeline,,,ravwojdyla,1419010,MDQ6VXNlcjE0MTkwMTA=,https://avatars.githubusercontent.com/u/1419010?v=4,,https://api.github.com/users/ravwojdyla,https://github.com/ravwojdyla,https://api.github.com/users/ravwojdyla/followers,https://api.github.com/users/ravwojdyla/following{/other_user},https://api.github.com/users/ravwojdyla/gists{/gist_id},https://api.github.com/users/ravwojdyla/starred{/owner}{/repo},https://api.github.com/users/ravwojdyla/subscriptions,https://api.github.com/users/ravwojdyla/orgs,https://api.github.com/users/ravwojdyla/repos,https://api.github.com/users/ravwojdyla/events{/privacy},https://api.github.com/users/ravwojdyla/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7050/reactions,1,0,0,0,0,0,0,0,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
402,https://api.github.com/repos/dask/dask/issues/7082,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7082/labels{/name},https://api.github.com/repos/dask/dask/issues/7082/comments,https://api.github.com/repos/dask/dask/issues/7082/events,https://github.com/dask/dask/issues/7082,788536188,MDU6SXNzdWU3ODg1MzYxODg=,7082,High level layer for persisted graphs,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,1,2021-01-18T20:42:39Z,2021-10-14T06:01:26Z,,MEMBER,,"High level layers are great for reducing communication costs between the client and scheduler.

```python
df = df.persist()  # I'm fast, thanks HLGs!
```

However the resulting graph is dense and low-level, resulting in slow subsequent computations

```python
df.sum().compute()  # Oof, I'm slow because `df.__dask_graph__()` is large
```

In principle the base layer of a persisted collection could probably be a high level layer, but is today a dict pointing to a sequence of futures

```python
from dask.distributed import Client
client = Client()
import dask
df = dask.datasets.timeseries(start=""2020-01-01"", end=""2020-01-31"", partition_freq=""4d"", freq=""60s"").persist()
layer = list(df.__dask_graph__().layers.values())[0]
layer
```
```
<dask.highlevelgraph.BasicLayer at 0x7f54e0f55100>
```

```python
layer.mapping
```

```
{('make-timeseries-845f690241d8441d2ba11456363165a4',
  0): <Future: finished, type: pandas.DataFrame, key: ('make-timeseries-845f690241d8441d2ba11456363165a4', 0)>,
 ('make-timeseries-845f690241d8441d2ba11456363165a4',
  1): <Future: finished, type: pandas.DataFrame, key: ('make-timeseries-845f690241d8441d2ba11456363165a4', 1)>,
 ('make-timeseries-845f690241d8441d2ba11456363165a4',
  2): <Future: finished, type: pandas.DataFrame, key: ('make-timeseries-845f690241d8441d2ba11456363165a4', 2)>,
 ('make-timeseries-845f690241d8441d2ba11456363165a4',
  3): <Future: finished, type: pandas.DataFrame, key: ('make-timeseries-845f690241d8441d2ba11456363165a4', 3)>,
 ('make-timeseries-845f690241d8441d2ba11456363165a4',
  4): <Future: finished, type: pandas.DataFrame, key: ('make-timeseries-845f690241d8441d2ba11456363165a4', 4)>,
 ('make-timeseries-845f690241d8441d2ba11456363165a4',
  5): <Future: finished, type: pandas.DataFrame, key: ('make-timeseries-845f690241d8441d2ba11456363165a4', 5)>,
 ('make-timeseries-845f690241d8441d2ba11456363165a4',
  6): <Future: finished, type: pandas.DataFrame, key: ('make-timeseries-845f690241d8441d2ba11456363165a4', 6)>}
```

cc @madsbk @rjzamora @ian-r-rose ",,https://api.github.com/repos/dask/dask/issues/7082/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7082/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
403,https://api.github.com/repos/dask/dask/issues/7086,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7086/labels{/name},https://api.github.com/repos/dask/dask/issues/7086/comments,https://api.github.com/repos/dask/dask/issues/7086/events,https://github.com/dask/dask/pull/7086,789062352,MDExOlB1bGxSZXF1ZXN0NTU3NDYzMjY2,7086,Use xxhash3 for hashing arrays,[],open,False,,[],,10,2021-01-19T14:19:13Z,2021-07-07T17:36:04Z,,CONTRIBUTOR,,"- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask`

[xxHash v0.8.0](https://github.com/Cyan4973/xxHash/releases/tag/v0.8.0) added support for `XXH3`. Using `xxhash.xxh3_64` instead of `xxhash.xxh64` in `hashing.py` shows better performance for tokenizing arrays.

Using XXH3:
```
$ python -m pyperf timeit -s ""from dask.base import tokenize; import numpy as np; a =np.ones((10_000,10_000))"" ""tokenize(a)""
.....................
Mean +- std dev: 75.2 ms +- 3.1 ms
```

Using Cityhash:
```
$ python -m pyperf timeit -s ""from dask.base import tokenize; import numpy as np; a =np.ones((10_000,10_000))"" ""tokenize(a)""
.....................
Mean +- std dev: 92.2 ms +- 5.1 ms
```

Using XXH:
```
$ python -m pyperf timeit -s ""from dask.base import tokenize; import numpy as np; a =np.ones((10_000,10_000))"" ""tokenize(a)""
.....................
Mean +- std dev: 97.4 ms +- 4.9 ms
```

ref: https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html",,https://api.github.com/repos/dask/dask/issues/7086/timeline,,,abduhbm,19528166,MDQ6VXNlcjE5NTI4MTY2,https://avatars.githubusercontent.com/u/19528166?v=4,,https://api.github.com/users/abduhbm,https://github.com/abduhbm,https://api.github.com/users/abduhbm/followers,https://api.github.com/users/abduhbm/following{/other_user},https://api.github.com/users/abduhbm/gists{/gist_id},https://api.github.com/users/abduhbm/starred{/owner}{/repo},https://api.github.com/users/abduhbm/subscriptions,https://api.github.com/users/abduhbm/orgs,https://api.github.com/users/abduhbm/repos,https://api.github.com/users/abduhbm/events{/privacy},https://api.github.com/users/abduhbm/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7086/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7086,https://github.com/dask/dask/pull/7086,https://github.com/dask/dask/pull/7086.diff,https://github.com/dask/dask/pull/7086.patch,,,,,,,,,,,,,,,,,,,
404,https://api.github.com/repos/dask/dask/issues/7088,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7088/labels{/name},https://api.github.com/repos/dask/dask/issues/7088/comments,https://api.github.com/repos/dask/dask/issues/7088/events,https://github.com/dask/dask/issues/7088,790103221,MDU6SXNzdWU3OTAxMDMyMjE=,7088,Add Stack function to Dask CUDF Dataframe,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2021-01-20T15:53:37Z,2021-10-14T06:07:41Z,,NONE,,"I would like to be able to call stack() on the Dask cudf dataframe. Currently stack is a function in the cudf dataframe, not in Dask cudf dataframe.
I would like the stacking to take place on the workers, and the resulting stacked data to be returned from the workers.
I know I can call compute() first on the dask cudf dataframe, but I want to avoid that because I want the stacking to take place on the worker nodes, and the final results returned.
",,https://api.github.com/repos/dask/dask/issues/7088/timeline,,,chardog,2762489,MDQ6VXNlcjI3NjI0ODk=,https://avatars.githubusercontent.com/u/2762489?v=4,,https://api.github.com/users/chardog,https://github.com/chardog,https://api.github.com/users/chardog/followers,https://api.github.com/users/chardog/following{/other_user},https://api.github.com/users/chardog/gists{/gist_id},https://api.github.com/users/chardog/starred{/owner}{/repo},https://api.github.com/users/chardog/subscriptions,https://api.github.com/users/chardog/orgs,https://api.github.com/users/chardog/repos,https://api.github.com/users/chardog/events{/privacy},https://api.github.com/users/chardog/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7088/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
405,https://api.github.com/repos/dask/dask/issues/7094,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7094/labels{/name},https://api.github.com/repos/dask/dask/issues/7094/comments,https://api.github.com/repos/dask/dask/issues/7094/events,https://github.com/dask/dask/issues/7094,791252375,MDU6SXNzdWU3OTEyNTIzNzU=,7094,CI Failures - windows `test_num_workers_config[processes]`,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,4,2021-01-21T15:52:23Z,2021-02-23T15:07:46Z,,MEMBER,,"I've seen this crop up a few times in recent PRs. For instance: 
 - https://github.com/dask/dask/pull/7092/checks?check_run_id=1742694302 
 - https://github.com/dask/dask/pull/7089/checks?check_run_id=1737011148
",,https://api.github.com/repos/dask/dask/issues/7094/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7094/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
406,https://api.github.com/repos/dask/dask/issues/7107,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7107/labels{/name},https://api.github.com/repos/dask/dask/issues/7107/comments,https://api.github.com/repos/dask/dask/issues/7107/events,https://github.com/dask/dask/issues/7107,793277375,MDU6SXNzdWU3OTMyNzczNzU=,7107,Tests randomly fail with FileNotFoundError on NFS,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,1,2021-01-25T10:58:41Z,2024-04-24T11:36:50Z,,MEMBER,,"dask git tip 2021-01-25
pytest 6.2.1
Python 3.8.6
Linux x64
git repo is deployed on a NFS filesystem

---

I'm consistently getting random failures on the tests that invoke compute() with the multiprocessing scheduler; e.g. in ``dask/bag/tests/test_bag.py`` I consistently get 2-5 tests failing, also when I run it alone, with the following stack trace (snipped):

```
../core.py:1442: in __iter__
    return iter(self.compute())
../../multiprocessing.py:196: in get
    pool = context.Pool(num_workers, initializer=initialize_worker_process)
lib/python3.8/multiprocessing/popen_spawn_posix.py:42: in _launch
    prep_data = spawn.get_preparation_data(process_obj._name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'SpawnPoolWorker-4545'

>           dir=os.getcwd(),

E       FileNotFoundError: [Errno 2] No such file or directory

lib/python3.8/multiprocessing/spawn.py:176: FileNotFoundError
```
The issue disappears if I move my dask directory from a nfs mountpoint to ext4.

Not having yet investigated further, I suspect that something may be calling ``os.chdir`` into a tmpdir, and then that tmpdir is deleted asynchronously by the pytest teardown.",,https://api.github.com/repos/dask/dask/issues/7107/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7107/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
407,https://api.github.com/repos/dask/dask/issues/7122,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7122/labels{/name},https://api.github.com/repos/dask/dask/issues/7122/comments,https://api.github.com/repos/dask/dask/issues/7122/events,https://github.com/dask/dask/pull/7122,796022023,MDExOlB1bGxSZXF1ZXN0NTYzMjcxNzUw,7122,BUG: len / column subset failing on filtered parquet dataset using pyarrow.dataset engine,[],open,False,,[],,0,2021-01-28T13:50:38Z,2021-03-08T20:19:54Z,,MEMBER,,"This is actually a bug report, but in form of a PR with test. I noticed that my demo notebook with the pyarrow dataset engine was not actually fully working anymore (it seems this was already the case at the end of https://github.com/dask/dask/pull/6534, though, so the bug was probably introduced somewhere along that long PR). 

The rather simple case of checking the length or getting a subset of columns of a filtered partitioned dataset is failing:

```python
df = pd.DataFrame({""part"": [""A"", ""B""] * 10, ""col"": range(20)})
ddf = dd.from_pandas(df, npartitions=2)
ddf.to_parquet(""test_dask_pyarrow_filter"", partition_on=[""part""])
ddf_subset = dd.read_parquet(""test_dask_pyarrow_filter"", filters=[[('part', '=', ""A"")]], engine=""pyarrow-dataset"")

# both fail
len(ddf_subset)
ddf_subset[""col""].sum().compute()
```

cc @rjzamora 

The reason that it is failing is because in `read_partition` in the lines below, we don't calculate a `keys_dict` if we have a pyarrow.dataset ParquetFileFragment, but we *still* have `partitions`:

https://github.com/dask/dask/blob/9bb586a6b8fac1983b7cea3ab399719f93dbbb29/dask/dataframe/io/parquet/arrow.py#L616-L625

The ""easy"" fix might be to just always calculate `keys_dict`, but on the other hand, in the case that we have a ParquetFileFragment, we shouldn't remove the partition columns from `columns` and let pyarrow read the `arrow_table` with partition columns included (I suppose was the rationale about the above if/else, but in practice that doesn't happen anymore, and `arrow_table` does not actually include the partition columns, and thus the code here is trying to add them, getting it from `keys_dict`, but which is empty. ",,https://api.github.com/repos/dask/dask/issues/7122/timeline,,,jorisvandenbossche,1020496,MDQ6VXNlcjEwMjA0OTY=,https://avatars.githubusercontent.com/u/1020496?v=4,,https://api.github.com/users/jorisvandenbossche,https://github.com/jorisvandenbossche,https://api.github.com/users/jorisvandenbossche/followers,https://api.github.com/users/jorisvandenbossche/following{/other_user},https://api.github.com/users/jorisvandenbossche/gists{/gist_id},https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo},https://api.github.com/users/jorisvandenbossche/subscriptions,https://api.github.com/users/jorisvandenbossche/orgs,https://api.github.com/users/jorisvandenbossche/repos,https://api.github.com/users/jorisvandenbossche/events{/privacy},https://api.github.com/users/jorisvandenbossche/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7122/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7122,https://github.com/dask/dask/pull/7122,https://github.com/dask/dask/pull/7122.diff,https://github.com/dask/dask/pull/7122.patch,,,,,,,,,,,,,,,,,,,
408,https://api.github.com/repos/dask/dask/issues/7124,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7124/labels{/name},https://api.github.com/repos/dask/dask/issues/7124/comments,https://api.github.com/repos/dask/dask/issues/7124/events,https://github.com/dask/dask/issues/7124,796147026,MDU6SXNzdWU3OTYxNDcwMjY=,7124,Automatically rechunk blockwise when chunk size increases substantially,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,12,2021-01-28T16:12:25Z,2021-07-20T04:25:32Z,,MEMBER,,"Currently blockwise blindly performs an outer product of chunks when doing outer products.  This can result in very large chunks, which break computation.

```python
import dask.array as da
x = da.ones((1000000, 1))
y = da.ones((1, 1000000))
z = x.dot(y)
z
```

```
dask.array<tensordot, shape=(1000000, 1000000), dtype=float64, chunksize=(1000000, 1000000), chunktype=numpy.ndarray>
```

In these situations we should probably take a look at the output chunk sizes, and consider rechunking preemptively.  

(we probably wanted to do this)

```python
z = x.rechunk((2000, 1)).dot(y.rechunk((1, 2000)))
```

Where the value of 2000 was determined by looking at `dask.config.get(""array.chunksize"")`

It would be nice to do this in a way that didn't require going through all `n x m` chunk outputs (or greater if there we're doing outer products with more axes), but instead in a way that only required going through `n + m` values.

cc @tomwhite",,https://api.github.com/repos/dask/dask/issues/7124/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7124/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
409,https://api.github.com/repos/dask/dask/issues/7134,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7134/labels{/name},https://api.github.com/repos/dask/dask/issues/7134/comments,https://api.github.com/repos/dask/dask/issues/7134/events,https://github.com/dask/dask/issues/7134,796864667,MDU6SXNzdWU3OTY4NjQ2Njc=,7134,Slicing with lists in multiple axes,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2021-01-29T13:02:51Z,2021-08-31T14:55:28Z,,NONE,,"<!-- Please do a quick search of existing issues to make sure that this has not been asked before. -->
Hi there!

Currently the docs state:
> However, it does not currently support the following:
> 
> Slicing with lists in multiple axes: `x[[1, 2, 3], [3, 2, 1]]`
> 
> This is straightforward to add though. If you have a use case then raise an issue. Also, users interested in this should take a look at vindex.

I believe I have a use case for this feature. Commonly in types of spectral analysis we have a cube in the form of a 3D array i.e. x,y,z = space,space,spectrum

In numpy it is easy to keep track of value of the spectral index values with a 1D array of the same length as the z axis (the same is true of the other axes, and is probably generalisable to N-dimensions).

Here's a basic example of finding the value along the spectral axis that corresponds to the maximum in the spectrum:
```python
# 10x10 image with a depth of 100
nx,ny,nz = 10, 10, 100
cube_arr = np.random.normal(size=[nz,ny,nx])
# Spectral axis goes from 0 to 10 over the 100 pixels
spectrum = np.linspace(0,10,nz)
# Find the pixels corresponding to max
cube_max_idx = np.argmax(cube_arr, axis=0)
# Get the values of the spectrum at the max - 2D array 
max_vals = spectrum[cube_max_idx]
```
The equivalent in dask.array would be:
```python
# 10x10 image with a depth of 100 - Obviously we would want to go bigger with Dask!
nx,ny,nz = 10, 10, 100
cube_arr = da.random.random([nz,ny,nx])
# Spectral axis goes from 0 to 10 over the 100 pixels
spectrum = da.linspace(0,10,nz)
# Find the pixels corresponding to max
cube_max_idx = da.argmax(cube_arr, axis=0)
# Get the values of the spectrum at the max
max_vals = spectrum[cube_max_idx]
```
Which currently raises
```
NotImplementedError: Slicing with dask.array of ints only permitted when the indexer has zero or one dimensions
```

Happy to provide more details if that helps. Thanks! ",,https://api.github.com/repos/dask/dask/issues/7134/timeline,,,AlecThomson,9074527,MDQ6VXNlcjkwNzQ1Mjc=,https://avatars.githubusercontent.com/u/9074527?v=4,,https://api.github.com/users/AlecThomson,https://github.com/AlecThomson,https://api.github.com/users/AlecThomson/followers,https://api.github.com/users/AlecThomson/following{/other_user},https://api.github.com/users/AlecThomson/gists{/gist_id},https://api.github.com/users/AlecThomson/starred{/owner}{/repo},https://api.github.com/users/AlecThomson/subscriptions,https://api.github.com/users/AlecThomson/orgs,https://api.github.com/users/AlecThomson/repos,https://api.github.com/users/AlecThomson/events{/privacy},https://api.github.com/users/AlecThomson/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7134/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
410,https://api.github.com/repos/dask/dask/issues/7137,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7137/labels{/name},https://api.github.com/repos/dask/dask/issues/7137/comments,https://api.github.com/repos/dask/dask/issues/7137/events,https://github.com/dask/dask/issues/7137,796946456,MDU6SXNzdWU3OTY5NDY0NTY=,7137,HighLevelGraph.cull culling doesn't rename layers,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,8,2021-01-29T14:55:38Z,2021-02-26T11:22:19Z,,MEMBER,,"**What happened**: when looking at the code I noticed that HighLevelGraph.cull doesn't rename layers. This can lead to problems because the layer name no longer uniquely identifies the layer. When manually optimising graphs (e.g. with the public `dask.optimize`) this can cause problems.

**What you expected to happen**: Culled layers should have new names, either UUIDs or hashes that describe the new set of keys.

**Minimal Complete Verifiable Example**:

I haven't actually stepped through the code to check that what I've described is actually the cause of this failure, but I wrote the code to trigger the condition. If it's not the cause, then I've found a bonus bug :-) The idea is that `a1` and `a2` end up with a layer with the same name but a different subset of keys, and only one copy of the layer is retained in `b`.
```python
#!/usr/bin/env python3

import dask.array as da
import dask

with dask.config.set({'optimization.fuse.active': False}):
    a = da.from_array([1, 2], chunks=1)
    a1 = a[:1]
    a2 = a[1:]
    (a1,) = dask.optimize(a1)
    (a2,) = dask.optimize(a2)
    b = a1 + a2
    print(b.compute())
```

Output:
```
Traceback (most recent call last):
  File ""cull-rename.py"", line 13, in <module>
    print(b.compute())
  File ""/home/bmerry/work/sdp/env3/lib/python3.8/site-packages/dask/base.py"", line 279, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/home/bmerry/work/sdp/env3/lib/python3.8/site-packages/dask/base.py"", line 561, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/home/bmerry/work/sdp/env3/lib/python3.8/site-packages/dask/threaded.py"", line 76, in get
    results = get_async(
  File ""/home/bmerry/work/sdp/env3/lib/python3.8/site-packages/dask/local.py"", line 487, in get_async
    raise_exception(exc, tb)
  File ""/home/bmerry/work/sdp/env3/lib/python3.8/site-packages/dask/local.py"", line 317, in reraise
    raise exc
  File ""/home/bmerry/work/sdp/env3/lib/python3.8/site-packages/dask/local.py"", line 222, in execute_task
    result = _execute_task(task, data)
  File ""/home/bmerry/work/sdp/env3/lib/python3.8/site-packages/dask/core.py"", line 121, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
TypeError: tuple indices must be integers or slices, not tuple
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2021.1.1
- Python version: 3.8.5
- Operating System: Ubuntu 20.04
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/7137/timeline,,,bmerry,1963944,MDQ6VXNlcjE5NjM5NDQ=,https://avatars.githubusercontent.com/u/1963944?v=4,,https://api.github.com/users/bmerry,https://github.com/bmerry,https://api.github.com/users/bmerry/followers,https://api.github.com/users/bmerry/following{/other_user},https://api.github.com/users/bmerry/gists{/gist_id},https://api.github.com/users/bmerry/starred{/owner}{/repo},https://api.github.com/users/bmerry/subscriptions,https://api.github.com/users/bmerry/orgs,https://api.github.com/users/bmerry/repos,https://api.github.com/users/bmerry/events{/privacy},https://api.github.com/users/bmerry/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7137/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
411,https://api.github.com/repos/dask/dask/issues/7141,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7141/labels{/name},https://api.github.com/repos/dask/dask/issues/7141/comments,https://api.github.com/repos/dask/dask/issues/7141/events,https://github.com/dask/dask/issues/7141,797065800,MDU6SXNzdWU3OTcwNjU4MDA=,7141,Visualizing performance characteristics of computations,"[{'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,14,2021-01-29T17:43:40Z,2022-03-24T22:08:54Z,,MEMBER,,"Users are sometimes caught off guard when they have a computation that works well and then add a new step which results in an overall computation with very different performance characteristics. For example, converting a CSV dataset to a parquet dataset

```python
import dask.dataframe ass dd

ddf = dd.read_csv(...)
ddf.to_parquet(...)
```

is easily paralizable. However, adding a `set_index` operation in the middle

```python
import dask.dataframe ass dd

ddf = dd.read_csv(...)
ddf = ddf.set_index(...)
ddf.to_parquet(...)
```

can impact performance significantly.

There are other operations like 

- `DataFrame.map_partitions` is easily paralizable
- `DataFrame.drop_duplicates` (and other methods which internally perform tree-reductions) which can produce large, interesting graph structures
- ...

It would be great if we had a visualization to communicate performance characteristics of various operations to users. For example, a graphviz-style plot at the `HighLevelGraph` `Layer` level where `set_index` layers are red and `map_paritions` layers are green. 

cc @jsignell @jacobtomlinson @rjzamora who may have an interest in thinking about visualizations ",,https://api.github.com/repos/dask/dask/issues/7141/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7141/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
412,https://api.github.com/repos/dask/dask/issues/7148,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7148/labels{/name},https://api.github.com/repos/dask/dask/issues/7148/comments,https://api.github.com/repos/dask/dask/issues/7148/events,https://github.com/dask/dask/pull/7148,797825379,MDExOlB1bGxSZXF1ZXN0NTY0NzM5Mjg3,7148,"Implements dask split functions for use on dask arrays: (array_split, split, hsplit, vsplit, dsplit)",[],open,False,,[],,0,2021-01-31T22:13:09Z,2021-03-08T20:19:54Z,,CONTRIBUTOR,,"- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask`

Will add split functions to dask which mirror the numpy functions: [`numpy.array_split`](https://numpy.org/doc/stable/reference/generated/numpy.array_split.html#numpy.array_split), [`numpy.split`](https://numpy.org/doc/stable/reference/generated/numpy.split.html), [`numpy.hsplit`](https://numpy.org/doc/stable/reference/generated/numpy.hsplit.html), [`numpy.vsplit`](https://numpy.org/doc/stable/reference/generated/numpy.vsplit.html), [`numpy.dsplit`](https://numpy.org/doc/stable/reference/generated/numpy.dsplit.html) Respectively. These will split the dask.array along a specified axis and return a list of dask arrays. 

also adds the function `assert_eq_iter` into `dask.array.utils.py` which allows for equality assertion of iterators containing zero or more `ndarray` and `dask.core.Array` arrays.

Also deprecates the need for the `split_at_breaks` function with a more performant alternative. 

** **
**To Do:**
** **
- [ ] add Nep 18 implementation:
     - [ ] Write / rewrite test in `test_array_function.py` to allow for different return types i.e. in the split-specific case: a list of dask.Arrays.",,https://api.github.com/repos/dask/dask/issues/7148/timeline,,,D-Stacks,78099568,MDQ6VXNlcjc4MDk5NTY4,https://avatars.githubusercontent.com/u/78099568?v=4,,https://api.github.com/users/D-Stacks,https://github.com/D-Stacks,https://api.github.com/users/D-Stacks/followers,https://api.github.com/users/D-Stacks/following{/other_user},https://api.github.com/users/D-Stacks/gists{/gist_id},https://api.github.com/users/D-Stacks/starred{/owner}{/repo},https://api.github.com/users/D-Stacks/subscriptions,https://api.github.com/users/D-Stacks/orgs,https://api.github.com/users/D-Stacks/repos,https://api.github.com/users/D-Stacks/events{/privacy},https://api.github.com/users/D-Stacks/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7148/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/7148,https://github.com/dask/dask/pull/7148,https://github.com/dask/dask/pull/7148.diff,https://github.com/dask/dask/pull/7148.patch,,,,,,,,,,,,,,,,,,,
413,https://api.github.com/repos/dask/dask/issues/7167,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7167/labels{/name},https://api.github.com/repos/dask/dask/issues/7167/comments,https://api.github.com/repos/dask/dask/issues/7167/events,https://github.com/dask/dask/issues/7167,800921327,MDU6SXNzdWU4MDA5MjEzMjc=,7167,"""ResourceWarning: unclosed file"" warnings in the test suite","[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,8,2021-02-04T04:32:53Z,2023-03-15T17:13:23Z,,MEMBER,,"I noticed there are many warnings that look like:

```
dask/bytes/tests/test_http.py::test_simple
  /usr/share/miniconda3/envs/test-environment/lib/python3.8/site-packages/_pytest/unraisableexception.py:78: PytestUnraisableExceptionWarning: Exception ignored in: <_io.FileIO [closed]>
  
  Traceback (most recent call last):
    File ""/home/runner/work/dask/dask/dask/bytes/tests/test_http.py"", line 50, in test_simple
      assert data == open(os.path.join(dir_server, fn), ""rb"").read()
  ResourceWarning: unclosed file <_io.BufferedReader name='/tmp/tmp2zbuwztd/a'>
  
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
```

in the test suite (see [this build](https://github.com/dask/dask/runs/1827520833#step:5:168) for an example). It would be good at some point to go through and resolve these warnings. ",,https://api.github.com/repos/dask/dask/issues/7167/timeline,,reopened,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7167/reactions,0,0,0,0,0,0,0,0,0,jrbourbeau,11656932.0,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
414,https://api.github.com/repos/dask/dask/issues/7176,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7176/labels{/name},https://api.github.com/repos/dask/dask/issues/7176/comments,https://api.github.com/repos/dask/dask/issues/7176/events,https://github.com/dask/dask/pull/7176,801914294,MDExOlB1bGxSZXF1ZXN0NTY4MTQ3ODA4,7176,read_sql_table str column support added,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,3,2021-02-05T07:08:30Z,2023-02-15T19:19:10Z,,FIRST_TIME_CONTRIBUTOR,,"- [ ] Tests added / passed
- [ ] Passes `black dask` / `flake8 dask`
- [ ] Closes #xxxx
",,https://api.github.com/repos/dask/dask/issues/7176/timeline,,,HamzaPekdogan,9397748,MDQ6VXNlcjkzOTc3NDg=,https://avatars.githubusercontent.com/u/9397748?v=4,,https://api.github.com/users/HamzaPekdogan,https://github.com/HamzaPekdogan,https://api.github.com/users/HamzaPekdogan/followers,https://api.github.com/users/HamzaPekdogan/following{/other_user},https://api.github.com/users/HamzaPekdogan/gists{/gist_id},https://api.github.com/users/HamzaPekdogan/starred{/owner}{/repo},https://api.github.com/users/HamzaPekdogan/subscriptions,https://api.github.com/users/HamzaPekdogan/orgs,https://api.github.com/users/HamzaPekdogan/repos,https://api.github.com/users/HamzaPekdogan/events{/privacy},https://api.github.com/users/HamzaPekdogan/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7176/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7176,https://github.com/dask/dask/pull/7176,https://github.com/dask/dask/pull/7176.diff,https://github.com/dask/dask/pull/7176.patch,,,,,,,,,,,,,,,,,,,
415,https://api.github.com/repos/dask/dask/issues/7181,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7181/labels{/name},https://api.github.com/repos/dask/dask/issues/7181/comments,https://api.github.com/repos/dask/dask/issues/7181/events,https://github.com/dask/dask/issues/7181,802392174,MDU6SXNzdWU4MDIzOTIxNzQ=,7181,Removing `compute` call from `_array_like_safe`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2021-02-05T18:45:06Z,2021-02-05T19:18:21Z,,MEMBER,,"In PR ( https://github.com/dask/dask/pull/7162 ), we needed to add a `.compute(scheduler=""sync"")` call in one case (see below). While this seems ok for the cases where we needed it (concrete arrays, scalars, and Python objects). There's the potential this could be used on other objects (like Dask Arrays) where we would not want to use this. It would be good to figure out another way to solve this problem (if possible) that does not rely on the usage of `compute`.

https://github.com/dask/dask/blob/996b50666ad197da2d30da415ce1790e3809aad4/dask/array/utils.py#L404

cc @pentschev @jrbourbeau",,https://api.github.com/repos/dask/dask/issues/7181/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7181/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
416,https://api.github.com/repos/dask/dask/issues/7187,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7187/labels{/name},https://api.github.com/repos/dask/dask/issues/7187/comments,https://api.github.com/repos/dask/dask/issues/7187/events,https://github.com/dask/dask/issues/7187,803574768,MDU6SXNzdWU4MDM1NzQ3Njg=,7187,[Performance] compute slower and uses more RAM than equivalent da.store implementation,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2021-02-08T13:38:44Z,2022-11-17T03:23:53Z,,MEMBER,,"This is left over from #3595; there were some discussions there about ways to improve `da.compute` that I think shouldn't be forgotten. The below all applies to arrays and the threaded scheduler; I don't have any experience with data frames or distributed so maybe it's applicable there too.

Computing an array involves computing all the individual chunks, followed by a concatenation (at least last time I looked; it's been a while since I poked in that area of the code). On the other hand, `da.store` writes completed chunks to the output array. That makes it both faster and more memory-efficient to replace use of `compute` with `np.empty` + `store`. For example:

```python
#!/usr/bin/env python3

import time

import numpy as np
import dask
import dask.array as da

def compute(b):
    b.compute()

def compute_by_store(b):
    x = np.empty(b.shape, b.dtype)
    da.store([b], [x], lock=False)

a = da.ones(4 * 10**9, dtype=np.uint8, chunks=10**7)
b = a * 3
t0 = time.monotonic()
compute(b)
t1 = time.monotonic()
compute_by_store(b)
t2 = time.monotonic()
print(f'Compute: {t1 - t0:.3f}\nStore:   {t2 - t1:.3f}')
```

Output:
```
Compute: 1.370
Store:   0.788
```

Memory usage is also halved by compute_by_store.

That's obviously a somewhat contrived example where the concatenation dominates the run-time, but I've seen significant difference in real-world use cases too.",,https://api.github.com/repos/dask/dask/issues/7187/timeline,,,bmerry,1963944,MDQ6VXNlcjE5NjM5NDQ=,https://avatars.githubusercontent.com/u/1963944?v=4,,https://api.github.com/users/bmerry,https://github.com/bmerry,https://api.github.com/users/bmerry/followers,https://api.github.com/users/bmerry/following{/other_user},https://api.github.com/users/bmerry/gists{/gist_id},https://api.github.com/users/bmerry/starred{/owner}{/repo},https://api.github.com/users/bmerry/subscriptions,https://api.github.com/users/bmerry/orgs,https://api.github.com/users/bmerry/repos,https://api.github.com/users/bmerry/events{/privacy},https://api.github.com/users/bmerry/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7187/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
417,https://api.github.com/repos/dask/dask/issues/7206,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7206/labels{/name},https://api.github.com/repos/dask/dask/issues/7206/comments,https://api.github.com/repos/dask/dask/issues/7206/events,https://github.com/dask/dask/issues/7206,806818543,MDU6SXNzdWU4MDY4MTg1NDM=,7206,Bug with delayed head-method for pandas string columns,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,6,2021-02-11T23:11:22Z,2022-02-24T14:36:26Z,,CONTRIBUTOR,,"**What happened**:

So I stumbled upon a very random bug. Essentially, when running the `head`-method with delayed execution on a dask Series with the pandas `string` type, I stumble upon this error:

```
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-20-a1acb387bb63> in <module>
----> 1 test = dask_df[""d""].head(compute=False).values

~/opt/miniconda3/envs/wiyd/lib/python3.8/site-packages/dask/dataframe/core.py in values(self)
   2739         will not work.
   2740         """"""
-> 2741         return self.map_partitions(methods.values)
   2742 
   2743     def _validate_chunks(self, arr, lengths):

~/opt/miniconda3/envs/wiyd/lib/python3.8/site-packages/dask/dataframe/core.py in map_partitions(self, func, *args, **kwargs)
    676         None as the division.
    677         """"""
--> 678         return map_partitions(func, self, *args, **kwargs)
    679 
    680     @insert_meta_param_description(pad=12)

~/opt/miniconda3/envs/wiyd/lib/python3.8/site-packages/dask/dataframe/core.py in map_partitions(func, meta, enforce_metadata, transform_divisions, *args, **kwargs)
   5460 
   5461     graph = HighLevelGraph.from_collections(name, dsk, dependencies=dependencies)
-> 5462     return new_dd_object(graph, name, meta, divisions)
   5463 
   5464 

~/opt/miniconda3/envs/wiyd/lib/python3.8/site-packages/dask/dataframe/core.py in new_dd_object(dsk, name, meta, divisions)
   6499                 for i in range(len(chunks[0])):
   6500                     layer[(name, i) + suffix] = layer.pop((name, i))
-> 6501         return da.Array(dsk, name=name, chunks=chunks, dtype=meta.dtype)
   6502     else:
   6503         return get_parallel_type(meta)(dsk, name, meta, divisions)

~/opt/miniconda3/envs/wiyd/lib/python3.8/site-packages/dask/array/core.py in __new__(cls, dask, name, chunks, dtype, meta, shape)
   1114         self.dask = dask
   1115         self.name = str(name)
-> 1116         meta = meta_from_array(meta, dtype=dtype)
   1117 
   1118         if (

~/opt/miniconda3/envs/wiyd/lib/python3.8/site-packages/dask/array/utils.py in meta_from_array(x, ndim, dtype)
     68 
     69     if isinstance(x, type):
---> 70         x = x(shape=(0,) * (ndim or 0), dtype=dtype)
     71 
     72     if (

TypeError: Cannot interpret 'StringDtype' as a data type
```

So what fails? (See full example below):

```python
dask_df[""d""].head(compute=False).values
```

Interestingly enough, running the delayed `head`-method on the whole dataframe works, so there must be a connection to Series with this bug. Also running the above statement without `values` works fine too:

```python
dask_df.head(compute=False).values
dask_df[""d""].head(compute=False)
```

**What you expected to happen**:
I would expect the behaviour to not error out and show the values when computed.

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import pandas as pd

df = pd.DataFrame.from_dict(
    {
        ""d"": [""a"", ""aa"", ""v"", ""aa"", ""aa"", ""aa""],
    }
)
df[""d""] = df[""d""].astype(""string"")
dask_df = dd.from_pandas(df, npartitions=2)

test = dask_df[""d""].head(compute=False).values
```

**Environment**:

- Dask version: 2021.02.0
- Python version: 3.8.6
- Operating System: MacOS
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/7206/timeline,,,jborchma,20072839,MDQ6VXNlcjIwMDcyODM5,https://avatars.githubusercontent.com/u/20072839?v=4,,https://api.github.com/users/jborchma,https://github.com/jborchma,https://api.github.com/users/jborchma/followers,https://api.github.com/users/jborchma/following{/other_user},https://api.github.com/users/jborchma/gists{/gist_id},https://api.github.com/users/jborchma/starred{/owner}{/repo},https://api.github.com/users/jborchma/subscriptions,https://api.github.com/users/jborchma/orgs,https://api.github.com/users/jborchma/repos,https://api.github.com/users/jborchma/events{/privacy},https://api.github.com/users/jborchma/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7206/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
418,https://api.github.com/repos/dask/dask/issues/7208,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7208/labels{/name},https://api.github.com/repos/dask/dask/issues/7208/comments,https://api.github.com/repos/dask/dask/issues/7208/events,https://github.com/dask/dask/issues/7208,807037218,MDU6SXNzdWU4MDcwMzcyMTg=,7208,High memory usage when loading a custom-strided/non-contigous numpy array ,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,14,2021-02-12T08:12:17Z,2021-10-14T07:16:19Z,,CONTRIBUTOR,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**: 

I am trying to load an array from numpy into dask that uses custom striding (essentially a variant of [stride_tricks](https://numpy.org/doc/stable/reference/generated/numpy.lib.stride_tricks.as_strided.html)). The problem is that calling `dask.array.from_array` creates an inflated copy of the array which blows up memory. I admit that I have not used dask before, so it can very well be user-error on my part.

The background is that I am trying to create a (naive) implementation of convolution for ndimages. In my case, both the image (stack of HD resolution images) and the kernel (kernel size >50x50) are large. Inflating the image (as is done in some convolution implementations to then rely on BLAS for matrix-matrix or matrix-vector math), is not admissible. However, we can express a windowed version of the array/image using custom strides without creating a copy/inflating. After having done that, we can apply the kernel without copying data around. After vectorization (SIMD) along the last dimension (it remains contiguous), doing so is surprisingly fast. I have a working implementation that makes it concurrent using OpenMP (apply kernel to windows in parallel), but I was musing about creating a dask-based implementation, which could be much better/cleaner.

**What you expected to happen**:

The array gets loaded into dask without creating a copy and while preserving the original strides.

**Minimal Complete Verifiable Example**:

```python
import numpy as np
from skimage.util import view_as_windows  # cleaner than using stride_tricks directly
import dask.array as da

size= 10000

# okay, only stores 10000x10000 doubles
numpy_array = view_as_windows(np.arange(size*size).reshape(size,size), (5,5))

# not okay, store 2498000400 doubles (~30x more memory needed)
foo = da.from_array(view_as_windows(np.arange(size*size).reshape(size,size), (5,5)))
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2.21.0
- Python version: 3.7.0 64-bit
- Operating System: Windows 10 V20H2
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/7208/timeline,,,FirefoxMetzger,4402489,MDQ6VXNlcjQ0MDI0ODk=,https://avatars.githubusercontent.com/u/4402489?v=4,,https://api.github.com/users/FirefoxMetzger,https://github.com/FirefoxMetzger,https://api.github.com/users/FirefoxMetzger/followers,https://api.github.com/users/FirefoxMetzger/following{/other_user},https://api.github.com/users/FirefoxMetzger/gists{/gist_id},https://api.github.com/users/FirefoxMetzger/starred{/owner}{/repo},https://api.github.com/users/FirefoxMetzger/subscriptions,https://api.github.com/users/FirefoxMetzger/orgs,https://api.github.com/users/FirefoxMetzger/repos,https://api.github.com/users/FirefoxMetzger/events{/privacy},https://api.github.com/users/FirefoxMetzger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7208/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
419,https://api.github.com/repos/dask/dask/issues/7218,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7218/labels{/name},https://api.github.com/repos/dask/dask/issues/7218/comments,https://api.github.com/repos/dask/dask/issues/7218/events,https://github.com/dask/dask/issues/7218,808634071,MDU6SXNzdWU4MDg2MzQwNzE=,7218,Should dask.array.name be a settable property?,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,20,2021-02-15T15:34:32Z,2021-04-27T22:46:37Z,,MEMBER,,"I am wondering whether `dask.Array.name` should be a settable property. Given the relationship between the task graph and `name`, it feels like `name` is a special property that should be protected. 

Consider the following case:

```python
import numpy as np
import dask.array as da

darr = da.from_array(np.arange(1, 10))
darr.name = ""foo""
darr.compute()
```

<details><summary>Output </summary>

```python-traceback
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-2-0163ab538b86> in <module>
      5 print(darr.name)
      6 darr.name = ""foo""
----> 7 darr.compute()

~/dask/dask/base.py in compute(self, **kwargs)
    280         dask.base.compute
    281         """"""
--> 282         (result,) = compute(self, traverse=False, **kwargs)
    283         return result
    284 

~/dask/dask/base.py in compute(*args, **kwargs)
    562         postcomputes.append(x.__dask_postcompute__())
    563 
--> 564     results = schedule(dsk, keys, **kwargs)
    565     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    566 

~/dask/dask/threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     74                 pools[thread][num_workers] = pool
     75 
---> 76     results = get_async(
     77         pool.apply_async,
     78         len(pool._pool),

~/dask/dask/local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    502                     finish(dsk, state, not succeeded)
    503 
--> 504     return nested_get(result, state[""cache""])
    505 
    506 

~/dask/dask/local.py in nested_get(ind, coll)
    298     """"""
    299     if isinstance(ind, list):
--> 300         return tuple([nested_get(i, coll) for i in ind])
    301     else:
    302         return coll[ind]

~/dask/dask/local.py in <listcomp>(.0)
    298     """"""
    299     if isinstance(ind, list):
--> 300         return tuple([nested_get(i, coll) for i in ind])
    301     else:
    302         return coll[ind]

~/dask/dask/local.py in nested_get(ind, coll)
    298     """"""
    299     if isinstance(ind, list):
--> 300         return tuple([nested_get(i, coll) for i in ind])
    301     else:
    302         return coll[ind]

~/dask/dask/local.py in <listcomp>(.0)
    298     """"""
    299     if isinstance(ind, list):
--> 300         return tuple([nested_get(i, coll) for i in ind])
    301     else:
    302         return coll[ind]

~/dask/dask/local.py in nested_get(ind, coll)
    300         return tuple([nested_get(i, coll) for i in ind])
    301     else:
--> 302         return coll[ind]
    303 
    304 

KeyError: ('foo', 0)
```
</details>

This is an especially confusing behavior since other libraries (like xarray and pandas) use name in a much more user-facing way (xref #7209)

**Proposal**
If I am right in my understanding that name is intentionally tied to the task graph, then I think the setter for `name` should be made to raise an error, and downstream libraries should use `self._name` instead. ",,https://api.github.com/repos/dask/dask/issues/7218/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7218/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
420,https://api.github.com/repos/dask/dask/issues/7219,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7219/labels{/name},https://api.github.com/repos/dask/dask/issues/7219/comments,https://api.github.com/repos/dask/dask/issues/7219/events,https://github.com/dask/dask/issues/7219,808648481,MDU6SXNzdWU4MDg2NDg0ODE=,7219,"dask.dataframe cannot handle timestamps-as-objects, even though Pandas can","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,23,2021-02-15T15:53:31Z,2023-01-24T20:27:01Z,,CONTRIBUTOR,,"**What happened**:

Comparing a column that is a timestamp-with-dtype-object to a `datetime.datetime()` object blows up.

**What you expected to happen**:

In Pandas, the comparison works.

**Minimal Complete Verifiable Example**:

This happens when using a fairly new Pyarrow feature that allows loading timestamps as objects in order to handle larger date ranges.

```python
import pyarrow as pa
from pyarrow import parquet as pq
import numpy as np
from dask import dataframe as dd
import pandas as pd
from pandas.testing import assert_frame_equal
from datetime import datetime


def make_df_with_timestamps():
    # Some of the milliseconds timestamps deliberately don't fit in the range
    # that is possible with nanosecond timestamps.
    df = pd.DataFrame(
        {
            ""dateTimeMs"": [
                np.datetime64(""0001-01-01 00:00"", ""ms""),
                np.datetime64(""2012-05-02 12:35"", ""ms""),
                np.datetime64(""2012-05-03 15:42"", ""ms""),
                np.datetime64(""3000-05-03 15:42"", ""ms""),
            ],
            ""dateTimeNs"": [
                np.datetime64(""1991-01-01 00:00"", ""ns""),
                np.datetime64(""2012-05-02 12:35"", ""ns""),
                np.datetime64(""2012-05-03 15:42"", ""ns""),
                np.datetime64(""2050-05-03 15:42"", ""ns""),
            ],
        }
    )
    # Not part of what we're testing, just ensuring that the inputs are what we
    # expect.
    assert (df.dateTimeMs.dtype, df.dateTimeNs.dtype) == (
        # O == object, <M8[ns] == timestamp64[ns]
        np.dtype(""O""),
        np.dtype(""<M8[ns]""),
    )
    return df


def test_timestamp_as_object_out_of_range(tmpdir):
    # Out of range timestamps can be converted Arrow and reloaded into Dask
    # DataFrame with no loss of information if the timestamp_as_object option
    # is True.
    pandas_df = make_df_with_timestamps()
    table = pa.Table.from_pandas(pandas_df)
    filename = tmpdir / ""timestamps_from_pandas.parquet""
    pq.write_table(table, filename, version=""2.0"")

    dask_df = dd.read_parquet(
        filename, engine=""pyarrow"", arrow_to_pandas={""timestamp_as_object"": True}
    )

    # Check roundtripping:
    print(pandas_df)
    pandas_df2 = dask_df.compute()
    print(pandas_df2)
    assert (pandas_df2.dateTimeMs.dtype, pandas_df2.dateTimeNs.dtype) == (
        # O == object, <M8[ns] == timestamp64[ns]
        np.dtype(""O""),
        np.dtype(""<M8[ns]""),
    )

    assert_frame_equal(pandas_df, pandas_df2)

    # Check operations:
    print(""Dask metadata"", dask_df.dateTimeMs.dtype, dask_df.dateTimeNs.dtype)

    # Comparing the nanoseconds datetime column works fine:
    pandas_df[pandas_df.dateTimeNs > datetime(2050, 1, 1, 0, 0, 0)]
    dask_df[dask_df.dateTimeNs > datetime(2050, 1, 1, 0, 0, 0)].compute()

    # Comparing the milliseconds datetime column blows up:
    pandas_df = pandas_df[pandas_df.dateTimeMs > datetime(2500, 1, 1, 0, 0, 0)]
    print(""Filtered to years>2500"", pandas_df)
    # This next line blows up:
    dask_df = dask_df[dask_df.dateTimeMs > datetime(2500, 1, 1, 0, 0, 0)]
    assert_frame_equal(pandas_df, dask_df.compute())
```

This blows up with ` TypeError(""'>' not supported between instances of 'str' and 'datetime.datetime'"")` on the line doing the Dask comparison (line before last).

**Anything else we need to know?**:

I will attempt to provide a PR fixing this.

**Environment**:

This is Dask from git as of Feb 15, 2021, but was reported to me by user using some other, released version. Python 3.8 on Linux.

```
Package         Version              Location
--------------- -------------------- -------------------------
attrs           20.3.0
dask            2021.2.0+8.g02b466d2 /home/itamarst/Devel/dask
fsspec          0.8.5
iniconfig       1.1.1
locket          0.2.1
numpy           1.20.1
packaging       20.9
pandas          1.2.2
partd           1.1.0
pip             21.0.1
pluggy          0.13.1
py              1.10.0
pyarrow         3.0.0
pyparsing       2.4.7
pytest          6.2.2
python-dateutil 2.8.1
pytz            2021.1
PyYAML          5.4.1
setuptools      49.1.3
six             1.15.0
toml            0.10.2
toolz           0.11.1
```",,https://api.github.com/repos/dask/dask/issues/7219/timeline,,,itamarst,3266662,MDQ6VXNlcjMyNjY2NjI=,https://avatars.githubusercontent.com/u/3266662?v=4,,https://api.github.com/users/itamarst,https://github.com/itamarst,https://api.github.com/users/itamarst/followers,https://api.github.com/users/itamarst/following{/other_user},https://api.github.com/users/itamarst/gists{/gist_id},https://api.github.com/users/itamarst/starred{/owner}{/repo},https://api.github.com/users/itamarst/subscriptions,https://api.github.com/users/itamarst/orgs,https://api.github.com/users/itamarst/repos,https://api.github.com/users/itamarst/events{/privacy},https://api.github.com/users/itamarst/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7219/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
421,https://api.github.com/repos/dask/dask/issues/7257,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7257/labels{/name},https://api.github.com/repos/dask/dask/issues/7257/comments,https://api.github.com/repos/dask/dask/issues/7257/events,https://github.com/dask/dask/pull/7257,813665456,MDExOlB1bGxSZXF1ZXN0NTc3Nzc2MDI2,7257,passing a list of filenames to dask.array.image.imread,[],open,False,,[],,4,2021-02-22T16:38:20Z,2021-03-16T17:49:29Z,,CONTRIBUTOR,,"-> in the aim to let the users specify the filenames they wish to work with.

A doctest illustrating such a use would be good, but I didn't find where the `'2015-*-*.png'` are located.
Feel free to complete it.

Patrick
",,https://api.github.com/repos/dask/dask/issues/7257/timeline,,,patquem,16154687,MDQ6VXNlcjE2MTU0Njg3,https://avatars.githubusercontent.com/u/16154687?v=4,,https://api.github.com/users/patquem,https://github.com/patquem,https://api.github.com/users/patquem/followers,https://api.github.com/users/patquem/following{/other_user},https://api.github.com/users/patquem/gists{/gist_id},https://api.github.com/users/patquem/starred{/owner}{/repo},https://api.github.com/users/patquem/subscriptions,https://api.github.com/users/patquem/orgs,https://api.github.com/users/patquem/repos,https://api.github.com/users/patquem/events{/privacy},https://api.github.com/users/patquem/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7257/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7257,https://github.com/dask/dask/pull/7257,https://github.com/dask/dask/pull/7257.diff,https://github.com/dask/dask/pull/7257.patch,,,,,,,,,,,,,,,,,,,
422,https://api.github.com/repos/dask/dask/issues/7266,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7266/labels{/name},https://api.github.com/repos/dask/dask/issues/7266/comments,https://api.github.com/repos/dask/dask/issues/7266/events,https://github.com/dask/dask/issues/7266,815594893,MDU6SXNzdWU4MTU1OTQ4OTM=,7266,Collaboration between Dask and Modin Dataframe,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,3,2021-02-24T15:39:26Z,2024-05-24T12:18:39Z,,CONTRIBUTOR,,"Hi folks, I'm Devin from the Modin group.

Between our groups, I believe there's a high potential for collaboration and improving the data science experience for Dask and Modin users. Due to the complexity/differences in the architectures of Dask and Modin Dataframes, there's a lot to consider. I'll outline a proposal for next steps here.

---

**Step 1: Interoperability between Modin and other Dask libraries** 
* Conversion of Modin Dataframe to:
  * Dask Dataframe
  * Dask Array
  * Other useful structures? There's a power law with Dask's other structures so it probably makes sense to prioritize based on commonality
* Interoperability between Modin Dataframe and Dask XGBoost

**Step 2: Learn from each other**
* Are there issues that are unable to be compromised (e.g. must sort row label values, must support certain operators, etc.)?
* What do Dask/Modin Dataframe users care about?
* What does Dask/Modin Dataframe allow that Modin/Dask does not?
* Is there enough overlap in our goals to combine forces?

**Step 3: Combining forces**
* How to do this will be based on Step 2 outcomes

Steps 1 and 2 can be worked on simultaneously. Regardless of the Step 2 outcomes I think Step 1 is a no-brainer.

---

Here are my high level thoughts:
* I would like Modin's users to be able to use other Dask objects and utilities
* I think Dask Dataframe users would benefit from the academic research work we've done (some yet unpublished)
* I also think there are engineering features that Modin has that would interest Dask Dataframe users as well
",,https://api.github.com/repos/dask/dask/issues/7266/timeline,,,devin-petersohn,10732128,MDQ6VXNlcjEwNzMyMTI4,https://avatars.githubusercontent.com/u/10732128?v=4,,https://api.github.com/users/devin-petersohn,https://github.com/devin-petersohn,https://api.github.com/users/devin-petersohn/followers,https://api.github.com/users/devin-petersohn/following{/other_user},https://api.github.com/users/devin-petersohn/gists{/gist_id},https://api.github.com/users/devin-petersohn/starred{/owner}{/repo},https://api.github.com/users/devin-petersohn/subscriptions,https://api.github.com/users/devin-petersohn/orgs,https://api.github.com/users/devin-petersohn/repos,https://api.github.com/users/devin-petersohn/events{/privacy},https://api.github.com/users/devin-petersohn/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7266/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
423,https://api.github.com/repos/dask/dask/issues/7280,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7280/labels{/name},https://api.github.com/repos/dask/dask/issues/7280/comments,https://api.github.com/repos/dask/dask/issues/7280/events,https://github.com/dask/dask/issues/7280,817544050,MDU6SXNzdWU4MTc1NDQwNTA=,7280,Allow custom schedulers to inline futures on persist(),"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,2,2021-02-24T17:02:17Z,2021-10-14T07:19:03Z,,CONTRIBUTOR,,"`dask.persist()` currently has [dedicated logic](https://github.com/dask/dask/blob/895c9541044e16809151f0e3db95c48ea338c6d3/dask/base.py#L744-L759) to detect if the scheduler is the Dask Distributed scheduler, which is the only path to inlining futures in the returned collections instead of resolving and materializing the concrete values of those futures; the latter happens by default for all other schedulers. In addition to this being a bit clunky, this unfortunately makes it impossible for other schedulers to match Dask Distributed's persist semantics of inlining futures, since those schedulers won't be able to tell whether they're in a `compute()` or `persist()` call.

## Possible solution

If Dask inverted this control by signaling to the scheduler that it is getting a persist call (e.g. with an injected `__persist=True` kwarg), other schedulers could opt-in to the future inlining semantics. There could still be dedicated detection logic for Dask Distributed, or there could be logic in `client.get()` to check for that flag and dispatch to a `client.persist()` variant that doesn't do the `collections_to_dsk` conversion or the post-persist transformations (I think that might be doable?), in which case the dedicated detection wouldn't be necessary.",,https://api.github.com/repos/dask/dask/issues/7280/timeline,,,clarkzinzow,7699919,MDQ6VXNlcjc2OTk5MTk=,https://avatars.githubusercontent.com/u/7699919?v=4,,https://api.github.com/users/clarkzinzow,https://github.com/clarkzinzow,https://api.github.com/users/clarkzinzow/followers,https://api.github.com/users/clarkzinzow/following{/other_user},https://api.github.com/users/clarkzinzow/gists{/gist_id},https://api.github.com/users/clarkzinzow/starred{/owner}{/repo},https://api.github.com/users/clarkzinzow/subscriptions,https://api.github.com/users/clarkzinzow/orgs,https://api.github.com/users/clarkzinzow/repos,https://api.github.com/users/clarkzinzow/events{/privacy},https://api.github.com/users/clarkzinzow/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7280/reactions,4,4,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
424,https://api.github.com/repos/dask/dask/issues/7283,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7283/labels{/name},https://api.github.com/repos/dask/dask/issues/7283/comments,https://api.github.com/repos/dask/dask/issues/7283/events,https://github.com/dask/dask/issues/7283,817579629,MDU6SXNzdWU4MTc1Nzk2Mjk=,7283,Harmonize split_every across modules,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,0,2021-02-26T18:41:36Z,2022-08-25T18:11:06Z,,MEMBER,,"The split_every parameter is currently dishomogeneous across the various dask modules:

#### dask.array
- domain: ``None`` or Integral  2 or mapping {axis: (Integral  2)}
- If ``None``, fall back to ``dask.config.get(""split_every"")``. 
- The key appears neither in ``dask/dask.yaml`` nor in ``dask/dask_schema.yaml``.
- If the key does not appear in the dask config, fall back to 4 (hardcoded).
- ``False`` is interpreted the same as ``None``.
- float (e.g. 1e3) and np.float64 are rejected, incoherently with the ``shape`` and ``chunks`` parameters.
- The docstring in ``dask.array.reductions.reduction`` is very clear about what split_every does - except that it appears nowhere in the rendered documentation; https://docs.dask.org/en/latest/array-api.html almost never mentions split_every due to the docs being auto-generated from numpy.
- The same docstring says ""Omit to let dask heuristically decide a good default"". This is incorrect; there's no heuristic; just a hard default.

#### dask.dataframe
- domain: ``None`` or ``False`` (which means no recursion) or int  2.
- If ``None``, fall back to 8 (hardcoded). The dask config is ignored.
- float and np.float64 are rejected. ``npartitions`` accepts them, but ``chunksize`` doesn't.

#### dask.bag
Same as dask.dataframe, except that ``npartitions`` does not accept float / np.float64.

#### dask.graph_manipulation
(new in #7282)
Same as dask.dataframe, except that float and np.float64 are accepted by split_every and rounded down to the nearest int.


# Proposed design
- dask.array to interpret ``False`` as no recursion, coherently with the other modules
- all modules to read the default from dask config, which will be set in ``dask/dask.yaml`` as either 4 or 8 (please discuss)
- no hardcoded defaults (coherently with the design of dask.optimize)
- ``dask/dask-schema.yaml`` to define the domain as ``False`` or int/float  2. floats will be rounded down to the nearest int. All modules to accept as functoin parameter ``None``, ``False``, or Number  2. Additionally, dask.array will accept, exclusively as a function parameter, {axis: (Number  2)}.
- review sphinx documentation

# Alternate design (not recommended)
- deprecate the top-level ``split_every`` key in dask config
- new config keys ``array.split_every``, ``dataframe.split_every``, ``bag.split_every`` and ``graph_manipulation.split_every`` which reflect the current mismatch in defaults and domain
- no hardcoded defaults
",,https://api.github.com/repos/dask/dask/issues/7283/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7283/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
425,https://api.github.com/repos/dask/dask/issues/7285,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7285/labels{/name},https://api.github.com/repos/dask/dask/issues/7285/comments,https://api.github.com/repos/dask/dask/issues/7285/events,https://github.com/dask/dask/issues/7285,817592963,MDU6SXNzdWU4MTc1OTI5NjM=,7285,clone / bind materialize the layers,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,3,2021-02-26T19:04:21Z,2021-10-14T07:10:52Z,,MEMBER,,"``dask.graph_manipulation.clone`` and ``dask.graph_manipulation.bind`` internally invoke ``HighLevelGraph.clone``, which in turn invokes ``Layer.clone``. This is a low-performance, fallback implementation which materializes the layer and returns a new ``BasicLayer``.

Override``Layer.clone`` in Blockwise and the other subclasses of Layer to provide optimized implementations that avoid materializing the layers.",,https://api.github.com/repos/dask/dask/issues/7285/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7285/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
426,https://api.github.com/repos/dask/dask/issues/7313,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7313/labels{/name},https://api.github.com/repos/dask/dask/issues/7313/comments,https://api.github.com/repos/dask/dask/issues/7313/events,https://github.com/dask/dask/issues/7313,821375774,MDU6SXNzdWU4MjEzNzU3NzQ=,7313,"Axis order from ""fancy"" indexing with dask.array does not match NumPy","[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2021-03-03T18:32:10Z,2021-08-11T23:56:20Z,,MEMBER,,"This indexing operations from Dask and NumPy should result in arrays with the same shape:
```python
import dask.array as da
import numpy as np

print(np.ones((2, 3, 4))[0, :, [0, 1]].shape)  # (2, 3)
print(da.ones((2, 3, 4))[0, :, [0, 1]].shape)  # (3, 2)
```

This is the ""Combing advanced and basic indexing"" case from NumPy: https://numpy.org/doc/stable/reference/arrays.indexing.html#combining-advanced-and-basic-indexing

It's also the same counter-intuitive example from NEP-21: https://numpy.org/neps/nep-0021-advanced-indexing.html#mixed-indexing

It would be best to fix this inconsistency, or to raise an error pointing users to `vindex`.

Note: this is somewhat related to but distinct from https://github.com/dask/dask/issues/4157

**Environment**:

- Dask version: 2.12.0
",,https://api.github.com/repos/dask/dask/issues/7313/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7313/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
427,https://api.github.com/repos/dask/dask/issues/7354,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7354/labels{/name},https://api.github.com/repos/dask/dask/issues/7354/comments,https://api.github.com/repos/dask/dask/issues/7354/events,https://github.com/dask/dask/pull/7354,827506806,MDExOlB1bGxSZXF1ZXN0NTg5NDEwNDQ5,7354,Add Dask Contrib docs,[],open,False,,[],,6,2021-03-10T10:33:33Z,2021-10-04T18:07:42Z,,MEMBER,,"This PR adds a documentation page describing the [Dask Contrib GitHub Organization](https://github.com/dask-contrib).

I have kinda arbitrarily made up all the criteria and stuff in here with things I consider sensible to give the community some guiding points to keep in mind. However some discussion and feedback here would be much appreciated.

For example I've written it with pretty formal language, but perhaps we want to make it more informal. Perhaps we want to add/remove criteria. Perhaps we don't want any criteria at all.",,https://api.github.com/repos/dask/dask/issues/7354/timeline,,,jacobtomlinson,1610850,MDQ6VXNlcjE2MTA4NTA=,https://avatars.githubusercontent.com/u/1610850?v=4,,https://api.github.com/users/jacobtomlinson,https://github.com/jacobtomlinson,https://api.github.com/users/jacobtomlinson/followers,https://api.github.com/users/jacobtomlinson/following{/other_user},https://api.github.com/users/jacobtomlinson/gists{/gist_id},https://api.github.com/users/jacobtomlinson/starred{/owner}{/repo},https://api.github.com/users/jacobtomlinson/subscriptions,https://api.github.com/users/jacobtomlinson/orgs,https://api.github.com/users/jacobtomlinson/repos,https://api.github.com/users/jacobtomlinson/events{/privacy},https://api.github.com/users/jacobtomlinson/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7354/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7354,https://github.com/dask/dask/pull/7354,https://github.com/dask/dask/pull/7354.diff,https://github.com/dask/dask/pull/7354.patch,,,,,,,,,,,,,,,,,,,
428,https://api.github.com/repos/dask/dask/issues/7371,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7371/labels{/name},https://api.github.com/repos/dask/dask/issues/7371/comments,https://api.github.com/repos/dask/dask/issues/7371/events,https://github.com/dask/dask/issues/7371,829503395,MDU6SXNzdWU4Mjk1MDMzOTU=,7371,Dask ProgressBar not playing well with logger messages,"[{'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,7,2021-03-11T20:35:40Z,2022-08-25T18:05:52Z,,NONE,,"```python
from loguru import logger
import dask.array as da
from dask.diagnostics import ProgressBar

a = da.random.normal(size=(10000, 1), chunks=(1000, 1))

def f(x):
    logger.warning(""Ouch!"")
    return x**2

with ProgressBar():
    a = a.map_blocks(f)
    a = a.compute()
```
<img src=""https://user-images.githubusercontent.com/14086031/110851643-4e3cd880-827f-11eb-8fb0-e44fbfc1adb5.png"" width=70%>
",,https://api.github.com/repos/dask/dask/issues/7371/timeline,,,ma-sadeghi,14086031,MDQ6VXNlcjE0MDg2MDMx,https://avatars.githubusercontent.com/u/14086031?v=4,,https://api.github.com/users/ma-sadeghi,https://github.com/ma-sadeghi,https://api.github.com/users/ma-sadeghi/followers,https://api.github.com/users/ma-sadeghi/following{/other_user},https://api.github.com/users/ma-sadeghi/gists{/gist_id},https://api.github.com/users/ma-sadeghi/starred{/owner}{/repo},https://api.github.com/users/ma-sadeghi/subscriptions,https://api.github.com/users/ma-sadeghi/orgs,https://api.github.com/users/ma-sadeghi/repos,https://api.github.com/users/ma-sadeghi/events{/privacy},https://api.github.com/users/ma-sadeghi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7371/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
429,https://api.github.com/repos/dask/dask/issues/7375,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7375/labels{/name},https://api.github.com/repos/dask/dask/issues/7375/comments,https://api.github.com/repos/dask/dask/issues/7375/events,https://github.com/dask/dask/pull/7375,829747075,MDExOlB1bGxSZXF1ZXN0NTkxMzYyMzkz,7375,DataFrame: handle ExtensionArrays when converting to dask.Array,[],open,False,,[],,0,2021-03-12T04:29:51Z,2021-04-02T18:04:40Z,,MEMBER,,"In #7206, computing the `meta` from a column containing a pandas ExtensionArray failed, because we were assuming the chunk type of the resulting array would always be a NumPy array, which doesn't know what to make of a pandas extension dtype.

There are two approaches we could take:
1) (56757b3 only) use `to_numpy()` instead of `.values` ([as recommended](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.values.html#pandas.DataFrame.values)), to be sure that any extension arrays are converted to NumPy arrays (both in the `meta`, and the actual compute).
2) (+ c15c4ea) Keep using `.values`, and let a pandas ExtensionArray be the `meta` of a Dask array. This avoids an (in some cases expensive) conversion, but might lead to weird downstream behavior, since the extension arrays aren't registered as dask chunk types, plus they can only be 1D.

Update: went with approach 1 (coerce to a NumPy array) after discussing with @jrbourbeau: we were unsure whether ExtensionArrays would behave correctly as chunk types and the API is still moving around, so let's play it safe and stick with NumPy for now.

In either case, I also extended `to_dask_array` to match [`to_numpy`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy), so you can specify a `dtype` and `na_value`, which will be handy as the extension array types become more prevalent.

@TomAugspurger any thoughts on which approach to take?

- [x] Closes #7206
- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask`
",,https://api.github.com/repos/dask/dask/issues/7375/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7375/reactions,2,1,0,0,0,0,0,0,1,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7375,https://github.com/dask/dask/pull/7375,https://github.com/dask/dask/pull/7375.diff,https://github.com/dask/dask/pull/7375.patch,,,,,,,,,,,,,,,,,,,
430,https://api.github.com/repos/dask/dask/issues/7377,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7377/labels{/name},https://api.github.com/repos/dask/dask/issues/7377/comments,https://api.github.com/repos/dask/dask/issues/7377/events,https://github.com/dask/dask/issues/7377,830065133,MDU6SXNzdWU4MzAwNjUxMzM=,7377,map_partition performing calculations on metadata,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}]",open,False,,[],,9,2021-03-12T12:19:21Z,2021-03-25T20:51:57Z,,NONE,,"When I call map_partitions on my accessor, get some unexpected issues.  

The first partition has data that is unrelated to the rest of my data.  This is causing issues performing type specific data.  How do I do I account for this first group of data?   It appears the first group is the set of data from the registration of the `make_nonempty.register` call.  

```
@make_array_nonempty.register(GeoType)
def _(dtype):
    a = np.array([_default_geometry(), _default_geometry()], dtype=object)
    return _from_geometry(a)
```

Is there a tag stating this is metadata?  I don't want map_partitions to look at this chunk.


```python
     SHAPE                                                        fielda  b
0  {""x"": 0, ""y"": 0, ""spatialReference"": {""wkid"": ...       1  1
1  {""x"": 0, ""y"": 0, ""spatialReference"": {""wkid"": ...       1  1
                                               SHAPE                             fielda  b
8  {""curveRings"": [[[-35.09392053986361, 7.573204...    2729  2
9  {""curveRings"": [[[7.505218982136703, 18.358753...    5387  2
                                               SHAPE                             fielda  b
2  {""curveRings"": [[[35.51113767361919, 12.957382...    9575  2
3  {""curveRings"": [[[-18.30138894072785, -16.9425...    9151  2
                                               SHAPE                             fielda  b
6  {""curveRings"": [[[-21.068573113681047, 33.0624...    2846  2
7  {""curveRings"": [[[-36.53534927307355, 7.872075...    4623  2
                                               SHAPE                             fielda  b
0  {""curveRings"": [[[-21.43621100432236, 1.310434...    1708  2
1  {""curveRings"": [[[-11.702427410357348, 30.1368...    9153  2
                                               SHAPE                            fielda  b
4  {""curveRings"": [[[33.74060870013736, 40.225838...     828  2
5  {""curveRings"": [[[-1.1111195840167558, -20.320...    4718  2
```

I need the operation to skip this snippet below:

```python
     SHAPE                                                        fielda  b
0  {""x"": 0, ""y"": 0, ""spatialReference"": {""wkid"": ...       1  1
1  {""x"": 0, ""y"": 0, ""spatialReference"": {""wkid"": ...       1  1
```



I think a solution could be to use `get_partitions` but I think this would prevent the distribution of code to fail.  Any solutions welcome.

#### UPDATE 1:
This only occurs is `meta` isn't specified on the `map_partitions`, but the custom type can't be understood...  

Thank you
",,https://api.github.com/repos/dask/dask/issues/7377/timeline,,,achapkowski,5131271,MDQ6VXNlcjUxMzEyNzE=,https://avatars.githubusercontent.com/u/5131271?v=4,,https://api.github.com/users/achapkowski,https://github.com/achapkowski,https://api.github.com/users/achapkowski/followers,https://api.github.com/users/achapkowski/following{/other_user},https://api.github.com/users/achapkowski/gists{/gist_id},https://api.github.com/users/achapkowski/starred{/owner}{/repo},https://api.github.com/users/achapkowski/subscriptions,https://api.github.com/users/achapkowski/orgs,https://api.github.com/users/achapkowski/repos,https://api.github.com/users/achapkowski/events{/privacy},https://api.github.com/users/achapkowski/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7377/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
431,https://api.github.com/repos/dask/dask/issues/7399,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7399/labels{/name},https://api.github.com/repos/dask/dask/issues/7399/comments,https://api.github.com/repos/dask/dask/issues/7399/events,https://github.com/dask/dask/pull/7399,832174320,MDExOlB1bGxSZXF1ZXN0NTkzMzc3Njcx,7399,DataFrame: allow map_partitions to make Arrays with non-NumPy chunks,[],open,False,,[],,7,2021-03-15T20:39:18Z,2021-06-18T16:54:02Z,,MEMBER,,"Currently, if your `map_partitions` function returns an array-like object that's not a NumPy array (and has a dtype which isn't a NumPy dtype), `map_partitions` will fail when constructing `meta`. This PR allows whatever `meta` was produced to pass through directly to the Array. This _should_ make mapped functions that return pandas ExtensionArrays ""just work"" (can add some tests that that's so if we want to go ahead with this). And if the ExtensionArray type won't behave well as an Array chunk type for a particular operation, then hopefully doing that operation on the `meta` should fail as well.

This was a 1-line change, but it then breaks other tests:

* `DataFrame.to_records` now produces an Array where the `meta` is an `np.recarray`, not an `np.ndarray`
* But when you `compute` an Array of `recarray`s, the chunks get concatenated with `np.concatenate`, which doesn't preserve ndarray subclasses. This causes `assert_eq` to complain that the type changed when computed (meta type is `recarray`, computed type is `ndarray`).
* When you make `concatenate` preserve ndarray subclasses, `test_to_npy_stack` fails, because the `meta` for the Array indicated `ndarray`, but the result was actually `memmap` (because the chunks are `memmap`s, which we now preserve).

So that's why I also added logic for concatenate to preserve ndarray subclasses. If we even are okay with that change, I'd be fine splitting it to a separate PR for clarity.

cc @jrbourbeau: is this worth doing?

Related to https://github.com/dask/dask/issues/7377#issuecomment-799594266 and #7206.

- [ ] Tests added / passed
- [x] Passes `black dask` / `flake8 dask`
",,https://api.github.com/repos/dask/dask/issues/7399/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7399/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/7399,https://github.com/dask/dask/pull/7399,https://github.com/dask/dask/pull/7399.diff,https://github.com/dask/dask/pull/7399.patch,,,,,,,,,,,,,,,,,,,
432,https://api.github.com/repos/dask/dask/issues/7400,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7400/labels{/name},https://api.github.com/repos/dask/dask/issues/7400/comments,https://api.github.com/repos/dask/dask/issues/7400/events,https://github.com/dask/dask/pull/7400,832348878,MDExOlB1bGxSZXF1ZXN0NTkzNTIxNzMw,7400,bug: TypeError handling in groupby apply,[],open,False,,[],,7,2021-03-16T02:23:57Z,2021-03-18T22:07:01Z,,FIRST_TIME_CONTRIBUTOR,,"This was a tricky one to isolate. While I do have this reproducible test, and found some relevant pandas code, I'm not sure why it's even worse when interacting with the dask multiprocess scheduler.

Checks two issues:
  1. Is the `groupby().apply`'d function called twice, but with a missing column on the second call?
  2. Is a TypeError (and only a TypeError) thrown from the first call swallowed and hidden

TypeErrors are handled differently due to this code in pandas:
https://github.com/pandas-dev/pandas/blob/v1.3.0.dev0/pandas/core/groupby/groupby.py#L892-L905
",,https://api.github.com/repos/dask/dask/issues/7400/timeline,,,brycedrennan,1217531,MDQ6VXNlcjEyMTc1MzE=,https://avatars.githubusercontent.com/u/1217531?v=4,,https://api.github.com/users/brycedrennan,https://github.com/brycedrennan,https://api.github.com/users/brycedrennan/followers,https://api.github.com/users/brycedrennan/following{/other_user},https://api.github.com/users/brycedrennan/gists{/gist_id},https://api.github.com/users/brycedrennan/starred{/owner}{/repo},https://api.github.com/users/brycedrennan/subscriptions,https://api.github.com/users/brycedrennan/orgs,https://api.github.com/users/brycedrennan/repos,https://api.github.com/users/brycedrennan/events{/privacy},https://api.github.com/users/brycedrennan/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7400/reactions,0,0,0,0,0,0,0,0,0,brycedrennan,1217531.0,MDQ6VXNlcjEyMTc1MzE=,https://avatars.githubusercontent.com/u/1217531?v=4,,https://api.github.com/users/brycedrennan,https://github.com/brycedrennan,https://api.github.com/users/brycedrennan/followers,https://api.github.com/users/brycedrennan/following{/other_user},https://api.github.com/users/brycedrennan/gists{/gist_id},https://api.github.com/users/brycedrennan/starred{/owner}{/repo},https://api.github.com/users/brycedrennan/subscriptions,https://api.github.com/users/brycedrennan/orgs,https://api.github.com/users/brycedrennan/repos,https://api.github.com/users/brycedrennan/events{/privacy},https://api.github.com/users/brycedrennan/received_events,User,False,False,https://api.github.com/repos/dask/dask/pulls/7400,https://github.com/dask/dask/pull/7400,https://github.com/dask/dask/pull/7400.diff,https://github.com/dask/dask/pull/7400.patch,,,,,,,,,,,,,,,,,,,
433,https://api.github.com/repos/dask/dask/issues/7416,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7416/labels{/name},https://api.github.com/repos/dask/dask/issues/7416/comments,https://api.github.com/repos/dask/dask/issues/7416/events,https://github.com/dask/dask/issues/7416,835822983,MDU6SXNzdWU4MzU4MjI5ODM=,7416,compute_chunk_sizes could be more efficient for arrays with >1 dimension,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2021-03-19T10:37:55Z,2021-05-26T14:57:46Z,,CONTRIBUTOR,,"MCVE: https://colab.research.google.com/drive/1KNlfPiZECPcCestEh3gzpDrB9mvbbN2H?usp=sharing

In the above example, after indexing a 3d dask array with a 1d dask array via `da.compress()`, I would like to then compute the chunk sizes. Running `compute_chunk_sizes()` takes 44 s. Manually computing the chunk sizes requires ~200 ms. 

Looking at the source code for `compute_chunk_sizes()` I suspect the inefficiency comes because it is mapping a function across all blocks in the array, whereas it only needs to compute the chunk sizes along the margin of each dimension. I.e., a lot of work is being duplicated.

Btw this is a usability issue that's come up in working with large genomic datasets. When there are multiple large n-d arrays that need to be indexed and have their chunk sizes computed, it is inconvenient to have to wait minutes for that operation to complete. This came up in the course of investigating https://github.com/pydata/xarray/issues/4663.

**Environment**:

- Dask version: 2021.3.0
- Python version: 3.6
- Operating System: Ubuntu
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/7416/timeline,,,alimanfoo,703554,MDQ6VXNlcjcwMzU1NA==,https://avatars.githubusercontent.com/u/703554?v=4,,https://api.github.com/users/alimanfoo,https://github.com/alimanfoo,https://api.github.com/users/alimanfoo/followers,https://api.github.com/users/alimanfoo/following{/other_user},https://api.github.com/users/alimanfoo/gists{/gist_id},https://api.github.com/users/alimanfoo/starred{/owner}{/repo},https://api.github.com/users/alimanfoo/subscriptions,https://api.github.com/users/alimanfoo/orgs,https://api.github.com/users/alimanfoo/repos,https://api.github.com/users/alimanfoo/events{/privacy},https://api.github.com/users/alimanfoo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7416/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
434,https://api.github.com/repos/dask/dask/issues/7437,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7437/labels{/name},https://api.github.com/repos/dask/dask/issues/7437/comments,https://api.github.com/repos/dask/dask/issues/7437/events,https://github.com/dask/dask/issues/7437,837813629,MDU6SXNzdWU4Mzc4MTM2Mjk=,7437,Backend for scipy sparse building csr/csc matrix inefficiently,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,1,2021-03-22T15:09:50Z,2022-08-25T17:53:05Z,,NONE,,"**What happened**:
I'm using dask to work with `scipy.sparse` `csr_matrix`'s that are returned from `dask_ml.feature_extraction.text.HashingVectorizer`.
I need to save the matrix to disk and I was not able to do this with TileDB, Zarr or HDF5. (Maybe their is a way, but I haven't figured it out.)
So, I implemented a simple `SparseCache` class that supports numpy-style setitem indexing while under the hood it stores the chunks as npz files using `scipy.sparse.save_npz` and retrieves them with `scipy.sparse.load_npz`.
Later, I load this data back into a Dask Array. Then, I want to get the matrix in memory locally, so I call compute() and I get an out of memory error. The matrix is about 4 GB and I have 12 GB memory available locally, so it should fit.
I debug the code and find that in `dask.array.backends.register_scipy_sparse._concatenate` the function `scipy.sparse.hstack(L)` is being called a bunch of times on lists of `csr_matrix` objects with length of 1.
Right before `scipy.sparse.vstack(L)` is called to build the final matrix, the memory usage has already doubled to 8 GB because all of the data has been unnecessarily duplicated by these `hstack` calls.

**What you expected to happen**:
The `backends` code for scipy sparse shouldn't waste memory by duplicating data unnecessarily.

**Minimal Complete Verifiable Example**:

```python
import dask.array as dask_array
cw = SparseCache() #A custom class that supports numpy-style setitem indexing using scipy.sparse.save_npz/load_npz to access chunks of scipy sparse matricies
x = dask_array.from_array(cw, chunks=cw.chunks, lock=False, asarray=False, fancy=True, inline_array=False)
x = x.compute()
```

**Anything else we need to know?**:
If I change `dask.array.backends.register_scipy_sparse._concatenate` as below, then the data isn't duplicated.
```
    def _concatenate(L, axis=0):
        if axis == 0:
            #return scipy.sparse.vstack(L)
            return L[0] if len(L) == 1 else scipy.sparse.vstack(L)
        elif axis == 1:
            #return scipy.sparse.hstack(L)
            return L[0] if len(L) == 1 else scipy.sparse.hstack(L)
        else:
            msg = (
                ""Can only concatenate scipy sparse matrices for axis in ""
                ""{0, 1}.  Got %s"" % axis
            )
            raise ValueError(msg)
```

**Environment**:

- Dask version: 2021.3.0
- Python version: 3.7.7
- Operating System: Win10
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/7437/timeline,,,ag-tcm,66845101,MDQ6VXNlcjY2ODQ1MTAx,https://avatars.githubusercontent.com/u/66845101?v=4,,https://api.github.com/users/ag-tcm,https://github.com/ag-tcm,https://api.github.com/users/ag-tcm/followers,https://api.github.com/users/ag-tcm/following{/other_user},https://api.github.com/users/ag-tcm/gists{/gist_id},https://api.github.com/users/ag-tcm/starred{/owner}{/repo},https://api.github.com/users/ag-tcm/subscriptions,https://api.github.com/users/ag-tcm/orgs,https://api.github.com/users/ag-tcm/repos,https://api.github.com/users/ag-tcm/events{/privacy},https://api.github.com/users/ag-tcm/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7437/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
435,https://api.github.com/repos/dask/dask/issues/7459,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7459/labels{/name},https://api.github.com/repos/dask/dask/issues/7459/comments,https://api.github.com/repos/dask/dask/issues/7459/events,https://github.com/dask/dask/pull/7459,839235035,MDExOlB1bGxSZXF1ZXN0NTk5MjgzMDAy,7459,[DNM] Guide updates for PipInstall changes,[],open,False,,[],,6,2021-03-24T00:36:28Z,2021-06-09T20:49:26Z,,MEMBER,,"Updates for the ""Managing environments"" guide for dask/distributed#4628**do not merge until that is merged**. (The API is also under some debate; I'll update this accordingly once we reach a consensus.)",,https://api.github.com/repos/dask/dask/issues/7459/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7459/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7459,https://github.com/dask/dask/pull/7459,https://github.com/dask/dask/pull/7459.diff,https://github.com/dask/dask/pull/7459.patch,,,,,,,,,,,,,,,,,,,
436,https://api.github.com/repos/dask/dask/issues/7482,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7482/labels{/name},https://api.github.com/repos/dask/dask/issues/7482/comments,https://api.github.com/repos/dask/dask/issues/7482/events,https://github.com/dask/dask/issues/7482,843451063,MDU6SXNzdWU4NDM0NTEwNjM=,7482,Array unique fails with cupy backed arrays during cpu/gpu setitem,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,6,2021-03-29T14:51:42Z,2021-10-14T07:44:28Z,,MEMBER,,"When we call `unique` on a cupy backed dask array, we fail due to a setitem on a numpy array with a cupy array. Perhaps using `np.empty_like` rather than `np.empty` may help resolve this, though there may be more complexity due to the complex dimension/dtype handling:

https://github.com/dask/dask/blob/cdb89fe317a43393f6c89cd780b54a3260839fd3/dask/array/routines.py#L1041-L1059

```python-traceback
import dask.array as da
import numpy as np
import cupy as cp

arr = np.random.randint(0, 5, 20)
darr = da.from_array(arr)
da.unique(darr).compute() # array([0, 1, 2, 3, 4])

arr = cp.random.randint(0, 5, 20)
darr = da.from_array(arr)
da.unique(darr).compute()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-19-2d8a28a02ebf> in <module>
      9 arr = cp.random.randint(0, 5, 20)
     10 darr = da.from_array(arr)
---> 11 da.unique(darr).compute()

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/base.py in compute(self, **kwargs)
    281         dask.base.compute
    282         """"""
--> 283         (result,) = compute(self, traverse=False, **kwargs)
    284         return result
    285 

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/base.py in compute(*args, **kwargs)
    563         postcomputes.append(x.__dask_postcompute__())
    564 
--> 565     results = schedule(dsk, keys, **kwargs)
    566     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    567 

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     74                 pools[thread][num_workers] = pool
     75 
---> 76     results = get_async(
     77         pool.apply_async,
     78         len(pool._pool),

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    485                         _execute_task(task, data)  # Re-execute locally
    486                     else:
--> 487                         raise_exception(exc, tb)
    488                 res, worker_id = loads(res_info)
    489                 state[""cache""][key] = res

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/local.py in reraise(exc, tb)
    315     if exc.__traceback__ is not tb:
    316         raise exc.with_traceback(tb)
--> 317     raise exc
    318 
    319 

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    220     try:
    221         task, data = loads(task_info)
--> 222         result = _execute_task(task, data)
    223         id = get_id()
    224         result = dumps((result, id))

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in <genexpr>(.0)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in <genexpr>(.0)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in <genexpr>(.0)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    113     """"""
    114     if isinstance(arg, list):
--> 115         return [_execute_task(a, cache) for a in arg]
    116     elif istask(arg):
    117         func, args = arg[0], arg[1:]

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in <listcomp>(.0)
    113     """"""
    114     if isinstance(arg, list):
--> 115         return [_execute_task(a, cache) for a in arg]
    116     elif istask(arg):
    117         func, args = arg[0], arg[1:]

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/optimization.py in __call__(self, *args)
    961         if not len(args) == len(self.inkeys):
    962             raise ValueError(""Expected %d args, got %d"" % (len(self.inkeys), len(args)))
--> 963         return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
    964 
    965     def __reduce__(self):

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in get(dsk, out, cache)
    149     for key in toposort(dsk):
    150         task = dsk[key]
--> 151         result = _execute_task(task, cache)
    152         cache[key] = result
    153     result = _execute_task(out, cache)

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in <genexpr>(.0)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/utils.py in apply(func, args, kwargs)
     33 def apply(func, args, kwargs=None):
     34     if kwargs:
---> 35         return func(*args, **kwargs)
     36     else:
     37         return func(*args)

/raid/nicholasb/miniconda3/envs/cuml-dev/lib/python3.8/site-packages/dask/array/routines.py in _unique_internal(ar, indices, counts, return_inverse)
   1048 
   1049     r = np.empty(u.shape, dtype=dt)
-> 1050     r[""values""] = u
   1051     if return_inverse:
   1052         r[""inverse""] = np.arange(len(r), dtype=np.intp)

cupy/core/core.pyx in cupy.core.core.ndarray.__array__()

TypeError: Implicit conversion to a NumPy array is not allowed. Please use `.get()` to construct a NumPy array explicitly.
```

```
conda list | grep ""dask\|cupy\|numpy""
cupy                      8.5.0            py38ha0d87d6_1    conda-forge
dask                      2021.3.0+56.g913a192f          pypi_0    pypi
dask-cuda                 0.19.0a210326           py38_45    rapidsai-nightly
dask-cudf                 0.19.0a210326   py38_gad5452d7eb_288    rapidsai-nightly
dask-glm                  0.2.1.dev52+g1daf4c5.d20210326           dev_0    <develop>
dask-labextension         4.0.1              pyhd8ed1ab_0    conda-forge
dask-ml                   1.8.0              pyhd8ed1ab_0    conda-forge
numpy                     1.20.1           py38h18fd61f_0    conda-forge
numpydoc                  1.1.0                      py_1    conda-forge
```",,https://api.github.com/repos/dask/dask/issues/7482/timeline,,,beckernick,8457388,MDQ6VXNlcjg0NTczODg=,https://avatars.githubusercontent.com/u/8457388?v=4,,https://api.github.com/users/beckernick,https://github.com/beckernick,https://api.github.com/users/beckernick/followers,https://api.github.com/users/beckernick/following{/other_user},https://api.github.com/users/beckernick/gists{/gist_id},https://api.github.com/users/beckernick/starred{/owner}{/repo},https://api.github.com/users/beckernick/subscriptions,https://api.github.com/users/beckernick/orgs,https://api.github.com/users/beckernick/repos,https://api.github.com/users/beckernick/events{/privacy},https://api.github.com/users/beckernick/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7482/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
437,https://api.github.com/repos/dask/dask/issues/7510,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7510/labels{/name},https://api.github.com/repos/dask/dask/issues/7510/comments,https://api.github.com/repos/dask/dask/issues/7510/events,https://github.com/dask/dask/issues/7510,849411466,MDU6SXNzdWU4NDk0MTE0NjY=,7510,Local scheduler parameter `chunksize`,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,4,2021-04-02T19:16:47Z,2022-08-25T19:05:03Z,,MEMBER,,"Recently we added the ability to batch submissions with the local scheduler [using `chunksize`]( https://github.com/dask/dask/blob/a31c0fc72e1cc59b8b0254965824abb0718c5f56/dask/local.py#L420 ) as users have voiced interest ( https://github.com/dask/dask/issues/6220#issuecomment-648878068 ). Mostly this is unused (so a no-op) with [the exception of the `multiprocessing` case where we do some batching]( https://github.com/dask/dask/blob/a31c0fc72e1cc59b8b0254965824abb0718c5f56/dask/multiprocessing.py#L178 ) to amortize the cost of process spin up. It's also not that visible in the documentation or elsewhere. That said, we might want to share this more broadly.

One question that comes up with this is whether we like the parameter name, `chunksize` (taken from `concurrent.futures` and used elsewhere ( https://github.com/dask/distributed/pull/3650 )) or if that's confusing and we want to use something else like `batchsize`. Another question is this sits at the top-level config (similar to other things like [`pool` and `num_workers`]( https://github.com/dask/dask/blob/a31c0fc72e1cc59b8b0254965824abb0718c5f56/dask/multiprocessing.py#L179-L180 )), is that where we want this? Lastly is this parameter useful outside the local scheduler (like would Distributed want to use this)

",,https://api.github.com/repos/dask/dask/issues/7510/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7510/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
438,https://api.github.com/repos/dask/dask/issues/7545,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7545/labels{/name},https://api.github.com/repos/dask/dask/issues/7545/comments,https://api.github.com/repos/dask/dask/issues/7545/events,https://github.com/dask/dask/issues/7545,855083852,MDU6SXNzdWU4NTUwODM4NTI=,7545,Duplicated computations with mixed array/dataframe delayed output,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2021-04-10T14:49:18Z,2021-10-14T07:37:51Z,,CONTRIBUTOR,,"**What happened**:

A computation from a delayed call returning two outputs is done twice when one output is array and one output is a dataframe.  Interestingly, if both outputs are arrays, or both outputs are dataframes, the duplication does not occur.  

If the two outputs (one array, one dataframe) are fed to another delayed call, a computation on the output of that 2nd delayed call does not cause in the extra computation.

In the code below, `compute` is printed twice under 'Individually'.

**What you expected to happen**:

`compute` should be printed once under 'Individually'.

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.array as da
import dask.dataframe as dd
import numpy as np
import pandas as pd

def calc():
    print('compute')
    return np.zeros(1), pd.DataFrame({'z': [1]})

res = dask.delayed(calc, nout=2)()
res0 = da.from_delayed(res[0], shape=(1,), dtype=np.float64)
res1 = dd.from_delayed(res[1], meta=[('z', np.int64)])

print('Individually')
_ = dask.compute(res0, res1, scheduler='synchronous')

def comb(a, b):
    return a, b
res_comb = dask.delayed(comb)(res0, res1)

print()
print('Combined')
_ = dask.compute(res_comb, scheduler='synchronous')
```

```sh
Individually
compute
compute

Combined
compute
```

**Anything else we need to know?**:

I do not think this is a meta/dtype/shape inference issue, as duplication isn't happening with the ""Combined"" computation.

**Environment**:

- Dask version: 2021.04.0+16.ge83379d5
- Python version: 3.8.8
- Operating System: MacOS 11.2.3
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/7545/timeline,,,chrisroat,1053153,MDQ6VXNlcjEwNTMxNTM=,https://avatars.githubusercontent.com/u/1053153?v=4,,https://api.github.com/users/chrisroat,https://github.com/chrisroat,https://api.github.com/users/chrisroat/followers,https://api.github.com/users/chrisroat/following{/other_user},https://api.github.com/users/chrisroat/gists{/gist_id},https://api.github.com/users/chrisroat/starred{/owner}{/repo},https://api.github.com/users/chrisroat/subscriptions,https://api.github.com/users/chrisroat/orgs,https://api.github.com/users/chrisroat/repos,https://api.github.com/users/chrisroat/events{/privacy},https://api.github.com/users/chrisroat/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7545/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
439,https://api.github.com/repos/dask/dask/issues/7550,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7550/labels{/name},https://api.github.com/repos/dask/dask/issues/7550/comments,https://api.github.com/repos/dask/dask/issues/7550/events,https://github.com/dask/dask/issues/7550,856435612,MDU6SXNzdWU4NTY0MzU2MTI=,7550,Slicing with broadcastable subarray fails,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2021-04-12T23:32:52Z,2021-04-12T23:53:40Z,,MEMBER,,"Currently slicing with a single array, which could be broadcasted fails. If this array is broadcasted, things work without issues

**What happened**:

```python
---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
<ipython-input-4-48d1ef76a37c> in <module>
----> 1 a[b]

~/Developer/dask/dask/array/core.py in __getitem__(self, index)
   1721             self, index2 = slice_with_int_dask_array(self, index2)
   1722         if any(isinstance(i, Array) and i.dtype == bool for i in index2):
-> 1723             self, index2 = slice_with_bool_dask_array(self, index2)
   1724 
   1725         if all(isinstance(i, slice) and i == slice(None) for i in index2):

~/Developer/dask/dask/array/slicing.py in slice_with_bool_dask_array(x, index)
   1159         isinstance(ind, Array) and ind.dtype == bool and ind.ndim != 1 for ind in index
   1160     ):
-> 1161         raise NotImplementedError(
   1162             ""Slicing with dask.array of bools only permitted when ""
   1163             ""the indexer has only one dimension or when ""

NotImplementedError: Slicing with dask.array of bools only permitted when the indexer has only one dimension or when it has the same dimension as the sliced array
```

**What you expected to happen**:

Broadcasting is handled for us

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.array as da

import numpy as np

s = (2, 2, 4, 5)
a = da.arange(int(np.prod(s))).reshape(s)
b = da.array([[True, False], [True, True]])

a[da.broadcast_to(b[..., None, None], shape=a.shape)]  # <--- works

a[b]                                                   # <--- fails

```

**Anything else we need to know?**:

Derived from comment ( https://github.com/data-apis/array-api/issues/84#issuecomment-818289677 )

cc @asmeurer

**Environment**:

- Dask version: 2021.4.0
- Python version: 3.8.8
- Operating System: macOS
- Install method (conda, pip, source): Conda
",,https://api.github.com/repos/dask/dask/issues/7550/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7550/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
440,https://api.github.com/repos/dask/dask/issues/7554,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7554/labels{/name},https://api.github.com/repos/dask/dask/issues/7554/comments,https://api.github.com/repos/dask/dask/issues/7554/events,https://github.com/dask/dask/issues/7554,857007924,MDU6SXNzdWU4NTcwMDc5MjQ=,7554,Blockwise chunk alignment metadata incorrect,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2021-04-13T14:16:39Z,2021-04-15T21:00:33Z,,MEMBER,,"The shapes of `z` and `z.compute()` don't match. This leads to lots of other strange behavior like slicing not working properly.

```python
import operator
import numpy as np
import dask.array as da

a = da.from_array([0, 1, 2], chunks=1)
b = da.from_array([10, 50, 100], chunks=3)
z = da.blockwise(np.outer, 'ji', a, 'i', b, 'j')
da.utils.assert_eq(z, z)
```
```python-traceback
---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
<ipython-input-18-034a387c96f6> in <module>
----> 1 da.utils.assert_eq(z, z)

~/conda/envs/dask-dev/lib/python3.8/site-packages/dask/array/utils.py in assert_eq(a, b, check_shape, check_graph, check_meta, **kwargs)
    259     b_original = b
    260 
--> 261     a, adt, a_meta, a_computed = _get_dt_meta_computed(
    262         a, check_shape=check_shape, check_graph=check_graph
    263     )

~/conda/envs/dask-dev/lib/python3.8/site-packages/dask/array/utils.py in _get_dt_meta_computed(x, check_shape, check_graph)
    246             assert x.dtype == x_original.dtype
    247         if check_shape:
--> 248             assert_eq_shape(x_original.shape, x.shape, check_nan=False)
    249     else:
    250         if not hasattr(x, ""dtype""):

~/conda/envs/dask-dev/lib/python3.8/site-packages/dask/array/utils.py in assert_eq_shape(a, b, check_nan)
    223                 assert math.isnan(aa) == math.isnan(bb)
    224         else:
--> 225             assert aa == bb
    226 
    227 

AssertionError: 
```",,https://api.github.com/repos/dask/dask/issues/7554/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7554/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
441,https://api.github.com/repos/dask/dask/issues/7574,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7574/labels{/name},https://api.github.com/repos/dask/dask/issues/7574/comments,https://api.github.com/repos/dask/dask/issues/7574/events,https://github.com/dask/dask/issues/7574,861401478,MDU6SXNzdWU4NjE0MDE0Nzg=,7574,Duplicated keys in da.linalg functions,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,7,2021-04-19T14:56:09Z,2022-01-07T17:41:36Z,,MEMBER,,"The functions

- da.linalg.cholesky
- da.linalg.lu
- da.linalg.solve (it's a wrapper around the above two)

contain the same keys in multiple layers of the HighLevelGraph.
Since #7274 (2021.03.1), this causes ``len`` to return an incorrect result:

```python
>>> a = da.random.normal((3, 3), chunks=-1)
>>> b = da.random.normal((3, 3), chunks=-1)
>>> c = da.linalg.solve(a, b)
>>> len(c.dask)
27
>>> len(c.dask.to_dict())
13
```

The problem is not an easy one to solve. Both cholesky and lu produce two output arrays, a lower and a higher matrix.
The chunks below the diagonal of the lower matrix are a function of the matching chunks of the higher matrix.
The chunks above the diagonal of the higher matrix are a function of the matching chunks of the lower matrix.

Hence, 
1. one cannot have a separate layer for the lower matrix and another for the higher matrix, because that would cause a circular dependency in ``HighLevelGraph.dependencies``.
2. one also cannot have the two matrices use the same layer, because ``da.Array.__dask_layers__`` is hardcoded to ``(self.name, )``.

The current implementation puts all the keys in a single dict and then creates two layers out of it - hence the duplication.
```python

    graph_upper = HighLevelGraph.from_collections(name_upper, dsk, dependencies=[a])
    graph_lower = HighLevelGraph.from_collections(name, dsk, dependencies=[a])
    [...]
    upper = Array(graph_upper, name_upper, shape=a.shape, chunks=a.chunks, meta=meta)
    lower = Array(graph_lower, name, shape=a.shape, chunks=a.chunks, meta=meta)
    return lower, upper
```

# Proposed solutions

## 1. Do nothing
Update the docstring of ``HighLevelGraph.__len__`` to state that there are legitimate cases where the output won't be accurate.
**Pros:** trivial
**Cons:** confused users; violates the ``collections.abc.Mapping`` protocol; duplicates data upon msgpack serialization

## 2. Skip already-seen layers
Modify ``HighLevelGraph.__len__`` to skip layers whose ``id`` has already been encountered.
**Pros:** trivial; negligible performance impact
**Cons:** very fragile. Namely, it won't survive msgpack serialization.

## 3. Dummy layers
Move the current single layer down one level; then create two layers one for the upper matrix and one for the lower matrix, which are trivial redirects to the common layer:

```python
{
    cholesky_u: {
        (cholesky_u, 0, 0): (cholesky_lu_u, 0, 0),
        (cholesky_u, 0, 1): (cholesky_lu_u, 0, 1),
        ...
    },
    cholesky_l: {
        (cholesky_l, 0, 0): (cholesky_lu_l, 0, 0),
        (cholesky_l, 0, 1): (cholesky_lu_l, 0, 1),
        ...
    },
    cholesky_lu: {
        (cholesky_lu_u, 0, 0): <actual logic>,
        (cholesky_lu_u, 0, 1): <actual logic>,
        (cholesky_lu_l, 0, 0): <actual logic>,
        (cholesky_lu_l, 0, 1): <actual logic>,
        ...
    },
```
**Pros:** hack is localized to functions of secondary importance
**Cons:** ugly and wasteful

## 4. Set Array.layers
Change ``da.Array.__init__`` to accept a new optional parameter, ``layers``. The upper and lower matrices will then be able to share the same layer (both in key and in value).
Methods changes as follows:
```python
def __dask_layers__(self):
    return self.layers if self.layers is not None else (self.name, )
```
**Pros:** The Right Thing To Do; very likely to be useful in more use cases yet to be discovered
**Cons:** Lots of legwork and widespread impact (``__dask_postpersist__`` etc. will all need to change)

",,https://api.github.com/repos/dask/dask/issues/7574/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7574/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
442,https://api.github.com/repos/dask/dask/issues/7587,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7587/labels{/name},https://api.github.com/repos/dask/dask/issues/7587/comments,https://api.github.com/repos/dask/dask/issues/7587/events,https://github.com/dask/dask/issues/7587,864380498,MDU6SXNzdWU4NjQzODA0OTg=,7587,Optimization turned off when using delayed,"[{'id': 1968982461, 'node_id': 'MDU6TGFiZWwxOTY4OTgyNDYx', 'url': 'https://api.github.com/repos/dask/dask/labels/delayed', 'name': 'delayed', 'color': '4f6edd', 'default': False, 'description': ''}]",open,False,,[],,4,2021-04-21T23:19:20Z,2021-10-14T07:34:34Z,,CONTRIBUTOR,,"**What happened**:

A graph does not seem to be optimized properly when using delayed.

**What you expected to happen**:

Adding a delayed step at the end of a graph should not block optimization of the rest of the graph.

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.array as da

arr = da.zeros((1,2,2,1,2), chunks=1)
# Example of a non-trivial graph that can be optimized.
arr = arr.max(2)[...,1].rechunk(-1).transpose(0,2,1)

dask.visualize(arr, optimize_graph=True, filename='array')

delay = dask.delayed(lambda x: x)(arr)
dask.visualize(delay, optimize_graph=True, filename='delay')
```

**Environment**:

- Dask version: 2021.04.0
- Python version: 3.9.2
- Operating System: MacOS 11.2.3
- Install method (conda, pip, source): conda

Optimized visualization of array:
<img src=""https://user-images.githubusercontent.com/1053153/115632393-76771880-a2bc-11eb-8f5d-9071fa7a7d59.png"" width=""200"" />

Optimized visualization after adding delay step.
<img src=""https://user-images.githubusercontent.com/1053153/115632414-81ca4400-a2bc-11eb-8032-73a5961142c1.png"" width=""200"" />



",,https://api.github.com/repos/dask/dask/issues/7587/timeline,,,chrisroat,1053153,MDQ6VXNlcjEwNTMxNTM=,https://avatars.githubusercontent.com/u/1053153?v=4,,https://api.github.com/users/chrisroat,https://github.com/chrisroat,https://api.github.com/users/chrisroat/followers,https://api.github.com/users/chrisroat/following{/other_user},https://api.github.com/users/chrisroat/gists{/gist_id},https://api.github.com/users/chrisroat/starred{/owner}{/repo},https://api.github.com/users/chrisroat/subscriptions,https://api.github.com/users/chrisroat/orgs,https://api.github.com/users/chrisroat/repos,https://api.github.com/users/chrisroat/events{/privacy},https://api.github.com/users/chrisroat/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7587/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
443,https://api.github.com/repos/dask/dask/issues/7613,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7613/labels{/name},https://api.github.com/repos/dask/dask/issues/7613/comments,https://api.github.com/repos/dask/dask/issues/7613/events,https://github.com/dask/dask/issues/7613,869198845,MDU6SXNzdWU4NjkxOTg4NDU=,7613,Dask crashes or hangs during out-of-core dataframes sort,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,19,2021-04-27T19:37:16Z,2021-10-26T20:10:44Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

This is essentially the same issue as [this one](https://github.com/dask/community/issues/151) on dask/community, but I thought it would be worth a try to see if anyone can help here. Please let me know if I should close one of these!

**What happened**: An out-of-core sort of a large dataframe hangs or crashes.

**What you expected to happen**: The sort should finish.

**Minimal Complete Verifiable Example**:

I set up a single-node dask distributed cluster on a machine with 32 vCPUs and 128GB RAM. I started a dask worker with this command (note that I used nprocs=8 because this seemed to help reduce some of the errors compared to nprocs=32):
```bash
dask-worker localhost:8786 --nthreads 1 --nprocs=8 --memory-limit=10000000000  # 10GB.
```
Then, I ran this [script](https://gist.github.com/stephanie-wang/f4d061ca237837f79069807cf88e6c14#file-test_sort-py), which is meant to benchmark a full sort of a large dataframe. The script generates partitions on-disk, then shuffles and blocks on the result using this line:
```python
print(df.set_index('a').head(10, npartitions=-1))  # Force `head` to wait on all partitions.
```

On 10GB with 100 (100MB) partitions, I started to get a lot of errors with nprocs=32 ([stdout here](https://gist.github.com/stephanie-wang/f4d061ca237837f79069807cf88e6c14#file-stdout-128gb-ram-10gb-dataset-100mb-partitions-memory-limit-auto)). Then I tried nprocs=8 and the script finished successfully ([results here](https://gist.github.com/stephanie-wang/f4d061ca237837f79069807cf88e6c14#file-output-csv)).

However, I haven't been able to get the script to work with 100GB yet. Here is an example of the [output](https://gist.github.com/stephanie-wang/f4d061ca237837f79069807cf88e6c14#file-stdout-128gb-ram-100gb-dataset-1gb-partitions-memory-limit-10gb-nprocs-8). So far, in addition to changing nprocs and nthreads, I've also tried partitions=100 and 1000 and lowering the `target` and `memory` config parameters described [here](https://distributed.dask.org/en/latest/worker.html#memory-management).

**Anything else we need to know?**:

**Environment**:

- Dask version: 2021.4.1
- Python version: 3.7.7
- Operating System: Ubuntu 18.04
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/7613/timeline,,,stephanie-wang,2560516,MDQ6VXNlcjI1NjA1MTY=,https://avatars.githubusercontent.com/u/2560516?v=4,,https://api.github.com/users/stephanie-wang,https://github.com/stephanie-wang,https://api.github.com/users/stephanie-wang/followers,https://api.github.com/users/stephanie-wang/following{/other_user},https://api.github.com/users/stephanie-wang/gists{/gist_id},https://api.github.com/users/stephanie-wang/starred{/owner}{/repo},https://api.github.com/users/stephanie-wang/subscriptions,https://api.github.com/users/stephanie-wang/orgs,https://api.github.com/users/stephanie-wang/repos,https://api.github.com/users/stephanie-wang/events{/privacy},https://api.github.com/users/stephanie-wang/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7613/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
444,https://api.github.com/repos/dask/dask/issues/7622,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7622/labels{/name},https://api.github.com/repos/dask/dask/issues/7622/comments,https://api.github.com/repos/dask/dask/issues/7622/events,https://github.com/dask/dask/issues/7622,873634008,MDU6SXNzdWU4NzM2MzQwMDg=,7622,Using series apply with a dict meta instead of tuple throws,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,5,2021-05-01T10:24:03Z,2021-09-27T15:07:41Z,,CONTRIBUTOR,,"Via [this StackOverflow post](https://stackoverflow.com/q/67273742/5085211): Suppose `test.csv` is

```
age,name
28,Alice
```

Now, let's try the following:

```python
import dask.dataframe as dd

df = dd.read_csv(""test.csv"", dtype={'name': str})
result = df['age'].apply(lambda num: num + 1, meta={'age': int})
result.compute()
```

This fails with the below error. Notably, replacing the meta argument with `('age', int)` does not cause any issues.

**What happened**:

The following error:

```python
--------------------------------------------------------------------------
AttributeError                           Traceback (most recent call last)
<ipython-input-3-10c145120c76> in <module>
      3 df = dd.read_csv(""test.csv"", dtype={'name': str})
      4 result = df['age'].apply(lambda num: num + 1, meta={'age': int})
----> 5 result.compute()

\miniconda3\lib\site-packages\dask\base.py in compute(self, **kwargs)
    281         dask.base.compute
    282         """"""
--> 283         (result,) = compute(self, traverse=False, **kwargs)
    284         return result
    285

\miniconda3\lib\site-packages\dask\base.py in compute(*args, **kwargs)
    563         postcomputes.append(x.__dask_postcompute__())
    564
--> 565     results = schedule(dsk, keys, **kwargs)
    566     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    567

\miniconda3\lib\site-packages\dask\threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     82         get_id=_thread_get_id,
     83         pack_exception=pack_exception,
---> 84         **kwargs
     85     )
     86

\miniconda3\lib\site-packages\dask\local.py in get_async(apply_async, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, **kwargs)
    485                         _execute_task(task, data)  # Re-execute locally
    486                     else:
--> 487                         raise_exception(exc, tb)
    488                 res, worker_id = loads(res_info)
    489                 state[""cache""][key] = res

\miniconda3\lib\site-packages\dask\local.py in reraise(exc, tb)
    315     if exc.__traceback__ is not tb:
    316         raise exc.with_traceback(tb)
--> 317     raise exc
    318
    319

\miniconda3\lib\site-packages\dask\local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    220     try:
    221         task, data = loads(task_info)
--> 222         result = _execute_task(task, data)
    223         id = get_id()
    224         result = dumps((result, id))

\miniconda3\lib\site-packages\dask\core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

\miniconda3\lib\site-packages\dask\optimization.py in __call__(self, *args)
    961         if not len(args) == len(self.inkeys):
    962             raise ValueError(""Expected %d args, got %d"" % (len(self.inkeys), len(args)))
--> 963         return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
    964
    965     def __reduce__(self):

\miniconda3\lib\site-packages\dask\core.py in get(dsk, out, cache)
    149     for key in toposort(dsk):
    150         task = dsk[key]
--> 151         result = _execute_task(task, cache)
    152         cache[key] = result
    153     result = _execute_task(out, cache)

\miniconda3\lib\site-packages\dask\core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

\miniconda3\lib\site-packages\dask\utils.py in apply(func, args, kwargs)
     33 def apply(func, args, kwargs=None):
     34     if kwargs:
---> 35         return func(*args, **kwargs)
     36     else:
     37         return func(*args)

\miniconda3\lib\site-packages\dask\dataframe\core.py in apply_and_enforce(*args, **kwargs)
   5493             c = meta.columns
   5494         else:
-> 5495             c = meta.name
   5496         return _rename(c, df)
   5497     return df

\miniconda3\lib\site-packages\pandas\core\generic.py in __getattr__(self, name)
   5463             if self._info_axis._can_hold_identifiers_and_holds_name(name):
   5464                 return self[name]
-> 5465             return object.__getattribute__(self, name)
   5466
   5467     def __setattr__(self, name: str, value) -> None:

AttributeError: 'DataFrame' object has no attribute 'name'
```

**What you expected to happen**:

The same as if I had used the tuple instead:

```python
In [6]: import dask.dataframe as dd
   ...:
   ...: df = dd.read_csv(""test.csv"", dtype={'name': str})
   ...: df['age'].apply(lambda num: num + 1, meta=('age', int)).compute()
Out[6]:
0    29
Name: age, dtype: int64
```

**Environment**:

- Dask version: 2021.03.0
- Python version: 3.7.6
- Operating System: Windows 10
- Install method (conda, pip, source): conda",,https://api.github.com/repos/dask/dask/issues/7622/timeline,,,fuglede,6169306,MDQ6VXNlcjYxNjkzMDY=,https://avatars.githubusercontent.com/u/6169306?v=4,,https://api.github.com/users/fuglede,https://github.com/fuglede,https://api.github.com/users/fuglede/followers,https://api.github.com/users/fuglede/following{/other_user},https://api.github.com/users/fuglede/gists{/gist_id},https://api.github.com/users/fuglede/starred{/owner}{/repo},https://api.github.com/users/fuglede/subscriptions,https://api.github.com/users/fuglede/orgs,https://api.github.com/users/fuglede/repos,https://api.github.com/users/fuglede/events{/privacy},https://api.github.com/users/fuglede/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7622/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
445,https://api.github.com/repos/dask/dask/issues/7639,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7639/labels{/name},https://api.github.com/repos/dask/dask/issues/7639/comments,https://api.github.com/repos/dask/dask/issues/7639/events,https://github.com/dask/dask/issues/7639,883982587,MDU6SXNzdWU4ODM5ODI1ODc=,7639,svd_compressed() fails for complex input,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,17,2021-05-10T11:07:32Z,2022-10-28T15:57:56Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->
**What happened**:
**Complex** singular values and vectors of `svd_compressed()` are different from standard `np.linalg.svd`.

**What you expected to happen**:
Complex singular values and vectors of `svd_compressed()` are similar (within some uncertainties) to standard `np.linalg.svd`.

**Minimal Complete Verifiable Example**:

```python
import numpy as np
import xarray as xr
import dask.array as da
from matplotlib.pyplot import imshow

data = xr.tutorial.open_dataset(
    'air_temperature',
    chunks={'lat': 25, 'lon': 25, 'time': -1}
)
temp = data.air
temp = temp.stack(x=('lat', 'lon')).compute()
temp -= temp.mean('time')
# artificial complexification of data
temp = temp + (1j * 0.1 * temp**2)
kernel = np.dot(temp.conj().T, temp) / temp.shape[0]

# standard SVD
u, s, vt = np.linalg.svd(kernel, full_matrices=False)
# dask SVD 
dask_kernel = da.from_array(kernel)
k = 100
dsvd = da.linalg.svd_compressed(dask_kernel, k)
u2, s2, vt2 = (x.compute() for x in dsvd)

np.allclose(s[:100], s2)  # False
np.allclose(vt[:100], vt2)  # False

# visual check: look at first singular vector
v = vt.reshape((temp.shape[1],) + data.air.shape[1:])
v2 = vt2.reshape((k,) + data.air.shape[1:])

# imaginary parts of first singular vector are clearly different
imshow(v[0,:,:].imag, vmin=-1e-3, vmax=1e-3)
imshow(-v2[0,:,:].imag, vmin=-1e-3, vmax=1e-3)
```

**Anything else we need to know?**:
1. For real input, both methods yield the same results.
2. When running `svd_compressed()` a warning is thrown complaining about complex being casted to real dtypes:
```
/home/nrieger/anaconda3/envs/xmca/lib/python3.7/site-packages/dask/array/utils.py:108: ComplexWarning: Casting complex values to real discards the imaginary part
  meta = meta.astype(dtype)
``` 

**Environment**:

- Dask version: 2021.04.0
- Python version: 3.7.10
- Operating System: Ubuntu 20.04
- Install method: conda
",,https://api.github.com/repos/dask/dask/issues/7639/timeline,,,nicrie,45175997,MDQ6VXNlcjQ1MTc1OTk3,https://avatars.githubusercontent.com/u/45175997?v=4,,https://api.github.com/users/nicrie,https://github.com/nicrie,https://api.github.com/users/nicrie/followers,https://api.github.com/users/nicrie/following{/other_user},https://api.github.com/users/nicrie/gists{/gist_id},https://api.github.com/users/nicrie/starred{/owner}{/repo},https://api.github.com/users/nicrie/subscriptions,https://api.github.com/users/nicrie/orgs,https://api.github.com/users/nicrie/repos,https://api.github.com/users/nicrie/events{/privacy},https://api.github.com/users/nicrie/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7639/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
446,https://api.github.com/repos/dask/dask/issues/7650,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7650/labels{/name},https://api.github.com/repos/dask/dask/issues/7650/comments,https://api.github.com/repos/dask/dask/issues/7650/events,https://github.com/dask/dask/issues/7650,890336752,MDU6SXNzdWU4OTAzMzY3NTI=,7650,`dumps_task` in `SimpleShuffleLayer` and `BroadcastJoinLayer` unpack,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,1,2021-05-12T17:42:30Z,2021-06-03T15:33:18Z,,MEMBER,,"Just a TODO that `SimpleShuffleLayer` and `BroadcastJoinLayer` both use `dumps_task` in their `__dask_distributed_unpack__` methods, which leads to pickling on the scheduler, which we want to avoid.

Additionally, could this manual use of `pickle.dumps` in `BroadcastJoinLayer.__dask_distributed_pack__` lead to a double-pickle scenario, where when the task actually gets executed, the kwarg values are bytestrings, not the actual unpickled values: https://github.com/dask/dask/blob/b3a86469cb339767617c03c05e60db101ceb177a/dask/layers.py#L663-L671

Related to https://github.com/dask/distributed/pull/4699.

cc @rjzamora @madsbk ",,https://api.github.com/repos/dask/dask/issues/7650/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7650/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
447,https://api.github.com/repos/dask/dask/issues/7652,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7652/labels{/name},https://api.github.com/repos/dask/dask/issues/7652/comments,https://api.github.com/repos/dask/dask/issues/7652/events,https://github.com/dask/dask/issues/7652,890800623,MDU6SXNzdWU4OTA4MDA2MjM=,7652,Sparsely blocked/chunked arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,15,2021-05-13T07:19:15Z,2022-08-19T10:50:31Z,,NONE,,"I have an application whereby I am manually forming a dask array using `blocks` as each of the chunks in the final array need to go through a specific transform to ensure the correct alignment in the final dask array. Furthermore, not all the chunks in the array which is formed contain useful information, but some are just needed to ensure spatial alignment between their neighboring chunks, thus forming a Dask array with sparse blocks/chunks.

Currently I am using masked arrays to mask out entire chunks, however, this is inefficient as those blocks are still included in the computational graph and are still evaluated to some degree. Ultimately it would be nice to have the concept of chunk/block masks which let dask know that the evaluation of any operation on an entire chunk will result in a NaN or empty result and can thus be skipped entirely without additional computation. 

The application generally has more `empty` blocks/chunks that those with valid data and thus the computational graph grows very large with a lot of unneeded operations, having a way to prevent this would be nice.

A small example of how I currently handle this:
```
import numpy as np
import dask.array as da

arr0 = da.from_array(np.arange(1, 26).reshape(5,5), chunks=(5, 5))
arr1 = da.from_array(np.arange(25, 50).reshape(5,5), chunks=(5, 5))
# This chunk is empty/blank/invalid but is needed to align the other chunks
arr2 = da.from_array(np.full((5,5), np.nan), chunks=(5, 5)) 
arr3 = da.from_array(np.arange(75, 100).reshape(5,5), chunks=(5, 5))

a = da.block([[arr0, arr1],[arr2, arr3]])
b = da.ma.masked_invalid(a)
c = b.min().compute()
```

What would be nice to have:
```
import numpy as np
import dask.array as da

arr0 = da.from_array(np.arange(1, 26).reshape(5,5), chunks=(5, 5))
arr1 = da.from_array(np.arange(25, 50).reshape(5,5), chunks=(5, 5))
arr3 = da.from_array(np.arange(75, 100).reshape(5,5), chunks=(5, 5))

a = da.sparse_block([[arr0, arr1],[None, arr3]])
b = a.min().compute()
```",,https://api.github.com/repos/dask/dask/issues/7652/timeline,,,system123,91509,MDQ6VXNlcjkxNTA5,https://avatars.githubusercontent.com/u/91509?v=4,,https://api.github.com/users/system123,https://github.com/system123,https://api.github.com/users/system123/followers,https://api.github.com/users/system123/following{/other_user},https://api.github.com/users/system123/gists{/gist_id},https://api.github.com/users/system123/starred{/owner}{/repo},https://api.github.com/users/system123/subscriptions,https://api.github.com/users/system123/orgs,https://api.github.com/users/system123/repos,https://api.github.com/users/system123/events{/privacy},https://api.github.com/users/system123/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7652/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
448,https://api.github.com/repos/dask/dask/issues/7655,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7655/labels{/name},https://api.github.com/repos/dask/dask/issues/7655/comments,https://api.github.com/repos/dask/dask/issues/7655/events,https://github.com/dask/dask/pull/7655,891814517,MDExOlB1bGxSZXF1ZXN0NjQ0NjIxOTY1,7655,Array slicing HighLevelGraph layer,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,22,2021-05-14T10:38:07Z,2021-11-23T01:14:31Z,,MEMBER,,"Array slicing HighLevelGraph layer

FYI @ian-r-rose & @gjoseph92 
I've made a start, inserting a HighLevelGraph into the `slice_slices_and_integers` function of `dask.array.slicing.py`. 

The next step is to somehow propagate this upwards through the rest of the slicing functions, so that it is only materialized if absolutely necessary (eg: to do fancy indexing, etc.)",,https://api.github.com/repos/dask/dask/issues/7655/timeline,,,GenevieveBuckley,30920819,MDQ6VXNlcjMwOTIwODE5,https://avatars.githubusercontent.com/u/30920819?v=4,,https://api.github.com/users/GenevieveBuckley,https://github.com/GenevieveBuckley,https://api.github.com/users/GenevieveBuckley/followers,https://api.github.com/users/GenevieveBuckley/following{/other_user},https://api.github.com/users/GenevieveBuckley/gists{/gist_id},https://api.github.com/users/GenevieveBuckley/starred{/owner}{/repo},https://api.github.com/users/GenevieveBuckley/subscriptions,https://api.github.com/users/GenevieveBuckley/orgs,https://api.github.com/users/GenevieveBuckley/repos,https://api.github.com/users/GenevieveBuckley/events{/privacy},https://api.github.com/users/GenevieveBuckley/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7655/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7655,https://github.com/dask/dask/pull/7655,https://github.com/dask/dask/pull/7655.diff,https://github.com/dask/dask/pull/7655.patch,,,,,,,,,,,,,,,,,,,
449,https://api.github.com/repos/dask/dask/issues/7673,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7673/labels{/name},https://api.github.com/repos/dask/dask/issues/7673/comments,https://api.github.com/repos/dask/dask/issues/7673/events,https://github.com/dask/dask/issues/7673,895180237,MDU6SXNzdWU4OTUxODAyMzc=,7673,da.from_zarr ignores Zarr's dimension_separator,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,9,2021-05-19T08:59:04Z,2021-08-23T06:56:23Z,,NONE,,"**What happened**:

Zarr arrays that have been stored with ""/"" as the `dimension_separator` attribute (in .zarray) have no data in them when opened with `da.from_zarr`. See https://github.com/zarr-developers/zarr-python/pull/715

**What you expected to happen**:

All Zarr stores in the zarr-python repository were updated in https://github.com/zarr-developers/zarr-python/pull/716 to read this new metadata. The two options I can think of are either using a full store like FSStore in `from_zarr` or adding support for `dimension_separator` directly.

cc: @martindurant 

**Minimal Complete Verifiable Example**:

```python
import zarr as zr
import dask.array as da

z = zr.storage.FSStore(
    ""foo.zarr"",
    dimension_separator=""/"",
    auto_mkdir=True,
    mode=""w"",
)
a = zr.creation.array(store=z, data=[range(4) for x in range(4)])

# Passes
base = da.from_zarr(z, """")
m = base.max().compute()
assert m == 3, m

# Fails
base = da.from_zarr(""foo.zarr"")
m = base.max().compute()
assert m == 3, m
```

**Anything else we need to know?**:

Originally reported in: https://github.com/zarr-developers/zarr-python/pull/709#issuecomment-834118324

**Environment**:

- Dask version: 2021.5.0
- Python version: 3.9.4
- Operating System: OSX 11.2.3
- Install method (conda, pip, source):
```
conda create -n dask dask zarr fsspec
```
",,https://api.github.com/repos/dask/dask/issues/7673/timeline,,,joshmoore,88113,MDQ6VXNlcjg4MTEz,https://avatars.githubusercontent.com/u/88113?v=4,,https://api.github.com/users/joshmoore,https://github.com/joshmoore,https://api.github.com/users/joshmoore/followers,https://api.github.com/users/joshmoore/following{/other_user},https://api.github.com/users/joshmoore/gists{/gist_id},https://api.github.com/users/joshmoore/starred{/owner}{/repo},https://api.github.com/users/joshmoore/subscriptions,https://api.github.com/users/joshmoore/orgs,https://api.github.com/users/joshmoore/repos,https://api.github.com/users/joshmoore/events{/privacy},https://api.github.com/users/joshmoore/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7673/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
450,https://api.github.com/repos/dask/dask/issues/7677,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7677/labels{/name},https://api.github.com/repos/dask/dask/issues/7677/comments,https://api.github.com/repos/dask/dask/issues/7677/events,https://github.com/dask/dask/issues/7677,895789366,MDU6SXNzdWU4OTU3ODkzNjY=,7677,Add a terminology section to the docs?,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,6,2021-05-19T19:10:46Z,2021-07-07T19:23:13Z,,MEMBER,,"I often hear something like ""the Dask docs are great, but can be a bit overwhelming when first getting started"". One reason is that Dask has some terminology that new users may be unfamiliar with (e.g. ""chunks"", ""task graph"", ""graph optimization"", etc.)

Xarray has a nice documentation page where they define common terms that are used throughout their project (https://xarray.pydata.org/en/stable/user-guide/terminology.html). 

Would adding a similar terminology page to Dask's documentation be useful? We could define terms like ""chunks"", ""task graph"", ... in a central location and then link back to the terminology page when we use a term like ""task graph"" in other documentation pages. This might help new users get up to speed on Dask's vocabulary more quickly. ",,https://api.github.com/repos/dask/dask/issues/7677/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7677/reactions,7,7,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
451,https://api.github.com/repos/dask/dask/issues/7686,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7686/labels{/name},https://api.github.com/repos/dask/dask/issues/7686/comments,https://api.github.com/repos/dask/dask/issues/7686/events,https://github.com/dask/dask/pull/7686,897998223,MDExOlB1bGxSZXF1ZXN0NjQ5OTI1Njc0,7686,Use BlockwiseDep for map_blocks with block_id or block_info,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,7,2021-05-21T12:29:15Z,2021-07-04T15:54:19Z,,MEMBER,,"When the `map_blocks` function has `block_id` or `block_info` arguments, it is populated with information about the current block. Previously this was done by synthesizing all the information at the time `map_blocks` was called and stored in a da.Array of objects. Now that Blockwise supports I/O-deps, it's feasible to defer this work until the Blockwise is materialised.

I've made this a draft PR because I have no idea what I'm doing with the serialization and need some advice. I've made a distributed test pass, but after seeing some comments in other PRs I'm aware that there are some subtleties about what may be deserialized on the scheduler (in this case I think an np.ndarray is getting deserialized there).

Maybe a solution would be to have `_BlockInfo.__getitem__` generate a task to generate the block_info, rather than generating it itself? That would also have the advantage that constructing the block info would be left to the workers.

I've extended `da.blockwise` to accept BlockwiseDep arguments (and documented it), so that `map_blocks` can pass them through (since `map_blocks` calls `da.blockwise` rather than `dask.blockwise`). I probably still need to add some direct tests, rather than relying on the coverage from `map_blocks`.

The performance looks good. Here's some benchmark code:
```
#!/usr/bin/env python3

from time import monotonic

import dask.array as da
import numpy as np


def func(a, b, block_info=None):
    return a + b


a = da.from_array(np.arange(200)[np.newaxis, :], chunks=1)
b = da.from_array(np.arange(200)[:, np.newaxis], chunks=1)
t0 = monotonic()
c = da.map_blocks(func, a, b)
t1 = monotonic()
c.compute()
t2 = monotonic()
print(f'Prepare: {t1 - t0:.3f}')
print(f'Compute: {t2 - t1:.3f}')
```

Before:
```
Prepare: 0.446
Compute: 7.457
```

After:
```
Prepare: 0.001
Compute: 6.715
```

- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask` / `isort dask`
",,https://api.github.com/repos/dask/dask/issues/7686/timeline,,,bmerry,1963944,MDQ6VXNlcjE5NjM5NDQ=,https://avatars.githubusercontent.com/u/1963944?v=4,,https://api.github.com/users/bmerry,https://github.com/bmerry,https://api.github.com/users/bmerry/followers,https://api.github.com/users/bmerry/following{/other_user},https://api.github.com/users/bmerry/gists{/gist_id},https://api.github.com/users/bmerry/starred{/owner}{/repo},https://api.github.com/users/bmerry/subscriptions,https://api.github.com/users/bmerry/orgs,https://api.github.com/users/bmerry/repos,https://api.github.com/users/bmerry/events{/privacy},https://api.github.com/users/bmerry/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7686/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7686,https://github.com/dask/dask/pull/7686,https://github.com/dask/dask/pull/7686.diff,https://github.com/dask/dask/pull/7686.patch,,,,,,,,,,,,,,,,,,,
452,https://api.github.com/repos/dask/dask/issues/7702,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7702/labels{/name},https://api.github.com/repos/dask/dask/issues/7702/comments,https://api.github.com/repos/dask/dask/issues/7702/events,https://github.com/dask/dask/issues/7702,900664459,MDU6SXNzdWU5MDA2NjQ0NTk=,7702,Allow encoding execution priorities / order in delayed objects / graph,"[{'id': 1968982461, 'node_id': 'MDU6TGFiZWwxOTY4OTgyNDYx', 'url': 'https://api.github.com/repos/dask/dask/labels/delayed', 'name': 'delayed', 'color': '4f6edd', 'default': False, 'description': ''}]",open,False,,[],,3,2021-05-25T11:17:46Z,2021-10-14T07:53:15Z,,CONTRIBUTOR,,"## Setup

I have a function as follows:
```python
def my_function(ddf: dd.DataFrame, list_of_args: List[Dict]) -> List[Delayed]:
    ddf_tasks = ddf.to_delayed()

    reduced_results = []
    for args in list_of_args:
        reduced_results.append([delayed(reduce)(task, args) for task in ddf_tasks])

    combined_results = [delayed(combine)(result, args) for result in reduced_result]
    return combined_results 
```
Here `reduce` creates summary statistics about a `pandas.DataFrame` and `combine` combines these summaries. A motivating example would be to compute the percentage of missings in an individual column (I know dask can do this, these get arbitrarily more complex):

```python
def reduce(df, args):
    return {""n"": len(df), ""n_missing"": df[args[""column""]].isna().sum()}


def combine(results, args):
    n_missing = sum(result[""n_missing""] for result in results)
    n = sum(result[""n""] for result in results)
    return n_missing / n
```

A typical call of `my_function` would then be as follows:
```python
from kartothek.io.dask.dataframe import read_dataset_as_ddf
import minimalkv

store = minimalkv.get_store_from_url(""hfs:///path/to/file"")

ddf = read_dataset_as_ddf(uuid=""uuid"", store=store)

list_of_args = [{""column"": ""a""}, {""column"": ""b""}, {""column"": ""c""}]

result = my_function(ddf, list_of_args)
```

Here each task in `ddf.to_delayed()` is basically a delayed call of `pd.read_parquet`. Importantly the result of these delayed calls is big and `ddf.compute()` will not fit into memory at once. However the return of the `reduce` functions is small. We can assume that all results of all `reduce` calls fit into memory at once, if not we would apply a tree-reduce algorithm.

On a small sample, this is the result of `visualize(result, filename=""file.jpeg"", color=""order"", cmap=""autumn"", optimize_graph=True)`:

![file](https://user-images.githubusercontent.com/61679398/119481291-d1d07680-bd52-11eb-934b-61cb98666323.jpeg)

The square nodes 0, ..., 4 contain large amounts of data. Optimally, dask would first compute one of them (say 0), compute the results of all dependencies without further dependencies (here 7, 29 and 22) and then discard the data (0) to free up memory. Sadly, this is not what happens. In the graph the nodes are by execution order. IIUC, according to [this](https://docs.dask.org/en/latest/order.html), dask selects one of the final nodes (20) and prioritizes its dependencies (3, 15, 11 and 19). These have dependencies 4, 2, 3, 1, 0, so dask (tries to) load all data into memory. It does not free the memory once children are computed, since the data is also a parent of other nodes further down in the queue (e.g. 26 / 21, 25, 24, 23, 22). As all data does not fit into memory, dask begins writing to / loading from disk.

## Request / Question

It would be nice to reprioritize the above graph and encode the priorisation in the graph / delayed objects. If I understand correctly, currenlty, as described [here](https://distributed.dask.org/en/latest/priority.html), priorities can only be passed to a scheduler, but not encoded in the graph. In case I could encode priorities, I could add checkpoints that make sure the dask gets executed in the order that I would like. Here I would probably add something like

```python
from dask.graph_manipulation import checkpoint

checkpoints = [
    checkpoint(
        *[reduced_result[i] for reduced_result in reduced_results],
        priority=i
     ) for i in range(len(ddf_tasks))
]
```
to my function and integrate the checkpoints into the dask graph. 

Do you have any suggestions on how to implement this with existing tools? Boundary conditions are:
 - All data does not fit into memory.
 - The input data frame might contain some computation. We should thus not copy its graph multiple times over.
 - The dask execution should make use of parallelization. Making loading of a partition (e.g. 2) dependent on all children of another (e.g. 3, 27, 21, children of 4) would break this.

Optimally, each worker would load a separate partition of the dask data frame, compute all dependencies up to the combine step, keep these results in memory but discard the data and continue with the next partition.",,https://api.github.com/repos/dask/dask/issues/7702/timeline,,,mlondschien,61679398,MDQ6VXNlcjYxNjc5Mzk4,https://avatars.githubusercontent.com/u/61679398?v=4,,https://api.github.com/users/mlondschien,https://github.com/mlondschien,https://api.github.com/users/mlondschien/followers,https://api.github.com/users/mlondschien/following{/other_user},https://api.github.com/users/mlondschien/gists{/gist_id},https://api.github.com/users/mlondschien/starred{/owner}{/repo},https://api.github.com/users/mlondschien/subscriptions,https://api.github.com/users/mlondschien/orgs,https://api.github.com/users/mlondschien/repos,https://api.github.com/users/mlondschien/events{/privacy},https://api.github.com/users/mlondschien/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7702/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
453,https://api.github.com/repos/dask/dask/issues/7708,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7708/labels{/name},https://api.github.com/repos/dask/dask/issues/7708/comments,https://api.github.com/repos/dask/dask/issues/7708/events,https://github.com/dask/dask/issues/7708,902345123,MDU6SXNzdWU5MDIzNDUxMjM=,7708,Delayed method in a 'delayed_pure' context produces a different Delayed key every time it is evaluated,"[{'id': 1968982461, 'node_id': 'MDU6TGFiZWwxOTY4OTgyNDYx', 'url': 'https://api.github.com/repos/dask/dask/labels/delayed', 'name': 'delayed', 'color': '4f6edd', 'default': False, 'description': ''}]",open,False,,[],,4,2021-05-26T12:52:07Z,2021-10-14T07:52:50Z,,NONE,,"**What happened**:

Delayed method in a `delayed_pure` context produces a different Delayed key every time it is evaluated.

**What you expected to happen**:

A method producing the same Delayed key every time it is evaluated with the same arguments in a `delayed_pure` context.

It works as expected when the whole class is decorated as delayed, but it doesn't if only a single method is decorated as delayed.

**Minimal Complete Verifiable Example**:

The following example:
```python
import dask

class A(object):
    BASE = 10

    def __init__(self, base):
        self.BASE = base

    @dask.delayed
    def addmethod(self, x, y):
        return self.BASE + x + y

a = A(100)

with dask.config.set(delayed_pure=True):
    assert a.addmethod(3, 4).key == a.addmethod(3, 4).key
```
incorrectly raises an AssertionError,

whereas the following correctly doesn't:

```python
import dask

@dask.delayed
class A(object):
    BASE = 10

    def __init__(self, base):
        self.BASE = base

    def addmethod(self, x, y):
        return self.BASE + x + y

a = A(100)

with dask.config.set(delayed_pure=True):
    assert a.addmethod(3, 4).key == a.addmethod(3, 4).key
```

**Environment**:

- Dask version: 2021.04.1
- Python version: 3.9.4
- Operating System: Windows
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/7708/timeline,,,kdebrab,1150402,MDQ6VXNlcjExNTA0MDI=,https://avatars.githubusercontent.com/u/1150402?v=4,,https://api.github.com/users/kdebrab,https://github.com/kdebrab,https://api.github.com/users/kdebrab/followers,https://api.github.com/users/kdebrab/following{/other_user},https://api.github.com/users/kdebrab/gists{/gist_id},https://api.github.com/users/kdebrab/starred{/owner}{/repo},https://api.github.com/users/kdebrab/subscriptions,https://api.github.com/users/kdebrab/orgs,https://api.github.com/users/kdebrab/repos,https://api.github.com/users/kdebrab/events{/privacy},https://api.github.com/users/kdebrab/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7708/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
454,https://api.github.com/repos/dask/dask/issues/7709,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7709/labels{/name},https://api.github.com/repos/dask/dask/issues/7709/comments,https://api.github.com/repos/dask/dask/issues/7709/events,https://github.com/dask/dask/issues/7709,902618665,MDU6SXNzdWU5MDI2MTg2NjU=,7709,Update HighLevelGraph documentation,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,24,2021-05-26T16:09:26Z,2021-12-16T14:11:12Z,,MEMBER,,"I just came across [this page of the docs](https://docs.dask.org/en/latest/high-level-graphs.html) which hasn't been changed much since Dec 2018. I think it would be useful to update it to include a runnable example and some information about the `Layer` class. 

Once that page is updated, it will probably make sense to update https://docs.dask.org/en/latest/phases-of-computation.html and https://docs.dask.org/en/latest/graphs.html to make it clearer how HLGs fit in.

I am happy to take on this work, but just wanted to put this here in case I am missing something. 

Some resources that I am planning to draw on:
[Layer Issue](https://github.com/dask/dask/issues/6438)
[Blog post about scheduling](https://blog.dask.org/2020/07/21/faster-scheduling)
[Scheduling workshop from summit](https://zoom.us/rec/share/vO7Xx5HAupQHDEjTgmspp6VZoCY_zabi1nouOHCwl4mBSg2hVQpIFqTTpVQUNZA4.8cE5K7SjaMIUNINW?startTime=1621620212000)

Pinging the people who I have seen working on HLG related things: @rjzamora @GenevieveBuckley @gjoseph92 @ian-r-rose @jrbourbeau ",,https://api.github.com/repos/dask/dask/issues/7709/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7709/reactions,3,3,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
455,https://api.github.com/repos/dask/dask/issues/7722,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7722/labels{/name},https://api.github.com/repos/dask/dask/issues/7722/comments,https://api.github.com/repos/dask/dask/issues/7722/events,https://github.com/dask/dask/issues/7722,904534132,MDU6SXNzdWU5MDQ1MzQxMzI=,7722,[Discussion] Proposed layer reorganization,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,19,2021-05-28T02:00:42Z,2021-10-14T07:52:29Z,,MEMBER,,"High level graph `Layer` implementations have a number of constraints on them which makes their design and location within the project somewhat subtle. For security reasons they cannot deserialize or otherwise run arbitrary python code, and in general they cannot depend on numpy, pandas, or other such complex dependencies. As a result of the latter requirement, many `Layer` implementations have been  placed in `dask.layers` and, where they can be safely referenced without triggering unwanted imports (cf #7381).

During some discussions, @gjoseph92, @GenevieveBuckley and I have become concerned about the size and maintainability of `layers.py`. As we look towards implementing more layers, this file will get more unwieldy: each layer will typically have an implementation and possibly a set of utility functions, and the module will eventually become a significant fraction of dask.

Since the natural location for these layers (near userland code that instantiates them) isn't workable due to the unwanted imports, we have sketched out a proposed structure for making this easier to organize and maintain going forward. The basic idea is to keep shadow submodules of `dask.array` and `dask.dataframe` (and possibly `dask.bag`) as siblings of those submodules, each containing layer implementations for their counterpart. So `dask.array_layers` would have `Layer` classes and all the supporting utilities for `dask.array`. This could look something like (conceptually, not literally):

```
 core.py
 base.py
 array
       overlap.py (user code for overlap)
        slicing.py (user code for slicing)
 dataframe
       shuffle.py (user code for shuffles)
       io.py (user code for read_csv, read_parquet, etc)
 array_layers
       overlap.py (layers for overlap)
        slicing.py (layers for slicing)
 dataframe_layers
       shuffle.py (layers for shuffles)
       io.py (layers for read_csv, read_parquet, etc)
```

Code from `dask.array` could freely import code from `dask.array_layers`, but not the reverse. I don't think the layers submodules would exactly mirror their counterparts, but a rough correspondence for collection-producing operations would make it much easier to keep things organized and avoid having `layers.py` be an enormous dumping ground.

Thoughts? especially cc @rjzamora and @jrbourbeau ",,https://api.github.com/repos/dask/dask/issues/7722/timeline,,,ian-r-rose,5728311,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7722/reactions,2,0,0,0,0,0,2,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
456,https://api.github.com/repos/dask/dask/issues/7727,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7727/labels{/name},https://api.github.com/repos/dask/dask/issues/7727/comments,https://api.github.com/repos/dask/dask/issues/7727/events,https://github.com/dask/dask/issues/7727,905635330,MDU6SXNzdWU5MDU2MzUzMzA=,7727,`dask.array.store` with `compute=False` and `return_stored=True`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,2,2021-05-28T15:45:30Z,2021-06-03T17:37:17Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:

I am trying to store a Dask Array representing an intermediate step in my calculation to disk, thus using `dask.array.store` with `return_stored=True`. I would like to setup the full calculation lazily and call `compute` at the very end. However, if I try to run further computation on the arrays returned by `store`, errors are raised if `compute=False`.  Everything works fine if `compute=True`.

**Minimal Complete Verifiable Example**:

```python
import dask.array as da
import zarr

x = zarr.open(""x.zarr"", mode='w', shape=(100, 100), chunks=(20, 100))

x_da = da.random.random(x.shape, chunks=x.chunks)

# this raises the following error when calling z.compute()
x_stored,  = da.store(x_da, x.oindex, lock=False, compute=False, return_stored=True)

# this works fine
x_stored,  = da.store(x_da, x.oindex, lock=False, compute=True, return_stored=True)

z = x_stored + 1

z.compute()
```

Traceback:

```python
  File ""/Users/fnattino/Programs/swyft-nlesc/notebooks/return_stored.py"", line 16, in <module>
    main()
  File ""/Users/fnattino/Programs/swyft-nlesc/notebooks/return_stored.py"", line 12, in main
    z.compute()
  File ""/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/base.py"", line 285, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/base.py"", line 561, in compute
    dsk = collections_to_dsk(collections, optimize_graph, **kwargs)
  File ""/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/base.py"", line 337, in collections_to_dsk
    dsk = opt(dsk, keys, **kwargs)
  File ""/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/array/optimization.py"", line 47, in optimize
    dsk = dsk.cull(set(keys))
  File ""/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/highlevelgraph.py"", line 866, in cull
    for layer_name in reversed(self._toposort_layers()):
  File ""/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/highlevelgraph.py"", line 832, in _toposort_layers
    reverse_deps[dep].append(k)
KeyError: 'load-store-6152012c-bfc7-11eb-b643-acde48001122'
```

**Environment**:

- Dask version: 2021.05.0
- Python version: 3.8.3
- Operating System: OS X
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/7727/timeline,,,fnattino,49899980,MDQ6VXNlcjQ5ODk5OTgw,https://avatars.githubusercontent.com/u/49899980?v=4,,https://api.github.com/users/fnattino,https://github.com/fnattino,https://api.github.com/users/fnattino/followers,https://api.github.com/users/fnattino/following{/other_user},https://api.github.com/users/fnattino/gists{/gist_id},https://api.github.com/users/fnattino/starred{/owner}{/repo},https://api.github.com/users/fnattino/subscriptions,https://api.github.com/users/fnattino/orgs,https://api.github.com/users/fnattino/repos,https://api.github.com/users/fnattino/events{/privacy},https://api.github.com/users/fnattino/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7727/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
457,https://api.github.com/repos/dask/dask/issues/7755,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7755/labels{/name},https://api.github.com/repos/dask/dask/issues/7755/comments,https://api.github.com/repos/dask/dask/issues/7755/events,https://github.com/dask/dask/issues/7755,909979166,MDU6SXNzdWU5MDk5NzkxNjY=,7755,Document dev process around high level graphs,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,1,2021-06-03T00:18:06Z,2021-10-14T07:48:04Z,,MEMBER,,"We would like to enable other people to write high level layers.  For example some of the imaging crowd is trying to accomplish this for Map Overlap.

Currently it's not clear what contract needs to be filled to do this well, particularly around efficient culling (it is common in imaging to construct very large dask arrays and then slide very small pieces out of them, so there are great potentials for benefit here).  The current `cull` method has a brief docstring on what is needed, but it's not super clear.  In particular, I think that it would be helpful to explain that the result Layer should probably have changed state so that it only generates the correct keys.  Also, we should define and give examples for the resulting `deps` mapping.  The current doctest example doesn't include this, and it's not clear what the expected format is.

cc @madsbk @rjzamora if either of you have the time.

@GenevieveBuckley is working on map-overlap and is somewhat blocked on trying to follow the high level graph layer flow",,https://api.github.com/repos/dask/dask/issues/7755/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7755/reactions,7,7,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
458,https://api.github.com/repos/dask/dask/issues/7767,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7767/labels{/name},https://api.github.com/repos/dask/dask/issues/7767/comments,https://api.github.com/repos/dask/dask/issues/7767/events,https://github.com/dask/dask/issues/7767,912897089,MDU6SXNzdWU5MTI4OTcwODk=,7767,"Very high peak memory-usage on ""compute_chunk_sizes""","[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2021-06-06T17:25:23Z,2021-10-14T07:49:53Z,,NONE,,"**What happened**:
The profiler shows an extreme memory peak in [concatenate3](https://github.com/dask/dask/blob/6632607c9a65fda46cb2b32763ae55501825bd87/dask/array/core.py#L4813):

![image](https://user-images.githubusercontent.com/1200058/120933895-757b3880-c6fc-11eb-8f56-154a9e96771b.png)

**What you expected to happen**:
Very low memory usage since `np.sum(block)` should be enough to compute the chunk sizes

**Minimal Complete Verifiable Example**:
```python
with dask.config.set(scheduler='threads'):
    dask.array.random.seed(seed=42)
    
    d = dask.array.random.binomial(1, 0.18, size=(49, 467, 18401), chunks=(5, 467, 5)).astype(""bool"").persist()
    d
print(d.sum().compute())
# 75781858

locs = np.argwhere(d)

# %load_ext filprofiler
# %%filprofile

with dask.config.set(scheduler='single-threaded'):
    locs.compute_chunk_sizes()
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2021.6.0
- Python version: 3.8
- Operating System: CentOS 8
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/7767/timeline,,,Hoeze,1200058,MDQ6VXNlcjEyMDAwNTg=,https://avatars.githubusercontent.com/u/1200058?v=4,,https://api.github.com/users/Hoeze,https://github.com/Hoeze,https://api.github.com/users/Hoeze/followers,https://api.github.com/users/Hoeze/following{/other_user},https://api.github.com/users/Hoeze/gists{/gist_id},https://api.github.com/users/Hoeze/starred{/owner}{/repo},https://api.github.com/users/Hoeze/subscriptions,https://api.github.com/users/Hoeze/orgs,https://api.github.com/users/Hoeze/repos,https://api.github.com/users/Hoeze/events{/privacy},https://api.github.com/users/Hoeze/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7767/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
459,https://api.github.com/repos/dask/dask/issues/7779,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7779/labels{/name},https://api.github.com/repos/dask/dask/issues/7779/comments,https://api.github.com/repos/dask/dask/issues/7779/events,https://github.com/dask/dask/issues/7779,916461734,MDU6SXNzdWU5MTY0NjE3MzQ=,7779,Type annotations for dask.delayed,"[{'id': 1968982461, 'node_id': 'MDU6TGFiZWwxOTY4OTgyNDYx', 'url': 'https://api.github.com/repos/dask/dask/labels/delayed', 'name': 'delayed', 'color': '4f6edd', 'default': False, 'description': ''}]",open,False,,[],,2,2021-06-09T17:45:31Z,2021-11-19T17:17:22Z,,NONE,,"The `dask.delayed` decorator should have type annotations.

```py
from dask import delayed

@delayed(pure=True)
def well_typed_function() -> int:
    return 1
```
mypy: Untyped decorator makes function ""well_typed_function"" untyped

Ideally, the type of delayed would be something like

```py
from typing import TypeVar
from dask.delayed import Delayed

T = TypeVar(""T"")

delayed(obj: T, pure:bool = True, ...) -> Delayed[T]
```
A simpler alternative would be
```py
from typing import Any
from dask.delayed import Delayed

delayed(obj: Any, pure:bool = True, ...) -> Delayed
```

",,https://api.github.com/repos/dask/dask/issues/7779/timeline,,,twoertwein,6618166,MDQ6VXNlcjY2MTgxNjY=,https://avatars.githubusercontent.com/u/6618166?v=4,,https://api.github.com/users/twoertwein,https://github.com/twoertwein,https://api.github.com/users/twoertwein/followers,https://api.github.com/users/twoertwein/following{/other_user},https://api.github.com/users/twoertwein/gists{/gist_id},https://api.github.com/users/twoertwein/starred{/owner}{/repo},https://api.github.com/users/twoertwein/subscriptions,https://api.github.com/users/twoertwein/orgs,https://api.github.com/users/twoertwein/repos,https://api.github.com/users/twoertwein/events{/privacy},https://api.github.com/users/twoertwein/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7779/reactions,3,3,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
460,https://api.github.com/repos/dask/dask/issues/7781,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7781/labels{/name},https://api.github.com/repos/dask/dask/issues/7781/comments,https://api.github.com/repos/dask/dask/issues/7781/events,https://github.com/dask/dask/pull/7781,916764576,MDExOlB1bGxSZXF1ZXN0NjY2MzkzMjMx,7781,#7779 added Type annotations for dask.delayed,[],open,False,,[],,12,2021-06-10T00:05:37Z,2022-03-05T08:40:11Z,,FIRST_TIME_CONTRIBUTOR,,"- [ ] Closes #7779
- [ ] Tests added / passed
- [ ] Passes `black dask` / `flake8 dask` / `isort dask`
",,https://api.github.com/repos/dask/dask/issues/7781/timeline,,,BrianArbuckle,5581818,MDQ6VXNlcjU1ODE4MTg=,https://avatars.githubusercontent.com/u/5581818?v=4,,https://api.github.com/users/BrianArbuckle,https://github.com/BrianArbuckle,https://api.github.com/users/BrianArbuckle/followers,https://api.github.com/users/BrianArbuckle/following{/other_user},https://api.github.com/users/BrianArbuckle/gists{/gist_id},https://api.github.com/users/BrianArbuckle/starred{/owner}{/repo},https://api.github.com/users/BrianArbuckle/subscriptions,https://api.github.com/users/BrianArbuckle/orgs,https://api.github.com/users/BrianArbuckle/repos,https://api.github.com/users/BrianArbuckle/events{/privacy},https://api.github.com/users/BrianArbuckle/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7781/reactions,1,0,0,0,0,0,0,0,1,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7781,https://github.com/dask/dask/pull/7781,https://github.com/dask/dask/pull/7781.diff,https://github.com/dask/dask/pull/7781.patch,,,,,,,,,,,,,,,,,,,
461,https://api.github.com/repos/dask/dask/issues/7788,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7788/labels{/name},https://api.github.com/repos/dask/dask/issues/7788/comments,https://api.github.com/repos/dask/dask/issues/7788/events,https://github.com/dask/dask/issues/7788,918384712,MDU6SXNzdWU5MTgzODQ3MTI=,7788,Find number of tasks in overlap layer without materializing the layer,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,3,2021-06-11T08:04:04Z,2021-12-08T10:34:34Z,,MEMBER,,"Follow up work to https://github.com/dask/dask/pull/7595#pullrequestreview-670702731
> Follow-up work could include:
> - computing layer length without materialization

We want to do this because `len()` is called a lot (even accidentally, since it gets called whenever the HTML representation of a dask array is shown). It's not good that it causes unwanted materialization of the graph.

Here's some initial thoughts (see discussion here https://github.com/dask/dask/pull/7595#discussion_r627194025)
> @gjoseph92 made an excellent point earlier that `__len__` and `__iter__` will materialize the whole task graph, and this is all too easy to do accidentally (eg: `_repr_html()` calls `__len__`).
> 
> When I talked about this with Ian, we were not quite sure how to calculate the number of keys in the dictionary *a priori*. That's very easy to know with `map_blocks`, but harder to work out with `map_overlap`. The number of tasks depends on lots of things, including:
> * the number of chunks in the array
> * how those chunks are arranged together (is it a line of chunks, is it lots of little squares making up a bigger square)
> * the overlap depth in pixels (and this seems to change it in really weird ways)
> * the boundary conditions (None, reflect, periodic, nearest, constant)
> 
> It's probably not an intractable problem, but it's not straightforward. Any advice is appreciated.

> I thought I'd work it out if I just sat down and spent a bit of focused time thinking about it, but nope I can't work out the logic.
> 
> I find it especially odd that the number of dictionary keys *decreases* like it hits a some kind of a cliff as you increase the overlap depth:

```python
import numpy as np
import dask.array as da

x = da.from_array(np.random.random((10,10)), chunks=(5,5))

result1 = x.map_blocks(lambda x: x)
print(len(result1.dask))
# 8

result2 = x.map_overlap(lambda x: x, depth=2, boundary='None')
print(len(result2.dask))
# 166

result3 = x.map_overlap(lambda x: x, depth=7, boundary='None')
print(len(result3.dask))
# 83
```

Deepak points out:


>>  I find it especially odd that the number of dictionary keys decreases like it hits a some kind of a cliff as you increase the overlap depth:

> This is because depth=7 > chunksize=5. So map_overlap rechunks to chunksize=7. For any number  5, the number of tasks is 166. For any number > 5, the number of tasks is 83.
",,https://api.github.com/repos/dask/dask/issues/7788/timeline,,,GenevieveBuckley,30920819,MDQ6VXNlcjMwOTIwODE5,https://avatars.githubusercontent.com/u/30920819?v=4,,https://api.github.com/users/GenevieveBuckley,https://github.com/GenevieveBuckley,https://api.github.com/users/GenevieveBuckley/followers,https://api.github.com/users/GenevieveBuckley/following{/other_user},https://api.github.com/users/GenevieveBuckley/gists{/gist_id},https://api.github.com/users/GenevieveBuckley/starred{/owner}{/repo},https://api.github.com/users/GenevieveBuckley/subscriptions,https://api.github.com/users/GenevieveBuckley/orgs,https://api.github.com/users/GenevieveBuckley/repos,https://api.github.com/users/GenevieveBuckley/events{/privacy},https://api.github.com/users/GenevieveBuckley/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7788/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
462,https://api.github.com/repos/dask/dask/issues/7789,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7789/labels{/name},https://api.github.com/repos/dask/dask/issues/7789/comments,https://api.github.com/repos/dask/dask/issues/7789/events,https://github.com/dask/dask/issues/7789,918389636,MDU6SXNzdWU5MTgzODk2MzY=,7789,Implement `cull` method for ArrayOverlapLayer,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,0,2021-06-11T08:07:51Z,2021-10-14T07:46:50Z,,MEMBER,,"Follow up work to https://github.com/dask/dask/pull/7595#pullrequestreview-670702731
> Follow-up work could include:
> - implementing `cull` (right now culling forces materialization as well)

(Probably a good idea to wait and do this after https://github.com/dask/dask/pull/7655/)",,https://api.github.com/repos/dask/dask/issues/7789/timeline,,,GenevieveBuckley,30920819,MDQ6VXNlcjMwOTIwODE5,https://avatars.githubusercontent.com/u/30920819?v=4,,https://api.github.com/users/GenevieveBuckley,https://github.com/GenevieveBuckley,https://api.github.com/users/GenevieveBuckley/followers,https://api.github.com/users/GenevieveBuckley/following{/other_user},https://api.github.com/users/GenevieveBuckley/gists{/gist_id},https://api.github.com/users/GenevieveBuckley/starred{/owner}{/repo},https://api.github.com/users/GenevieveBuckley/subscriptions,https://api.github.com/users/GenevieveBuckley/orgs,https://api.github.com/users/GenevieveBuckley/repos,https://api.github.com/users/GenevieveBuckley/events{/privacy},https://api.github.com/users/GenevieveBuckley/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7789/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
463,https://api.github.com/repos/dask/dask/issues/7791,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7791/labels{/name},https://api.github.com/repos/dask/dask/issues/7791/comments,https://api.github.com/repos/dask/dask/issues/7791/events,https://github.com/dask/dask/issues/7791,918409623,MDU6SXNzdWU5MTg0MDk2MjM=,7791,get_output_keys method for ArrayOverlapLayer that won't materialize the graph,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,1,2021-06-11T08:21:38Z,2021-12-08T10:15:24Z,,MEMBER,,"We need a `get_output_keys` method for the `ArrayOverlapLayer` class that *won't* materialize the task graph.

Related: 
- https://github.com/dask/dask/pull/7595
- https://github.com/dask/dask/pull/7790

",,https://api.github.com/repos/dask/dask/issues/7791/timeline,,,GenevieveBuckley,30920819,MDQ6VXNlcjMwOTIwODE5,https://avatars.githubusercontent.com/u/30920819?v=4,,https://api.github.com/users/GenevieveBuckley,https://github.com/GenevieveBuckley,https://api.github.com/users/GenevieveBuckley/followers,https://api.github.com/users/GenevieveBuckley/following{/other_user},https://api.github.com/users/GenevieveBuckley/gists{/gist_id},https://api.github.com/users/GenevieveBuckley/starred{/owner}{/repo},https://api.github.com/users/GenevieveBuckley/subscriptions,https://api.github.com/users/GenevieveBuckley/orgs,https://api.github.com/users/GenevieveBuckley/repos,https://api.github.com/users/GenevieveBuckley/events{/privacy},https://api.github.com/users/GenevieveBuckley/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7791/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
464,https://api.github.com/repos/dask/dask/issues/7828,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7828/labels{/name},https://api.github.com/repos/dask/dask/issues/7828/comments,https://api.github.com/repos/dask/dask/issues/7828/events,https://github.com/dask/dask/pull/7828,928560940,MDExOlB1bGxSZXF1ZXN0Njc2NTQ3Njky,7828,Updating GPU documentation,[],open,False,,[],,0,2021-06-23T19:11:20Z,2021-06-24T14:45:50Z,,FIRST_TIME_CONTRIBUTOR,,"Hello!

This PR updates the GPU page for the dask.org documentation. It:

* Expands on the ways you can use Dask for GPUs (with specific collections, through multi-gpu libraries like PyTorch DDP, and through running concurrent model trainings)
* Adds some images to help explain the uses (with Dask styling)
* Adds credits for the linked video
* Assorted other cleaning",,https://api.github.com/repos/dask/dask/issues/7828/timeline,,,jnolis,3317138,MDQ6VXNlcjMzMTcxMzg=,https://avatars.githubusercontent.com/u/3317138?v=4,,https://api.github.com/users/jnolis,https://github.com/jnolis,https://api.github.com/users/jnolis/followers,https://api.github.com/users/jnolis/following{/other_user},https://api.github.com/users/jnolis/gists{/gist_id},https://api.github.com/users/jnolis/starred{/owner}{/repo},https://api.github.com/users/jnolis/subscriptions,https://api.github.com/users/jnolis/orgs,https://api.github.com/users/jnolis/repos,https://api.github.com/users/jnolis/events{/privacy},https://api.github.com/users/jnolis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7828/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7828,https://github.com/dask/dask/pull/7828,https://github.com/dask/dask/pull/7828.diff,https://github.com/dask/dask/pull/7828.patch,,,,,,,,,,,,,,,,,,,
465,https://api.github.com/repos/dask/dask/issues/7850,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7850/labels{/name},https://api.github.com/repos/dask/dask/issues/7850/comments,https://api.github.com/repos/dask/dask/issues/7850/events,https://github.com/dask/dask/issues/7850,933880312,MDU6SXNzdWU5MzM4ODAzMTI=,7850,Unable to load ORC table using `read_orc`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,6,2021-06-30T16:17:03Z,2021-07-22T19:26:03Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:

I am trying to use `read_orc` to read an ORC table located in a Kerberised HDFS. I can use `read_parquet` but `read_orc` fails with the following attribute error:

```py
/projects/gds/chavesrl/condapv/envs/N2D/lib/python3.7/site-packages/dask/dataframe/io/orc.py in read_orc(path, columns, storage_options)
     74                 raise ValueError(""Incompatible schemas while parsing ORC files"")
     75             nstripes_per_file.append(o.nstripes)
---> 76     schema = _get_pyarrow_dtypes(schema, categories=None)
     77     if columns is not None:
     78         ex = set(columns) - set(schema)

/projects/gds/chavesrl/condapv/envs/N2D/lib/python3.7/site-packages/dask/dataframe/io/utils.py in _get_pyarrow_dtypes(schema, categories)
      9 
     10     # Check for pandas metadata
---> 11     has_pandas_metadata = schema.metadata is not None and b""pandas"" in schema.metadata
     12     if has_pandas_metadata:
     13         pandas_metadata = json.loads(schema.metadata[b""pandas""].decode(""utf8""))

AttributeError: 'NoneType' object has no attribute 'metadata'
```

after running the following code:
```py
from dask.dataframe import read_orc
read_orc(info['location']+'/*', 
         storage_options = {
             'user':'{username}', 
             'kerb_ticket' : '/tmp/krb5cc_132855'
         })
```
where `info['location']` is of the likes of: `hdfs://cluster/db/schema/table_name`


**What you expected to happen**:

To have the table be loaded as a dask dataframe in the same way parquet tables are read succesfully

**Anything else we need to know?**:

**Environment**:

- Dask version: '2021.04.0'
- Python version: 3.7.10
- Operating System: Linux RedHat
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/7850/timeline,,,lucharo,47890755,MDQ6VXNlcjQ3ODkwNzU1,https://avatars.githubusercontent.com/u/47890755?v=4,,https://api.github.com/users/lucharo,https://github.com/lucharo,https://api.github.com/users/lucharo/followers,https://api.github.com/users/lucharo/following{/other_user},https://api.github.com/users/lucharo/gists{/gist_id},https://api.github.com/users/lucharo/starred{/owner}{/repo},https://api.github.com/users/lucharo/subscriptions,https://api.github.com/users/lucharo/orgs,https://api.github.com/users/lucharo/repos,https://api.github.com/users/lucharo/events{/privacy},https://api.github.com/users/lucharo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7850/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
466,https://api.github.com/repos/dask/dask/issues/7859,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7859/labels{/name},https://api.github.com/repos/dask/dask/issues/7859/comments,https://api.github.com/repos/dask/dask/issues/7859/events,https://github.com/dask/dask/issues/7859,936006307,MDU6SXNzdWU5MzYwMDYzMDc=,7859,mysterious rechunking error,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2021-07-02T18:58:32Z,2021-08-05T15:34:23Z,,MEMBER,,"on `dask==2021.6.2`:

```python
import dask.array as da

# this matters -- (1185, 241, 1060) and (1185, 241, 1058) run fine
shape = (1185, 241, 1059) 
final_chunks = (64,64,64)

coarsened = da.coarsen(da.mean, da.zeros(shape, chunks=(1,-1,-1)), {0: 2, 1: 2, 2: 2}, trim_excess=True)
rechunked_a = coarsened.rechunk(*final_chunks)
rechunked_b = coarsened.rechunk(final_chunks)

assert rechunked_a.chunks == rechunked_b.chunks

a = rechunked_a.compute()
b = rechunked_b.compute()
```
`rechunked_a` runs fine, but `rechunked_b` errors with a traceback that ends here: 

```
~/miniconda3/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

TypeError: tuple indices must be integers or slices, not tuple
```
I will keep digging into it, but this has to be some kind of weird bug in the rechunking code.",,https://api.github.com/repos/dask/dask/issues/7859/timeline,,,d-v-b,3805136,MDQ6VXNlcjM4MDUxMzY=,https://avatars.githubusercontent.com/u/3805136?v=4,,https://api.github.com/users/d-v-b,https://github.com/d-v-b,https://api.github.com/users/d-v-b/followers,https://api.github.com/users/d-v-b/following{/other_user},https://api.github.com/users/d-v-b/gists{/gist_id},https://api.github.com/users/d-v-b/starred{/owner}{/repo},https://api.github.com/users/d-v-b/subscriptions,https://api.github.com/users/d-v-b/orgs,https://api.github.com/users/d-v-b/repos,https://api.github.com/users/d-v-b/events{/privacy},https://api.github.com/users/d-v-b/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7859/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
467,https://api.github.com/repos/dask/dask/issues/7860,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7860/labels{/name},https://api.github.com/repos/dask/dask/issues/7860/comments,https://api.github.com/repos/dask/dask/issues/7860/events,https://github.com/dask/dask/issues/7860,936041940,MDU6SXNzdWU5MzYwNDE5NDA=,7860,map_partitions or map_blocks with large objects eats up scheduler memory,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}]",open,False,,[],,5,2021-07-02T20:10:19Z,2021-10-14T08:18:15Z,,NONE,,"Opening this report from investigation in https://github.com/dask/dask-ml/issues/842 and https://github.com/dask/dask-ml/pull/843

When passing some large objects as arguments to map_blocks / map_partitions, the scheduler memory can quickly be overwhelmed. Large objects _should_ be wrapped in delayed to add them to graph and avoid this issue ([see here](https://github.com/dask/dask/blob/626cc724ffa1d14cd74f48ff4f21ef443d832afa/dask/array/core.py#L428)) , but the way the object sizes are determined miss some large objects. In the cases I've encountered, it does not correctly compute the size of scikit-learn estimators.

This is because sys.getsizeof does not properly traverse object references to compute the ""real"" size of an object. This is a notoriously difficult thing to do in Python, so not sure what the best course of action here should be. 

**Minimal Complete Verifiable Example**:

Running on machine with 2 cores and 16 GB of RAM

```python
from dask_ml.datasets import make_classification
from sklearn.ensemble import RandomForestClassifier
import numpy as np
import pickle
import sys
import dask
from dask.distributed import Client

client = Client()

X, y = make_classification(
    n_samples=50000,
    chunks=1000,
    random_state=42,
)

rf = RandomForestClassifier(n_estimators=100, random_state=42, n_jobs=-1)
_ = rf.fit(X, y)


def dask_predict(part, model):
    return model.predict(part)

preds = X.map_blocks(
    dask_predict,
    model=rf,
    dtype=""int"",
    drop_axis=1,
)
preds.compute()
```

Scheduler memory ballons up to this:

<img width=""458"" alt=""image"" src=""https://user-images.githubusercontent.com/8964039/124323726-c7727b00-db4f-11eb-9b2b-4ae9f02b282b.png"">

And ends up with this error:

```
KilledWorker: (""('normal-dask_predict-4b858b85224825aeb2d45678c4c91d39', 27)"", <WorkerState 'tcp://127.0.0.1:33369', name: 0, memory: 0, processing: 50>)
```

If we explictly delayed the rf object, 

```python
rf_delayed = dask.delayed(rf)
preds = X.map_blocks(
    dask_predict,
    model=rf_delayed,
    dtype=""int"",
    drop_axis=1,
    meta=np.array([1]),
)
preds.compute()
```

the memory use looks like this:

<img width=""750"" alt=""Screen Shot 2021-07-02 at 4 00 52 PM"" src=""https://user-images.githubusercontent.com/8964039/124323750-d1947980-db4f-11eb-826f-9bf82e334202.png"">

**Environment**:

- Dask version: 2021.5.1
- Python version: 3.7
- Operating System: ubuntu
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/7860/timeline,,,rikturr,8964039,MDQ6VXNlcjg5NjQwMzk=,https://avatars.githubusercontent.com/u/8964039?v=4,,https://api.github.com/users/rikturr,https://github.com/rikturr,https://api.github.com/users/rikturr/followers,https://api.github.com/users/rikturr/following{/other_user},https://api.github.com/users/rikturr/gists{/gist_id},https://api.github.com/users/rikturr/starred{/owner}{/repo},https://api.github.com/users/rikturr/subscriptions,https://api.github.com/users/rikturr/orgs,https://api.github.com/users/rikturr/repos,https://api.github.com/users/rikturr/events{/privacy},https://api.github.com/users/rikturr/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7860/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
468,https://api.github.com/repos/dask/dask/issues/7885,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7885/labels{/name},https://api.github.com/repos/dask/dask/issues/7885/comments,https://api.github.com/repos/dask/dask/issues/7885/events,https://github.com/dask/dask/issues/7885,941278602,MDU6SXNzdWU5NDEyNzg2MDI=,7885,Mixed dataframe - array graph optimization (column projection pushdown not working if final result is an array),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,4,2021-07-10T16:06:37Z,2021-10-12T07:22:28Z,,MEMBER,,"From https://github.com/geopandas/dask-geopandas/issues/78, but I made a small standalone example to illustrate the issue (see below for the full example workflow).  
If you have a workflow where you read a DataFrame from a file (eg parquet, which supports column selection), select a subset of the columns, and then perform an operation which results in an Array and not Series/DataFrame, the ""column projection"" pushdown (`project_columns` method of the `DataFrameIOLayer`, used in the `optimize_dataframe_getitem` function which is called in the general graph optimization step for DataFrames) is not working. 

To the extent I understand the graph optimization and debugged this use case, the reason this doesn't work in this case is because the final collection object of the workflow is a dask Array (although all layers of the HighLevelGraph except for the last ones are still DataFrame-based), and thus the optimization step at

https://github.com/dask/dask/blob/2a0020daa5ca960d9ae7f898b181d28693367a2f/dask/base.py#L333-L338

uses the Array's optimize function (`Array.__dask_optimize__` -> `dask.array.optimization.optimize`) to optimize the full graph instead of the dask DataFrame version (and it's the dataframe version that has the logic to call `optimize_dataframe_getitem` and optimize this).

We can probably work around this in dask-geopandas (eg return a 4-element Series instead of 4-element array for the `total_bounds` attribute in question), but would such mixed-layer optimizations be in scope for dask?

----

**Full example**

Consider the following dask dataframe from a Parquet dataset:

```python
import pandas as pd
import dask.dataframe as dd

df = pd.DataFrame(np.random.randn(100, 3), columns=[""a"", ""b"", ""c""])
ddf = dd.from_pandas(df, npartitions=2)
ddf.to_parquet(""test_column_projection"")

ddf = dd.read_parquet(""test_column_projection/"", engine=""pyarrow"")
```

and I create a reduction operation (example here is to calculate min and max of one column):

```python
def reduce_chunk(s):
    return pd.Series([s.min(), s.max()], index=[""min"", ""max""])

def reduce_aggregate(df):
    return pd.Series([df[""min""].min(), df[""max""].max()], index=[""min"", ""max""])

result = ddf[""a""].reduction(reduce_chunk, aggregate=reduce_aggregate)
```

Thanks to the column projection pushdown in the graph optimization, the `getitem` layer ensures that the Parquet reader only reads column ""a"". To ensure this for illustration purposes, I added a print statement to the parquet reading function:

```python
from dask.dataframe.io.parquet import arrow

def log_columns_keyword(f):
    """"""Print the value passed for the columns to read""""""
    def wrapper(*args, **kwargs):
        print(f.__name__, ""columns:"", args[3])
        return f(*args, **kwargs)
    return wrapper

arrow._read_table_from_path = log_columns_keyword(arrow._read_table_from_path)
```

which gives:
```
In [4]: result.compute(scheduler=""synchronous"")
_read_table_from_path columns: ['a', '__null_dask_index__']
_read_table_from_path columns: ['a', '__null_dask_index__']
Out[4]: 
min   -1.962085
max    2.065056
dtype: float64
```

However, if I now rewrite the reduction to return an array instead of a Series:

```python
def reduce_chunk2(s):
    return np.array([s.min(), s.max()])

def reduce_aggregate2(arr):
    return np.array([arr[0::2].min(), arr[1::2].max()])

result2 = ddf[""a""].reduction(reduce_chunk2, aggregate=reduce_aggregate2)
```

we get:

```
In [6]: result2.compute(scheduler=""synchronous"")
_read_table_from_path columns: ['a', 'b', 'c', '__null_dask_index__']
_read_table_from_path columns: ['a', 'b', 'c', '__null_dask_index__']
Out[6]: array([-1.96208513,  2.06505574])
```

So here it is reading all columns from the Parquet file, even though I am only calculating something on `ddf[""a""]`.


",,https://api.github.com/repos/dask/dask/issues/7885/timeline,,,jorisvandenbossche,1020496,MDQ6VXNlcjEwMjA0OTY=,https://avatars.githubusercontent.com/u/1020496?v=4,,https://api.github.com/users/jorisvandenbossche,https://github.com/jorisvandenbossche,https://api.github.com/users/jorisvandenbossche/followers,https://api.github.com/users/jorisvandenbossche/following{/other_user},https://api.github.com/users/jorisvandenbossche/gists{/gist_id},https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo},https://api.github.com/users/jorisvandenbossche/subscriptions,https://api.github.com/users/jorisvandenbossche/orgs,https://api.github.com/users/jorisvandenbossche/repos,https://api.github.com/users/jorisvandenbossche/events{/privacy},https://api.github.com/users/jorisvandenbossche/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7885/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
469,https://api.github.com/repos/dask/dask/issues/7899,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7899/labels{/name},https://api.github.com/repos/dask/dask/issues/7899/comments,https://api.github.com/repos/dask/dask/issues/7899/events,https://github.com/dask/dask/issues/7899,944745056,MDU6SXNzdWU5NDQ3NDUwNTY=,7899,[FEA] API to write dask dataframes to local storage of each node in multi-node cluster,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,10,2021-07-14T19:51:07Z,2021-07-16T20:04:04Z,,MEMBER,,"#### [FEA] API to write dask dataframes to local storage of each node in multi-node cluster


### Example requested API:

```python
df.to_parquet(xxx, write_locally_per_node=True) 
```
**Please feel free to suggest a better API to do this.**  


### Usecase Details: 

While working on multi-node dask cluster users often don't have the shared storage available in the system.  This problem becomes more worse for multi-node cloud systems when intra-node communication is often a bottleneck.  


We need to write these frames locally to run a bunch of downstream tasks (think running multiple machine learning models on each node). 

Having an API that allows this will simplify doing this. 

### Workaround:

We currently use the below workaround to achieve this but having it locally in dask will be super helpful. 
```python

## This function writes data-frames
def writing_func(df,node_ip, out_dir, part_num):
    import os
    worker_ip = get_worker().name.split('//')[1].split(':')[0]
    
    ### ensure we are writing using a worker that belongs to node_ip
    assert worker_ip==node_ip
    
    out_fn = str(part_num) + '.parquet'
    out_path=os.path.join(out_dir,out_fn)
    df.to_parquet(out_path)
    return len(df)

def get_node_ip_dict():
    workers = client.scheduler_info()['workers'].keys()
    ips = set([x.split('//')[1].split(':')[0] for x in workers])
    ip_d = dict.fromkeys(ips)
    for worker in workers:
        ip = worker.split('//')[1].split(':')[0]
        if ip_d[ip] is None:
            ip_d[ip]=[]
        ip_d[ip].append(worker)
    return ip_d
    
    
 ip_dict = get_node_ip_dict()
 
output_task_ls=[]
for node_ip,node_workers in ip_dict.items():
    
    ## create a task ls
    task_ls = [dask.delayed(writing_func)(df,node_ip,out_dir,part_num) for part_num,df in enumerate(dask_df.to_delayed())]
    
    ## submit the task to the workers on the node
    o_ls = client.compute(task_ls,workers=node_workers,allow_other_workers=False,sync=False)
    output_task_ls.append(o_ls)

len_list = [sum([o.result() for o in o_ls]) for o_ls in output_task_ls]
```
 CC: @quasiben , @randerzander",,https://api.github.com/repos/dask/dask/issues/7899/timeline,,,VibhuJawa,4837571,MDQ6VXNlcjQ4Mzc1NzE=,https://avatars.githubusercontent.com/u/4837571?v=4,,https://api.github.com/users/VibhuJawa,https://github.com/VibhuJawa,https://api.github.com/users/VibhuJawa/followers,https://api.github.com/users/VibhuJawa/following{/other_user},https://api.github.com/users/VibhuJawa/gists{/gist_id},https://api.github.com/users/VibhuJawa/starred{/owner}{/repo},https://api.github.com/users/VibhuJawa/subscriptions,https://api.github.com/users/VibhuJawa/orgs,https://api.github.com/users/VibhuJawa/repos,https://api.github.com/users/VibhuJawa/events{/privacy},https://api.github.com/users/VibhuJawa/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7899/reactions,1,0,0,0,0,0,1,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
470,https://api.github.com/repos/dask/dask/issues/7911,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7911/labels{/name},https://api.github.com/repos/dask/dask/issues/7911/comments,https://api.github.com/repos/dask/dask/issues/7911/events,https://github.com/dask/dask/issues/7911,947724826,MDU6SXNzdWU5NDc3MjQ4MjY=,7911,Deterministic dict order,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}]",open,False,,[],,7,2021-07-19T14:40:34Z,2021-10-14T08:17:54Z,,MEMBER,,"@zzhengnan has been working on unskipping doctests and as part of that work we realized that the order of many of the dicts in dask is not deterministic. Obviously this matters from the doctests perspective (https://github.com/dask/dask/pull/7874#discussion_r669227208) but it's not clear to me if it would be a generally useful thing to have predictable dict ordering. Here's an example pulled from the highlevelgraph docstring.


**Minimal Complete Verifiable Example**:

```python
>>> import dask
>>> import dask.dataframe as dd
>>> dask.datasets.timeseries(freq=""1H"", start=""2021-07-01"", end=""2021-07-05"").to_csv(""myfile.*.csv"")
>>> df = df.read_csv(""myfile.*.csv"")
>>> df = df[df.name == ""Alice""]
>>> graph = df.__dask_graph__()
>>> graph
HighLevelGraph with 4 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x7f4456afec70>
 0. read-csv-136524d4e292271449abaac2e2d5db0f
 1. getitem-063bc8eb2c47ea9536bbd7059706a728
 2. eq-55ca3c29ae249bb1a1ab9eb42332a747
 3. getitem-56f4e42f7c46ae412827cce188b37184

>>> graph.layers
{'getitem-56f4e42f7c46ae412827cce188b37184': Blockwise<(('read-csv-136524d4e292271449abaac2e2d5db0f', ('.0',)), ('eq-55ca3c29ae249bb1a1ab9eb42332a747', ('.0',))) -> getitem-56f4e42f7c46ae412827cce188b37184>,
 'read-csv-136524d4e292271449abaac2e2d5db0f': DataFrameIOLayer<name='read-csv-136524d4e292271449abaac2e2d5db0f', n_parts=4, columns=['timestamp', 'id', 'name', 'x', 'y']>,
 'getitem-063bc8eb2c47ea9536bbd7059706a728': Blockwise<(('read-csv-136524d4e292271449abaac2e2d5db0f', ('.0',)), ('name', None)) -> getitem-063bc8eb2c47ea9536bbd7059706a728>,
 'eq-55ca3c29ae249bb1a1ab9eb42332a747': Blockwise<(('getitem-063bc8eb2c47ea9536bbd7059706a728', ('.0',)), ('Alice', None)) -> eq-55ca3c29ae249bb1a1ab9eb42332a747>}
```",,https://api.github.com/repos/dask/dask/issues/7911/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7911/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
471,https://api.github.com/repos/dask/dask/issues/7923,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7923/labels{/name},https://api.github.com/repos/dask/dask/issues/7923/comments,https://api.github.com/repos/dask/dask/issues/7923/events,https://github.com/dask/dask/issues/7923,950191751,MDU6SXNzdWU5NTAxOTE3NTE=,7923,Binops between `dd.Series` and NumPy arrays fail while inferring meta,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2021-07-21T23:55:01Z,2021-10-14T08:16:26Z,,MEMBER,,"**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import numpy as np

arr = np.arange(10)
series = dd.from_array(arr)
series + arr
```
```python
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
~/dev/dask/dask/dataframe/utils.py in raise_on_meta_error(funcname, udf)
    175     try:
--> 176         yield
    177     except Exception as e:

~/dev/dask/dask/dataframe/core.py in elemwise(op, *args, **kwargs)
   5332         with raise_on_meta_error(funcname(op)):
-> 5333             meta = partial_by_order(*parts, function=op, other=other)
   5334 

~/dev/dask/dask/utils.py in partial_by_order(*args, **kwargs)
   1169         args2.insert(i, arg)
-> 1170     return function(*args2, **kwargs)
   1171 

~/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/ops/common.py in new_method(self, other)
     64 
---> 65         return method(self, other)
     66 

~/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/ops/__init__.py in wrapper(left, right)
    342         rvalues = extract_array(right, extract_numpy=True)
--> 343         result = arithmetic_op(lvalues, rvalues, op)
    344 

~/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/ops/array_ops.py in arithmetic_op(left, right, op)
    189         with np.errstate(all=""ignore""):
--> 190             res_values = na_arithmetic_op(lvalues, rvalues, op)
    191 

~/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/ops/array_ops.py in na_arithmetic_op(left, right, op, is_cmp)
    142     try:
--> 143         result = expressions.evaluate(op, left, right)
    144     except TypeError:

~/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/computation/expressions.py in evaluate(op, a, b, use_numexpr)
    232         if use_numexpr:
--> 233             return _evaluate(op, op_str, a, b)  # type: ignore
    234     return _evaluate_standard(op, op_str, a, b)

~/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/computation/expressions.py in _evaluate_standard(op, op_str, a, b)
     67     with np.errstate(all=""ignore""):
---> 68         return op(a, b)
     69 

ValueError: operands could not be broadcast together with shapes (2,) (10,) 

The above exception was the direct cause of the following exception:

ValueError                                Traceback (most recent call last)
<ipython-input-7-cc129ab42671> in <module>
----> 1 series + arr

~/dev/dask/dask/dataframe/core.py in <lambda>(self, other)
   1561             return lambda self, other: elemwise(op, other, self)
   1562         else:
-> 1563             return lambda self, other: elemwise(op, self, other)
   1564 
   1565     def rolling(self, window, min_periods=None, center=False, win_type=None, axis=0):

~/dev/dask/dask/dataframe/core.py in elemwise(op, *args, **kwargs)
   5331         ]
   5332         with raise_on_meta_error(funcname(op)):
-> 5333             meta = partial_by_order(*parts, function=op, other=other)
   5334 
   5335     result = new_dd_object(graph, _name, meta, divisions)

~/miniconda3/envs/dask-dev/lib/python3.8/contextlib.py in __exit__(self, type, value, traceback)
    129                 value = type()
    130             try:
--> 131                 self.gen.throw(type, value, traceback)
    132             except StopIteration as exc:
    133                 # Suppress StopIteration *unless* it's the same exception that

~/dev/dask/dask/dataframe/utils.py in raise_on_meta_error(funcname, udf)
    195         )
    196         msg = msg.format("" in `{0}`"".format(funcname) if funcname else """", repr(e), tb)
--> 197         raise ValueError(msg) from e
    198 
    199 

ValueError: Metadata inference failed in `add`.

Original error is below:
------------------------
ValueError('operands could not be broadcast together with shapes (2,) (10,) ')

Traceback:
---------
  File ""/Users/gabe/dev/dask/dask/dataframe/utils.py"", line 176, in raise_on_meta_error
    yield
  File ""/Users/gabe/dev/dask/dask/dataframe/core.py"", line 5333, in elemwise
    meta = partial_by_order(*parts, function=op, other=other)
  File ""/Users/gabe/dev/dask/dask/utils.py"", line 1170, in partial_by_order
    return function(*args2, **kwargs)
  File ""/Users/gabe/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/ops/common.py"", line 65, in new_method
    return method(self, other)
  File ""/Users/gabe/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/ops/__init__.py"", line 343, in wrapper
    result = arithmetic_op(lvalues, rvalues, op)
  File ""/Users/gabe/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/ops/array_ops.py"", line 190, in arithmetic_op
    res_values = na_arithmetic_op(lvalues, rvalues, op)
  File ""/Users/gabe/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/ops/array_ops.py"", line 143, in na_arithmetic_op
    result = expressions.evaluate(op, left, right)
  File ""/Users/gabe/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/computation/expressions.py"", line 233, in evaluate
    return _evaluate(op, op_str, a, b)  # type: ignore
  File ""/Users/gabe/miniconda3/envs/dask-dev/lib/python3.8/site-packages/pandas/core/computation/expressions.py"", line 68, in _evaluate_standard
    return op(a, b)
```

**Anything else we need to know?**:

We have a [`_maybe_from_pandas`](https://github.com/dask/dask/blob/56d1891c15320872b815f1ab2f8e41867b231e5e/dask/dataframe/core.py#L5264) coercion for the input argumentsperhaps there should also be an equivalent `_maybe_from_array`? FWIW, this works as expected:
```python
>>> import dask.array as da
>>> darr = da.from_array(arr)
>>> series + darr
Dask Series Structure:
npartitions=1
0    int64
9      ...
dtype: int64
Dask Name: add, 3 tasks
```
So turning any arrays in the inputs into dask arrays might be sufficient.

**Environment**:

- Dask version: 56d1891c15320872b815f1ab2f8e41867b231e5e
- Python version: 3.8.8
- Operating System: macOS
- Install method (conda, pip, source): source
",,https://api.github.com/repos/dask/dask/issues/7923/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7923/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
472,https://api.github.com/repos/dask/dask/issues/7926,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7926/labels{/name},https://api.github.com/repos/dask/dask/issues/7926/comments,https://api.github.com/repos/dask/dask/issues/7926/events,https://github.com/dask/dask/issues/7926,951142711,MDU6SXNzdWU5NTExNDI3MTE=,7926,"dd.to_hdf produces HDF5ExtError ( unable to lock file, errno = 11, error message = 'Resource temporarily unavailable') on local cluster","[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,2,2021-07-22T23:56:20Z,2021-07-26T16:16:12Z,,NONE,,"dask.dataframe (dd) produces a HDF5ExtError when running on local cluster.

some data (~100MB) is written to the file, so I suspect it is an parallel writing issue maybe? 

The script works if not using client

**Minimal example:**
```
import dask.dataframe as dd
import dask.array as da

# load dask client
from dask.distributed import Client
client = Client()
client

ddf = da.random.randint(0, 0xFFFF, (int(1e8), 10)).to_dask_dataframe(columns=[f""test {i}"" for i in range (10)])

ddf.to_hdf(""delme.h5"", 
           key='/data*',
           complevel=5, 
           complib=""blosc:lz4hc"", 
)

```

**Output:**
```
---------------------------------------------------------------------------
HDF5ExtError                              Traceback (most recent call last)
<ipython-input-6-557a3a58ea58> in <module>
----> 1 ddf.to_hdf(""delme.h5"", 
      2            key='/data*',
      3            complevel=5,
      4            complib=""blosc:lz4hc"",
      5            mode='w'

~/anaconda3/lib/python3.8/site-packages/dask/dataframe/core.py in to_hdf(self, path_or_buf, key, mode, append, **kwargs)
   1464         from .io import to_hdf
   1465 
-> 1466         return to_hdf(self, path_or_buf, key, mode, append, **kwargs)
   1467 
   1468     def to_csv(self, filename, **kwargs):

~/anaconda3/lib/python3.8/site-packages/dask/dataframe/io/hdf.py in to_hdf(df, path, key, mode, append, scheduler, name_function, compute, lock, dask_kwargs, **kwargs)
    249 
    250     if compute:
--> 251         compute_as_if_collection(
    252             DataFrame, dsk, keys, scheduler=scheduler, **dask_kwargs
    253         )

~/anaconda3/lib/python3.8/site-packages/dask/base.py in compute_as_if_collection(cls, dsk, keys, scheduler, get, **kwargs)
    311     schedule = get_scheduler(scheduler=scheduler, cls=cls, get=get)
    312     dsk2 = optimization_function(cls)(ensure_dict(dsk), keys, **kwargs)
--> 313     return schedule(dsk2, keys, **kwargs)
    314 
    315 

~/anaconda3/lib/python3.8/site-packages/distributed/client.py in get(self, dsk, keys, workers, allow_other_workers, resources, sync, asynchronous, direct, retries, priority, fifo_timeout, actors, **kwargs)
   2702                     should_rejoin = False
   2703             try:
-> 2704                 results = self.gather(packed, asynchronous=asynchronous, direct=direct)
   2705             finally:
   2706                 for f in futures.values():

~/anaconda3/lib/python3.8/site-packages/distributed/client.py in gather(self, futures, errors, direct, asynchronous)
   2016             else:
   2017                 local_worker = None
-> 2018             return self.sync(
   2019                 self._gather,
   2020                 futures,

~/anaconda3/lib/python3.8/site-packages/distributed/client.py in sync(self, func, asynchronous, callback_timeout, *args, **kwargs)
    857             return future
    858         else:
--> 859             return sync(
    860                 self.loop, func, *args, callback_timeout=callback_timeout, **kwargs
    861             )

~/anaconda3/lib/python3.8/site-packages/distributed/utils.py in sync(loop, func, callback_timeout, *args, **kwargs)
    324     if error[0]:
    325         typ, exc, tb = error[0]
--> 326         raise exc.with_traceback(tb)
    327     else:
    328         return result[0]

~/anaconda3/lib/python3.8/site-packages/distributed/utils.py in f()
    307             if callback_timeout is not None:
    308                 future = asyncio.wait_for(future, callback_timeout)
--> 309             result[0] = yield future
    310         except Exception:
    311             error[0] = sys.exc_info()

~/anaconda3/lib/python3.8/site-packages/tornado/gen.py in run(self)
    760 
    761                     try:
--> 762                         value = future.result()
    763                     except Exception:
    764                         exc_info = sys.exc_info()

~/anaconda3/lib/python3.8/site-packages/distributed/client.py in _gather(self, futures, errors, direct, local_worker)
   1881                             exc = CancelledError(key)
   1882                         else:
-> 1883                             raise exception.with_traceback(traceback)
   1884                         raise exc
   1885                     if errors == ""skip"":

~/anaconda3/lib/python3.8/site-packages/dask/dataframe/io/hdf.py in _pd_to_hdf()
     25         lock.acquire()
     26     try:
---> 27         pd_to_hdf(*args, **kwargs)
     28     finally:
     29         if lock:

~/anaconda3/lib/python3.8/site-packages/pandas/core/generic.py in to_hdf()
   2698         from pandas.io import pytables
   2699 
-> 2700         pytables.to_hdf(
   2701             path_or_buf,
   2702             key,

~/anaconda3/lib/python3.8/site-packages/pandas/io/pytables.py in to_hdf()
    309     path_or_buf = stringify_path(path_or_buf)
    310     if isinstance(path_or_buf, str):
--> 311         with HDFStore(
    312             path_or_buf, mode=mode, complevel=complevel, complib=complib
    313         ) as store:

~/anaconda3/lib/python3.8/site-packages/pandas/io/pytables.py in __init__()
    589         self._fletcher32 = fletcher32
    590         self._filters = None
--> 591         self.open(mode=mode, **kwargs)
    592 
    593     def __fspath__(self):

~/anaconda3/lib/python3.8/site-packages/pandas/io/pytables.py in open()
    738             raise ValueError(msg)
    739 
--> 740         self._handle = tables.open_file(self._path, self._mode, **kwargs)
    741 
    742     def close(self):

~/anaconda3/lib/python3.8/site-packages/tables/file.py in open_file()
    313 
    314     # Finally, create the File instance, and return it
--> 315     return File(filename, mode, title, root_uep, filters, **kwargs)
    316 
    317 

~/anaconda3/lib/python3.8/site-packages/tables/file.py in __init__()
    776 
    777         # Now, it is time to initialize the File extension
--> 778         self._g_new(filename, mode, **params)
    779 
    780         # Check filters and set PyTables format version for new files.

tables/hdf5extension.pyx in tables.hdf5extension.File._g_new()

HDF5ExtError: HDF5 error back trace

  File ""H5F.c"", line 509, in H5Fopen
    unable to open file
  File ""H5Fint.c"", line 1400, in H5F__open
    unable to open file
  File ""H5Fint.c"", line 1615, in H5F_open
    unable to lock the file
  File ""H5FD.c"", line 1640, in H5FD_lock
    driver lock request failed
  File ""H5FDsec2.c"", line 941, in H5FD_sec2_lock
    unable to lock file, errno = 11, error message = 'Resource temporarily unavailable'

End of HDF5 error back trace

Unable to open/create file 'delme.h5'
```

**Environment**:

- Dask version: '2021.07.0'
- tables version: '3.6.1'
- Python version:   Python 3.8.2  (Ananconda)
- Operating System: Ubuntu 21.04
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/7926/timeline,,,N4321D,35295509,MDQ6VXNlcjM1Mjk1NTA5,https://avatars.githubusercontent.com/u/35295509?v=4,,https://api.github.com/users/N4321D,https://github.com/N4321D,https://api.github.com/users/N4321D/followers,https://api.github.com/users/N4321D/following{/other_user},https://api.github.com/users/N4321D/gists{/gist_id},https://api.github.com/users/N4321D/starred{/owner}{/repo},https://api.github.com/users/N4321D/subscriptions,https://api.github.com/users/N4321D/orgs,https://api.github.com/users/N4321D/repos,https://api.github.com/users/N4321D/events{/privacy},https://api.github.com/users/N4321D/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7926/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
473,https://api.github.com/repos/dask/dask/issues/7930,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7930/labels{/name},https://api.github.com/repos/dask/dask/issues/7930/comments,https://api.github.com/repos/dask/dask/issues/7930/events,https://github.com/dask/dask/issues/7930,951917904,MDU6SXNzdWU5NTE5MTc5MDQ=,7930,Issue opening h5py arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,6,2021-07-23T21:52:44Z,2021-10-12T07:19:13Z,,NONE,,"I used dask (and xarray) to combine a set of H5py files into a dataframe. 
This worked great until I updated dask from 2.28 to 2021.07.1.

If I run the same script now, I always run out of memory, just after loading the files and doing any operation on the 
dataframe. 

I first thought it was an xarray issue (reported here: https://github.com/pydata/xarray/issues/5585). 
So I switched to a pure dask solution (based on: https://docs.dask.org/en/latest/array-creation.html)

However, I keep running into the same problem. 

I tried 3 different methods:
1. converting a h5py to a numpy dict and load as pandas df with dask.delayed. Then construct a dask dataframe from the delayed
2. loading the individual files as dask arrays and convert them to dask dataframe per file, then combine the dataframes
3. load the files as dask arrays, combine them into a big dask array, then convert that to dataframe.
All with the same results: Kernel died, due to memory

I tried different chunk sizes. Smaller chunks just makes everything slower (incl overloading the RAM). Bigger chunks just make it faster but stilll overload the memory. In any case the kernel still crashes early in the process, due to memory overload. 
Also when trying to save the dataframe, nothing/just a few kbs are written. 
Therefore I suspect that there is a problem with the creation of the dataframe, not saving it.

First I suspected the transformation form array to dataframe to be the issue. 
But running calculation on the array itself or saving it also cause the same issue. 
That's why I think it has to do with the loading of an array from h5py.

If am doing something principally wrong here, please let me know. But this code worked great for me on earlier versions of dask.
Thank you!

Here is code to reproduce. I have 16GB  RAM, so to reproduce you might need to adjust the number of files loaded if you have more RAM: 

## Create Datafiles (note this takes a couple of GB disk space) ##
```
import numpy as np
import h5py

from shutil import copyfile


def makefile(data, n, nfiles):
    for i in range(nfiles):
        print(f""\rCreating File: {i} / {nfiles - 1}       "", end="""")
        if i == 0:
            with h5py.File(f""{i}.h5"", 'w') as file:
                for par in range(n):
                    file.create_dataset(f'data/{par}',
                                        data=data,
                                        dtype='f4',
                                        maxshape=(None,),
                                        chunks= (32000,), # (dlength,),
                                        compression='gzip',
                                        compression_opts=5,
                                        fletcher32=True,
                                        shuffle=True,
                                    )
        else:
            copyfile('0.h5', f""{i}.h5"")


data = np.random.randint(0, 0xFFFF, int(1e7))
makefile(data, 10, 100)    # ~100 files is enough to create an error on my 16GB RAM 24GB swap, increase if you have more RAM?
del data

```

##  Setup ##
```
import os
import h5py
import dask
import dask.dataframe as dd
import dask.array as da
import numpy as np
import pandas as pd


from dask.diagnostics import ProgressBar
ProgressBar().register()

file_list = sorted([f for f in os.listdir(""."") if f.endswith('.h5')])
```
## Method 1 (Pandas) ##

```
@dask.delayed
def hdfs_2_pd(f):
    file = h5py.File(f, 'r')[""data/""]
    return pd.DataFrame.from_dict({k:v[:] for k, v in file.items()})
    
ddf = dd.from_delayed([hdfs_2_pd(f) for f in file_list])

```

## Method 2 (ddf per file) ##
```
out = []
for fn in file_list:
    f = h5py.File(fn, ""r"") # HDF5 file
    d = f['/data/']
    x = da.stack([da.from_array(i, chunks=(100000,)) for i in d.values()], axis=1)
    keys = d.keys()
    out.append(dd.from_dask_array(x, columns=keys))
ddf = dd.concat(out)
```

## Method 3: combine arrays ##
```
out = []

for fn in file_list:
    f = h5py.File(fn, ""r"") # HDF5 file
    d = f['/data/']
    x = da.stack([da.from_array(i, chunks=(100000,)) for i in d.values()], axis=1)
    keys = d.keys()
    out.append(x)

combined = da.concatenate(out)
ddf = dd.from_dask_array(combined, columns=keys)
```
## Testing ddf ##
All these methods produce a dask dataframe. However in the next steps Memory will fully load 
and the kernel will crash:

```
ddf['0'].mean().compute()
```
output:
`[                                        ] | 0% Completed |  6min 57.9s`

```
ddf.to_hdf(""combined.h5"", 
           key='/data*',
           complevel=5, 
           complib=""blosc:lz4hc"", 
          )
```
output: 
`[#                                       ] | 3% Completed | 13min  8.7s`

```
ddf.to_parquet(""conbined.pq"", 
               compression=""gzip"", 
               append=False,
               overwrite=True,
)
```
output:
`[##                                      ] | 5% Completed |  4min 11.9s`


```
da.to_hdf5('./combined_arr.h5', 
           {f""/test"": combined}, 
           compression='gzip', 
           shuffle=True, 
           compression_opts=5)
```
output:
`[#                                       ] | 3% Completed |  5min 57.9s`




**Environment**:

- Dask version: '2021.07.0'
- h5py version: '2.10.0'
- Python version: Python 3.8.2 (Ananconda)
- Operating System: Ubuntu 21.04
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/7930/timeline,,,N4321D,35295509,MDQ6VXNlcjM1Mjk1NTA5,https://avatars.githubusercontent.com/u/35295509?v=4,,https://api.github.com/users/N4321D,https://github.com/N4321D,https://api.github.com/users/N4321D/followers,https://api.github.com/users/N4321D/following{/other_user},https://api.github.com/users/N4321D/gists{/gist_id},https://api.github.com/users/N4321D/starred{/owner}{/repo},https://api.github.com/users/N4321D/subscriptions,https://api.github.com/users/N4321D/orgs,https://api.github.com/users/N4321D/repos,https://api.github.com/users/N4321D/events{/privacy},https://api.github.com/users/N4321D/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7930/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
474,https://api.github.com/repos/dask/dask/issues/7933,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7933/labels{/name},https://api.github.com/repos/dask/dask/issues/7933/comments,https://api.github.com/repos/dask/dask/issues/7933/events,https://github.com/dask/dask/issues/7933,952324449,MDU6SXNzdWU5NTIzMjQ0NDk=,7933,High Level Expressions,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,65,2021-07-25T17:56:18Z,2022-09-22T19:21:46Z,,MEMBER,,"### Summary

We should make space for high level query optimization.  There are a couple of ways to do this.  This issue includes motivation, a description of two approaches, and some thoughts on trade-offs.

### Motivation

There are a variety of situations where we might want to rewrite a user's code.

#### Dataframes

1. Column projection, as in `dd.read_parquet(...)[""x""]` -> `dd.read_parquet(..., columns=[""x""])`
2. Predicate pushdown (same as above)
3. High level expression fusion (what we do today with blockwise)
4. Pushing length calls down through elementwise calls
5. Pushing filters earlier in a computation
6. ...

#### Arrays

1.  Automatic rechunking at the beginning of a computation based on the end of the computation
2. Slicing

### History

Today there is no real place where we capture a user's intent or their lines of code.  We immediately create a task graph for the requested operation, dump it into a mapping, and create a new dask.dataframe.DataFrame or dask.array.Array instance.  That instance has no knowledge of what created it, or what created the other input dataframes on which it depends.

This was a good choice early on.  It made it easy for us to quickly implement lots of complex operations without thinking about a class hierarchy for them.  This choice followed on from the choices of Blaze, where we started with high level expressions, but got a bit stuck because they constrained our thinking (and no one really cares about high level query optimization for a system that they don't use.

However today we have maybe reached a point where our ""keep everything low-level and simple"" strategy has hit a limit, and now we're curious about how best to bolt on a high level expression system.  Doing this smoothly given the current system is hard.  I see two ways out.

### High Level Graph layers

We *do* have a record of what operations came before us in the high level graph layers.  Currently the API of layers is very generic.  They must be a mapping that adheres to the Dask graph spec, and they must be serializable in a certain way.  There are some consistent subclasses, like blockwise, which enable high level optimizations which have proven useful.  

There isn't really much structure here though, and as a result it's hard to do interesting optimizations.  For example it would be nice if we could change a layer at the very bottom of the graph, and then replay all of the operations on that input over again to see how they would change.  High level layers today don't have enough shared structure that we know how to do this.

I like High Level Graph Layers because it gives us a space to hijack and add in all sorts of complex machinery, but without affecting the user-facing Dataframe class.  We would have to add a lot more structure here though, and we'll always be working around the collection class, which is a drawback.

### Collection subclasses

I'm going to focus on an alternative that is a bit more radical.  We could also have every user call generate a DataFrame subclass.  There would still be a DataFrame instance that took in a generic graph/divisions/meta, but that would be mostly for backwards compatibility.  Instead most dataframe operations would produce subclasses that had a well-defined common structure, as well as more custom attributes for their specific operation.  Let's look at a couple of examples.

```python
# API calls just create instances.  All logic happens there.
def read_parquet(file, columns, filters):
    return ReadParquet(file, columns, filters)

class ReadParquet(DataFrame):
    args = [""file"", ""column"", ""filters""]  # List of arguments to use when reconstructing
    inputs = []  # List of arguments that are DataFrame objects

    def __init__(self, file, columns, filters):
        self.file  = file
        self.columns = columns
        self.filters = filters

        self.divisions, self.meta = # do a bit of work on metadata
        
    def _generate_dask_layer(self) -> dict:
        ...

class ColumnProjection(DataFrame):
    args = [""dataframe"", ""columns""]
    inputs = [""dataframe""]

    def __init__(self, dataframe, columns):
        self.dataframe = dataframe
        self.columns = columns
        self._meta = self.dataframe._meta[columns]

    def _generate_dask_layer(self) -> dict:
        ...

class Add(DataFrame):
    args = [""left"", ""right""]

    def __init__(self, left, right):
        self.left = left
        self.right = right
        self.inputs = []
        if is_dask_collection(left):
            self.inputs.append(""left"")
        if is_dask_collection(right):
            self.inputs.append(""right"")

        self._meta = ...
        self._divisions = ...

    def _generate_dask_layer(self) -> dict:
        ...


```

As folks familiar with SymPy will recall, having attributes like args/inputs around makes it possible to re-generate a DataFrame automatically.  So if we do something like the following:

```python
df = dd.read_parquet(...)
z = df.x + df.y
```

Then this turns into an expression tree like the following:

```python
Add(
    ColumnProjection(
        ReadParquet(..., columns=None),
        ""x"",
    ),
    ColumnProjection(
        ReadParquet(..., columns=None),
        ""y"",
    ),
)
```

We can then traverse this tree (which is easy because we have a list of all attributes that are dask collections in the `inputs` attribute) and apply optimizaitons (which is easy because we can easily reconstruct layers because we have the `args` attribute).  

For example the `ColumnProjection` class may have an optimization method like the following:

```python
class ColumnProjection(DataFrame):
    ... # continued from above

    def _optimize(self) -> DataFrame:
        if isinstance(self.dataframe, ReadParquet):
            args = {arg: getattr(self.dataframe, arg) for arg in self.dataframe.args}
            args[""columns""] = self.columns
            return ReadParquet(**args)._optimize()

        # here is another optimization, just to show variety
        if isinstance(self.datafarme, ColumnProjection):  # like df[[""x"", ""y""][""x""]
            return ColumnProjection(self.dataframe.dataframe, self.columns)._optimize()

        # no known optimizations, optimize all inputs and then reconstruct (this would live in a superclass)
        args = []
        for arg in self.args:
            if arg in self.inputs:
                arg = getattr(self, arg)._optimize()
            else:
                arg = getattr(self, arg)
            args.append(arg)
        
        return type(self)(*args)
```

This is just one way of doing a traversal, using a method on a class.  We can do fancier things.  Mostly what I wanted to show here was that because we have args/inputs and class types it's fairly easy to encode optimizations and rewrite things.

What's notable here is that we aren't generating the graph, or even any semblance of the graph ahead of time.  At any point where we run code that requires something like `_meta` or `_divisions` from an input we stop all opportunities to change the graph under that stage.  This is OK for our internal code.  We can defer graph generation I think.  

I think that the main advantage to this approach is that we can easily reconstruct expressions given newly modified inputs.  I think that this is fundamentally what is lacking with our current HLG layer approach.  

However, this would also be a significant deviation from how Dask works today.  It's likely that this would affect all downstream projects that subclass Dask arrays/dataframes today (RAPIDS, Pint, yt, ...).  I think that that's probably ok.  Those groups will, I think, understand.

### Personal Thoughts

I've historically been against doing collection subclasses (the second approach), but after thinking about this for a while I think I'm now more in favor.  It seems like maybe we've arrived at the time when the benefits to doing this outweigh the complexity costs.  I think that this is motivated also by the amount of complexity that we're encountering walking down the HLG path.  

However, I do think that this will be hard for us to implement in an incremental way.  *If* we want to go down this path we probably need to think about an approach that lets the current `DataFrame` API persist for backwards compatibility with downstream projects (they wouldn't get any benefits of this system though) and a way where we can move over collection subclasses incrementally.

cc @rjzamora @jcrist ",,https://api.github.com/repos/dask/dask/issues/7933/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7933/reactions,10,7,0,0,0,0,3,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
475,https://api.github.com/repos/dask/dask/issues/7941,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7941/labels{/name},https://api.github.com/repos/dask/dask/issues/7941/comments,https://api.github.com/repos/dask/dask/issues/7941/events,https://github.com/dask/dask/issues/7941,953304110,MDU6SXNzdWU5NTMzMDQxMTA=,7941,DOC: mention tqdm-dask integration in the docs?,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,2,2021-07-26T21:29:12Z,2021-08-06T15:01:57Z,,MEMBER,,"https://github.com/tqdm/tqdm#dask-integration

Could be in https://docs.dask.org/en/latest/diagnostics-local.html (https://github.com/dask/dask/blob/main/docs/source/diagnostics-local.rst)",,https://api.github.com/repos/dask/dask/issues/7941/timeline,,,raybellwaves,17162724,MDQ6VXNlcjE3MTYyNzI0,https://avatars.githubusercontent.com/u/17162724?v=4,,https://api.github.com/users/raybellwaves,https://github.com/raybellwaves,https://api.github.com/users/raybellwaves/followers,https://api.github.com/users/raybellwaves/following{/other_user},https://api.github.com/users/raybellwaves/gists{/gist_id},https://api.github.com/users/raybellwaves/starred{/owner}{/repo},https://api.github.com/users/raybellwaves/subscriptions,https://api.github.com/users/raybellwaves/orgs,https://api.github.com/users/raybellwaves/repos,https://api.github.com/users/raybellwaves/events{/privacy},https://api.github.com/users/raybellwaves/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7941/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
476,https://api.github.com/repos/dask/dask/issues/7948,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7948/labels{/name},https://api.github.com/repos/dask/dask/issues/7948/comments,https://api.github.com/repos/dask/dask/issues/7948/events,https://github.com/dask/dask/pull/7948,954316593,MDExOlB1bGxSZXF1ZXN0Njk4MjMxMjMz,7948,Experiment with high level dataframe expressions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,0,2021-07-27T22:37:31Z,2021-07-30T02:10:24Z,,MEMBER,,This should not be merged.  This is here as a demonstration and proof of concept around https://github.com/dask/dask/issues/7933,,https://api.github.com/repos/dask/dask/issues/7948/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7948/reactions,1,0,0,0,0,0,1,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/7948,https://github.com/dask/dask/pull/7948,https://github.com/dask/dask/pull/7948.diff,https://github.com/dask/dask/pull/7948.patch,,,,,,,,,,,,,,,,,,,
477,https://api.github.com/repos/dask/dask/issues/7950,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7950/labels{/name},https://api.github.com/repos/dask/dask/issues/7950/comments,https://api.github.com/repos/dask/dask/issues/7950/events,https://github.com/dask/dask/pull/7950,954513013,MDExOlB1bGxSZXF1ZXN0Njk4Mzk1NDg2,7950,Improve tensordot performance with auto-rechunking,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,17,2021-07-28T06:12:35Z,2021-12-02T03:51:08Z,,MEMBER,,"Automatic rechunking for tensordot computations.

- [x] Closes https://github.com/dask/dask/issues/2225
- [ ] Tests added / passed
- [x] Passes `black dask` / `flake8 dask` / `isort dask`
",,https://api.github.com/repos/dask/dask/issues/7950/timeline,,,GenevieveBuckley,30920819,MDQ6VXNlcjMwOTIwODE5,https://avatars.githubusercontent.com/u/30920819?v=4,,https://api.github.com/users/GenevieveBuckley,https://github.com/GenevieveBuckley,https://api.github.com/users/GenevieveBuckley/followers,https://api.github.com/users/GenevieveBuckley/following{/other_user},https://api.github.com/users/GenevieveBuckley/gists{/gist_id},https://api.github.com/users/GenevieveBuckley/starred{/owner}{/repo},https://api.github.com/users/GenevieveBuckley/subscriptions,https://api.github.com/users/GenevieveBuckley/orgs,https://api.github.com/users/GenevieveBuckley/repos,https://api.github.com/users/GenevieveBuckley/events{/privacy},https://api.github.com/users/GenevieveBuckley/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7950/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7950,https://github.com/dask/dask/pull/7950,https://github.com/dask/dask/pull/7950.diff,https://github.com/dask/dask/pull/7950.patch,,,,,,,,,,,,,,,,,,,
478,https://api.github.com/repos/dask/dask/issues/7951,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7951/labels{/name},https://api.github.com/repos/dask/dask/issues/7951/comments,https://api.github.com/repos/dask/dask/issues/7951/events,https://github.com/dask/dask/issues/7951,954880184,MDU6SXNzdWU5NTQ4ODAxODQ=,7951,Slicing Dask arrays with NumPy scalars,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2021-07-28T13:53:30Z,2021-07-29T19:28:55Z,,MEMBER,,"Dask arrays can be sliced with Python integers, Python lists, NumPy arrays, etc. However, slicing with a NumPy scalar results in an `AssertionError` being raised (full traceback is further down below):

```python
In [1]: import dask.array as da

In [2]: import numpy as np

In [3]: x = da.arange(10)

In [4]: x[0]   # Slicing with Python integer works 
Out[4]: dask.array<getitem, shape=(), dtype=int64, chunksize=(), chunktype=numpy.ndarray>

In [5]: x[[0, 1]]   # Slicing with Python list works 
Out[5]: dask.array<getitem, shape=(2,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray>

In [6]: x[np.array([0, 1])]   # Slicing with NumPy arrays
Out[6]: dask.array<getitem, shape=(2,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray>

In [7]: x[np.array(0)]   # Slicing with NumPy scalars raises an error
# AssertionError is raised here
```



<details>
<summary>Details:</summary>

```python
In [1]: import dask.array as da

In [2]: import numpy as np

In [3]: x = da.arange(10)

In [4]: x[0]
Out[4]: dask.array<getitem, shape=(), dtype=int64, chunksize=(), chunktype=numpy.ndarray>

In [5]: x[[0, 1]]
Out[5]: dask.array<getitem, shape=(2,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray>

In [6]: x[np.array([0, 1])]
Out[6]: dask.array<getitem, shape=(2,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray>

In [7]: x[np.array(0)]
---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
<ipython-input-7-e3c33b6b5f59> in <module>
----> 1 x[np.array(0)]

~/projects/dask/dask/dask/array/core.py in __getitem__(self, index)
   1766
   1767         out = ""getitem-"" + tokenize(self, index2)
-> 1768         dsk, chunks = slice_array(out, self.name, self.chunks, index2, self.itemsize)
   1769
   1770         graph = HighLevelGraph.from_collections(out, dsk, dependencies=[self])

~/projects/dask/dask/dask/array/slicing.py in slice_array(out_name, in_name, blockdims, index, itemsize)
    169
    170     # Pass down to next function
--> 171     dsk_out, bd_out = slice_with_newaxes(out_name, in_name, blockdims, index, itemsize)
    172
    173     bd_out = tuple(map(tuple, bd_out))

~/projects/dask/dask/dask/array/slicing.py in slice_with_newaxes(out_name, in_name, blockdims, index, itemsize)
    191
    192     # Pass down and do work
--> 193     dsk, blockdims2 = slice_wrap_lists(out_name, in_name, blockdims, index2, itemsize)
    194
    195     if where_none:

~/projects/dask/dask/dask/array/slicing.py in slice_wrap_lists(out_name, in_name, blockdims, index, itemsize)
    247     # No lists, hooray! just use slice_slices_and_integers
    248     if not where_list:
--> 249         return slice_slices_and_integers(out_name, in_name, blockdims, index)
    250
    251     # Replace all lists with full slices  [3, 1, 0] -> slice(None, None, None)

~/projects/dask/dask/dask/array/slicing.py in slice_slices_and_integers(out_name, in_name, blockdims, index)
    300             )
    301
--> 302     assert all(isinstance(ind, (slice, Integral)) for ind in index)
    303     assert len(index) == len(blockdims)
    304

AssertionError:
```

</details>",,https://api.github.com/repos/dask/dask/issues/7951/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7951/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
479,https://api.github.com/repos/dask/dask/issues/7957,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7957/labels{/name},https://api.github.com/repos/dask/dask/issues/7957/comments,https://api.github.com/repos/dask/dask/issues/7957/events,https://github.com/dask/dask/issues/7957,956185817,MDU6SXNzdWU5NTYxODU4MTc=,7957,series1.eq(series2) gives different results than pandas with certain dtypes,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2021-07-29T20:33:14Z,2021-09-13T16:04:24Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
When runing series1.eq(series2) with two series, one with a `category` dtype and one with a `string` dtype, the results returned from Dask are different than the results from pandas.

**What you expected to happen**:
I expect that these results should match.

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import pandas as pd
import numpy as np
ser1 = pd.Series(['a', 'a', np.nan, 'a', 'b', 'b', 'b', 'b']).astype('category')
ser2 = pd.Series(['c', 'c', 'c', 'c', pd.NA, pd.NA, pd.NA, pd.NA]).astype('string')
ser1.eq(ser2)
```
```
0    False
1    False
2     <NA>
3    False
4     <NA>
5     <NA>
6     <NA>
7     <NA>
dtype: boolean
```

```python
dask1 = dd.from_pandas(ser1, npartitions=2)
dask2 = dd.from_pandas(ser2, npartitions=2)
dask1.eq(dask2).compute()
```

```
0    False
1    False
2    False
3    False
4     <NA>
5     <NA>
6     <NA>
7     <NA>
dtype: object
```

**Anything else we need to know?**:
Running this example with `npartitions=1` produces the same output as pandas.

**Environment**:

- Dask version: 2021.7.1
- Python version: 3.7.4
- Operating System: macOS Mojave
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/7957/timeline,,,thehomebrewnerd,4307001,MDQ6VXNlcjQzMDcwMDE=,https://avatars.githubusercontent.com/u/4307001?v=4,,https://api.github.com/users/thehomebrewnerd,https://github.com/thehomebrewnerd,https://api.github.com/users/thehomebrewnerd/followers,https://api.github.com/users/thehomebrewnerd/following{/other_user},https://api.github.com/users/thehomebrewnerd/gists{/gist_id},https://api.github.com/users/thehomebrewnerd/starred{/owner}{/repo},https://api.github.com/users/thehomebrewnerd/subscriptions,https://api.github.com/users/thehomebrewnerd/orgs,https://api.github.com/users/thehomebrewnerd/repos,https://api.github.com/users/thehomebrewnerd/events{/privacy},https://api.github.com/users/thehomebrewnerd/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7957/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
480,https://api.github.com/repos/dask/dask/issues/7971,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7971/labels{/name},https://api.github.com/repos/dask/dask/issues/7971/comments,https://api.github.com/repos/dask/dask/issues/7971/events,https://github.com/dask/dask/pull/7971,957252806,MDExOlB1bGxSZXF1ZXN0NzAwNzE1OTY1,7971,Fix slicing Dask arrays with NumPy array of ndim=0,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2021-07-31T14:12:18Z,2021-08-01T07:37:22Z,,FIRST_TIME_CONTRIBUTOR,,"- [x] Closes #7951 
- [x] Tests added / passed
- [x] Passes `black dask` / `flake8 dask` / `isort dask`

In addition to error described in #7951, this PR also fixes the following case which is caused by [this](https://github.com/dask/dask/blob/d3bf07cec0b77c37b3ec1c8c30a3ae0cf00a993a/dask/array/slicing.py#L253) line.
```python
In [1]: import dask.array as da

In [2]: import numpy as np

In [3]: x_np = np.arange(9).reshape((3, 3))

In [4]: x = da.from_array(x_np)

In [5]: x[[0], np.array(0)].compute()   # Slicing Dask array 
Out[5]: array([[0, 1, 2]])  # returns the first row in an array

In [6]: x_np[[0], np.array(0)]   # Slicing NumPy array
Out[6]: array([0])  # returns the element at (0, 0) in an array
```",,https://api.github.com/repos/dask/dask/issues/7971/timeline,,,afofa,34076831,MDQ6VXNlcjM0MDc2ODMx,https://avatars.githubusercontent.com/u/34076831?v=4,,https://api.github.com/users/afofa,https://github.com/afofa,https://api.github.com/users/afofa/followers,https://api.github.com/users/afofa/following{/other_user},https://api.github.com/users/afofa/gists{/gist_id},https://api.github.com/users/afofa/starred{/owner}{/repo},https://api.github.com/users/afofa/subscriptions,https://api.github.com/users/afofa/orgs,https://api.github.com/users/afofa/repos,https://api.github.com/users/afofa/events{/privacy},https://api.github.com/users/afofa/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7971/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/7971,https://github.com/dask/dask/pull/7971,https://github.com/dask/dask/pull/7971.diff,https://github.com/dask/dask/pull/7971.patch,,,,,,,,,,,,,,,,,,,
481,https://api.github.com/repos/dask/dask/issues/7977,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7977/labels{/name},https://api.github.com/repos/dask/dask/issues/7977/comments,https://api.github.com/repos/dask/dask/issues/7977/events,https://github.com/dask/dask/issues/7977,958451012,MDU6SXNzdWU5NTg0NTEwMTI=,7977,Pyarrow metadata `RuntimeError` in `to_parquet`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,"[{'login': 'ian-r-rose', 'id': 5728311, 'node_id': 'MDQ6VXNlcjU3MjgzMTE=', 'avatar_url': 'https://avatars.githubusercontent.com/u/5728311?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/ian-r-rose', 'html_url': 'https://github.com/ian-r-rose', 'followers_url': 'https://api.github.com/users/ian-r-rose/followers', 'following_url': 'https://api.github.com/users/ian-r-rose/following{/other_user}', 'gists_url': 'https://api.github.com/users/ian-r-rose/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/ian-r-rose/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/ian-r-rose/subscriptions', 'organizations_url': 'https://api.github.com/users/ian-r-rose/orgs', 'repos_url': 'https://api.github.com/users/ian-r-rose/repos', 'events_url': 'https://api.github.com/users/ian-r-rose/events{/privacy}', 'received_events_url': 'https://api.github.com/users/ian-r-rose/received_events', 'type': 'User', 'site_admin': False}]",,26,2021-08-02T19:40:51Z,2024-02-03T16:46:39Z,,MEMBER,,"Offline a user reported getting `RuntimeError: file metadata is only available after writer close` when writing a Dask DataFrame to parquet with our pyarrow engine. The traceback they were presented with was:

```python
Traceback (most recent call last):
  File ""example.py"", line 349, in <module>
    main(date_dict, example_conf)
  File ""example.py"", line 338, in main
    make_example_datasets(
  File ""example.py"", line 311, in make_example_datasets
    default_to_parquet(sub_ddf, v[""path""], engine=""pyarrow"", overwrite=True)
  File ""example.py"", line 232, in default_to_parquet
    ddf.to_parquet(path=path, engine=engine, overwrite=overwrite, write_metadata_file=False)
  File ""/opt/conda/lib/python3.8/site-packages/dask/dataframe/core.py"", line 4453, in to_parquet
    return to_parquet(self, path, *args, **kwargs)
  File ""/opt/conda/lib/python3.8/site-packages/dask/dataframe/io/parquet/core.py"", line 721, in to_parquet
    out = out.compute(**compute_kwargs)
  File ""/opt/conda/lib/python3.8/site-packages/dask/base.py"", line 286, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/opt/conda/lib/python3.8/site-packages/dask/base.py"", line 568, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/opt/conda/lib/python3.8/site-packages/distributed/client.py"", line 2743, in get
    results = self.gather(packed, asynchronous=asynchronous, direct=direct)
  File ""/opt/conda/lib/python3.8/site-packages/distributed/client.py"", line 2020, in gather
    return self.sync(
  File ""/opt/conda/lib/python3.8/site-packages/distributed/client.py"", line 861, in sync
    return sync(
  File ""/opt/conda/lib/python3.8/site-packages/distributed/utils.py"", line 326, in sync
    raise exc.with_traceback(tb)
  File ""/opt/conda/lib/python3.8/site-packages/distributed/utils.py"", line 309, in f
    result[0] = yield future
  File ""/opt/conda/lib/python3.8/site-packages/tornado/gen.py"", line 762, in run
    value = future.result()
  File ""/opt/conda/lib/python3.8/site-packages/distributed/client.py"", line 1885, in _gather
    raise exception.with_traceback(traceback)
  File ""/opt/conda/lib/python3.8/site-packages/dask/dataframe/io/parquet/arrow.py"", line 947, in write_partition
    pq.write_table(
  File ""/opt/conda/lib/python3.8/site-packages/pyarrow/parquet.py"", line 1817, in write_table
    writer.write_table(table, row_group_size=row_group_size)
  File ""/opt/conda/lib/python3.8/site-packages/pyarrow/parquet.py"", line 662, in __exit__
    self.close()
  File ""/opt/conda/lib/python3.8/site-packages/pyarrow/parquet.py"", line 684, in close
    self._metadata_collector.append(self.writer.metadata)
  File ""pyarrow/_parquet.pyx"", line 1434, in pyarrow._parquet.ParquetWriter.metadata.__get__
RuntimeError: file metadata is only available after writer close
```

cc @rjzamora in case you've seen this before or have an idea of what might be causing this ",,https://api.github.com/repos/dask/dask/issues/7977/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7977/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,ian-r-rose,5728311.0,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False
482,https://api.github.com/repos/dask/dask/issues/7996,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7996/labels{/name},https://api.github.com/repos/dask/dask/issues/7996/comments,https://api.github.com/repos/dask/dask/issues/7996/events,https://github.com/dask/dask/issues/7996,961714430,MDU6SXNzdWU5NjE3MTQ0MzA=,7996,Flaky `test_setitem_extended_API_2d[index13-value13]`,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,2,2021-08-05T11:12:32Z,2022-03-07T08:26:06Z,,MEMBER,,"`test_setitem_extended_API_2d[index13-value13]` is flaky. It only runs in gpuCI, so regular Linux/MacOS/Windows builds will not report it. I couldn't reproduce it locally so far, even after hundreds of runs. For now it has been marked flaky in https://github.com/dask/dask/pull/7994 .",,https://api.github.com/repos/dask/dask/issues/7996/timeline,,,pentschev,4398246,MDQ6VXNlcjQzOTgyNDY=,https://avatars.githubusercontent.com/u/4398246?v=4,,https://api.github.com/users/pentschev,https://github.com/pentschev,https://api.github.com/users/pentschev/followers,https://api.github.com/users/pentschev/following{/other_user},https://api.github.com/users/pentschev/gists{/gist_id},https://api.github.com/users/pentschev/starred{/owner}{/repo},https://api.github.com/users/pentschev/subscriptions,https://api.github.com/users/pentschev/orgs,https://api.github.com/users/pentschev/repos,https://api.github.com/users/pentschev/events{/privacy},https://api.github.com/users/pentschev/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7996/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
483,https://api.github.com/repos/dask/dask/issues/7999,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/7999/labels{/name},https://api.github.com/repos/dask/dask/issues/7999/comments,https://api.github.com/repos/dask/dask/issues/7999/events,https://github.com/dask/dask/issues/7999,962042007,MDU6SXNzdWU5NjIwNDIwMDc=,7999,Possible bug when using dask.array.bincount and dask.array.apply_along_axis,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2021-08-05T17:24:13Z,2023-09-13T13:48:54Z,,NONE,,"After hours of scratching my head, I believe that I have found a bug when using bincount and apply_along_axis. The error returned is a bit weird, since it tells me that my dask arrays does not have the chunks attribute, when they clearly have it.
I will attach both the numpy behaviour and the dask behaviour with the same data.

Numpy:
```python
import numpy as np
import dask.array as da

def bincount(weight, x):
    return np.bincount(x, weight)

idx_np = np.random.randint(0, 1024, 1000)
weight_np = np.random.random((1000,2))
result = np.apply_along_axis(bincount, 0, weight_np, idx_np)
array([[0.55832968, 0.82649572],
       [0.69563411, 0.51647341],
       [0.        , 0.        ],
       ...,
       [0.        , 0.        ],
       [0.67865151, 1.09591976],
       [2.09644783, 2.00890233]])
```

Dask:
```python
import numpy as np
import dask.array as da

def bincount_dask(weight, x):
    return da.bincount(x, weight).compute_chunk_sizes()

idx = da.random.randint(0, 1024, 1000)
weight = da.random.random((1000, 2))

da.apply_along_axis(bincount_dask, 1, weight, idx) # I don't know why the axis are different on numpy and dask (?)

---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-272-953d6609330b> in <module>
----> 1 da.apply_along_axis(bincount_dask, 1, weight, idx)

~/.local/lib/python3.9/site-packages/dask/array/routines.py in apply_along_axis(func1d, axis, arr, dtype, shape, *args, **kwargs)
    454     if shape is None or dtype is None:
    455         test_data = np.ones((1,), dtype=arr.dtype)
--> 456         test_result = np.array(func1d(test_data, *args, **kwargs))
    457         if shape is None:
    458             shape = test_result.shape

<ipython-input-271-38b0783af9ef> in bincount_dask(weight, x)
      1 def bincount_dask(weight, x):
----> 2     return da.bincount(x, weight).compute_chunk_sizes()

~/.local/lib/python3.9/site-packages/dask/array/routines.py in bincount(x, weights, minlength, split_every)
    670         raise ValueError(""Input array must be one dimensional. Try using x.ravel()"")
    671     if weights is not None:
--> 672         if weights.chunks != x.chunks:
    673             raise ValueError(""Chunks of input array x and weights must match."")
    674 

AttributeError: 'numpy.ndarray' object has no attribute 'chunks'


```


- Dask version: dask==2021.6.1
- Python version: 3.9
- Operating System: Manjaro Linux
- Install method (conda, pip, source): pip3
",,https://api.github.com/repos/dask/dask/issues/7999/timeline,,,miguelcarcamov,5432126,MDQ6VXNlcjU0MzIxMjY=,https://avatars.githubusercontent.com/u/5432126?v=4,,https://api.github.com/users/miguelcarcamov,https://github.com/miguelcarcamov,https://api.github.com/users/miguelcarcamov/followers,https://api.github.com/users/miguelcarcamov/following{/other_user},https://api.github.com/users/miguelcarcamov/gists{/gist_id},https://api.github.com/users/miguelcarcamov/starred{/owner}{/repo},https://api.github.com/users/miguelcarcamov/subscriptions,https://api.github.com/users/miguelcarcamov/orgs,https://api.github.com/users/miguelcarcamov/repos,https://api.github.com/users/miguelcarcamov/events{/privacy},https://api.github.com/users/miguelcarcamov/received_events,User,False,https://api.github.com/repos/dask/dask/issues/7999/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
484,https://api.github.com/repos/dask/dask/issues/8001,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8001/labels{/name},https://api.github.com/repos/dask/dask/issues/8001/comments,https://api.github.com/repos/dask/dask/issues/8001/events,https://github.com/dask/dask/issues/8001,962082339,MDU6SXNzdWU5NjIwODIzMzk=,8001,in code suggestion of when to use split_out in dask.dataframe.groupby,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,6,2021-08-05T18:18:31Z,2021-10-14T07:58:53Z,,MEMBER,,"After spending some time working out why my groupby operation was not working I came across https://examples.dask.org/dataframes/02-groupby.html#Many-groups. If It wasn't for the great docs around dask I would likely to have missed this.

The `split_out` arg really helped.

This made sense as I had ~500,000,000 groups.

I know it may not be easy but similar to other warning messages (I believe i've seen a suggestion of using `Client.Scatter` at some point but can't find where it comes from in the codebase) it would be nice to suggest in the code to the user once (if possible) it works out how many groups there are, or even optimize it so it happens under the hood (see https://github.com/dask/dask/issues/7933).

Example:

```
import dask.dataframe as dd
from dask.distributed import Client, LocalCluster, performance_report

cluster = LocalCluster(local_directory=""/tmp"")
client = Client(cluster)

df = dd.demo.make_timeseries(
    start=""2000-01-01"",
    end=""2000-01-04"",
    dtypes={""x"": float, ""y"": float, ""id"": int},
    freq=""10ms"",
    partition_freq=""24h"",
)

# key of [""x"", ""y""] gives ~ 25,920,000 groups

# Doesn't finish
with performance_report(filename=""ddf-too-many-groups.html""):
    df.groupby([""x"", ""y""]).sum().compute()

# Finishes
with performance_report(filename=""ddf-split-out.html""):
    df.groupby([""x"", ""y""]).sum(split_out=4).compute()
```

Performance reports:

- [ddf-too-many-groups.html.zip](https://github.com/dask/dask/files/6940859/ddf-too-many-groups.html.zip)
- [ddf-split-out.html.zip](https://github.com/dask/dask/files/6940857/ddf-split-out.html.zip)


Traceback of `df.groupby([""x"", ""y""]).sum().compute()`:

```
KilledWorker                              Traceback (most recent call last)
/var/folders/rf/26llfhwd68x7cftb1z3h000w0000gp/T/ipykernel_39651/3854007570.py in <module>
      1 with performance_report(filename=""""):
----> 2     df.groupby([""x"", ""y""]).sum().compute()

~/miniconda3/envs/main/lib/python3.9/site-packages/dask/base.py in compute(self, **kwargs)
    284         dask.base.compute
    285         """"""
--> 286         (result,) = compute(self, traverse=False, **kwargs)
    287         return result
    288 

~/miniconda3/envs/main/lib/python3.9/site-packages/dask/base.py in compute(*args, **kwargs)
    566         postcomputes.append(x.__dask_postcompute__())
    567 
--> 568     results = schedule(dsk, keys, **kwargs)
    569     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    570 

~/miniconda3/envs/main/lib/python3.9/site-packages/distributed/client.py in get(self, dsk, keys, workers, allow_other_workers, resources, sync, asynchronous, direct, retries, priority, fifo_timeout, actors, **kwargs)
   2746                     should_rejoin = False
   2747             try:
-> 2748                 results = self.gather(packed, asynchronous=asynchronous, direct=direct)
   2749             finally:
   2750                 for f in futures.values():

~/miniconda3/envs/main/lib/python3.9/site-packages/distributed/client.py in gather(self, futures, errors, direct, asynchronous)
   2023             else:
   2024                 local_worker = None
-> 2025             return self.sync(
   2026                 self._gather,
   2027                 futures,

~/miniconda3/envs/main/lib/python3.9/site-packages/distributed/client.py in sync(self, func, asynchronous, callback_timeout, *args, **kwargs)
    864             return future
    865         else:
--> 866             return sync(
    867                 self.loop, func, *args, callback_timeout=callback_timeout, **kwargs
    868             )

~/miniconda3/envs/main/lib/python3.9/site-packages/distributed/utils.py in sync(loop, func, callback_timeout, *args, **kwargs)
    324     if error[0]:
    325         typ, exc, tb = error[0]
--> 326         raise exc.with_traceback(tb)
    327     else:
    328         return result[0]

~/miniconda3/envs/main/lib/python3.9/site-packages/distributed/utils.py in f()
    307             if callback_timeout is not None:
    308                 future = asyncio.wait_for(future, callback_timeout)
--> 309             result[0] = yield future
    310         except Exception:
    311             error[0] = sys.exc_info()

~/miniconda3/envs/main/lib/python3.9/site-packages/tornado/gen.py in run(self)
    760 
    761                     try:
--> 762                         value = future.result()
    763                     except Exception:
    764                         exc_info = sys.exc_info()

~/miniconda3/envs/main/lib/python3.9/site-packages/distributed/client.py in _gather(self, futures, errors, direct, local_worker)
   1888                             exc = CancelledError(key)
   1889                         else:
-> 1890                             raise exception.with_traceback(traceback)
   1891                         raise exc
   1892                     if errors == ""skip"":

KilledWorker: (""('dataframe-groupby-sum-agg-f6215c9bc267c471d79fe7d859ac9f04', 0)"", <WorkerState 'tcp://127.0.0.1:60293', name: 0, memory: 0, processing: 1>)
```
",,https://api.github.com/repos/dask/dask/issues/8001/timeline,,,raybellwaves,17162724,MDQ6VXNlcjE3MTYyNzI0,https://avatars.githubusercontent.com/u/17162724?v=4,,https://api.github.com/users/raybellwaves,https://github.com/raybellwaves,https://api.github.com/users/raybellwaves/followers,https://api.github.com/users/raybellwaves/following{/other_user},https://api.github.com/users/raybellwaves/gists{/gist_id},https://api.github.com/users/raybellwaves/starred{/owner}{/repo},https://api.github.com/users/raybellwaves/subscriptions,https://api.github.com/users/raybellwaves/orgs,https://api.github.com/users/raybellwaves/repos,https://api.github.com/users/raybellwaves/events{/privacy},https://api.github.com/users/raybellwaves/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8001/reactions,1,0,0,0,0,0,1,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
485,https://api.github.com/repos/dask/dask/issues/8020,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8020/labels{/name},https://api.github.com/repos/dask/dask/issues/8020/comments,https://api.github.com/repos/dask/dask/issues/8020/events,https://github.com/dask/dask/pull/8020,967161278,MDExOlB1bGxSZXF1ZXN0NzA5MzUyMDQy,8020,Use uniform distribution in `timeseries` demo,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,3,2021-08-11T17:51:19Z,2021-08-12T13:21:58Z,,MEMBER,,"I was putting together a demo using our `timeseries` utility and noticed generating random integers can take a significant amount of time -- especially when generating a DataFrame with many columns. After digging in a bit deeper, this is because we're generating integers from a Poisson distribution

https://github.com/dask/dask/blob/da2458250d4fcd8f1a99458778de536a667224a2/dask/dataframe/io/demo.py#L16-L17

which can be an order of magnitude slower than from, for example, a uniform distribution:

```python
In [1]: import numpy as np

In [2]: rstate = np.random.RandomState(2)

In [3]: %timeit rstate.poisson(1_000, size=86_400)   # 86_400 is the default partition size for `timeseries`
5.39 ms  41.2 s per loop (mean  std. dev. of 7 runs, 100 loops each)

In [4]: %timeit rstate.randint(low=0, high=1e9, size=86_400)
395 s  1.98 s per loop (mean  std. dev. of 7 runs, 1000 loops each)

In [5]: 5.39e3 / 395
Out[5]: 13.645569620253164
```

This PR proposes we switch to using a uniform distribution for generating random integers. 

cc @rjzamora who has recently worked with our `timeseries` utility",,https://api.github.com/repos/dask/dask/issues/8020/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8020/reactions,2,0,0,0,0,0,2,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8020,https://github.com/dask/dask/pull/8020,https://github.com/dask/dask/pull/8020.diff,https://github.com/dask/dask/pull/8020.patch,,,,,,,,,,,,,,,,,,,
486,https://api.github.com/repos/dask/dask/issues/8045,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8045/labels{/name},https://api.github.com/repos/dask/dask/issues/8045/comments,https://api.github.com/repos/dask/dask/issues/8045/events,https://github.com/dask/dask/issues/8045,971635987,MDU6SXNzdWU5NzE2MzU5ODc=,8045,Calculate valid partition divisions to avoid parser EOF error when CSV rows contain unescaped newlines,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,5,2021-08-16T11:22:40Z,2021-10-25T01:48:31Z,,CONTRIBUTOR,,"This follows discussion in #4415 on the parser error encountered (EOF within string) when partitioning a file with unescaped newlines on a row. The partition naively splits on newlines (from what I understand?), which is only a valid assumption for files without unescaped within-row EOL characters.

https://github.com/dask/dask/blob/e6b9e8983b26389c74036aeec615ac0e5ef34c65/dask/dataframe/io/csv.py#L704-L707

**Would it be possible to assist dask in identifying where to partition a CSV somehow?**

From the above issue I surmise that this is not currently a feature (but if it is and nobody thought to suggest it there please let me know).

I can imagine a function that:
- opens the file,
- seeks to the would-be partition offset minus some chunk size (expected to cover one or more lines),
- reads in a chunk
- identifies the latest row ending position within that chunk
- passes that chunk to dask as the partition point
- [repeat until file is completely partitioned]

(I recently wrote a function that greps backwards within a buffer, [here](https://github.com/lmmx/wikitransp/blob/1e6a49983960b69736ee95073357b19bccd2b91e/src/wikitransp/scraper/buf_grep.py#L10), which seems in the same spirit)

This could be done to identify the partition positions and then pass these into dask, or dask could provide a helper method to generate these positions.

Alternatively, if dasks partition positions are accessible, these could be modified after calculation, but I presume manually doing so would be undesirable (primarily as if all the partition positions moved backwards then the final one would risk being greater than the max. permitted partition size)

I tried to load the [WIT](https://github.com/google-research-datasets/wit) dataset which has newlines within rows (i.e. unescaped free text, from Wikipedia image captions) and [cannot get the advantage of cuDF speedup over pandas due to the problem of distributing the computation](https://github.com/rapidsai/cudf/issues/9042) (in the way that dask achieves with partitions).

I think Id be able to speed this up if dask could successfully partition with such a routine, but I dont know where to put it (i.e. I dont see the select where to partition aspect of dask exposed in the API, I presume it is not)

Another alternative I can envision is to `try`/`except` reading one row at the start of each partition (skipping the first as this is not post-partition), and if it fails with the EOF error then move that partition to the previous newline and repeat

---

Minimal example:

- First get the sample file (here I also decompressed it)
  - `wget https://storage.googleapis.com/gresearch/wit/wit_v1.train.all-1percent_sample.tsv.gz`

```py
import dask.dataframe as dd
from pathlib import Path
import time

p = Path(""wit_v1.train.all-1percent_sample.tsv"")
print(f""Data file: {p.name}"")

t0 = time.time()
dtype_dict = {""mime_type"": ""category""}
fields = [*dtype_dict]
df = dd.read_csv(p, sep=""\t"", dtype=dtype_dict, usecols=fields)
filetypes = list(df.mime_type)
t1 = time.time()
print(f""dask took: {t1-t0}s"")
```

```STDERR
Data file: wit_v1.train.all-1percent_sample.tsv
Traceback (most recent call last):
  File ""dask_test.py"", line 12, in <module>
    filetypes = list(df.mime_type)
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/dataframe/core.py"", line 579, in __len__
    return self.reduction(
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/base.py"", line 286, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/base.py"", line 568, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/threaded.py"", line 79, in get
    results = get_async(
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/local.py"", line 514, in get_async
    raise_exception(exc, tb)
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/local.py"", line 325, in reraise
    raise exc
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/local.py"", line 223, in execute_task
    result = _execute_task(task, data)
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/core.py"", line 121, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/optimization.py"", line 969, in __call__
    return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/core.py"", line 151, in get
    result = _execute_task(task, cache)
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/core.py"", line 121, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/core.py"", line 121, in <genexpr>
    return func(*(_execute_task(a, cache) for a in args))
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/core.py"", line 121, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/dataframe/io/csv.py"", line 125, in __call__
    df = pandas_read_text(
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/dask/dataframe/io/csv.py"", line 178, in pandas_read_text
    df = reader(bio, **kwargs)
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/pandas/util/_decorators.py"", line 311, in wrapper
    return func(*args, **kwargs)
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/pandas/io/parsers/readers.py"", line 586, in read_csv
    return _read(filepath_or_buffer, kwds)
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/pandas/io/parsers/readers.py"", line 488, in _read
    return parser.read(nrows)
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/pandas/io/parsers/readers.py"", line 1047, in read
    index, columns, col_dict = self._engine.read(nrows)
  File ""/home/louis/miniconda3/envs/dask_test/lib/python3.8/site-packages/pandas/io/parsers/c_parser_wrapper.py"", line 223, in read
    chunks = self._reader.read_low_memory(nrows)
  File ""pandas/_libs/parsers.pyx"", line 801, in pandas._libs.parsers.TextReader.read_low_memory
  File ""pandas/_libs/parsers.pyx"", line 857, in pandas._libs.parsers.TextReader._read_rows
  File ""pandas/_libs/parsers.pyx"", line 843, in pandas._libs.parsers.TextReader._tokenize_rows
  File ""pandas/_libs/parsers.pyx"", line 1925, in pandas._libs.parsers.raise_parser_error
pandas.errors.ParserError: Error tokenizing data. C error: EOF inside string starting at row 34111
```

(The exact row number given varies)

- This refers to an error thrown when `reader` (i.e. `pd.read_csv`) reads the bytes buffer `bio` https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/io/csv.py#L173-L178
- via https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/io/csv.py#L125-L135

- In turn this `CsvFunctionWrapper` call comes from [`text_blocks_to_pandas`](https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/io/csv.py#L285-L398) getting called in [the return statement of `read_pandas`](https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/io/csv.py#L622-L633) (which gets put [in the `dask.dataframe` namespace ](https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/__init__.py#L22), from [`dd.io`](https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/io/__init__.py#L2), from [`dd.io.csv`](https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/io/csv.py#L745) where it's a wrapper on `make_reader` using `pd.read_csv` as its [`reader`](https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/io/csv.py#L711) arg)
  - i.e. it simplifies to just [`pd.read_csv`](https://github.com/pandas-dev/pandas/blob/0d46c238e7ec92363152270f444bc0cb251919b7/pandas/io/parsers/readers.py#L502), passing a bytes buffer corresponding to the block's bytes within the file rather than the input file

I can't see any way of inspecting the [divisions](https://docs.dask.org/en/latest/dataframe-design.html#partitions) that are computed here (as they're not coming from a pre-existing dataframe but created from the TSV, hence no index to display in the divisions)

```py
>>> df.divisions
(None, None, None, None, None, None, None, None, None, None, None, None)
>>> df.known_divisions
False
```

but since it's bytes buffers under the hood you could check the divisions by seeking to the end of these buffers and performing the routine described above.

The blocks in question are the [`values`](https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/io/csv.py#L624) passed as the `block_lists` arg to `text_blocks_to_pandas` after being constructed in `read_pandas`: https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/io/csv.py#L620

so `read_pandas` is where the change I am suggesting would go.

The `values` in turn were unpacked from `b_out`, which comes from `read_bytes` (from [`dask.bytes.core`](https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/bytes/core.py#L12)):

https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/io/csv.py#L547-L562

The offsets are derived from these block sizes without any line delimiter detection:

https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/bytes/core.py#L115-L116

and then very importantly **the blocks are split according to the delimiter** here (the delimiter was [passed as the byte-encoded line terminator](https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/dataframe/io/csv.py#L549)):

https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/bytes/core.py#L126-L138

After which they are ready to be [passed on](https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/bytes/core.py#L130-L137) to the `delayed_read` which then becomes `values` a.k.a. `block_list`.

It's that step of splitting the blocks according to the delimiter that I think could be modified to ensure rows are parsed correctly.

2 further aspects to this:

- Within the `delayed_read` function call is `OpenFile` (i.e. executed and then passed into `delayed_read`)
- `delayed_read` is itself an alias: https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/bytes/core.py#L123
  - [`delayed`](https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/delayed.py#L233) is the lazy computation proxy (not relevant to what's done here)
  - `read_blocks_from_file` means that the computation being delayed is to read the block passed with 4 arguments: `lazy_file`, `off`, `bs`, `delimiter` https://github.com/dask/dask/blob/5cb8961b6035c90654e3999a7d99e6f5305b7ffc/dask/bytes/core.py#L168-L172 
  - The `lazy_file` = an [`OpenFile`](https://github.com/intake/filesystem_spec/blob/master/fsspec/core.py#L30) object via `fsspec.core`
  - The `off` offset is the unmodified offset (a multiple of the block size from `list(range(0, size, block_size)`)
  - The `bs` is the `l`, an item in `lengths`, which will always be `block_size` except for the last block which may be shorter if the file size is not an exact multiple of the `block_size`
  - `read_block` is called when `l` in `lengths` is set [by virtue of `block_size` being set, as it is here] to anything other than `None`, and this function [comes from `fsspec.utils`](https://github.com/intake/filesystem_spec/blob/3cdfd6cf8386857815535a32f747cd2033b30da7/fsspec/utils.py#L203-L265). 
- The [signature and docstring](https://github.com/intake/filesystem_spec/blob/3cdfd6cf8386857815535a32f747cd2033b30da7/fsspec/utils.py#L203-L217) show that its default behaviour is `split_before=False`, hence it starts/stops reading **after** the delimiter [newline] at `offset` and `offset+length`. This is how the newlines are detected.

---

So long story short:
- Roughly speaking [assuming file is evenly split into blocks of equal size], `dd.read_csv` reduces to

```py
for o in range(0, size, dd.io.csv.AUTO_BLOCK_SIZE):
  fsspec.read_block(f=input_csv, offset=o, length=dd.io.csv.AUTO_BLOCKSIZE,, delimiter=""\n"", split_before=False)
```

- This respects line separators but not necessarily row-delimiting line separators
- Extending this procedure to respect row-delimiting line separators would make dask usable with a larger subset of the CSV files pandas can read

---

The problem remains somewhat tricky to specify (how to verify that the newline at a given offset into a CSV is/isnt the start of a valid row and partition at the next one)

---

I thought about this some more and the three approaches I can think of are:

1. Let the user provide a custom checking function to be used to verify the buffer bytes at a position are valid
  - In the example dataset I am using, this would be very simple: the first column must equal a lower case two letter language code followed by the separator, and so on. This would make it very simple to check that the bytes after the line separator at a given offset was indeed the start of a row. (Or rather, to rule out invalid rows)
2. Let the user provide a list of rows which may contain free text (including newlines, i.e. the ""separable columns"", those which may be separated across lines), so as to validate based on an attempted separation (reading as many bytes as necessary, including line separator/s, until fulfilling the expected number of columns). Alternatively, these may be discerned from the sample.
3. Simply have pandas 'stream' a row, and catch any parsing error as a failure

The 1st option would potentially involve reading fewer bytes (thus faster).

The 2nd option seems the simplest to achieve, to identify the correct ""delimiter offset"" for the given partition offset (that is, the number of newline delimiters away from the offset at which the next row-delimiting newline is found). If the first newline delimiter after the partition offset was a valid start of row then the 'delimiter offset' would be 0, if it was the one after then it'd be 1, and so on.

The 3rd option would be most 'foolproof' (and perhaps simplest).

I need to think about this some more (I suspect it may need a mix of the 3 approaches). Any suggestions/comments welcome",,https://api.github.com/repos/dask/dask/issues/8045/timeline,,,lmmx,2979452,MDQ6VXNlcjI5Nzk0NTI=,https://avatars.githubusercontent.com/u/2979452?v=4,,https://api.github.com/users/lmmx,https://github.com/lmmx,https://api.github.com/users/lmmx/followers,https://api.github.com/users/lmmx/following{/other_user},https://api.github.com/users/lmmx/gists{/gist_id},https://api.github.com/users/lmmx/starred{/owner}{/repo},https://api.github.com/users/lmmx/subscriptions,https://api.github.com/users/lmmx/orgs,https://api.github.com/users/lmmx/repos,https://api.github.com/users/lmmx/events{/privacy},https://api.github.com/users/lmmx/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8045/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
487,https://api.github.com/repos/dask/dask/issues/8058,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8058/labels{/name},https://api.github.com/repos/dask/dask/issues/8058/comments,https://api.github.com/repos/dask/dask/issues/8058/events,https://github.com/dask/dask/issues/8058,973129186,MDU6SXNzdWU5NzMxMjkxODY=,8058,[Discussion] Improve Parquet-Metadata Processing in read_parquet,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,8,2021-08-17T23:09:04Z,2021-10-12T07:18:17Z,,MEMBER,,"
## Current Metadata-Related Challenges in `read_parquet`

The current approach to parquet-metadata handling in Dask-Dataframe has been causing pain for many users recently. The problem is especially true for large-scale IO from cloud-based file systems.  The origin of this pain seems to be the historical decision to rely on a shared _metadata file.

### Why we use _metadata

The historical reason for our adoption of the _metadata file is simple: The usual convention in Dask is to only use the client process to construct a graph when a public collection-related API is used. There are certainly exceptions to this (e.g. `set_index`), but it is typically true that non-compute/persist API calls will only execute on the client.  Therefore, in order to avoid the slow process of opening and processing footer metadata for every file in a parquet dataset on the client, we have encouraged the construction of a single/global _metadata file at write time.  This is why Dask's `to_parquet` implementation will construct and write this file by default (see the `write_metadata_file` argument).

### Why _metadata can be a problem

Although most parquet users will likely benefit from writing/reading a shared _metadata file, there are clearly cases where this approach breaks down. As illustrated in issues like #8031 and #8027, there are large-scale IO scenarios in which a single metadata file can be too large to write and/or read on a single process.  Given that the entire purpose of Dask-Dataframe is to enable/accelerate large-scale tabular-data processing, I feel that we should treat these cases seriously.

As I will present below, my short-term suggestion to the _metadata problem is two-fold:

1. Make it possible to ignore the existence of a shared _metadata file when it is present (Note that this step is already implemented in #8034)
2. Refactor the `Engine.read_metadata` implementation internals (especially for ""pyarrow-datsaet"" and ""fastparquet"") to allow `parts`/`statistics` to be collected in parallel, and to avoid the unnecessary/intermediate step of constructing a proxy global-metadata object when the _metadata file is missing and/or needs to be ignored.


## The Current Organization of `read_parquet`


### Core-Engine Interface

To understand the proposed short-term _metadata solution, it is useful to have a rough understanding of ""core""-""engine"" interface that is currently used within Dask-Dataframe's `read_parquet` API.  When the user calls `read_parquet`, they are either explicitly or implicitly specifying a backend engine. That engine is then expected to produce three critical pieces of information when `engine.read_metadata` is called:

1. `meta`: The metadata (an empty `pandas.DataFrame` object) for the output DataFrame collection
2. `parts`: The `list` of information needed to produce the output-DataFrame partitions at IO time.  After `parts` is finalized, each if its elements will be used for a distinct call to `engine.read_partition` to produce a single output-`pandas.DataFrame` partition.  For this reason, generating `parts` is effectively the same as materializing the task graph.
3. `statistics`: A list of statistics for each element of `parts`. This list is required to calculate output divisions, aggregate files by `chunksize`, and/or apply filters (except for ""pyarrow-dataset"").

**Outline of the existing read_parquet algorithm:**

```python
def read_parquet(paths, filters, engine, ...):
    ...
    # ENGINE logic to calculate meta, parts & statistics.
    #
    # This is where the engine is expected to produce output
    # `meta`, and the `parts` & `statistics` lists-
    (
        meta,
        parts,
        statistics,
        ...
    ) = engine.read_metadata(paths, filters, ...)

    # CORE logic to apply filters and calculate divisions
    (
        parts,
        divisions,
        ...
    ) = process_statistics(parts, statistics, filters, ...)

    # CORE logic to define Layer/DataFrame
    layer = DataFrameIOLayer(parts, ...)
    ...
    return new_dd_object(...)
```


Although the best long-term `read_parquet` API will likely need to break the single `read_metadata` API into 2-3 distinct functions, the short-term proposal will start by leaving the surface area of this function as is.  Instead of modifying the ""public"" Engine API, I suggest that we focus on a smaller internal refactor of `read_metadata`.


### Engine-Specific Logic: Collecting Metadata and `parts`/`statistics`

In order to understand how we must modify the existing `Engine.read_metadata` implementations, it is useful to describe how these functions are currently designed.  The general approach comprises three steps:

1. Use engine-specific logic to construct a global parquet-metadata object (or a global-metadata ""proxy"")
2. Use collected metadata/schema information to define the output DataFrame `meta`
3. Use a mix of shared and engine-specific logic to convert `metadata` to `parts` and `statistics`

**Outline of the existing ArrowDatasetEngine.read_metadata implementation:**

```python
class ArrowDatasetEngine:

    @classmethod
    def read_metadata(cls, paths, filters, ...):
	
        # Collect a `metadata` structure. For ""pyarrow-legacy"",
        # this is a `pyarrow.parquet.FileMetaData` object. For
        # ""pyarrow-dataset"", this is a list of dataset fragments.
        metadata, ... = cls._gather_metadata(paths, filters, ...)

        # Use the pyarrow.dataset schema to construct the `meta`
        # of the output DataFrame collection
        meta, ... = cls._generate_dd_meta(schema, ...)
		
        # Use the `metadata` object (list of fragments) to construct
        # coupled `parts` and `statistics` lists
        parts, statistics, ... = cls._construct_parts(metadata, ...)
		
        return meta, statistics, parts
		
    @classmethod
    def _gather_metadata(cls, paths, ...):
	
        # Create pyarrow.dataset object
        ds = pa_dataset.dataset(paths, ...)
		
        # Collect filtered list of dataset ""fragments"".
        # Call this list of fragments the ""metadata""
        # (this is NOT a formal ""parquet-metadata"" object)
        metadata = _collect_pyarrow_dataset_frags(ds, filters, ...)

        return schema, metadata, ...
		
    @classmethod
    def _construct_parts(cls, metadata, ...):
	
        # Here we use a combination of engine-specific and
        # shared logic to construct coupled `parts` and `statistics`
        parts, statistics = <messy-logic>(metadata, ...)

        return parts, statistics, ...
```

The exact details of these steps depend on the specific engine, but the general algorithm is pretty much the same for both ""pyarrow"" and ""fastparquet"". This general algorithm works well in many cases, but it has the following drawbacks:

1. The metadata/metadata-proxy object construction does not yet allow the user to opt out of _metadata processing.
2. The metadata/metadata-proxy object is only collected in parallel for the ""arrow-legacy"" API (not for ""pyarrow"" or ""fastparquet"")
3. Even when the metadata object is collected in parallel for ""pyarrow-legacy"", it is still reduced into a single object and then processed in serial on the client.  This is clearly not the most efficient way to produce the final `parts`/`statistics` lists.
4. (**more of a future problem**) The `meta` is not constructed until after a metadata or metadata-proxy object has been constructed.  This is not a problem yet, but is likely to become one when it is time to implement an abstract-expression API for read_parquet. 


## Short-Term Proposal

### Make _metadata Processing Optional

I propose that we allow the user to specify that a global _metadata file should be ignored by Dask. This first step is already implemented in #8034, where a new `ignore_metadata_file=` kwarg has been added to the public `read_parquet` API. Please feel free to provide specific feedback in that PR.

### Refactor `*Engine.read_metadata`

**Outline of the PROPOSED `ArrowDatasetEngine.read_metadat`a implementation**:

```python
class ArrowDatasetEngine:
    @classmethod
    def read_metadata(cls, paths, filters, ignore_metadata_file, ...):

        # Stage 1: Use a combination of engine specific logic and shared
        # fsspec utilities to construct an engine-specific `datset_info` dictionary.
        dataset_info = cls._collect_dataset_info(paths, ignore_metadata_file, ...)

        # Stage 2: Use information in `dataset_info` (like schema) to define
        # the `meta` for the output DataFrame collection.
        meta, ... = cls._generate_dd_meta(dataset_info, ...)
		
        # Stage 3: Use information in `dataset_info` to directly construct
        # `parts` and `statistics`
        parts, statistics = cls._make_partition_plan(dataset_info, meta, filters, ...)
		
        return meta, statistics, parts
```

#### Stage-1 Details

The purpose of this stage is to do as little work as possible to populate a dictionary of high-level information about the dataset in question.  This ""high-level"" information will most likely include the schema, the paths, the file-system, and the discovered hive partitions.  Although our first pass at this should not try to do anything particularly clever here, we may eventually want to use this space to discover the paths/hive-partitions in parallel. We can also leverage #9051 (`categorical_partitions`) to avoid the need to discover all files up front (since we may not need full categorical dtypes for the schema).

Assuming that we should keep stage 1 simple for now, the new `_collect_dataset_info` functions will effectively pull out the existing logic in `*engine.read_metadata` used to define a `pyarrow.dataset`/`ParquetDataset`/`ParquetFile` objects.  These objects can be stored, along with other important information, in the output `dataset_info` dictionary. Note that the only critical detail in this stage is that we must support the `ignore_metadata_file=True` option.


#### Stage-2 Details

There is not much (if any) work to be done here.  The existing logic in the various `_generate_dd_meta` implementations can be reused.

#### Stage-3 Details

This stage will correspond to the lion's share of the pain required for this work. While the short-term plan for Stage-1 and Stage-2 are to effectively move around existing code into simple functions with clear objectives, Stage-3 will require us to implement a new algorithm to (optionally) construct `parts`/`statistics` in parallel.  I expect the exact details here to be pretty engine-specific.  That is, ""pyarrow-datset"" will (optionally) parallelize over the processing of file fragments into `parts`/`statistics`, while ""fastparquet"" will need to parallelize over paths a bit differently.  However, I do expect all engine to follow a similar ""parallelize over file-path/object"" approach.  In the case that the _metadata file exists (and the user has not asked to ignore it), we should avoid constructing `parts`/`statistics` on the workers.


**ROUGH illustration of the PROPOSED `ArrowDatasetEngine._make_partition_plan` implementation**:

```python
@classmethod
def _make_partition_plan(cls, dataset_info, meta, filters, split_row_groups, ...):

    parts, statistics = [], []
	
    # (OPTIONALLY) DASK-PARALLELIZE THIS LOOP:
    for file_object in all_file_objects:
        part, part_stats = cls._collect_file_parts(file_object, ...)
	
    return parts, statistics
```",,https://api.github.com/repos/dask/dask/issues/8058/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8058/reactions,2,1,0,0,0,0,0,0,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
488,https://api.github.com/repos/dask/dask/issues/8084,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8084/labels{/name},https://api.github.com/repos/dask/dask/issues/8084/comments,https://api.github.com/repos/dask/dask/issues/8084/events,https://github.com/dask/dask/pull/8084,978683491,MDExOlB1bGxSZXF1ZXN0NzE5MjMxODU2,8084,First proof-of-concept pass at an expression system (#7933),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3028194444, 'node_id': 'MDU6TGFiZWwzMDI4MTk0NDQ0', 'url': 'https://api.github.com/repos/dask/dask/labels/dispatch', 'name': 'dispatch', 'color': 'fc03db', 'default': False, 'description': 'Related to `Dispatch` extension objects'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,10,2021-08-25T04:01:37Z,2021-10-25T01:48:25Z,,FIRST_TIME_CONTRIBUTOR,,"This is just a very simple proof-of-concept showing how an expression system
might look on the dataframe objects. It is only implemented on the dataframe
classes and elemwise() so far. You should probably ignore any test failures
unless they are indicative of a fundamental structural problem with the design.

Example:

```py
>>> import dask
>>> df = dask.datasets.timeseries()
>>> a = df + df
>>> a.expr
ElemwiseFrameExpr('add-351c22ecb90bf820bea3cd561bc5a9b5', <meta object>,
                  <divisions tuple>, 'add',
                  FrameLeafExpr('make-timeseries-74d9e57f1bea216a4831f24dcb99fc19', <meta object>, <divisions list>),
                  FrameLeafExpr('make-timeseries-74d9e57f1bea216a4831f24dcb99fc19', <meta object>, <divisions list>))
```

(stuff in <> is elided because currently it just prints the entire thing)

Some comments:

- We are currently storing name, meta, and divisions on the expression, but
  not the graph. This seems the most reasonable to me, but may need to be
  rethought.

- I have maintained backwards compatibility for everything except for the
  class constructors for DataFrame, etc. However, it isn't necessarily clear
  to me that people don't use those constructors directly. For example,
  dask.datasets.timeseries() constructed a DataFrame directly. We might want
  to rethink how to do this while maintaining maximal backwards compatibility.

- Relatedly, it's not clear to me just where the adapter for putting the
  expression on the leaf node should go. For now, I have changed the
  constructor of _Frame, and modified the get_parallel_type dispatcher
  functions used by new_dd_object() function. But it's not obvious to me that
  that is correct. Also, we need a new type of function that constructs an
  object with subexpressions, which should be used by any function that
  constructs an object from other objects (i.e., the expression wouldn't be a
  leaf node in the expression tree). Maybe having a new function is best
  because that makes backwards compatibility easier, but it also means
  changing everything.

- Right now I have name, meta, and divisions as the args on the expression.
  I'm not sure if that's the best way to do it. It's definitely the simplest,
  because it means everything is just in args. Although I do think we might
  want to wrap those three objects themselves in special wrapper expression
  classes, if just to make the expression tree printing sane.

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `black dask` / `flake8 dask` / `isort dask`
",,https://api.github.com/repos/dask/dask/issues/8084/timeline,,,asmeurer,71486,MDQ6VXNlcjcxNDg2,https://avatars.githubusercontent.com/u/71486?v=4,,https://api.github.com/users/asmeurer,https://github.com/asmeurer,https://api.github.com/users/asmeurer/followers,https://api.github.com/users/asmeurer/following{/other_user},https://api.github.com/users/asmeurer/gists{/gist_id},https://api.github.com/users/asmeurer/starred{/owner}{/repo},https://api.github.com/users/asmeurer/subscriptions,https://api.github.com/users/asmeurer/orgs,https://api.github.com/users/asmeurer/repos,https://api.github.com/users/asmeurer/events{/privacy},https://api.github.com/users/asmeurer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8084/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8084,https://github.com/dask/dask/pull/8084,https://github.com/dask/dask/pull/8084.diff,https://github.com/dask/dask/pull/8084.patch,,,,,,,,,,,,,,,,,,,
489,https://api.github.com/repos/dask/dask/issues/8143,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8143/labels{/name},https://api.github.com/repos/dask/dask/issues/8143/comments,https://api.github.com/repos/dask/dask/issues/8143/events,https://github.com/dask/dask/pull/8143,996327018,PR_kwDOAbcwm84rvvx-,8143,A few threaded scheduler fixups,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,7,2021-09-14T18:44:17Z,2022-04-01T16:17:34Z,,MEMBER,,"Previously there was a bug where the number of threads used by the
threaded scheduler was different if `dask.compute` was called in the
main thread vs in a background thread. While fixing this, I also noticed
that the logic around maintaining a cache of executors could be done in
a simpler way that avoided the need for a lock or active management (we
could instead rely on GC behavior). This patch includes fixes for both.",,https://api.github.com/repos/dask/dask/issues/8143/timeline,,,jcrist,2783717,MDQ6VXNlcjI3ODM3MTc=,https://avatars.githubusercontent.com/u/2783717?v=4,,https://api.github.com/users/jcrist,https://github.com/jcrist,https://api.github.com/users/jcrist/followers,https://api.github.com/users/jcrist/following{/other_user},https://api.github.com/users/jcrist/gists{/gist_id},https://api.github.com/users/jcrist/starred{/owner}{/repo},https://api.github.com/users/jcrist/subscriptions,https://api.github.com/users/jcrist/orgs,https://api.github.com/users/jcrist/repos,https://api.github.com/users/jcrist/events{/privacy},https://api.github.com/users/jcrist/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8143/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8143,https://github.com/dask/dask/pull/8143,https://github.com/dask/dask/pull/8143.diff,https://github.com/dask/dask/pull/8143.patch,,,,,,,,,,,,,,,,,,,
490,https://api.github.com/repos/dask/dask/issues/8147,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8147/labels{/name},https://api.github.com/repos/dask/dask/issues/8147/comments,https://api.github.com/repos/dask/dask/issues/8147/events,https://github.com/dask/dask/issues/8147,996597901,I_kwDOAbcwm847ZuCN,8147,Unified data reader / writer interfaces,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2021-09-15T02:39:57Z,2022-03-24T21:18:41Z,,CONTRIBUTOR,,"This post summarizes some of the inconsistencies in the reader / writer APIs.

Inconsistencies naturally arise as open source projects develop.  I think the project is now in a place where we can think about the readers / writers holistically and design an interface that'll be internally consistent.  This'll also be a great opportunity to revisit assumptions and defaults (e.g. default append behavior, default compression algo for CSVs, and filenaming conventions that'll be less error prone).

I expect a lot more readers / writers will be added in the future and would like to avoid even more ways of doing things.

I think we can get the best of all worlds with some well thought out work:

* give users a better interface
* eliminate some tech debt
* keep code backwards compatible

**Writer inconsistencies**

* Heres how to append with `to_parquet`: `ddf.to_parquet(some_folder, append=True)`
* Heres how to append with `to_csv`: `ddf.to_csv(some_folder, mode=a)`

There are also functionality differences.  `to_csv` allows for filename customization with `name_function` but `to_parquet` doesn't allow for customization.

There are some behavior/convention inconsistencies:

_to_parquet_

```python
df = pd.DataFrame(
    {""nums"": [1, 2, 3, 4, 5, 6], ""letters"": [""a"", ""b"", ""c"", ""d"", ""e"", ""f""]}
)
ddf = dd.from_pandas(df, npartitions=2)

ddf.to_parquet(""some_parquet_folder"") # nothing is returned
```

Here are the files that are outputted:

```
some_parquet_folder/
  _common_metadata
  _metadata
  part.0.parquet
  part.1.parquet
```

_to_csv_

```python
ddf.to_csv(""some_csv_folder"") # this returns a list of filenames that are outputted, which is bad for huge writes
```

Here are the files that are outputted:

```
some_csv_folder/
  0.part
  1.part
```

It'd be better for these files to be named `part.0.csv` and `part.1.csv` to be consistent with the Parquet filenames.  The Spark convention of `part-00000-78f9c583-ea60-4962-af99-895f453dce23-c000.snappy.csv` would be even better to allow identification of files written per batch and lessen the probability of filename collisions.

**Reader inconsistencies**

There are also lots of subtle inconsistencies with the data readers (CSV wants glob notation and Parquet does not).

* `dd.read_csv( ""s3://coiled-datasets/timeseries/7d/csv/2000/*.csv"")`
* `dd.read_parquet(""s3://coiled-datasets/timeseries/7d)`

**Recommended next steps**

* Get thoughts from the core team if this project sounds interesting
* I can provide suggested next steps is the team would find them useful",,https://api.github.com/repos/dask/dask/issues/8147/timeline,,,MrPowers,2722395,MDQ6VXNlcjI3MjIzOTU=,https://avatars.githubusercontent.com/u/2722395?v=4,,https://api.github.com/users/MrPowers,https://github.com/MrPowers,https://api.github.com/users/MrPowers/followers,https://api.github.com/users/MrPowers/following{/other_user},https://api.github.com/users/MrPowers/gists{/gist_id},https://api.github.com/users/MrPowers/starred{/owner}{/repo},https://api.github.com/users/MrPowers/subscriptions,https://api.github.com/users/MrPowers/orgs,https://api.github.com/users/MrPowers/repos,https://api.github.com/users/MrPowers/events{/privacy},https://api.github.com/users/MrPowers/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8147/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
491,https://api.github.com/repos/dask/dask/issues/8152,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8152/labels{/name},https://api.github.com/repos/dask/dask/issues/8152/comments,https://api.github.com/repos/dask/dask/issues/8152/events,https://github.com/dask/dask/issues/8152,997376073,I_kwDOAbcwm847csBJ,8152,Warn if `num_workers == 1`,"[{'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,15,2021-09-15T18:14:15Z,2022-03-01T17:54:27Z,,MEMBER,,"Currently `num_workers` can wind up being `1` if a machine has only a single CPU (like a minimal cloud instance). In these cases, it might be worth warning users that they only have `1` worker and so they won't get the benefits of parallelism with Dask. Of course the messaging/communication may need a bit of thought to find the right balance.",,https://api.github.com/repos/dask/dask/issues/8152/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8152/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
492,https://api.github.com/repos/dask/dask/issues/8153,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8153/labels{/name},https://api.github.com/repos/dask/dask/issues/8153/comments,https://api.github.com/repos/dask/dask/issues/8153/events,https://github.com/dask/dask/pull/8153,997498041,PR_kwDOAbcwm84rzcb2,8153,[WIP] MultiIndex,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3028194444, 'node_id': 'MDU6TGFiZWwzMDI4MTk0NDQ0', 'url': 'https://api.github.com/repos/dask/dask/labels/dispatch', 'name': 'dispatch', 'color': 'fc03db', 'default': False, 'description': 'Related to `Dispatch` extension objects'}]",open,False,,[],,0,2021-09-15T20:38:23Z,2022-03-10T19:14:10Z,,MEMBER,,"- [ ] Closes #1493
- [ ] Tests added / passed
- [ ] Passes `black dask` / `flake8 dask` / `isort dask`

This first commit is pulled from @TomAugspurger's original branch: https://github.com/TomAugspurger/dask/commit/0e741e15cc524aabeb3d7b5cf3f3c91be262cf5c

My plan is to try to keep moving forward with that work and raise NotImplemented all over the place.
",,https://api.github.com/repos/dask/dask/issues/8153/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8153/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/8153,https://github.com/dask/dask/pull/8153,https://github.com/dask/dask/pull/8153.diff,https://github.com/dask/dask/pull/8153.patch,,,,,,,,,,,,,,,,,,,
493,https://api.github.com/repos/dask/dask/issues/8172,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8172/labels{/name},https://api.github.com/repos/dask/dask/issues/8172/comments,https://api.github.com/repos/dask/dask/issues/8172/events,https://github.com/dask/dask/issues/8172,1005556634,I_kwDOAbcwm84775Oa,8172,botocore error when writing parquet to S3,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,4,2021-09-23T15:15:23Z,2021-11-07T10:42:38Z,,NONE,,"I'm unable to write a particular dataframe to S3.

## Code overview
Read a parquet file from S3
```python
import dask.dataframe as dd
df = dd.read_parquet(path=[f's3://{bucket}/{path_to_file}'],  # single file
    kwargs={'dataset': {'schema': schema}},  # Tried with & without this
    storage_options={'client_kwargs': s3_conf})
```
Extract rows with an na value to troubleshoot later
```python
null_df = df[df.isna().any(axis=1)]
```
Some columns that should be int have na values we can't directly cast. Find na values in columns that are supposed to be int, and replace them with a representative value (-1)
```python
null_df[col_names] = null_df[col_names].where(~null_df[col_names].isna(), -1.0)
```
Now types can be safely converted
```python
null_df = null_df.astype(dict_mapping_cols_to_np_types)
```
(I also replaced na values in float type columns with 0 to be safe).

Write the parquet file to a new S3 location
```python
# pyarrow_schema is the pyarrow equivalent to our numpy type mapping from earlier 
null_df.to_parquet(path=f's3://{bucket}/{new_path}.parquet', engine='pyarrow', schema=pyarrow_schema, storage_options={'client_kwargs': s3_conf})
```

## The error
The primary resulting error:
```Traceback (most recent call last):
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/s3fs/core.py"", line 248, in _call_s3
    out = await method(**additional_kwargs)
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/aiobotocore/client.py"", line 155, in _make_api_call
    raise error_class(parsed_response, operation_name)
botocore.exceptions.ClientError: An error occurred (MalformedACLError) when calling the CreateMultipartUpload operation: The XML you provided was not well-formed or did not validate against our published schema.
```

<details><summary>The full trace</summary>
<p>
Traceback (most recent call last):
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/s3fs/core.py"", line 248, in _call_s3
    out = await method(**additional_kwargs)
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/aiobotocore/client.py"", line 155, in _make_api_call
    raise error_class(parsed_response, operation_name)
botocore.exceptions.ClientError: An error occurred (MalformedACLError) when calling the CreateMultipartUpload operation: The XML you provided was not well-formed or did not validate against our published schema.

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/pyarrow/parquet.py"", line 1987, in write_table
    writer.write_table(table, row_group_size=row_group_size)
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/pyarrow/parquet.py"", line 693, in write_table
    self.writer.write_table(table, row_group_size=row_group_size)
  File ""pyarrow/_parquet.pyx"", line 1439, in pyarrow._parquet.ParquetWriter.write_table
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/fsspec/spec.py"", line 1401, in write
    self.flush()
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/fsspec/spec.py"", line 1437, in flush
    self._initiate_upload()
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/s3fs/core.py"", line 1871, in _initiate_upload
    self.mpu = self._call_s3(
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/s3fs/core.py"", line 1863, in _call_s3
    return self.fs.call_s3(method, self.s3_additional_kwargs, *kwarglist, **kwargs)
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/fsspec/asyn.py"", line 88, in wrapper
    return sync(self.loop, func, *args, **kwargs)
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/fsspec/asyn.py"", line 69, in sync
    raise result[0]
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/fsspec/asyn.py"", line 25, in _runner
    result[0] = await coro
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/s3fs/core.py"", line 268, in _call_s3
    raise err
OSError: [Errno 22] The XML you provided was not well-formed or did not validate against our published schema.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""src/main.py"", line 379, in <module>
    handle_run_id(s3_client=s3_client,
  File ""/home/lz1sx9/project_repos/AVMMS_124381_Build_map-builder/features/post_processing/src/utils/decorators.py"", line 35, in wrapper
    return func(logger=logger, *args, **kwargs)
  File ""src/main.py"", line 258, in handle_run_id
    handle_geohash(s3_conf=s3_conf, run_id=run_id, bucket=bucket, geohash=geohash, all_files=all_files_carto,
  File ""/home/lz1sx9/project_repos/AVMMS_124381_Build_map-builder/features/post_processing/src/utils/decorators.py"", line 35, in wrapper
    return func(logger=logger, *args, **kwargs)
  File ""src/main.py"", line 198, in handle_geohash
    s3_utils.write_null_rows_to_s3(df_to_process=road_edges,
  File ""/home/lz1sx9/project_repos/AVMMS_124381_Build_map-builder/features/post_processing/src/utils/decorators.py"", line 35, in wrapper
    return func(logger=logger, *args, **kwargs)
  File ""/home/lz1sx9/project_repos/AVMMS_124381_Build_map-builder/features/post_processing/src/utils/s3_utils.py"", line 167, in write_null_rows_to_s3
    larger_df.to_parquet(path=f's3://{bucket}/feature_testing/cliff-testing/test.parquet',
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/dask/dataframe/core.py"", line 4540, in to_parquet
    return to_parquet(self, path, *args, **kwargs)
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/dask/dataframe/io/parquet/core.py"", line 725, in to_parquet
    return compute_as_if_collection(
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/dask/base.py"", line 315, in compute_as_if_collection
    return schedule(dsk2, keys, **kwargs)
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/dask/threaded.py"", line 79, in get
    results = get_async(
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/dask/local.py"", line 517, in get_async
    raise_exception(exc, tb)
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/dask/local.py"", line 325, in reraise
    raise exc
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/dask/local.py"", line 223, in execute_task
    result = _execute_task(task, data)
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/dask/core.py"", line 121, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/dask/utils.py"", line 35, in apply
    return func(*args, **kwargs)
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/dask/dataframe/io/parquet/arrow.py"", line 946, in write_partition
    pq.write_table(
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/pyarrow/parquet.py"", line 1987, in write_table
    writer.write_table(table, row_group_size=row_group_size)
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/pyarrow/parquet.py"", line 678, in __exit__
    self.close()
  File ""/home/lz1sx9/anaconda3/envs/dask/lib/python3.8/site-packages/pyarrow/parquet.py"", line 700, in close
    self._metadata_collector.append(self.writer.metadata)
  File ""pyarrow/_parquet.pyx"", line 1453, in pyarrow._parquet.ParquetWriter.metadata.__get__
RuntimeError: file metadata is only available after writer close
</p></details>

## Other notes
I have no issues writing other dask dataframes to this location with the same approach. I can also split my dataframe with `null_df.random_split(frac=[.4, .6], random_state=1)`, and the smaller portion will write but not the larger. I've compared the smaller and larger by inspecting `df.columns`, `df.dtypes`, and `df.info` and see no differences.

The parquet file I originally read from S3 is 5.91 MB (not sure how that changes after reading to a local location), so I assume `null_df` is significantly smaller since it's a subset of the original.

## Environment

- Dask version: 2021.7.2, same result with 2021.09.1
- Python version: 3.8
- Operating System: Ubuntu 18.04.5 LTS
- Install method (conda, pip, source): pip from inside dedicated conda env
",,https://api.github.com/repos/dask/dask/issues/8172/timeline,,,cliffplaysdrums,17258650,MDQ6VXNlcjE3MjU4NjUw,https://avatars.githubusercontent.com/u/17258650?v=4,,https://api.github.com/users/cliffplaysdrums,https://github.com/cliffplaysdrums,https://api.github.com/users/cliffplaysdrums/followers,https://api.github.com/users/cliffplaysdrums/following{/other_user},https://api.github.com/users/cliffplaysdrums/gists{/gist_id},https://api.github.com/users/cliffplaysdrums/starred{/owner}{/repo},https://api.github.com/users/cliffplaysdrums/subscriptions,https://api.github.com/users/cliffplaysdrums/orgs,https://api.github.com/users/cliffplaysdrums/repos,https://api.github.com/users/cliffplaysdrums/events{/privacy},https://api.github.com/users/cliffplaysdrums/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8172/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
494,https://api.github.com/repos/dask/dask/issues/8196,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8196/labels{/name},https://api.github.com/repos/dask/dask/issues/8196/comments,https://api.github.com/repos/dask/dask/issues/8196/events,https://github.com/dask/dask/pull/8196,1011270612,PR_kwDOAbcwm84sdwhh,8196,Remove `try..except` block in `set_partitions_pre`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2021-09-29T17:55:09Z,2022-09-06T16:21:17Z,,MEMBER,,"As discussed in #8193, now that Dask's `sort_values` has null handling, it might be worthwhile refactoring `set_partitions_pre` to remove the `try..except` block there. Now the function does the following:

- Calls `searchsorted` on only the non-null elements of `divisions` and `s` (avoiding the failure caused when `divisions` and `s` contain strings)
- Uses item assignment to place the null elements of `s` in the correct partition based on `na_position`
- Uses item assignment to place any elements of `s` incorrectly sorted by `searchsorted` into the correct partition based on `ascending`

Additionally, as suggested by @rjzamora there might be less overhead by initializing our `partitions` array with `np.zeros` rather than `np.empty`.

After the cuDF breakage that resulted from #8167, I would prefer merging this after we have some additional dask-cuDF testing for `set_index`.

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `black dask` / `flake8 dask` / `isort dask`
",,https://api.github.com/repos/dask/dask/issues/8196/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8196/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8196,https://github.com/dask/dask/pull/8196,https://github.com/dask/dask/pull/8196.diff,https://github.com/dask/dask/pull/8196.patch,,,,,,,,,,,,,,,,,,,
495,https://api.github.com/repos/dask/dask/issues/8216,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8216/labels{/name},https://api.github.com/repos/dask/dask/issues/8216/comments,https://api.github.com/repos/dask/dask/issues/8216/events,https://github.com/dask/dask/issues/8216,1015430653,I_kwDOAbcwm848hj39,8216,Pandas 1.2.0 compatibility - column reductions are applied column-wise (when possible),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2021-10-04T17:18:29Z,2022-02-23T15:13:23Z,,MEMBER,,"Therefore now applied on eg the integer columns separately. In a test case, this caused the integers to overflow for `prod()`. While before, the DataFrame was converted to a float ndarray (because it also has a float columns), not giving those overflow issues. Hence the test was failing (see test `dask/dataframe/tests/test_ufunc.py::test_ufunc_with_reduction`). The question here is whether dask wants to follow that behaviour.",,https://api.github.com/repos/dask/dask/issues/8216/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8216/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
496,https://api.github.com/repos/dask/dask/issues/8218,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8218/labels{/name},https://api.github.com/repos/dask/dask/issues/8218/comments,https://api.github.com/repos/dask/dask/issues/8218/events,https://github.com/dask/dask/issues/8218,1016483853,I_kwDOAbcwm848llAN,8218,Possible bug: `dask.array.compute()` hanging with `multiprocessing.Pool`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2021-10-05T15:41:54Z,2021-11-15T01:46:41Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:

Calling `compute()` twice in the same function hangs: first time one calls `compute()` in a straightforward manner, second time via `multiprocessing.Pool`; see example below:

- if I call `my_func(2)` then I go ahead and execute the mpi block (with the dask cluster commented out), the execution hangs (see stack trace below, after a `KeyboardInterrupt`);
- if I repeat the operation - call `my_func(2)` then execute just the dask cluster block (with the mpi block commented out) all goes through to finish (slowly, but it is expected);

Outline: I know we should be using the dask distributed client to operate multiprocessing jobs, but unfortunately, our actual code machinery makes use of `multiprocessing.Pool` at the moment and it will take a lot of changes to adapt it to use dask distributed; but we also want to use dask arrays, and finally, compute actual numerical values. Unfortunately, in a particular setup, we are faced with this odd combination of having to call a function twice - once explicitly on one thread and second time over in a `Pool`, and our whole machinery grinds to a halt. Any advice would be highly appreciated :beer: Very many thanks in advance! Cheers

Stack trace after a `KeyboardInterrupt`:
```
^CProcess ForkPoolWorker-2:
Process ForkPoolWorker-1:
Traceback (most recent call last):
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/process.py"", line 315, in _bootstrap
    self.run()
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/process.py"", line 108, in run
    self._target(*self._args, **self._kwargs)
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/pool.py"", line 114, in worker
    task = get()
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/queues.py"", line 366, in get
    res = self._reader.recv_bytes()
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/connection.py"", line 221, in recv_bytes
    buf = self._recv_bytes(maxlength)
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/connection.py"", line 419, in _recv_bytes
    buf = self._recv(4)
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/connection.py"", line 384, in _recv
    chunk = read(handle, remaining)
KeyboardInterrupt
Traceback (most recent call last):
  File ""/home/valeriu/dask_fail.py"", line 28, in <module>
    main()
  File ""/home/valeriu/dask_fail.py"", line 19, in main
    x = pool.map(my_func, [2])
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/pool.py"", line 364, in map
    return self._map_async(func, iterable, mapstar, chunksize).get()
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/pool.py"", line 765, in get
Traceback (most recent call last):
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/process.py"", line 315, in _bootstrap
    self.run()
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/process.py"", line 108, in run
    self._target(*self._args, **self._kwargs)
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/pool.py"", line 125, in worker
    result = (True, func(*args, **kwds))
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/pool.py"", line 48, in mapstar
    return list(map(*args))
  File ""/home/valeriu/dask_fail.py"", line 10, in my_func
    s = compute(a)
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/site-packages/dask/base.py"", line 570, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/site-packages/dask/threaded.py"", line 79, in get
    results = get_async(
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/site-packages/dask/local.py"", line 506, in get_async
    for key, res_info, failed in queue_get(queue).result():
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/site-packages/dask/local.py"", line 134, in queue_get
    return q.get()
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/queue.py"", line 171, in get
    self.not_empty.wait()
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/threading.py"", line 312, in wait
    waiter.acquire()
KeyboardInterrupt
    self.wait(timeout)
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/multiprocessing/pool.py"", line 762, in wait
    self._event.wait(timeout)
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/threading.py"", line 574, in wait
    signaled = self._cond.wait(timeout)
  File ""/home/valeriu/miniconda3/envs/esmvaltool-standard2/lib/python3.9/threading.py"", line 312, in wait
    waiter.acquire()
KeyboardInterrupt
```

**What you expected to happen**:

**Minimal Complete Verifiable Example**:

```python
import dask.array as da
from dask import compute
from dask.distributed import Client
from multiprocessing import Pool


def my_func(x1):
    a = da.arange(4)
    print(a)
    s = compute(a)


def main():
    # call function like a peasant
    my_func(2)

    # mpi block
    pool = Pool(processes=2)
    x = pool.map(my_func, [2])

    # dask cluster block
    client = Client()
    x = client.map(my_func, [2])
    x = client.gather(x)


if __name__ == '__main__':
    main()
```

**Anything else we need to know?**:

**Environment**:

- Dask version:
```
dask                      2021.9.1           pyhd8ed1ab_0    conda-forge
dask-core                 2021.9.1           pyhd8ed1ab_0    conda-forge
```
- Python version: `3.9.7`
- Operating System:
```
Distributor ID:	Ubuntu
Description:	Ubuntu 16.04.7 LTS
Release:	16.04
Codename:	xenial
```
- Install method (conda, pip, source): `conda-forge` (see build hash above)
",,https://api.github.com/repos/dask/dask/issues/8218/timeline,,,valeriupredoi,28983971,MDQ6VXNlcjI4OTgzOTcx,https://avatars.githubusercontent.com/u/28983971?v=4,,https://api.github.com/users/valeriupredoi,https://github.com/valeriupredoi,https://api.github.com/users/valeriupredoi/followers,https://api.github.com/users/valeriupredoi/following{/other_user},https://api.github.com/users/valeriupredoi/gists{/gist_id},https://api.github.com/users/valeriupredoi/starred{/owner}{/repo},https://api.github.com/users/valeriupredoi/subscriptions,https://api.github.com/users/valeriupredoi/orgs,https://api.github.com/users/valeriupredoi/repos,https://api.github.com/users/valeriupredoi/events{/privacy},https://api.github.com/users/valeriupredoi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8218/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
497,https://api.github.com/repos/dask/dask/issues/8223,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8223/labels{/name},https://api.github.com/repos/dask/dask/issues/8223/comments,https://api.github.com/repos/dask/dask/issues/8223/events,https://github.com/dask/dask/pull/8223,1016761474,PR_kwDOAbcwm84st65P,8223,[Never Merge] Prototype for scalable dataframe shuffle,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,4,2021-10-05T20:08:42Z,2022-08-03T14:15:47Z,,MEMBER,,"_This is a duplicate of https://github.com/dask/dask/pull/8209, but I'm taking over from @fjetter since I may want to occasionally push small fixes here. Original message copied below, with edits._

This is a prototype implementation of a new `dask.dataframe` shuffle algorithm which runs on a `dask.distributed` cluster. Different to the task based shuffle algorithm this uses an out-of-band communication and administration approach to circumvent scheduler imposed bottlenecks.

## How to try / Feedback requested
Install this branch of `dask/dask` (`pip install -U git+https://github.com/gjoseph92/dask@shuffle_service`) and run a shuffle workload (`set_index`, `groupby`, etc.), _passing the keyword argument `shuffle=""service""`_. Until distributed 2021.10.0 or later is released, you'll also need to install `dask/distributed` from `main` (`pip install -U git+https://github.com/dask/distributed`).

With this PR, we've been able to easily do shuffles that crash the cluster currently. Additionally, since this writes intermediate data to disk, you can shuffle larger-than-memory DataFrames. Note that the data written to disk won't show up as spilled-to-disk on the dashboard. Similarly, you'll see high unmanged memory on workers while the shuffle is working.

As a rule of thumb:
* total cluster disk space needs to fit the full dataset
* worker RAM needs to fit ~2GiB + partition_size * nthreads * ~5x safety factor?

Additionally, more threads don't improve performance much (since everything is GIL-bound), so we recommend 2 threads unless other parts of your workload require more.

We would love you to try this out and report back to us. This implementation is targeted for large scale data processing and we would appreciate people trying this out and giving us feedback about it. Especially if you have large datasets sitting around. If you encounter any stability or performance related issues, please _open a dedicated ticket_ and link to this PR such that we can structure discussions a bit. 

##  Warnings 
This is experimental. We do not expect this PR to ever be merged. Instead, we'll take ideas (and feedback) from this PR into a different one that's better-designed, stable, and maintainable.

With that explained, here are things to look out for:
* Doesn't work for `merge` yet, because that requires multiple simultaneous shuffles
* Requires distributed>=2021.10.0 which doesn't exist yet, so until it does, you need to install distributed from `main`
* All workers must have >= 2 threads
* The cluster must have enough total disk space to hold the entire dataset (but can have much less RAM than that)
* If a worker runs out of disk space, the whole shuffle will error
* Workers sometimes run out of memory and die randomly during the `transfer` phase
* If a worker dies during the `transfer` phase, the cluster will deadlock for 15 minutes typically (distributed's 300s connect timeout * 3 retries), then the task will error
* If a worker dies during the `unpack` phase, the cluster will deadlock indefinitely
* Multiple shuffles at the same time will fail in strange ways. Running a shuffle more than once on a cluster without restarting it could possibly behave oddly too.
* Mostly tested on synthetic data from `dask.datasets.timeseries`. Real data with uneven distributions and input partition sizes may behave poorly.
* It's slower than it should be and mostly GIL-bound (though probably still faster than a standard task-based shuffle): https://github.com/dask/distributed/issues/5258#issuecomment-914957989, https://github.com/pandas-dev/pandas/issues/43155#issuecomment-915689887
* Remember to pass `shuffle=""service""`!

## Reviews
For all who are brave enough to review this I would only encourage a high level pass. There are many moving parts and many open TODOs. We're discussing breaking off some parts of the implementation to allow for easier review (or move some parts to dask/distributed). This is still TBD but suggestions are welcome.

## High level design
The concurrency model driving this is rather complex and is made of multiple coroutines and threads to deal with grouping, concatenating, sending and receiving data. This process is kicked off in the `transfer` task which is applied on every input partition. This allows computation and network to efficiently overlap. Data is buffered efficiently such that network overhead for small sized data chunks, _shards_, is minimal.

The receiving end of these submissions is a small extension on the Worker which accepts incoming data and caches it (on disk, see below) for later processing. The task graph currently employs a barrier task for synchronization and buffer flushing. The output partitions will then be picked up by the `unpack` task which collects the data stored on the given worker and extracts it into a runnable task. From there on, everything is BAU.

To enable larger than (cluster) memory dataset shuffles there is an efficient spill to disk implementation which caches all received shards on disk while the shuffle is still running. This is currently not optional. There is currently no persistence hierarchy implemented as is usual for a Worker holding data.

## References
* https://github.com/dask/dask/issues/6314
* https://github.com/dask/dask/issues/3514
* https://github.com/dask/dask/issues/6164

cc @mrocklin , @gjoseph92 , @quasiben , @madsbk , ...?",,https://api.github.com/repos/dask/dask/issues/8223/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8223/reactions,2,0,0,0,0,0,2,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/8223,https://github.com/dask/dask/pull/8223,https://github.com/dask/dask/pull/8223.diff,https://github.com/dask/dask/pull/8223.patch,,,,,,,,,,,,,,,,,,,
498,https://api.github.com/repos/dask/dask/issues/8229,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8229/labels{/name},https://api.github.com/repos/dask/dask/issues/8229/comments,https://api.github.com/repos/dask/dask/issues/8229/events,https://github.com/dask/dask/issues/8229,1019277344,I_kwDOAbcwm848wPAg,8229,Unexpected behaviour with out-of-bound indices,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2021-10-06T21:33:25Z,2021-10-25T21:41:58Z,,NONE,,"**What happened**:

I encountered the following issue when slicing a Dask array with a one-dimensional Dask array of integers. If the array used for slicing contains indices that are out of range in addition to some valid indices, I would expect an `IndexError` to be raised. Instead, no error is raised and it looks like the element corresponding to the first valid index is repeated for all the out-of-bounds indices. If all indices are out of bounds, then `IndexError` is raised as expected, but the error message includes wrong references to the bad indices and array size. 

**Minimal Complete Verifiable Example**:

```python
In [1]: import dask.array as da

In [2]: x = da.arange(10)

In [3]: idx = 11
   ...: y = x[idx]  # This raises a IndexError, as expected.

In [4]: idx = da.from_array([11])
   ...: y = x[idx]
   ...: y.compute() # This raises a IndexError, but the error message should probably be: ""index 11 is out of bounds for axis 0 with size 10""?

In [5]: idx = da.from_array([0, 11])
   ...: y = x[idx]
   ...: y.compute()  # this should raise a `IndexError`. Instead, the zeroth element is repeated.
Out[5]: array([0, 0])  

In [6]: idx = da.from_array([0, 1, 11, 12, 13])
   ...: y = x[idx]
   ...: y.compute()  # same as above - the zeroth element is repeated for all the out-of-bounds indices
Out[6]: array([0, 1, 0, 0, 0])
```

<details><summary>Traceback at [3]</summary>
<p>

```python
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-3-0094457f9d34> in <module>
      1 idx = 11
----> 2 y = x[idx]

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/array/core.py in __getitem__(self, index)
   1737         )
   1738 
-> 1739         index2 = normalize_index(index, self.shape)
   1740         dependencies = {self.name}
   1741         for i in index2:

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/array/slicing.py in normalize_index(idx, shape)
    915     for i, d in zip(idx, none_shape):
    916         if d is not None:
--> 917             check_index(i, d)
    918     idx = tuple(map(sanitize_index, idx))
    919     idx = tuple(map(normalize_slice, idx, none_shape))

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/array/slicing.py in check_index(ind, dimension)
    985 
    986     elif ind >= dimension:
--> 987         raise IndexError(
    988             ""Index is not smaller than dimension %d >= %d"" % (ind, dimension)
    989         )

IndexError: Index is not smaller than dimension 11 >= 10
```

</p>
</details>

<details><summary>Traceback at [4]</summary>
<p>

```python
--------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-4-795172e62a76> in <module>
      1 idx = da.from_array([11])
      2 y = x[idx]
----> 3 y.compute()

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/base.py in compute(self, **kwargs)
    286         dask.base.compute
    287         """"""
--> 288         (result,) = compute(self, traverse=False, **kwargs)
    289         return result
    290 

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/base.py in compute(*args, **kwargs)
    568         postcomputes.append(x.__dask_postcompute__())
    569 
--> 570     results = schedule(dsk, keys, **kwargs)
    571     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    572 

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     77             pool = MultiprocessingPoolExecutor(pool)
     78 
---> 79     results = get_async(
     80         pool.submit,
     81         pool._max_workers,

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/local.py in get_async(submit, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, chunksize, **kwargs)
    515                             _execute_task(task, data)  # Re-execute locally
    516                         else:
--> 517                             raise_exception(exc, tb)
    518                     res, worker_id = loads(res_info)
    519                     state[""cache""][key] = res

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/local.py in reraise(exc, tb)
    323     if exc.__traceback__ is not tb:
    324         raise exc.with_traceback(tb)
--> 325     raise exc
    326 
    327 

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    221     try:
    222         task, data = loads(task_info)
--> 223         result = _execute_task(task, data)
    224         id = get_id()
    225         result = dumps((result, id))

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/optimization.py in __call__(self, *args)
    967         if not len(args) == len(self.inkeys):
    968             raise ValueError(""Expected %d args, got %d"" % (len(self.inkeys), len(args)))
--> 969         return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
    970 
    971     def __reduce__(self):

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/core.py in get(dsk, out, cache)
    149     for key in toposort(dsk):
    150         task = dsk[key]
--> 151         result = _execute_task(task, cache)
    152         cache[key] = result
    153     result = _execute_task(out, cache)

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/utils.py in apply(func, args, kwargs)
     33 def apply(func, args, kwargs=None):
     34     if kwargs:
---> 35         return func(*args, **kwargs)
     36     else:
     37         return func(*args)

/opt/miniconda3/envs/dark_generators/lib/python3.8/site-packages/dask/array/chunk.py in slice_with_int_dask_array_aggregate(idx, chunk_outputs, x_chunks, axis)
    392     # np.take does not support slice indices
    393     # return np.take(chunk_outputs, idx_final, axis)
--> 394     return chunk_outputs[
    395         tuple(
    396             idx_final if i == axis else slice(None) for i in range(chunk_outputs.ndim)

IndexError: index 0 is out of bounds for axis 0 with size 0
```

</p>
</details>

**Environment**:

- Dask version: 2021.9.1
- Python version: 3.8.12
- Operating System: OS X
- Install method (conda, pip, source): `conda install dask[complete] -c conda-forge`
",,https://api.github.com/repos/dask/dask/issues/8229/timeline,,,fnattino,49899980,MDQ6VXNlcjQ5ODk5OTgw,https://avatars.githubusercontent.com/u/49899980?v=4,,https://api.github.com/users/fnattino,https://github.com/fnattino,https://api.github.com/users/fnattino/followers,https://api.github.com/users/fnattino/following{/other_user},https://api.github.com/users/fnattino/gists{/gist_id},https://api.github.com/users/fnattino/starred{/owner}{/repo},https://api.github.com/users/fnattino/subscriptions,https://api.github.com/users/fnattino/orgs,https://api.github.com/users/fnattino/repos,https://api.github.com/users/fnattino/events{/privacy},https://api.github.com/users/fnattino/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8229/reactions,0,0,0,0,0,0,0,0,0,jrbourbeau,11656932.0,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
499,https://api.github.com/repos/dask/dask/issues/8233,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8233/labels{/name},https://api.github.com/repos/dask/dask/issues/8233/comments,https://api.github.com/repos/dask/dask/issues/8233/events,https://github.com/dask/dask/issues/8233,1020207045,I_kwDOAbcwm848zx_F,8233,Monthly community meeting,"[{'id': 964975428, 'node_id': 'MDU6TGFiZWw5NjQ5NzU0Mjg=', 'url': 'https://api.github.com/repos/dask/dask/labels/community', 'name': 'community', 'color': 'd93f0b', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2021-10-07T15:57:00Z,2022-03-21T19:09:42Z,,MEMBER,,"A monthly Dask community meeting happens the first Thursday of the month at 10:00 US Central Time in [this video meeting](https://us06web.zoom.us/j/87619866741?pwd=S2RxMlRKcnVvakt4NHZoS1cwOGZoZz09). We chat about ongoing development efforts, give updates on what's happened in the Dask ecosystem over the last month, etc. Meeting notes are available in [this Google doc](https://docs.google.com/document/d/1UqNAP87a56ERH_xkQsS5Q_0PKYybd5Lj2WANy_hRzI0/edit).

_Note: I'm creating an issue for this so we can pin it to the top of our issue tracker in an experiment to increase the visibility of our monthly meeting_",,https://api.github.com/repos/dask/dask/issues/8233/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8233/reactions,7,0,0,0,0,0,7,0,0,jsignell,4806877.0,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
500,https://api.github.com/repos/dask/dask/issues/8245,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8245/labels{/name},https://api.github.com/repos/dask/dask/issues/8245/comments,https://api.github.com/repos/dask/dask/issues/8245/events,https://github.com/dask/dask/issues/8245,1022552303,I_kwDOAbcwm8488ujv,8245,Implement `unstack()` and/or `pivot()`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,4,2021-10-11T10:50:54Z,2022-02-05T16:46:11Z,,CONTRIBUTOR,,"For a recent [Stackoverflow question](https://stackoverflow.com/questions/69480773/convert-column-of-categoricals-to-additional-columns/69524920#69524920), I wrote a PoC version of `unstack`, which I believe does not exist in Dask. I suppose this is connected to https://github.com/dask/dask/issues/1493 but is in principle independent of it.

Pasting verbatim from the SO question for convenience:

```python
import dask.dataframe as dd

# Create Dask DataFrame out of your `frame`
# npartitions is more than 1 to demonstrate this works on a partitioned datataset
df = dd.from_pandas(frame, npartitions=3)

# Dask needs to know work out what the categories are
# Alternatively you can use df.categorize
# See https://docs.dask.org/en/latest/dataframe-categoricals.html
category = 'category'
df[category] = df[category].astype(category).cat.as_known()

# Dask needs to know what the resulting DataFrame looks like
new_columns = pd.CategoricalIndex(df[category].cat.categories, name=category)
meta = pd.DataFrame(columns=new_columns, 
                    index=df._meta.set_index(['idx', 'id']).index)

# Implement using apply_concat_apply (""aca"")
# More details: https://blog.dask.org/2019/10/08/df-groupby
def identity(x): return x

def my_unstack(x):
    return x.set_index(['id', 'idx', 'category'], drop=True).unstack()
    
def combine(x):
    return x.groupby(level=[0, 1]).sum()

result = dd.core.apply_concat_apply([df], 
                   chunk=identity, 
                   aggregate=my_unstack, 
                   combine=combine,
                   meta=meta)
result.compute()
```

Could this be actually used in Dask? `my_unstack` would of course have to be extended, but is this in principle correct and could eventually be part of the API?

I am happy to contribute to a PR in such a case.",,https://api.github.com/repos/dask/dask/issues/8245/timeline,,,DahnJ,18722560,MDQ6VXNlcjE4NzIyNTYw,https://avatars.githubusercontent.com/u/18722560?v=4,,https://api.github.com/users/DahnJ,https://github.com/DahnJ,https://api.github.com/users/DahnJ/followers,https://api.github.com/users/DahnJ/following{/other_user},https://api.github.com/users/DahnJ/gists{/gist_id},https://api.github.com/users/DahnJ/starred{/owner}{/repo},https://api.github.com/users/DahnJ/subscriptions,https://api.github.com/users/DahnJ/orgs,https://api.github.com/users/DahnJ/repos,https://api.github.com/users/DahnJ/events{/privacy},https://api.github.com/users/DahnJ/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8245/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
501,https://api.github.com/repos/dask/dask/issues/8247,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8247/labels{/name},https://api.github.com/repos/dask/dask/issues/8247/comments,https://api.github.com/repos/dask/dask/issues/8247/events,https://github.com/dask/dask/pull/8247,1022712254,PR_kwDOAbcwm84tBM4y,8247,[WIP] fix OOM error of dask-glm with cupy on GPU,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,10,2021-10-11T13:30:42Z,2022-03-24T16:13:28Z,,FIRST_TIME_CONTRIBUTOR,,"- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `black dask` / `flake8 dask` / `isort dask`

This is not a fix and it breaks current tests, especially cupy sparse. It is supposed to demonstrate the problem and facilitate discussion. It simply reverts the changes made in  https://github.com/dask/dask/pull/6846

With this commit, [the dask glm cupy demo notebook](https://github.com/daxiongshu/rapids-demos/blob/master/dask_glm_Multi-GPU_demo.ipynb) can achieve its original speedup and scales to 100GB.
",,https://api.github.com/repos/dask/dask/issues/8247/timeline,,,daxiongshu,3236827,MDQ6VXNlcjMyMzY4Mjc=,https://avatars.githubusercontent.com/u/3236827?v=4,,https://api.github.com/users/daxiongshu,https://github.com/daxiongshu,https://api.github.com/users/daxiongshu/followers,https://api.github.com/users/daxiongshu/following{/other_user},https://api.github.com/users/daxiongshu/gists{/gist_id},https://api.github.com/users/daxiongshu/starred{/owner}{/repo},https://api.github.com/users/daxiongshu/subscriptions,https://api.github.com/users/daxiongshu/orgs,https://api.github.com/users/daxiongshu/repos,https://api.github.com/users/daxiongshu/events{/privacy},https://api.github.com/users/daxiongshu/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8247/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8247,https://github.com/dask/dask/pull/8247,https://github.com/dask/dask/pull/8247.diff,https://github.com/dask/dask/pull/8247.patch,,,,,,,,,,,,,,,,,,,
502,https://api.github.com/repos/dask/dask/issues/8262,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8262/labels{/name},https://api.github.com/repos/dask/dask/issues/8262/comments,https://api.github.com/repos/dask/dask/issues/8262/events,https://github.com/dask/dask/issues/8262,1026534525,I_kwDOAbcwm849L6x9,8262,Use Rich more broadly?,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,1,2021-10-14T15:25:03Z,2021-10-25T03:28:14Z,,MEMBER,,"Rich is neat.  Do we want to leverage it more broadly?  

![image](https://user-images.githubusercontent.com/306380/137348119-7ef5d8d5-a738-4ed9-ab83-117ba28db962.png)

Dask gets lots of love around our error messages.  Good error messages reduce user pain.  Rich might help us to improve our current error messages and user feedback.  I suspect that once we start using it people might also really enjoy building more with it (it appears to be fun).  

However, it would be a new dependency.  Do we want to take it on for some of the subprojects like dask.dataframe or dask.distributed?

For context, I created a new conda environment with python installed, and then installed rich and got the following new dependencies

```
  Package               Version  Build           Channel                     Size

  Install:


  + colorama              0.4.4  pyh9f0ad1d_0    conda-forge/noarch        Cached
  + commonmark            0.9.1  py_0            conda-forge/noarch        Cached
  + future               0.18.2  py39h2804cbe_3  conda-forge/osx-arm64     Cached
  + pygments             2.10.0  pyhd8ed1ab_0    conda-forge/noarch        Cached
  + rich                10.12.0  py39h2804cbe_0  conda-forge/osx-arm64     347 KB
  + typing_extensions  3.10.0.2  pyha770c72_0    conda-forge/noarch         28 KB
```

So, two questions for the group:

1. Where would we use this?
2. How do we feel about the added dependency?",,https://api.github.com/repos/dask/dask/issues/8262/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8262/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
503,https://api.github.com/repos/dask/dask/issues/8280,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8280/labels{/name},https://api.github.com/repos/dask/dask/issues/8280/comments,https://api.github.com/repos/dask/dask/issues/8280/events,https://github.com/dask/dask/issues/8280,1032045911,I_kwDOAbcwm849g8VX,8280,computing std of sparse matrix produces an error,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2021-10-21T04:24:29Z,2022-03-01T18:22:58Z,,NONE,,"The following code raises an error

```python
import dask.array as da
import sparse
import numpy as np
x = da.from_array(sparse.random((10, 10), nnz=20, data_rvs=np.random.random))
x.std(axis=0).compute()
````
The current issue is that `dask.array.reductions.moment_agg` has a line `denominator[denominator < 0] = np.nan`, but in this case `denominator` is a `sp.COO` matrix which does not allow item assignment. A possible solution is to use `denominator = np.where(denominator<0, np.nan, denominator)` instead of the direct assignment .",,https://api.github.com/repos/dask/dask/issues/8280/timeline,,,vttrifonov,12157034,MDQ6VXNlcjEyMTU3MDM0,https://avatars.githubusercontent.com/u/12157034?v=4,,https://api.github.com/users/vttrifonov,https://github.com/vttrifonov,https://api.github.com/users/vttrifonov/followers,https://api.github.com/users/vttrifonov/following{/other_user},https://api.github.com/users/vttrifonov/gists{/gist_id},https://api.github.com/users/vttrifonov/starred{/owner}{/repo},https://api.github.com/users/vttrifonov/subscriptions,https://api.github.com/users/vttrifonov/orgs,https://api.github.com/users/vttrifonov/repos,https://api.github.com/users/vttrifonov/events{/privacy},https://api.github.com/users/vttrifonov/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8280/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
504,https://api.github.com/repos/dask/dask/issues/8289,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8289/labels{/name},https://api.github.com/repos/dask/dask/issues/8289/comments,https://api.github.com/repos/dask/dask/issues/8289/events,https://github.com/dask/dask/issues/8289,1033945026,I_kwDOAbcwm849oL_C,8289,#4012 for read_csv?,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,5,2021-10-22T21:00:53Z,2022-03-03T08:30:49Z,,NONE,,"Very interesting feature, I bumped into a similar problem with read_csv (~20k files ~1MB each) and landed on #4012. 
Is there any similar feature for read_csv? 
I tried to search but found none, also tried a few walkarounds but none effective. 
The reason I need this is because I think the huge graph is blowing up my memory. 

This issue is more like a sanity check and general support to see if it make sense to continue this direction. 
If it turns out more details are required I could provide the follow ups. ",,https://api.github.com/repos/dask/dask/issues/8289/timeline,,,y-he2,62895281,MDQ6VXNlcjYyODk1Mjgx,https://avatars.githubusercontent.com/u/62895281?v=4,,https://api.github.com/users/y-he2,https://github.com/y-he2,https://api.github.com/users/y-he2/followers,https://api.github.com/users/y-he2/following{/other_user},https://api.github.com/users/y-he2/gists{/gist_id},https://api.github.com/users/y-he2/starred{/owner}{/repo},https://api.github.com/users/y-he2/subscriptions,https://api.github.com/users/y-he2/orgs,https://api.github.com/users/y-he2/repos,https://api.github.com/users/y-he2/events{/privacy},https://api.github.com/users/y-he2/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8289/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
505,https://api.github.com/repos/dask/dask/issues/8292,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8292/labels{/name},https://api.github.com/repos/dask/dask/issues/8292/comments,https://api.github.com/repos/dask/dask/issues/8292/events,https://github.com/dask/dask/issues/8292,1034215582,I_kwDOAbcwm849pOCe,8292,graph became invalid in 2021.10.0,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,20,2021-10-23T17:29:44Z,2021-12-21T19:03:23Z,,CONTRIBUTOR,,"**What happened**:

Error raised during `graph.validate()` for a graph which was valid in 2021.9.1.

This graph creates a dataframe per chunk of an array, then merges the dataframes along one axis of the array.  A final per-chunk analysis is then run, where a merged dataframe is used in the analysis of each chunk that was used to make it.

**What you expected to happen**:

The constructed graph should validate.

**Minimal Complete Verifiable Example**:

```python
import functools
import operator

import dask
import dask.array as da
import dask.dataframe as dd

import numpy as np

META = dd.utils.make_meta([(""foo"", int)])


def test_sequential():
    image = da.zeros((2, 1), chunks=(1, -1))

    indices = list(np.ndindex(*image.numblocks))
    slices = da.core.slices_from_chunks(image.chunks)
    chunks = list(map(functools.partial(operator.getitem, image), slices))

    # Create one dataframe per chunk.
    ddf_all = np.empty(image.numblocks, dtype=object)
    for idx_chunk, chunk in zip(indices, chunks):
        ddf_delayed = dask.delayed(lambda: None)(chunk)
        ddf_all[idx_chunk] = dd.from_delayed(ddf_delayed, meta=META)

    # Merge dataframes along first axis.
    ddf_array = np.empty(image.numblocks[2:], dtype=object)
    for idx_spatial in np.ndindex(*ddf_array.shape):
        idx_all = (...,) + idx_spatial
        ddf = dd.concat(ddf_all[idx_all].flatten().tolist())
        ddf_array[idx_spatial] = ddf

    # Run a per-chunk calculation using the merged dataframes,
    # where a single merged dataframe is passed back to the all chunks that
    # went into making it.
    signal = []
    for idx_chunk, chunk in zip(indices, chunks):
        ddf = ddf_array[idx_chunk[2:]]
        ddf_signal_chunk = dask.delayed(lambda: None)(chunk, ddf)
        signal.append(ddf_signal_chunk)

    ddf_signal = dd.from_delayed(signal, meta=META)
    ddf_signal.__dask_graph__().validate()  # FAILS
```

Output:
```
E               ValueError: incorrect dependencies['finalize-287aac88-1505-4627-8949-4d20bf676833']: {'getitem-5a7a378a35301a5d6727950e7814a5c2'} expected {'concat-732322a8bf255193f89c61560c08bcdb'}
```

**Environment**:

- Dask version: 2021.10.0
- Python version: 3.8.10
- Operating System: Ubuntu 20.1
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/8292/timeline,,,chrisroat,1053153,MDQ6VXNlcjEwNTMxNTM=,https://avatars.githubusercontent.com/u/1053153?v=4,,https://api.github.com/users/chrisroat,https://github.com/chrisroat,https://api.github.com/users/chrisroat/followers,https://api.github.com/users/chrisroat/following{/other_user},https://api.github.com/users/chrisroat/gists{/gist_id},https://api.github.com/users/chrisroat/starred{/owner}{/repo},https://api.github.com/users/chrisroat/subscriptions,https://api.github.com/users/chrisroat/orgs,https://api.github.com/users/chrisroat/repos,https://api.github.com/users/chrisroat/events{/privacy},https://api.github.com/users/chrisroat/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8292/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
506,https://api.github.com/repos/dask/dask/issues/8294,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8294/labels{/name},https://api.github.com/repos/dask/dask/issues/8294/comments,https://api.github.com/repos/dask/dask/issues/8294/events,https://github.com/dask/dask/issues/8294,1034913744,I_kwDOAbcwm849r4fQ,8294,Shuffle prototype: Feedback (disk usage + workers dying),[],open,False,,[],,6,2021-10-25T09:46:15Z,2021-11-06T14:03:01Z,,CONTRIBUTOR,,"I have tried #8223 on a ~3.4TB gzipped Parquet dataset.

I tried four runs so far, with two different behaviours
- First I tried the whole dataset. I got to the last step (`to_parquet`), but then ran out of disk space with over 4TB being used by the shuffle
- The subsequent three runs I have tried to use a subset (by passing a smaller number of files to `read_parquet`). I did not get over the `set_index` step. Workers seem to die and the computation hangs, always towards the end. Errors below.

Based on the first run, this does look like it could've actually been successful if I had more disk space. That's quite exciting, as external sorting has been a big issue for me. 




### Code used
Sadly I cannot share the data. I am at least sharing the code I'm using.

```python
from dask.distributed import Client, LocalCluster
from pathlib import Path

cluster = LocalCluster(n_workers=10, memory_limit='25GB', threads_per_worker=2)
client = Client(cluster)
paths_files = list(Path('.').glob('*/*.parquet'))
columns = ['col_a', 'col_b']

data = dd.read_parquet(paths_files, columns=columns)

# Here is where workers fail and computation hangs (3 out of 4 tries with a subset)
data = data.set_index('col_a', shuffle=""service"")
# Here is where it ran out of disk space (1 out of 4 tries)
data.to_parquet('cache-imported.gz.parq', compression='gzip')
```

### Errors

<details>
  <summary>Orginal error</summary>
  
```python
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:38001
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 205, in read
    frames_nbytes = await stream.read_bytes(fmt_size)
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 492, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 319, in connect
    handshake = await asyncio.wait_for(comm.read(), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 494, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:38001 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:38215
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 245, in write
    async def write(self, msg, serializers=None, on_error=""message""):
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 452, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 320, in connect
    await asyncio.wait_for(comm.write(local_info), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 454, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:38215 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:39419
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 245, in write
    async def write(self, msg, serializers=None, on_error=""message""):
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 452, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 320, in connect
    await asyncio.wait_for(comm.write(local_info), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 454, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:39419 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:42233
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 245, in write
    async def write(self, msg, serializers=None, on_error=""message""):
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 452, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 320, in connect
    await asyncio.wait_for(comm.write(local_info), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 454, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:42233 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:33333
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 245, in write
    async def write(self, msg, serializers=None, on_error=""message""):
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 452, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 320, in connect
    await asyncio.wait_for(comm.write(local_info), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 454, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:33333 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:38215
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 245, in write
    async def write(self, msg, serializers=None, on_error=""message""):
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 452, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 320, in connect
    await asyncio.wait_for(comm.write(local_info), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 454, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:38215 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:33333
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 245, in write
    async def write(self, msg, serializers=None, on_error=""message""):
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 452, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 320, in connect
    await asyncio.wait_for(comm.write(local_info), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 454, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:33333 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:33333
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 245, in write
    async def write(self, msg, serializers=None, on_error=""message""):
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 452, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 320, in connect
    await asyncio.wait_for(comm.write(local_info), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 454, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:33333 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:36893
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 205, in read
    frames_nbytes = await stream.read_bytes(fmt_size)
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 492, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 319, in connect
    handshake = await asyncio.wait_for(comm.read(), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 494, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:36893 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:41795
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 205, in read
    frames_nbytes = await stream.read_bytes(fmt_size)
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 492, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 319, in connect
    handshake = await asyncio.wait_for(comm.read(), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 494, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:41795 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:41795
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 245, in write
    async def write(self, msg, serializers=None, on_error=""message""):
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 452, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 320, in connect
    await asyncio.wait_for(comm.write(local_info), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 454, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:41795 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:41795
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 245, in write
    async def write(self, msg, serializers=None, on_error=""message""):
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 452, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 320, in connect
    await asyncio.wait_for(comm.write(local_info), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 454, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:41795 after 30 s
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:38707
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 205, in read
    frames_nbytes = await stream.read_bytes(fmt_size)
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 492, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 319, in connect
    handshake = await asyncio.wait_for(comm.read(), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 494, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2654, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3982, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 3959, in _get_data
    comm = await rpc.connect(worker)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:38707 after 30 s
distributed.utils - ERROR - (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", [(""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'register-replica', 'released', 'compute-task-1635104458.1960478', 1635104468.872155), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'released', 'fetch', {}, 'compute-task-1635104458.1960478', 1635104468.8722844), ('gather-dependencies', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'stimulus', 1635104468.872853), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'flight', {}, 'ensure-communicating-1635104468.8727045', 1635104468.8728676), ('request-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104468.8727045', 1635104470.384826), ('receive-dep-failed', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104468.8727045', 1635104503.914738), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'missing-dep'), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'fetch', {}, 'ensure-communicating-1635104468.8727045', 1635104503.9147604), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'missing', {}, 'ensure-communicating-1635104503.91477', 1635104503.9147818), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'missing', 'fetch', {}, 'find-missing-1635104504.5391095', 1635104504.5398495), ('gather-dependencies', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'stimulus', 1635104504.5398893), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'flight', {}, 'ensure-communicating-1635104504.5398538', 1635104504.5398993), ('request-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538', 1635104504.5399654), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'cancelled', {}, 'processing-released-1635104504.5400004', 1635104504.5406826), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'cancelled', 'cancelled', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'released'}, 'processing-released-1635104504.5400004', 1635104504.5406876), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'cancelled', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'released'}, 'processing-released-1635104504.5400004', 1635104504.540689), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'release-key', 'processing-released-1635104504.5400004'), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'cancelled', 'released', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'forgotten'}, 'processing-released-1635104504.5400004', 1635104504.5407002), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'released', 'forgotten', {}, 'processing-released-1635104504.5400004', 1635104504.5407038), ('lost-during-gather', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538'), ('receive-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538', 1635104548.287821)])
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils.py"", line 648, in log_errors
    yield
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2745, in gather_dep
    assert ts, (d, self.story(d))
AssertionError: (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", [(""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'register-replica', 'released', 'compute-task-1635104458.1960478', 1635104468.872155), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'released', 'fetch', {}, 'compute-task-1635104458.1960478', 1635104468.8722844), ('gather-dependencies', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'stimulus', 1635104468.872853), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'flight', {}, 'ensure-communicating-1635104468.8727045', 1635104468.8728676), ('request-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104468.8727045', 1635104470.384826), ('receive-dep-failed', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104468.8727045', 1635104503.914738), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'missing-dep'), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'fetch', {}, 'ensure-communicating-1635104468.8727045', 1635104503.9147604), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'missing', {}, 'ensure-communicating-1635104503.91477', 1635104503.9147818), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'missing', 'fetch', {}, 'find-missing-1635104504.5391095', 1635104504.5398495), ('gather-dependencies', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'stimulus', 1635104504.5398893), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'flight', {}, 'ensure-communicating-1635104504.5398538', 1635104504.5398993), ('request-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538', 1635104504.5399654), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'cancelled', {}, 'processing-released-1635104504.5400004', 1635104504.5406826), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'cancelled', 'cancelled', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'released'}, 'processing-released-1635104504.5400004', 1635104504.5406876), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'cancelled', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'released'}, 'processing-released-1635104504.5400004', 1635104504.540689), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'release-key', 'processing-released-1635104504.5400004'), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'cancelled', 'released', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'forgotten'}, 'processing-released-1635104504.5400004', 1635104504.5407002), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'released', 'forgotten', {}, 'processing-released-1635104504.5400004', 1635104504.5407038), ('lost-during-gather', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538'), ('receive-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538', 1635104548.287821)])
tornado.application - ERROR - Exception in callback functools.partial(<bound method IOLoop._discard_future_result of <tornado.platform.asyncio.AsyncIOLoop object at 0x7f5f45925ac0>>, <Task finished name='Task-8548' coro=<Worker.gather_dep() done, defined at /root/miniconda3/lib/python3.9/site-packages/distributed/worker.py:2588> exception=AssertionError((""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", [(""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'register-replica', 'released', 'compute-task-1635104458.1960478', 1635104468.872155), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'released', 'fetch', {}, 'compute-task-1635104458.1960478', 1635104468.8722844), ('gather-dependencies', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'stimulus', 1635104468.872853), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'flight', {}, 'ensure-communicating-1635104468.8727045', 1635104468.8728676), ('request-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104468.8727045', 1635104470.384826), ('receive-dep-failed', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104468.8727045', 1635104503.914738), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'missing-dep'), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'fetch', {}, 'ensure-communicating-1635104468.8727045', 1635104503.9147604), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'missing', {}, 'ensure-communicating-1635104503.91477', 1635104503.9147818), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'missing', 'fetch', {}, 'find-missing-1635104504.5391095', 1635104504.5398495), ('gather-dependencies', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'stimulus', 1635104504.5398893), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'flight', {}, 'ensure-communicating-1635104504.5398538', 1635104504.5398993), ('request-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538', 1635104504.5399654), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'cancelled', {}, 'processing-released-1635104504.5400004', 1635104504.5406826), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'cancelled', 'cancelled', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'released'}, 'processing-released-1635104504.5400004', 1635104504.5406876), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'cancelled', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'released'}, 'processing-released-1635104504.5400004', 1635104504.540689), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'release-key', 'processing-released-1635104504.5400004'), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'cancelled', 'released', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'forgotten'}, 'processing-released-1635104504.5400004', 1635104504.5407002), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'released', 'forgotten', {}, 'processing-released-1635104504.5400004', 1635104504.5407038), ('lost-during-gather', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538'), ('receive-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538', 1635104548.287821)]))>)
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/ioloop.py"", line 741, in _run_callback
    ret = callback()
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/ioloop.py"", line 765, in _discard_future_result
    future.result()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2745, in gather_dep
    assert ts, (d, self.story(d))
AssertionError: (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", [(""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'register-replica', 'released', 'compute-task-1635104458.1960478', 1635104468.872155), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'released', 'fetch', {}, 'compute-task-1635104458.1960478', 1635104468.8722844), ('gather-dependencies', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'stimulus', 1635104468.872853), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'flight', {}, 'ensure-communicating-1635104468.8727045', 1635104468.8728676), ('request-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104468.8727045', 1635104470.384826), ('receive-dep-failed', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104468.8727045', 1635104503.914738), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'missing-dep'), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'fetch', {}, 'ensure-communicating-1635104468.8727045', 1635104503.9147604), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'missing', {}, 'ensure-communicating-1635104503.91477', 1635104503.9147818), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'missing', 'fetch', {}, 'find-missing-1635104504.5391095', 1635104504.5398495), ('gather-dependencies', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'stimulus', 1635104504.5398893), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'fetch', 'flight', {}, 'ensure-communicating-1635104504.5398538', 1635104504.5398993), ('request-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538', 1635104504.5399654), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'cancelled', {}, 'processing-released-1635104504.5400004', 1635104504.5406826), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'cancelled', 'cancelled', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'released'}, 'processing-released-1635104504.5400004', 1635104504.5406876), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'flight', 'cancelled', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'released'}, 'processing-released-1635104504.5400004', 1635104504.540689), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'release-key', 'processing-released-1635104504.5400004'), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'cancelled', 'released', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"": 'forgotten'}, 'processing-released-1635104504.5400004', 1635104504.5407002), (""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)"", 'released', 'forgotten', {}, 'processing-released-1635104504.5400004', 1635104504.5407038), ('lost-during-gather', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538'), ('receive-dep', 'tcp://127.0.0.1:41795', {""('re-quantiles-1-59cbe1d46b9bfe7bf5a9da9c07036ff5', 75)""}, 'ensure-communicating-1635104504.5398538', 1635104548.287821)])
```

</details>
<details>
   <summary> Another error during `to_parquet`</summary>


```python
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:37667
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
ConnectionResetError: [Errno 104] Connection reset by peer

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2741, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4031, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4011, in _get_data
    response = await send_recv(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 640, in send_recv
    response = await comm.read(deserializers=deserializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed) Ephemeral Worker->Worker for gather local=tcp://127.0.0.1:37530 remote=tcp://127.0.0.1:37667>: ConnectionResetError: [Errno 104] Connection reset by peer
distributed.worker - ERROR - failed during get data with tcp://127.0.0.1:37667 -> tcp://127.0.0.1:34511
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
TimeoutError: [Errno 110] Connection timed out

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 1649, in get_data
    response = await comm.read(deserializers=serializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed)  local=tcp://127.0.0.1:37667 remote=tcp://127.0.0.1:37530>: TimeoutError: [Errno 110] Connection timed out
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:36281
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
ConnectionResetError: [Errno 104] Connection reset by peer

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2741, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4031, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4011, in _get_data
    response = await send_recv(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 640, in send_recv
    response = await comm.read(deserializers=deserializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed) Ephemeral Worker->Worker for gather local=tcp://127.0.0.1:45000 remote=tcp://127.0.0.1:36281>: ConnectionResetError: [Errno 104] Connection reset by peer
distributed.worker - ERROR - failed during get data with tcp://127.0.0.1:36281 -> tcp://127.0.0.1:34511
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
TimeoutError: [Errno 110] Connection timed out

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 1649, in get_data
    response = await comm.read(deserializers=serializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed)  local=tcp://127.0.0.1:36281 remote=tcp://127.0.0.1:45000>: TimeoutError: [Errno 110] Connection timed out
tornado.application - ERROR - Exception in callback functools.partial(<bound method IOLoop._discard_future_result of <tornado.platform.asyncio.AsyncIOLoop object at 0x7f348fe7bac0>>, <Task finished name='Task-9116' coro=<Worker.heartbeat() done, defined at /root/miniconda3/lib/python3.9/site-packages/distributed/worker.py:1182> exception=OSError('Timed out during handshake while connecting to tcp://127.0.0.1:43431 after 30 s')>)
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 245, in write
    async def write(self, msg, serializers=None, on_error=""message""):
asyncio.exceptions.CancelledError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 452, in wait_for
    fut.result()
asyncio.exceptions.CancelledError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 320, in connect
    await asyncio.wait_for(comm.write(local_info), time_left())
  File ""/root/miniconda3/lib/python3.9/asyncio/tasks.py"", line 454, in wait_for
    raise exceptions.TimeoutError() from exc
asyncio.exceptions.TimeoutError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/ioloop.py"", line 741, in _run_callback
    ret = callback()
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/ioloop.py"", line 765, in _discard_future_result
    future.result()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 1231, in heartbeat
    raise e
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 1190, in heartbeat
    response = await retry_operation(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 860, in send_recv_from_rpc
    comm = await self.pool.connect(self.addr)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1048, in connect
    raise exc
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 1032, in connect
    comm = await fut
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/core.py"", line 324, in connect
    raise OSError(
OSError: Timed out during handshake while connecting to tcp://127.0.0.1:43431 after 30 s
distributed.worker - ERROR - failed during get data with tcp://127.0.0.1:36281 -> tcp://127.0.0.1:37667
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
TimeoutError: [Errno 110] Connection timed out

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 1649, in get_data
    response = await comm.read(deserializers=serializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed)  local=tcp://127.0.0.1:36281 remote=tcp://127.0.0.1:44898>: TimeoutError: [Errno 110] Connection timed out
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:36281
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
ConnectionResetError: [Errno 104] Connection reset by peer

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2741, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4031, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4011, in _get_data
    response = await send_recv(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 640, in send_recv
    response = await comm.read(deserializers=deserializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed) Ephemeral Worker->Worker for gather local=tcp://127.0.0.1:44898 remote=tcp://127.0.0.1:36281>: ConnectionResetError: [Errno 104] Connection reset by peer
distributed.worker - ERROR - failed during get data with tcp://127.0.0.1:43515 -> tcp://127.0.0.1:37275
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
TimeoutError: [Errno 110] Connection timed out

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 1649, in get_data
    response = await comm.read(deserializers=serializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed)  local=tcp://127.0.0.1:43515 remote=tcp://127.0.0.1:45898>: TimeoutError: [Errno 110] Connection timed out
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:43515
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
ConnectionResetError: [Errno 104] Connection reset by peer

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2741, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4031, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4011, in _get_data
    response = await send_recv(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 640, in send_recv
    response = await comm.read(deserializers=deserializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed) Ephemeral Worker->Worker for gather local=tcp://127.0.0.1:45898 remote=tcp://127.0.0.1:43515>: ConnectionResetError: [Errno 104] Connection reset by peer
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:37275
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
ConnectionResetError: [Errno 104] Connection reset by peer

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2741, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4031, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4011, in _get_data
    response = await send_recv(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 640, in send_recv
    response = await comm.read(deserializers=deserializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed) Ephemeral Worker->Worker for gather local=tcp://127.0.0.1:40650 remote=tcp://127.0.0.1:37275>: ConnectionResetError: [Errno 104] Connection reset by peer
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:43515
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
ConnectionResetError: [Errno 104] Connection reset by peer

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2741, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4031, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4011, in _get_data
    response = await send_recv(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 640, in send_recv
    response = await comm.read(deserializers=deserializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed) Ephemeral Worker->Worker for gather local=tcp://127.0.0.1:46346 remote=tcp://127.0.0.1:43515>: ConnectionResetError: [Errno 104] Connection reset by peer
distributed.worker - ERROR - failed during get data with tcp://127.0.0.1:43515 -> tcp://127.0.0.1:37667
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
TimeoutError: [Errno 110] Connection timed out

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 1649, in get_data
    response = await comm.read(deserializers=serializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed)  local=tcp://127.0.0.1:43515 remote=tcp://127.0.0.1:46346>: TimeoutError: [Errno 110] Connection timed out
distributed.worker - ERROR - failed during get data with tcp://127.0.0.1:37275 -> tcp://127.0.0.1:34511
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
TimeoutError: [Errno 110] Connection timed out

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 1649, in get_data
    response = await comm.read(deserializers=serializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed)  local=tcp://127.0.0.1:37275 remote=tcp://127.0.0.1:40650>: TimeoutError: [Errno 110] Connection timed out
distributed.worker - WARNING - Unmanaged memory use is high. This may indicate a memory leak or the memory may not be released to the OS; see https://distributed.dask.org/en/latest/worker.html#memtrim for more information. -- Unmanaged memory: 29.25 GiB -- Worker memory limit: 46.57 GiB
distributed.worker - ERROR - failed during get data with tcp://127.0.0.1:37667 -> tcp://127.0.0.1:36281
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
TimeoutError: [Errno 110] Connection timed out

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 1649, in get_data
    response = await comm.read(deserializers=serializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed)  local=tcp://127.0.0.1:37667 remote=tcp://127.0.0.1:37070>: TimeoutError: [Errno 110] Connection timed out
distributed.worker - ERROR - Worker stream died during communication: tcp://127.0.0.1:37667
Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 867, in _read_to_buffer
    bytes_read = self.read_from_fd(buf)
  File ""/root/miniconda3/lib/python3.9/site-packages/tornado/iostream.py"", line 1140, in read_from_fd
    return self.socket.recv_into(buf, len(buf))
ConnectionResetError: [Errno 104] Connection reset by peer

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 2741, in gather_dep
    response = await get_data_from_worker(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4031, in get_data_from_worker
    return await retry_operation(_get_data, operation=""get_data_from_worker"")
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 385, in retry_operation
    return await retry(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/utils_comm.py"", line 370, in retry
    return await coro()
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/worker.py"", line 4011, in _get_data
    response = await send_recv(
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/core.py"", line 640, in send_recv
    response = await comm.read(deserializers=deserializers)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 221, in read
    convert_stream_closed_error(self, e)
  File ""/root/miniconda3/lib/python3.9/site-packages/distributed/comm/tcp.py"", line 126, in convert_stream_closed_error
    raise CommClosedError(f""in {obj}: {exc.__class__.__name__}: {exc}"") from exc
distributed.comm.core.CommClosedError: in <TCP (closed) Ephemeral Worker->Worker for gather local=tcp://127.0.0.1:37070 remote=tcp://127.0.0.1:37667>: ConnectionResetError: [Errno 104] Connection reset by peer
distributed.worker - WARNING - Unmanaged memory use is high. This may indicate a memory leak or the memory may not be released to the OS; see https://distributed.dask.org/en/latest/worker.html#memtrim for more information. -- Unmanaged memory: 33.46 GiB -- Worker memory limit: 46.57 GiB
distributed.worker - WARNING - Unmanaged memory use is high. This may indicate a memory leak or the memory may not be released to the OS; see https://distributed.dask.org/en/latest/worker.html#memtrim for more information. -- Unmanaged memory: 33.46 GiB -- Worker memory limit: 46.57 GiB
distributed.worker - WARNING - Compute Failed
Function:  unpack
args:      (<dask.dataframe.shuffle_service.ShuffleService object at 0x7f4627812d00>, 240, None)
kwargs:    {}
Exception: 'AttributeError(""\'ShuffleService\' object has no attribute \'retrieve_futures\'"")'

---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
/tmp/ipykernel_815540/1044375382.py in <module>
----> 1 data.to_parquet('cache-imported.gz.parq', compression='gzip')

~/miniconda3/lib/python3.9/site-packages/dask/dataframe/core.py in to_parquet(self, path, *args, **kwargs)
   4558         from .io import to_parquet
   4559 
-> 4560         return to_parquet(self, path, *args, **kwargs)
   4561 
   4562     def to_orc(self, path, *args, **kwargs):

~/miniconda3/lib/python3.9/site-packages/dask/dataframe/io/parquet/core.py in to_parquet(df, path, engine, compression, write_index, append, overwrite, ignore_divisions, partition_on, storage_options, custom_metadata, write_metadata_file, compute, compute_kwargs, schema, **kwargs)
    723     if compute:
    724         if write_metadata_file:
--> 725             return compute_as_if_collection(
    726                 DataFrame, graph, (final_name, 0), **compute_kwargs
    727             )

~/miniconda3/lib/python3.9/site-packages/dask/base.py in compute_as_if_collection(cls, dsk, keys, scheduler, get, **kwargs)
    313     schedule = get_scheduler(scheduler=scheduler, cls=cls, get=get)
    314     dsk2 = optimization_function(cls)(dsk, keys, **kwargs)
--> 315     return schedule(dsk2, keys, **kwargs)
    316 
    317 

~/miniconda3/lib/python3.9/site-packages/distributed/client.py in get(self, dsk, keys, workers, allow_other_workers, resources, sync, asynchronous, direct, retries, priority, fifo_timeout, actors, **kwargs)
   2691                     should_rejoin = False
   2692             try:
-> 2693                 results = self.gather(packed, asynchronous=asynchronous, direct=direct)
   2694             finally:
   2695                 for f in futures.values():

~/miniconda3/lib/python3.9/site-packages/distributed/client.py in gather(self, futures, errors, direct, asynchronous)
   1967             else:
   1968                 local_worker = None
-> 1969             return self.sync(
   1970                 self._gather,
   1971                 futures,

~/miniconda3/lib/python3.9/site-packages/distributed/client.py in sync(self, func, asynchronous, callback_timeout, *args, **kwargs)
    863             return future
    864         else:
--> 865             return sync(
    866                 self.loop, func, *args, callback_timeout=callback_timeout, **kwargs
    867             )

~/miniconda3/lib/python3.9/site-packages/distributed/utils.py in sync(loop, func, callback_timeout, *args, **kwargs)
    325     if error[0]:
    326         typ, exc, tb = error[0]
--> 327         raise exc.with_traceback(tb)
    328     else:
    329         return result[0]

~/miniconda3/lib/python3.9/site-packages/distributed/utils.py in f()
    308             if callback_timeout is not None:
    309                 future = asyncio.wait_for(future, callback_timeout)
--> 310             result[0] = yield future
    311         except Exception:
    312             error[0] = sys.exc_info()

~/miniconda3/lib/python3.9/site-packages/tornado/gen.py in run(self)
    760 
    761                     try:
--> 762                         value = future.result()
    763                     except Exception:
    764                         exc_info = sys.exc_info()

~/miniconda3/lib/python3.9/site-packages/distributed/client.py in _gather(self, futures, errors, direct, local_worker)
   1832                             exc = CancelledError(key)
   1833                         else:
-> 1834                             raise exception.with_traceback(traceback)
   1835                         raise exc
   1836                     if errors == ""skip"":

~/miniconda3/lib/python3.9/site-packages/dask/dataframe/shuffle_service.py in unpack()
     49     This is a task in the task graph
     50     """"""
---> 51     return service.get(i)
     52 
     53 

~/miniconda3/lib/python3.9/site-packages/dask/dataframe/shuffle_service.py in get()
    726                 # ^ this causes the `process_received_shards` threads to flush any data out
    727                 # of `worker.shuffler`, then stop.
--> 728                 concurrent.futures.wait(self.retrieve_futures)
    729                 self.retrieve_futures.clear()
    730 

AttributeError: 'ShuffleService' object has no attribute 'retrieve_futures'
```

</details>


### Environment
- Dask version: `'2021.09.1+26.gfd1b02b6'` (#8223)
- Pandas: `1.3.1`
- Python version: `3.9.5`
- Operating System: `Ubuntu 18.04.5 LTS`
- Install method (conda, pip, source): `conda`",,https://api.github.com/repos/dask/dask/issues/8294/timeline,,,DahnJ,18722560,MDQ6VXNlcjE4NzIyNTYw,https://avatars.githubusercontent.com/u/18722560?v=4,,https://api.github.com/users/DahnJ,https://github.com/DahnJ,https://api.github.com/users/DahnJ/followers,https://api.github.com/users/DahnJ/following{/other_user},https://api.github.com/users/DahnJ/gists{/gist_id},https://api.github.com/users/DahnJ/starred{/owner}{/repo},https://api.github.com/users/DahnJ/subscriptions,https://api.github.com/users/DahnJ/orgs,https://api.github.com/users/DahnJ/repos,https://api.github.com/users/DahnJ/events{/privacy},https://api.github.com/users/DahnJ/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8294/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
507,https://api.github.com/repos/dask/dask/issues/8307,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8307/labels{/name},https://api.github.com/repos/dask/dask/issues/8307/comments,https://api.github.com/repos/dask/dask/issues/8307/events,https://github.com/dask/dask/issues/8307,1037685892,I_kwDOAbcwm8492dSE,8307,Groupby + split_out fails when key columns have the same name,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2021-10-27T17:37:26Z,2021-12-06T01:48:45Z,,MEMBER,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
Performing a groupby+aggregate while using the `split_out` argument fails in the corner case when the key columns being used to `split_out` might use the same name.

**What you expected to happen**:
Same behavior as when not using `split_out`

**Minimal Complete Verifiable Example**:

```python
from dask import dataframe as dd
import pandas as pd

df = pd.DataFrame({'key':[1,2,1], 'val':[4,5,6]})
ddf = dd.from_pandas(df,2)
ddf.groupby(by=[df[""key""].isna(), df[""key""]]).count(split_out=2).compute()
```

<details>
<summary>Stacktrace</summary>
----> 6 ddf.groupby(by=[df[""key""].isna(), df[""key""]]).count(split_out=2).compute()

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/dask/base.py in compute(self, **kwargs)
    286         dask.base.compute
    287         """"""
--> 288         (result,) = compute(self, traverse=False, **kwargs)
    289         return result
    290 

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/dask/base.py in compute(*args, **kwargs)
    568         postcomputes.append(x.__dask_postcompute__())
    569 
--> 570     results = schedule(dsk, keys, **kwargs)
    571     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    572 

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/dask/threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     77             pool = MultiprocessingPoolExecutor(pool)
     78 
---> 79     results = get_async(
     80         pool.submit,
     81         pool._max_workers,

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/dask/local.py in get_async(submit, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, chunksize, **kwargs)
    515                             _execute_task(task, data)  # Re-execute locally
    516                         else:
--> 517                             raise_exception(exc, tb)
    518                     res, worker_id = loads(res_info)
    519                     state[""cache""][key] = res

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/dask/local.py in reraise(exc, tb)
    323     if exc.__traceback__ is not tb:
    324         raise exc.with_traceback(tb)
--> 325     raise exc
    326 
    327 

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    221     try:
    222         task, data = loads(task_info)
--> 223         result = _execute_task(task, data)
    224         id = get_id()
    225         result = dumps((result, id))

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    119         # temporaries by their reference count and can execute certain
    120         # operations in-place.
--> 121         return func(*(_execute_task(a, cache) for a in args))
    122     elif not ishashable(arg):
    123         return arg

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/dask/dataframe/core.py in hash_shard(df, nparts, split_out_setup, split_out_setup_kwargs, ignore_index)
   5492 ):
   5493     if split_out_setup:
-> 5494         h = split_out_setup(df, **(split_out_setup_kwargs or {}))
   5495     else:
   5496         h = df

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/dask/dataframe/core.py in split_out_on_index(df)
   5512     h = df.index
   5513     if isinstance(h, pd.MultiIndex):
-> 5514         h = pd.DataFrame([], index=h).reset_index()
   5515     return h
   5516 

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/pandas/util/_decorators.py in wrapper(*args, **kwargs)
    309                     stacklevel=stacklevel,
    310                 )
--> 311             return func(*args, **kwargs)
    312 
    313         return wrapper

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/pandas/core/frame.py in reset_index(self, level, drop, inplace, col_level, col_fill)
   5797                     )
   5798 
-> 5799                 new_obj.insert(0, name, level_values)
   5800 
   5801         new_obj.index = new_index

/miniconda3/envs/rapids-21.12/lib/python3.8/site-packages/pandas/core/frame.py in insert(self, loc, column, value, allow_duplicates)
   4412         if not allow_duplicates and column in self.columns:
   4413             # Should this be a different kind of error??
-> 4414             raise ValueError(f""cannot insert {column}, already exists"")
   4415         if not isinstance(loc, int):
   4416             raise TypeError(""loc must be int"")

ValueError: cannot insert key, already exists

</details>


**Anything else we need to know?**: N/A

**Environment**:

- Dask version: 2021.9.1
- Python version: 3.8
- Operating System: ubuntu 18.04
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/8307/timeline,,,ayushdg,19949207,MDQ6VXNlcjE5OTQ5MjA3,https://avatars.githubusercontent.com/u/19949207?v=4,,https://api.github.com/users/ayushdg,https://github.com/ayushdg,https://api.github.com/users/ayushdg/followers,https://api.github.com/users/ayushdg/following{/other_user},https://api.github.com/users/ayushdg/gists{/gist_id},https://api.github.com/users/ayushdg/starred{/owner}{/repo},https://api.github.com/users/ayushdg/subscriptions,https://api.github.com/users/ayushdg/orgs,https://api.github.com/users/ayushdg/repos,https://api.github.com/users/ayushdg/events{/privacy},https://api.github.com/users/ayushdg/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8307/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
508,https://api.github.com/repos/dask/dask/issues/8308,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8308/labels{/name},https://api.github.com/repos/dask/dask/issues/8308/comments,https://api.github.com/repos/dask/dask/issues/8308/events,https://github.com/dask/dask/issues/8308,1037844218,I_kwDOAbcwm8493D76,8308,`map_partitions` only aligns arguments in `*args`; `**kwargs` are concatenated first,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,4,2021-10-27T20:41:34Z,2022-06-24T14:35:46Z,,MEMBER,,"When passing an auxiliary dask DataFrame to `map_partitions`, its chunks are aligned to the main DataFrame and the function receives one chunk of each per task. If you give the same input as a kwarg, the function receives the entire DataFrame concatenated into one.

It's somewhat unclear from the docstring if this is expected behavior:
```
        Arguments and keywords to pass to the function.  At least one of the
        args should be a Dask.dataframe. Arguments and keywords may contain
        ``Scalar``, ``Delayed`` or regular python objects. DataFrame-like args
        (both dask and pandas) will be repartitioned to align (if necessary)
        before applying the function.
```

but either way it's a bit unintuitive that using a positional vs a kwarg would change behavior like this.

**Minimal Complete Verifiable Example**:

```python
import dask
df = dask.datasets.timeseries()
df2 = dask.datasets.timeseries()

def x(p, other):
    assert len(p) == len(other), f""{len(p)=}, {len(other)=}""
    return p.x - other.x

# Works, because `df2` given positionally
df.map_partitions(x, df2).compute()

# Fails, because `df2` given as kwarg
df.map_partitions(x, other=df2).compute()
# AssertionError: len(p)=86400, len(other)=2592000
```

The problem is likely that `map_partitions` finalizes (via `unpack_collections`) everything in kwargs. Additionally, `partitionwise_graph` has lots of unpacking logic for `args` to format them into proper blockwise `(name, indices)` pairs, but `kwargs` are passed through straight to `blockwise` to be treated as 0D objects.

**Anything else we need to know?**:

I would be okay keeping this behavior, but it should be documented much more clearly. Possibly even should raise a warning if a multi-chunk DataFrame/Array is given as a kwarg.

cc @rjzamora @ian-r-rose 

**Environment**:

- Dask version: 824244c14aeb7d9a95b2e08011b36d10b16feeb8
- Python version: 3.9.1
- Operating System: macOS
- Install method (conda, pip, source): source",,https://api.github.com/repos/dask/dask/issues/8308/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8308/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
509,https://api.github.com/repos/dask/dask/issues/8326,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8326/labels{/name},https://api.github.com/repos/dask/dask/issues/8326/comments,https://api.github.com/repos/dask/dask/issues/8326/events,https://github.com/dask/dask/issues/8326,1041676229,I_kwDOAbcwm84-FrfF,8326,GitHub action for stale issues/PRs hitting API limit,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2021-11-01T21:55:50Z,2021-12-06T01:48:43Z,,MEMBER,,"Looking at the [latest run for our new stale issue/PR actions](https://github.com/dask/dask/runs/4063171054?check_suite_focus=true) we see that it's working (:tada:) but we're also getting the following warning

```
Warning: No more operations left! Exiting...
Warning: If you think that not enough issues were processed you could try to increase the quantity related to the operations-per-run (https://github.com/actions/stale#operations-per-run) option which is currently set to 30
```

about hitting the default limit on GitHub API calls (as the warning says, the `actions/stale` action defaults to a limit of 30 API calls, but is configurable via the `operations-per-run` option). My guess is we should increase `operations-per-run` for our stale GHA, but I've not yet looked into what API rate limits GitHub itself imposes. We'll want to strike a balance where the stale action is able to use more API calls while not bringing down other services too. 

cc @GenevieveBuckley @jsignell ",,https://api.github.com/repos/dask/dask/issues/8326/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8326/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
510,https://api.github.com/repos/dask/dask/issues/8334,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8334/labels{/name},https://api.github.com/repos/dask/dask/issues/8334/comments,https://api.github.com/repos/dask/dask/issues/8334/events,https://github.com/dask/dask/issues/8334,1043366185,I_kwDOAbcwm84-MIEp,8334,Use map instead of batch submit in local.get_async,[],open,False,,[],,1,2021-11-03T10:26:08Z,2021-11-29T10:48:31Z,,NONE,,"The _local.get_async_ function only uses the submit function even when the actual scheduler used is a _concurrent.futures.Executor_ and _chunksize > 1_ or a call to the _map_ method would be more efficient. Using the _map_ method would also allow another slightly different approach to be implemented where chunking is delegated to the executor. That is, all tasks could be sent simultaneously using _map_ and the optimization of task distribution would be delegated to the provided executor.
",,https://api.github.com/repos/dask/dask/issues/8334/timeline,,,SebastienDorgan,12728415,MDQ6VXNlcjEyNzI4NDE1,https://avatars.githubusercontent.com/u/12728415?v=4,,https://api.github.com/users/SebastienDorgan,https://github.com/SebastienDorgan,https://api.github.com/users/SebastienDorgan/followers,https://api.github.com/users/SebastienDorgan/following{/other_user},https://api.github.com/users/SebastienDorgan/gists{/gist_id},https://api.github.com/users/SebastienDorgan/starred{/owner}{/repo},https://api.github.com/users/SebastienDorgan/subscriptions,https://api.github.com/users/SebastienDorgan/orgs,https://api.github.com/users/SebastienDorgan/repos,https://api.github.com/users/SebastienDorgan/events{/privacy},https://api.github.com/users/SebastienDorgan/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8334/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
511,https://api.github.com/repos/dask/dask/issues/8340,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8340/labels{/name},https://api.github.com/repos/dask/dask/issues/8340/comments,https://api.github.com/repos/dask/dask/issues/8340/events,https://github.com/dask/dask/issues/8340,1044200140,I_kwDOAbcwm84-PTrM,8340,Dask DataFrame not supported by NumPy functions (NEP-18),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2021-11-03T22:56:29Z,2021-12-06T01:48:42Z,,MEMBER,,"Dask Arrays mostly support [NEP-18](https://numpy.org/neps/nep-0018-array-function-protocol.html) dispatching via `__array_function__`, meaning you can call NumPy functions like `np.where` on dask Arrays, and it'll return dask arrays (dispatching to `dask.array.where` internally).

We should do the same for DataFrames. In the same way that `np.where` and other functions work on pandas DataFrames, they should also work equivalently on dask DataFrames. In practice, I think most NumPy functions on pandas DataFrames return NumPy arrays, so our implementation should probably return dask Arrays to be consistent. But in any case, the input shouldn't be computed.

Note that we do already support `__array_ufunc__` on DataFrame; the next step would be to also support `__array_function__`.

For users transitioning pandas code to dask that involves calling NumPy on DataFrames, this could be helpful.

cc @pentschev @jsignell ",,https://api.github.com/repos/dask/dask/issues/8340/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8340/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
512,https://api.github.com/repos/dask/dask/issues/8353,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8353/labels{/name},https://api.github.com/repos/dask/dask/issues/8353/comments,https://api.github.com/repos/dask/dask/issues/8353/events,https://github.com/dask/dask/issues/8353,1046643696,I_kwDOAbcwm84-YoPw,8353,ignore_index is not used in dd.concat,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2021-11-07T02:29:44Z,2022-08-11T03:17:30Z,,CONTRIBUTOR,,"I am working on making a PR for #8331 and ran into `dd.concat`. (coming soon)
As mentioned elsewhere #7500, #7473, the `ignore_index` keyword is not being used.

Here is a test I added that fails with `ignore_index=True`

```python
@pytest.mark.parametrize(""ignore"", [None, True, False])
def test_concat_ignore_index(ignore):
    arr = np.array([1,2,3])
    df = pd.DataFrame(arr)
    arr2 = np.array([4,5,6])
    df2 = pd.DataFrame(arr2)
    c1 = pd.concat([df, df2], ignore_index=ignore)
    dc1 = dd.concat([df, df2], ignore_index=ignore).compute()
    assert np.allclose(c1.index.values, dc1.index.values)
```
Output:
```
ignore=True
>       assert np.allclose(c1.index.values, dc1.index.values)
E       AssertionError: assert False
E        +  where False = <function allclose at 0x10ad6bf70>(array([0, 1, 2, 3, 4, 5]), array([0, 1, 2, 0, 1, 2]))
E        +    where <function allclose at 0x10ad6bf70> = np.allclose
E        +    and   array([0, 1, 2, 3, 4, 5]) = RangeIndex(start=0, stop=6, step=1).values
E        +      where RangeIndex(start=0, stop=6, step=1) =    0\n0  1\n1  2\n2  3\n3  4\n4  5\n5  6.index
E        +    and   array([0, 1, 2, 0, 1, 2]) = Int64Index([0, 1, 2, 0, 1, 2], dtype='int64').values
E        +      where Int64Index([0, 1, 2, 0, 1, 2], dtype='int64') =    0\n0  1\n1  2\n2  3\n0  4\n1  5\n2  6.index
```
**What happened**:
Index is [0,1,2,0,1,2]
**What you expected to happen**:
Index should be [0,1,2,3,4,5]

**Anything else we need to know?**:
I couldn't fix this for axis=1, axis=0 would be easier
looking at the traceback from the compute call is really confusing to me
It might be the case that [core.py](https://github.com/dask/dask/blob/271016680f0d7d14993763ec618d2062749d24e4/dask/dataframe/core.py#L123) is the issue but I am not sure

**Environment**:

- Dask version:2021.11.0+15.gfd3e4fd8.dirty
- Python version: 3.9.7 
- Operating System: OS X
- Install method (conda, pip, source): source
",,https://api.github.com/repos/dask/dask/issues/8353/timeline,,,boazmohar,9434009,MDQ6VXNlcjk0MzQwMDk=,https://avatars.githubusercontent.com/u/9434009?v=4,,https://api.github.com/users/boazmohar,https://github.com/boazmohar,https://api.github.com/users/boazmohar/followers,https://api.github.com/users/boazmohar/following{/other_user},https://api.github.com/users/boazmohar/gists{/gist_id},https://api.github.com/users/boazmohar/starred{/owner}{/repo},https://api.github.com/users/boazmohar/subscriptions,https://api.github.com/users/boazmohar/orgs,https://api.github.com/users/boazmohar/repos,https://api.github.com/users/boazmohar/events{/privacy},https://api.github.com/users/boazmohar/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8353/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
513,https://api.github.com/repos/dask/dask/issues/8355,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8355/labels{/name},https://api.github.com/repos/dask/dask/issues/8355/comments,https://api.github.com/repos/dask/dask/issues/8355/events,https://github.com/dask/dask/issues/8355,1047002109,I_kwDOAbcwm84-Z_v9,8355,"Could not deserialize task when using `npartitions=""auto""` in `DataFrame.set_index()`","[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,"[{'login': 'ian-r-rose', 'id': 5728311, 'node_id': 'MDQ6VXNlcjU3MjgzMTE=', 'avatar_url': 'https://avatars.githubusercontent.com/u/5728311?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/ian-r-rose', 'html_url': 'https://github.com/ian-r-rose', 'followers_url': 'https://api.github.com/users/ian-r-rose/followers', 'following_url': 'https://api.github.com/users/ian-r-rose/following{/other_user}', 'gists_url': 'https://api.github.com/users/ian-r-rose/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/ian-r-rose/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/ian-r-rose/subscriptions', 'organizations_url': 'https://api.github.com/users/ian-r-rose/orgs', 'repos_url': 'https://api.github.com/users/ian-r-rose/repos', 'events_url': 'https://api.github.com/users/ian-r-rose/events{/privacy}', 'received_events_url': 'https://api.github.com/users/ian-r-rose/received_events', 'type': 'User', 'site_admin': False}]",,5,2021-11-08T04:20:02Z,2022-09-14T18:36:06Z,,NONE,,"**What happened**:

When using `npartitions=""auto""` in `DataFrame.set_index()` on a local distributed cluster, a ""Could not deserialize task"" error occurs (see code and output below).

This happens only when:
1. Instantiating a cluster using `dask.distributed.Client()` (only tested on local, but the intended use case is Dask on Kubernetes).
2. Repartitioning using ""auto"" number of partitions.

**What you expected to happen**:

No error when using `npartitions=""auto""`. The following scenarios work, and all of them produce output like this:

```
Dask DataFrame Structure:
                data
npartitions=1       
               int64
                 ...
Dask Name: sort_index, 10 tasks
```


1. Not running using distributed.

```python
import dask.dataframe as dd
import pandas as pd

# No call to dask.distributed.Client()

dd.from_pandas(
    pd.DataFrame({
        ""id"": pd.Series(dtype=""str""),
        ""data"": pd.Series(dtype=""int"")
    }),
    npartitions=1
).set_index(""id"", npartitions=""auto"")
```

2. Using fixed number of partitions:

```python
from dask.distributed import Client
import dask.dataframe as dd
import pandas as pd

client = Client()

dd.from_pandas(
    pd.DataFrame({
        ""id"": pd.Series(dtype=""str""),
        ""data"": pd.Series(dtype=""int"")
    }),
    npartitions=1
).set_index(""id"", npartitions=1)
```

3. Not specifying `npartitions` argument in `set_index()`:

```python
from dask.distributed import Client
import dask.dataframe as dd
import pandas as pd

client = Client()

dd.from_pandas(
    pd.DataFrame({
        ""id"": pd.Series(dtype=""str""),
        ""data"": pd.Series(dtype=""int"")
    }),
    npartitions=1
).set_index(""id"")
```

**Minimal Complete Verifiable Example**:

```python
from dask.distributed import Client
import dask.dataframe as dd
import pandas as pd

client = Client()

dd.from_pandas(
    pd.DataFrame({
        ""id"": pd.Series(dtype=""str""),
        ""data"": pd.Series(dtype=""int"")
    }),
    npartitions=1
).set_index(""id"", npartitions=""auto"")
```

Output:

```
distributed.worker - ERROR - Could not deserialize task
Traceback (most recent call last):
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/worker.py"", line 4044, in loads_function
    result = cache_loads[bytes_object]
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/utils.py"", line 1354, in __getitem__
    value = super().__getitem__(key)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/collections/__init__.py"", line 1010, in __getitem__
    raise KeyError(key)
KeyError: b'\x80\x04\x95|\x13\x00\x00\x00\x00\x00\x00\x8c\x11dask.optimization\x94\x8c\x10SubgraphCallable\x94\x93\x94(}\x94(\x8c\'sizeof-a3c10fd37d65e26bfa433c2cdb2dd83c\x94(\x8c\ndask.utils\x94\x8c\x05apply\x94\x93\x94\x8c\x13dask.dataframe.core\x94\x8c\x11apply_and_enforce\x94\x93\x94]\x94\x8c\x13__dask_blockwise__0\x94a\x8c\x08builtins\x94\x8c\x04dict\x94\x93\x94]\x94(]\x94(\x8c\x05_func\x94h\x05\x8c\x08Dispatch\x94\x93\x94)\x81\x94}\x94(\x8c\x07_lookup\x94}\x94(h\r\x8c\x06object\x94\x93\x94\x8c\x0bdask.sizeof\x94\x8c\x0esizeof_default\x94\x93\x94h\r\x8c\tbytearray\x94\x93\x94h\x1b\x8c\x0csizeof_bytes\x94\x93\x94h\r\x8c\x05bytes\x94\x93\x94h!h\r\x8c\nmemoryview\x94\x93\x94h\x1b\x8c\x11sizeof_memoryview\x94\x93\x94\x8c\x05array\x94\x8c\x05array\x94\x93\x94h\x1b\x8c\x0csizeof_array\x94\x93\x94h\r\x8c\tfrozenset\x94\x93\x94h\x1b\x8c\x18sizeof_python_collection\x94\x93\x94h\r\x8c\x03set\x94\x93\x94h0h\r\x8c\x05tuple\x94\x93\x94h0h\r\x8c\x04list\x94\x93\x94h0h\x1b\x8c\x0cSimpleSizeof\x94\x93\x94h\x1b\x8c\x0esizeof_blocked\x94\x93\x94h\x0fh\x1b\x8c\x12sizeof_python_dict\x94\x93\x94\x8c\x11pandas.core.frame\x94\x8c\tDataFrame\x94\x93\x94\x8c\x17cloudpickle.cloudpickle\x94\x8c\r_builtin_type\x94\x93\x94\x8c\nLambdaType\x94\x85\x94R\x94(hB\x8c\x08CodeType\x94\x85\x94R\x94(K\x01K\x00K\x00K\x04K\x05K\x13CPt\x00|\x00j\x01\x83\x01}\x01|\x00\xa0\x02\xa1\x00D\x00]0\\\x02}\x02}\x03|\x01|\x03j\x03d\x01d\x02\x8d\x017\x00}\x01|\x03j\x04t\x05k\x02r\x12|\x01\x88\x00|\x03j\x06\x83\x017\x00}\x01q\x12t\x07|\x01\x83\x01d\x03\x17\x00S\x00\x94(N\x89\x8c\x05index\x94\x85\x94M\xe8\x03t\x94(\x8c\x06sizeof\x94hJ\x8c\titeritems\x94\x8c\x0cmemory_usage\x94\x8c\x05dtype\x94\x8c\x06object\x94\x8c\x07_values\x94\x8c\x03int\x94t\x94(\x8c\x02df\x94\x8c\x01p\x94\x8c\x04name\x94\x8c\x03col\x94t\x94\x8cP/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/dask/sizeof.py\x94\x8c\x17sizeof_pandas_dataframe\x94K\x94C\x0c\x00\x02\n\x01\x10\x01\x10\x01\n\x01\x10\x01\x94\x8c\x0bobject_size\x94\x85\x94)t\x94R\x94}\x94(\x8c\x0b__package__\x94\x8c\x04dask\x94\x8c\x08__name__\x94h\x1b\x8c\x08__file__\x94\x8cP/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/dask/sizeof.py\x94uNNh@\x8c\x10_make_empty_cell\x94\x93\x94)R\x94\x85\x94t\x94R\x94\x8c\x1ccloudpickle.cloudpickle_fast\x94\x8c\x12_function_setstate\x94\x93\x94hl}\x94}\x94(hdh[\x8c\x0c__qualname__\x94\x8c0register_pandas.<locals>.sizeof_pandas_dataframe\x94\x8c\x0f__annotations__\x94}\x94\x8c\x0e__kwdefaults__\x94N\x8c\x0c__defaults__\x94N\x8c\n__module__\x94h\x1b\x8c\x07__doc__\x94N\x8c\x0b__closure__\x94h@\x8c\n_make_cell\x94\x93\x94hE(hH(K\x01K\x00K\x00K\x02K\x05K\x13C@t\x00|\x00\x83\x01s\x0cd\x01S\x00\x88\x00j\x01j\x02|\x00d\x02d\x03d\x04\x8d\x03}\x01t\x03t\x04t\x05|\x01\x83\x02\x83\x01}\x01t\x06|\x01\x83\x01d\x02\x1b\x00t\x00|\x00\x83\x01\x14\x00S\x00\x94(NK\x00K\x14\x88\x8c\x04size\x94\x8c\x07replace\x94\x86\x94t\x94(\x8c\x03len\x94\x8c\x06random\x94\x8c\x06choice\x94\x8c\x04list\x94\x8c\x03map\x94hM\x8c\x03sum\x94t\x94\x8c\x01x\x94\x8c\x06sample\x94\x86\x94hZh]K\x8dC\n\x00\x01\x08\x01\x04\x01\x12\x01\x0e\x01\x94\x8c\x02np\x94\x85\x94)t\x94R\x94haNNhh)R\x94\x85\x94t\x94R\x94hoh\x94}\x94}\x94(hdh]hr\x8c$register_pandas.<locals>.object_size\x94ht}\x94hvNhwNhxh\x1bhyNhzh|h@\x8c\tsubimport\x94\x93\x94\x8c\x05numpy\x94\x85\x94R\x94\x85\x94R\x94\x85\x94\x8c\x17_cloudpickle_submodules\x94]\x94h\x9a\x8c\x0cnumpy.random\x94\x85\x94R\x94a\x8c\x0b__globals__\x94}\x94hMh\x15su\x86\x94\x86R0\x85\x94R\x94\x85\x94h\xa1]\x94h\xa6}\x94hMh\x15su\x86\x94\x86R0\x8c\x12pandas.core.series\x94\x8c\x06Series\x94\x93\x94hE(hH(K\x01K\x00K\x00K\x02K\x04K\x13CNt\x00|\x00j\x01d\x01d\x02\x8d\x01\x83\x01}\x01|\x00j\x02t\x03k\x02r(|\x01\x88\x00|\x00j\x04\x83\x017\x00}\x01|\x00j\x05j\x02t\x03k\x02rB|\x01\x88\x00|\x00j\x05\x83\x017\x00}\x01t\x00|\x01\x83\x01d\x03\x17\x00S\x00\x94(N\x88hKM\xe8\x03t\x94(hShOhPhQhRhJt\x94\x8c\x01s\x94hV\x86\x94hZ\x8c\x14sizeof_pandas_series\x94K\x9dC\x0c\x00\x02\x10\x01\n\x01\x0e\x01\x0c\x01\x0e\x01\x94h^)t\x94R\x94haNNhh)R\x94\x85\x94t\x94R\x94hoh\xbe}\x94}\x94(hdh\xb7hr\x8c-register_pandas.<locals>.sizeof_pandas_series\x94ht}\x94hvNhwNhxh\x1bhyNhzh\xaa\x85\x94h\xa1]\x94h\xa6}\x94u\x86\x94\x86R0\x8c\x18pandas.core.indexes.base\x94\x8c\x05Index\x94\x93\x94hE(hH(K\x01K\x00K\x00K\x02K\x03K\x13C.t\x00|\x00\xa0\x01\xa1\x00\x83\x01}\x01|\x00j\x02t\x03k\x02r""|\x01\x88\x00|\x00\x83\x017\x00}\x01t\x00|\x01\x83\x01d\x01\x17\x00S\x00\x94NM\xe8\x03\x86\x94(hShOhPhQt\x94\x8c\x01i\x94hV\x86\x94hZ\x8c\x13sizeof_pandas_index\x94K\xa6C\x08\x00\x02\x0c\x01\n\x01\x0c\x01\x94h^)t\x94R\x94haNNhh)R\x94\x85\x94t\x94R\x94hoh\xd6}\x94}\x94(hdh\xcfhr\x8c,register_pandas.<locals>.sizeof_pandas_index\x94ht}\x94hvNhwNhxh\x1bhyNhzh\xaa\x85\x94h\xa1]\x94h\xa6}\x94u\x86\x94\x86R0\x8c\x19pandas.core.indexes.multi\x94\x8c\nMultiIndex\x94\x93\x94hE(hH(K\x01K\x00K\x00K\x03K\x05K\x13CNt\x00t\x01\x87\x00f\x01d\x01d\x02\x84\x08|\x00j\x02D\x00\x83\x01\x83\x01\x83\x01}\x01t\x03|\x00d\x03\x83\x02r,|\x00j\x04n\x04|\x00j\x05D\x00]\x0e}\x02|\x01|\x02j\x067\x00}\x01q2t\x00|\x01\x83\x01d\x04\x17\x00S\x00\x94(NhH(K\x01K\x00K\x00K\x02K\x03K3C\x16|\x00]\x0e}\x01\x88\x00|\x01\x83\x01V\x00\x01\x00q\x02d\x00S\x00\x94N\x85\x94)\x8c\x02.0\x94\x8c\x01l\x94\x86\x94hZ\x8c\t<genexpr>\x94K\xafC\x04\x04\x00\x02\x00\x94h^)t\x94R\x94\x8cDregister_pandas.<locals>.sizeof_pandas_multiindex.<locals>.<genexpr>\x94\x8c\x05codes\x94M\xe8\x03t\x94(hSh\x87\x8c\x06levels\x94\x8c\x07hasattr\x94h\xed\x8c\x06labels\x94\x8c\x06nbytes\x94t\x94h\xcdhV\x8c\x01c\x94\x87\x94hZ\x8c\x18sizeof_pandas_multiindex\x94K\xadC\x08\x00\x02\x1c\x01\x1a\x01\x0c\x01\x94h^)t\x94R\x94haNNhh)R\x94\x85\x94t\x94R\x94hoh\xfd}\x94}\x94(hdh\xf6hr\x8c1register_pandas.<locals>.sizeof_pandas_multiindex\x94ht}\x94hvNhwNhxh\x1bhyNhzh\xaa\x85\x94h\xa1]\x94h\xa6}\x94u\x86\x94\x86R0h\r\x8c\x03str\x94\x93\x94h\x1dh\r\x8c\x04type\x94\x93\x94N\x85\x94R\x94h\x1dh\r\x8c\x04bool\x94\x93\x94h\x1dh\x9b\x8c\x07ndarray\x94\x93\x94hE(hH(K\x01K\x00K\x00K\x02K\x04KSC2d\x01|\x00j\x00k\x06r(|\x00t\x01d\x02d\x03\x84\x00|\x00j\x00D\x00\x83\x01\x83\x01\x19\x00}\x01|\x01j\x02S\x00t\x03|\x00j\x02\x83\x01S\x00\x94(NK\x00hH(K\x01K\x00K\x00K\x02K\x03KsC&|\x00]\x1e}\x01|\x01d\x00k\x03r\x16t\x00d\x01\x83\x01n\x06t\x00d\x02\x83\x01V\x00\x01\x00q\x02d\x01S\x00\x94K\x00NK\x01\x87\x94\x8c\x05slice\x94\x85\x94h\xe5h\xb5\x86\x94hZh\xe8K\x83C\x04\x04\x00\x02\x00\x94))t\x94R\x94\x8c?register_numpy.<locals>.sizeof_numpy_ndarray.<locals>.<genexpr>\x94t\x94(\x8c\x07strides\x94\x8c\x05tuple\x94h\xf2hSt\x94h\x89\x8c\x02xs\x94\x86\x94hZ\x8c\x14sizeof_numpy_ndarray\x94K\x80C\x08\x00\x02\n\x01\x18\x01\x06\x01\x94))t\x94R\x94haNNNt\x94R\x94hoj%\x01\x00\x00}\x94}\x94(hdj \x01\x00\x00hr\x8c,register_numpy.<locals>.sizeof_numpy_ndarray\x94ht}\x94hvNhwNhxh\x1bhyNhzNh\xa1]\x94h\xa6}\x94u\x86\x94\x86R0h@\x8c\x14_make_skeleton_class\x94\x93\x94(j.\x01\x00\x00(j\t\x01\x00\x00\x8c\n_DTypeMeta\x94j\t\x01\x00\x00\x85\x94}\x94\x8c 59f7a7c093a8408cb673ce696810d0d8\x94Nt\x94R\x94hm\x8c\x0f_class_setstate\x94\x93\x94j4\x01\x00\x00}\x94(\x8c\x08__init__\x94\x8c\x08builtins\x94\x8c\x07getattr\x94\x93\x94j4\x01\x00\x00j8\x01\x00\x00\x86\x94R\x94\x8c\x07__new__\x94j;\x01\x00\x00j4\x01\x00\x00\x8c\x07__new__\x94\x86\x94R\x94\x8c\t_abstract\x94j;\x01\x00\x00j4\x01\x00\x00jB\x01\x00\x00\x86\x94R\x94\x8c\x04type\x94j;\x01\x00\x00j4\x01\x00\x00jE\x01\x00\x00\x86\x94R\x94\x8c\x0b_parametric\x94j;\x01\x00\x00j4\x01\x00\x00jH\x01\x00\x00\x86\x94R\x94hy\x8c;Preliminary NumPy API: The Type of NumPy DTypes (metaclass)\x94u}\x94\x86\x94\x86R0\x8c\x0edtype[object_]\x94h\x9bhP\x93\x94\x85\x94}\x94\x8c 907c0e4265ec4814bf26c2d9a242a34a\x94Nt\x94R\x94j6\x01\x00\x00jT\x01\x00\x00}\x94(j>\x01\x00\x00j;\x01\x00\x00jT\x01\x00\x00\x8c\x07__new__\x94\x86\x94R\x94hyNu}\x94\x86\x94\x86R0h\x1dh\r\x8c\x03int\x94\x93\x94h\x1du\x8c\x05_lazy\x94}\x94(\x8c\x04cupy\x94h\x1b\x8c\rregister_cupy\x94\x93\x94\x8c\x05numba\x94h\x1b\x8c\x0eregister_numba\x94\x93\x94\x8c\x03rmm\x94h\x1b\x8c\x0cregister_rmm\x94\x93\x94\x8c\x05scipy\x94h\x1b\x8c\x11register_spmatrix\x94\x93\x94\x8c\x07pyarrow\x94h\x1b\x8c\x10register_pyarrow\x94\x93\x94uhdhMube]\x94(\x8c\x05_meta\x94h\xb1)\x81\x94}\x94(\x8c\x04_mgr\x94\x8c\x1epandas.core.internals.managers\x94\x8c\x12SingleBlockManager\x94\x93\x94)\x81\x94(]\x94h\xc7\x8c\n_new_Index\x94\x93\x94\x8c\x19pandas.core.indexes.range\x94\x8c\nRangeIndex\x94\x93\x94}\x94(hWN\x8c\x05start\x94K\x00\x8c\x04stop\x94K\x00\x8c\x04step\x94K\x01u\x86\x94R\x94a]\x94\x8c\x15numpy.core.multiarray\x94\x8c\x0c_reconstruct\x94\x93\x94j\x0f\x01\x00\x00K\x00\x85\x94C\x01b\x94\x87\x94R\x94(K\x01K\x00\x85\x94jO\x01\x00\x00\x8c\x02i8\x94\x89\x88\x87\x94R\x94(K\x03\x8c\x01<\x94NNNJ\xff\xff\xff\xffJ\xff\xff\xff\xffK\x00t\x94b\x89C\x00\x94t\x94ba]\x94jy\x01\x00\x00\x8c\x1bpandas.core.indexes.numeric\x94\x8c\nInt64Index\x94\x93\x94}\x94(\x8c\x04data\x94j\x86\x01\x00\x00j\x0f\x01\x00\x00K\x00\x85\x94j\x88\x01\x00\x00\x87\x94R\x94(K\x01K\x00\x85\x94j\x8e\x01\x00\x00\x89j\x91\x01\x00\x00t\x94bhWNu\x86\x94R\x94a}\x94\x8c\x060.14.1\x94}\x94(\x8c\x04axes\x94jw\x01\x00\x00\x8c\x06blocks\x94]\x94}\x94(\x8c\x06values\x94j\x8a\x01\x00\x00\x8c\x08mgr_locs\x94j\x86\x01\x00\x00j\x0f\x01\x00\x00K\x00\x85\x94j\x88\x01\x00\x00\x87\x94R\x94(K\x01K\x00\x85\x94j\x8e\x01\x00\x00\x89j\x91\x01\x00\x00t\x94buaust\x94b\x8c\x04_typ\x94\x8c\x06series\x94\x8c\t_metadata\x94]\x94hWa\x8c\x05attrs\x94}\x94\x8c\x06_flags\x94}\x94\x8c\x17allows_duplicate_labels\x94\x88shWNubee\x86\x94t\x94\x8c\x13__dask_blockwise__1\x94\x8c,from_pandas-1f79779fe4332aa2089519b52d3e3b08\x94uh\x04\x8c\x13__dask_blockwise__0\x94\x85\x94\x8c6subgraph_callable-240ce47e-86ed-41ab-88e2-655035bf9e42\x94t\x94R\x94.'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/worker.py"", line 3100, in _maybe_deserialize_task
    function, args, kwargs = _deserialize(*ts.runspec)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/worker.py"", line 4055, in _deserialize
    function = loads_function(function)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/worker.py"", line 4046, in loads_function
    result = pickle.loads(bytes_object)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/protocol/pickle.py"", line 75, in loads
    return pickle.loads(x)
AttributeError: type object '_DTypeMeta' has no attribute '_abstract'
distributed.worker - ERROR - Exception during execution of task ('sizeof-a3c10fd37d65e26bfa433c2cdb2dd83c', 0).
Traceback (most recent call last):
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/worker.py"", line 4044, in loads_function
    result = cache_loads[bytes_object]
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/utils.py"", line 1354, in __getitem__
    value = super().__getitem__(key)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/collections/__init__.py"", line 1010, in __getitem__
    raise KeyError(key)
KeyError: b'\x80\x04\x95|\x13\x00\x00\x00\x00\x00\x00\x8c\x11dask.optimization\x94\x8c\x10SubgraphCallable\x94\x93\x94(}\x94(\x8c\'sizeof-a3c10fd37d65e26bfa433c2cdb2dd83c\x94(\x8c\ndask.utils\x94\x8c\x05apply\x94\x93\x94\x8c\x13dask.dataframe.core\x94\x8c\x11apply_and_enforce\x94\x93\x94]\x94\x8c\x13__dask_blockwise__0\x94a\x8c\x08builtins\x94\x8c\x04dict\x94\x93\x94]\x94(]\x94(\x8c\x05_func\x94h\x05\x8c\x08Dispatch\x94\x93\x94)\x81\x94}\x94(\x8c\x07_lookup\x94}\x94(h\r\x8c\x06object\x94\x93\x94\x8c\x0bdask.sizeof\x94\x8c\x0esizeof_default\x94\x93\x94h\r\x8c\tbytearray\x94\x93\x94h\x1b\x8c\x0csizeof_bytes\x94\x93\x94h\r\x8c\x05bytes\x94\x93\x94h!h\r\x8c\nmemoryview\x94\x93\x94h\x1b\x8c\x11sizeof_memoryview\x94\x93\x94\x8c\x05array\x94\x8c\x05array\x94\x93\x94h\x1b\x8c\x0csizeof_array\x94\x93\x94h\r\x8c\tfrozenset\x94\x93\x94h\x1b\x8c\x18sizeof_python_collection\x94\x93\x94h\r\x8c\x03set\x94\x93\x94h0h\r\x8c\x05tuple\x94\x93\x94h0h\r\x8c\x04list\x94\x93\x94h0h\x1b\x8c\x0cSimpleSizeof\x94\x93\x94h\x1b\x8c\x0esizeof_blocked\x94\x93\x94h\x0fh\x1b\x8c\x12sizeof_python_dict\x94\x93\x94\x8c\x11pandas.core.frame\x94\x8c\tDataFrame\x94\x93\x94\x8c\x17cloudpickle.cloudpickle\x94\x8c\r_builtin_type\x94\x93\x94\x8c\nLambdaType\x94\x85\x94R\x94(hB\x8c\x08CodeType\x94\x85\x94R\x94(K\x01K\x00K\x00K\x04K\x05K\x13CPt\x00|\x00j\x01\x83\x01}\x01|\x00\xa0\x02\xa1\x00D\x00]0\\\x02}\x02}\x03|\x01|\x03j\x03d\x01d\x02\x8d\x017\x00}\x01|\x03j\x04t\x05k\x02r\x12|\x01\x88\x00|\x03j\x06\x83\x017\x00}\x01q\x12t\x07|\x01\x83\x01d\x03\x17\x00S\x00\x94(N\x89\x8c\x05index\x94\x85\x94M\xe8\x03t\x94(\x8c\x06sizeof\x94hJ\x8c\titeritems\x94\x8c\x0cmemory_usage\x94\x8c\x05dtype\x94\x8c\x06object\x94\x8c\x07_values\x94\x8c\x03int\x94t\x94(\x8c\x02df\x94\x8c\x01p\x94\x8c\x04name\x94\x8c\x03col\x94t\x94\x8cP/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/dask/sizeof.py\x94\x8c\x17sizeof_pandas_dataframe\x94K\x94C\x0c\x00\x02\n\x01\x10\x01\x10\x01\n\x01\x10\x01\x94\x8c\x0bobject_size\x94\x85\x94)t\x94R\x94}\x94(\x8c\x0b__package__\x94\x8c\x04dask\x94\x8c\x08__name__\x94h\x1b\x8c\x08__file__\x94\x8cP/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/dask/sizeof.py\x94uNNh@\x8c\x10_make_empty_cell\x94\x93\x94)R\x94\x85\x94t\x94R\x94\x8c\x1ccloudpickle.cloudpickle_fast\x94\x8c\x12_function_setstate\x94\x93\x94hl}\x94}\x94(hdh[\x8c\x0c__qualname__\x94\x8c0register_pandas.<locals>.sizeof_pandas_dataframe\x94\x8c\x0f__annotations__\x94}\x94\x8c\x0e__kwdefaults__\x94N\x8c\x0c__defaults__\x94N\x8c\n__module__\x94h\x1b\x8c\x07__doc__\x94N\x8c\x0b__closure__\x94h@\x8c\n_make_cell\x94\x93\x94hE(hH(K\x01K\x00K\x00K\x02K\x05K\x13C@t\x00|\x00\x83\x01s\x0cd\x01S\x00\x88\x00j\x01j\x02|\x00d\x02d\x03d\x04\x8d\x03}\x01t\x03t\x04t\x05|\x01\x83\x02\x83\x01}\x01t\x06|\x01\x83\x01d\x02\x1b\x00t\x00|\x00\x83\x01\x14\x00S\x00\x94(NK\x00K\x14\x88\x8c\x04size\x94\x8c\x07replace\x94\x86\x94t\x94(\x8c\x03len\x94\x8c\x06random\x94\x8c\x06choice\x94\x8c\x04list\x94\x8c\x03map\x94hM\x8c\x03sum\x94t\x94\x8c\x01x\x94\x8c\x06sample\x94\x86\x94hZh]K\x8dC\n\x00\x01\x08\x01\x04\x01\x12\x01\x0e\x01\x94\x8c\x02np\x94\x85\x94)t\x94R\x94haNNhh)R\x94\x85\x94t\x94R\x94hoh\x94}\x94}\x94(hdh]hr\x8c$register_pandas.<locals>.object_size\x94ht}\x94hvNhwNhxh\x1bhyNhzh|h@\x8c\tsubimport\x94\x93\x94\x8c\x05numpy\x94\x85\x94R\x94\x85\x94R\x94\x85\x94\x8c\x17_cloudpickle_submodules\x94]\x94h\x9a\x8c\x0cnumpy.random\x94\x85\x94R\x94a\x8c\x0b__globals__\x94}\x94hMh\x15su\x86\x94\x86R0\x85\x94R\x94\x85\x94h\xa1]\x94h\xa6}\x94hMh\x15su\x86\x94\x86R0\x8c\x12pandas.core.series\x94\x8c\x06Series\x94\x93\x94hE(hH(K\x01K\x00K\x00K\x02K\x04K\x13CNt\x00|\x00j\x01d\x01d\x02\x8d\x01\x83\x01}\x01|\x00j\x02t\x03k\x02r(|\x01\x88\x00|\x00j\x04\x83\x017\x00}\x01|\x00j\x05j\x02t\x03k\x02rB|\x01\x88\x00|\x00j\x05\x83\x017\x00}\x01t\x00|\x01\x83\x01d\x03\x17\x00S\x00\x94(N\x88hKM\xe8\x03t\x94(hShOhPhQhRhJt\x94\x8c\x01s\x94hV\x86\x94hZ\x8c\x14sizeof_pandas_series\x94K\x9dC\x0c\x00\x02\x10\x01\n\x01\x0e\x01\x0c\x01\x0e\x01\x94h^)t\x94R\x94haNNhh)R\x94\x85\x94t\x94R\x94hoh\xbe}\x94}\x94(hdh\xb7hr\x8c-register_pandas.<locals>.sizeof_pandas_series\x94ht}\x94hvNhwNhxh\x1bhyNhzh\xaa\x85\x94h\xa1]\x94h\xa6}\x94u\x86\x94\x86R0\x8c\x18pandas.core.indexes.base\x94\x8c\x05Index\x94\x93\x94hE(hH(K\x01K\x00K\x00K\x02K\x03K\x13C.t\x00|\x00\xa0\x01\xa1\x00\x83\x01}\x01|\x00j\x02t\x03k\x02r""|\x01\x88\x00|\x00\x83\x017\x00}\x01t\x00|\x01\x83\x01d\x01\x17\x00S\x00\x94NM\xe8\x03\x86\x94(hShOhPhQt\x94\x8c\x01i\x94hV\x86\x94hZ\x8c\x13sizeof_pandas_index\x94K\xa6C\x08\x00\x02\x0c\x01\n\x01\x0c\x01\x94h^)t\x94R\x94haNNhh)R\x94\x85\x94t\x94R\x94hoh\xd6}\x94}\x94(hdh\xcfhr\x8c,register_pandas.<locals>.sizeof_pandas_index\x94ht}\x94hvNhwNhxh\x1bhyNhzh\xaa\x85\x94h\xa1]\x94h\xa6}\x94u\x86\x94\x86R0\x8c\x19pandas.core.indexes.multi\x94\x8c\nMultiIndex\x94\x93\x94hE(hH(K\x01K\x00K\x00K\x03K\x05K\x13CNt\x00t\x01\x87\x00f\x01d\x01d\x02\x84\x08|\x00j\x02D\x00\x83\x01\x83\x01\x83\x01}\x01t\x03|\x00d\x03\x83\x02r,|\x00j\x04n\x04|\x00j\x05D\x00]\x0e}\x02|\x01|\x02j\x067\x00}\x01q2t\x00|\x01\x83\x01d\x04\x17\x00S\x00\x94(NhH(K\x01K\x00K\x00K\x02K\x03K3C\x16|\x00]\x0e}\x01\x88\x00|\x01\x83\x01V\x00\x01\x00q\x02d\x00S\x00\x94N\x85\x94)\x8c\x02.0\x94\x8c\x01l\x94\x86\x94hZ\x8c\t<genexpr>\x94K\xafC\x04\x04\x00\x02\x00\x94h^)t\x94R\x94\x8cDregister_pandas.<locals>.sizeof_pandas_multiindex.<locals>.<genexpr>\x94\x8c\x05codes\x94M\xe8\x03t\x94(hSh\x87\x8c\x06levels\x94\x8c\x07hasattr\x94h\xed\x8c\x06labels\x94\x8c\x06nbytes\x94t\x94h\xcdhV\x8c\x01c\x94\x87\x94hZ\x8c\x18sizeof_pandas_multiindex\x94K\xadC\x08\x00\x02\x1c\x01\x1a\x01\x0c\x01\x94h^)t\x94R\x94haNNhh)R\x94\x85\x94t\x94R\x94hoh\xfd}\x94}\x94(hdh\xf6hr\x8c1register_pandas.<locals>.sizeof_pandas_multiindex\x94ht}\x94hvNhwNhxh\x1bhyNhzh\xaa\x85\x94h\xa1]\x94h\xa6}\x94u\x86\x94\x86R0h\r\x8c\x03str\x94\x93\x94h\x1dh\r\x8c\x04type\x94\x93\x94N\x85\x94R\x94h\x1dh\r\x8c\x04bool\x94\x93\x94h\x1dh\x9b\x8c\x07ndarray\x94\x93\x94hE(hH(K\x01K\x00K\x00K\x02K\x04KSC2d\x01|\x00j\x00k\x06r(|\x00t\x01d\x02d\x03\x84\x00|\x00j\x00D\x00\x83\x01\x83\x01\x19\x00}\x01|\x01j\x02S\x00t\x03|\x00j\x02\x83\x01S\x00\x94(NK\x00hH(K\x01K\x00K\x00K\x02K\x03KsC&|\x00]\x1e}\x01|\x01d\x00k\x03r\x16t\x00d\x01\x83\x01n\x06t\x00d\x02\x83\x01V\x00\x01\x00q\x02d\x01S\x00\x94K\x00NK\x01\x87\x94\x8c\x05slice\x94\x85\x94h\xe5h\xb5\x86\x94hZh\xe8K\x83C\x04\x04\x00\x02\x00\x94))t\x94R\x94\x8c?register_numpy.<locals>.sizeof_numpy_ndarray.<locals>.<genexpr>\x94t\x94(\x8c\x07strides\x94\x8c\x05tuple\x94h\xf2hSt\x94h\x89\x8c\x02xs\x94\x86\x94hZ\x8c\x14sizeof_numpy_ndarray\x94K\x80C\x08\x00\x02\n\x01\x18\x01\x06\x01\x94))t\x94R\x94haNNNt\x94R\x94hoj%\x01\x00\x00}\x94}\x94(hdj \x01\x00\x00hr\x8c,register_numpy.<locals>.sizeof_numpy_ndarray\x94ht}\x94hvNhwNhxh\x1bhyNhzNh\xa1]\x94h\xa6}\x94u\x86\x94\x86R0h@\x8c\x14_make_skeleton_class\x94\x93\x94(j.\x01\x00\x00(j\t\x01\x00\x00\x8c\n_DTypeMeta\x94j\t\x01\x00\x00\x85\x94}\x94\x8c 59f7a7c093a8408cb673ce696810d0d8\x94Nt\x94R\x94hm\x8c\x0f_class_setstate\x94\x93\x94j4\x01\x00\x00}\x94(\x8c\x08__init__\x94\x8c\x08builtins\x94\x8c\x07getattr\x94\x93\x94j4\x01\x00\x00j8\x01\x00\x00\x86\x94R\x94\x8c\x07__new__\x94j;\x01\x00\x00j4\x01\x00\x00\x8c\x07__new__\x94\x86\x94R\x94\x8c\t_abstract\x94j;\x01\x00\x00j4\x01\x00\x00jB\x01\x00\x00\x86\x94R\x94\x8c\x04type\x94j;\x01\x00\x00j4\x01\x00\x00jE\x01\x00\x00\x86\x94R\x94\x8c\x0b_parametric\x94j;\x01\x00\x00j4\x01\x00\x00jH\x01\x00\x00\x86\x94R\x94hy\x8c;Preliminary NumPy API: The Type of NumPy DTypes (metaclass)\x94u}\x94\x86\x94\x86R0\x8c\x0edtype[object_]\x94h\x9bhP\x93\x94\x85\x94}\x94\x8c 907c0e4265ec4814bf26c2d9a242a34a\x94Nt\x94R\x94j6\x01\x00\x00jT\x01\x00\x00}\x94(j>\x01\x00\x00j;\x01\x00\x00jT\x01\x00\x00\x8c\x07__new__\x94\x86\x94R\x94hyNu}\x94\x86\x94\x86R0h\x1dh\r\x8c\x03int\x94\x93\x94h\x1du\x8c\x05_lazy\x94}\x94(\x8c\x04cupy\x94h\x1b\x8c\rregister_cupy\x94\x93\x94\x8c\x05numba\x94h\x1b\x8c\x0eregister_numba\x94\x93\x94\x8c\x03rmm\x94h\x1b\x8c\x0cregister_rmm\x94\x93\x94\x8c\x05scipy\x94h\x1b\x8c\x11register_spmatrix\x94\x93\x94\x8c\x07pyarrow\x94h\x1b\x8c\x10register_pyarrow\x94\x93\x94uhdhMube]\x94(\x8c\x05_meta\x94h\xb1)\x81\x94}\x94(\x8c\x04_mgr\x94\x8c\x1epandas.core.internals.managers\x94\x8c\x12SingleBlockManager\x94\x93\x94)\x81\x94(]\x94h\xc7\x8c\n_new_Index\x94\x93\x94\x8c\x19pandas.core.indexes.range\x94\x8c\nRangeIndex\x94\x93\x94}\x94(hWN\x8c\x05start\x94K\x00\x8c\x04stop\x94K\x00\x8c\x04step\x94K\x01u\x86\x94R\x94a]\x94\x8c\x15numpy.core.multiarray\x94\x8c\x0c_reconstruct\x94\x93\x94j\x0f\x01\x00\x00K\x00\x85\x94C\x01b\x94\x87\x94R\x94(K\x01K\x00\x85\x94jO\x01\x00\x00\x8c\x02i8\x94\x89\x88\x87\x94R\x94(K\x03\x8c\x01<\x94NNNJ\xff\xff\xff\xffJ\xff\xff\xff\xffK\x00t\x94b\x89C\x00\x94t\x94ba]\x94jy\x01\x00\x00\x8c\x1bpandas.core.indexes.numeric\x94\x8c\nInt64Index\x94\x93\x94}\x94(\x8c\x04data\x94j\x86\x01\x00\x00j\x0f\x01\x00\x00K\x00\x85\x94j\x88\x01\x00\x00\x87\x94R\x94(K\x01K\x00\x85\x94j\x8e\x01\x00\x00\x89j\x91\x01\x00\x00t\x94bhWNu\x86\x94R\x94a}\x94\x8c\x060.14.1\x94}\x94(\x8c\x04axes\x94jw\x01\x00\x00\x8c\x06blocks\x94]\x94}\x94(\x8c\x06values\x94j\x8a\x01\x00\x00\x8c\x08mgr_locs\x94j\x86\x01\x00\x00j\x0f\x01\x00\x00K\x00\x85\x94j\x88\x01\x00\x00\x87\x94R\x94(K\x01K\x00\x85\x94j\x8e\x01\x00\x00\x89j\x91\x01\x00\x00t\x94buaust\x94b\x8c\x04_typ\x94\x8c\x06series\x94\x8c\t_metadata\x94]\x94hWa\x8c\x05attrs\x94}\x94\x8c\x06_flags\x94}\x94\x8c\x17allows_duplicate_labels\x94\x88shWNubee\x86\x94t\x94\x8c\x13__dask_blockwise__1\x94\x8c,from_pandas-1f79779fe4332aa2089519b52d3e3b08\x94uh\x04\x8c\x13__dask_blockwise__0\x94\x85\x94\x8c6subgraph_callable-240ce47e-86ed-41ab-88e2-655035bf9e42\x94t\x94R\x94.'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/worker.py"", line 3181, in execute
    function, args, kwargs = await self._maybe_deserialize_task(
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/worker.py"", line 3100, in _maybe_deserialize_task
    function, args, kwargs = _deserialize(*ts.runspec)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/worker.py"", line 4055, in _deserialize
    function = loads_function(function)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/worker.py"", line 4046, in loads_function
    result = pickle.loads(bytes_object)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/protocol/pickle.py"", line 75, in loads
    return pickle.loads(x)
AttributeError: type object '_DTypeMeta' has no attribute '_abstract'
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/dask/dataframe/core.py"", line 4344, in set_index
    return set_index(
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/dask/dataframe/shuffle.py"", line 191, in set_index
    divisions, mins, maxes = _calculate_divisions(
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/dask/dataframe/shuffle.py"", line 40, in _calculate_divisions
    divisions, sizes, mins, maxes = base.compute(divisions, sizes, mins, maxes)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/dask/base.py"", line 570, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/client.py"", line 2693, in get
    results = self.gather(packed, asynchronous=asynchronous, direct=direct)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/client.py"", line 1969, in gather
    return self.sync(
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/client.py"", line 865, in sync
    return sync(
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/utils.py"", line 327, in sync
    raise exc.with_traceback(tb)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/utils.py"", line 310, in f
    result[0] = yield future
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/tornado/gen.py"", line 762, in run
    value = future.result()
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/client.py"", line 1834, in _gather
    raise exception.with_traceback(traceback)
  File ""/Users/aloysius/mambaforge/envs/swarm/lib/python3.8/site-packages/distributed/protocol/pickle.py"", line 75, in loads
    return pickle.loads(x)
AttributeError: type object '_DTypeMeta' has no attribute '_abstract'
```


**Anything else we need to know?**:

**Environment**:

- Dask version: 2021.10.0
- Distributed version: 2021.10.0
- Python version: 3.8.12
- Operating System: MacOS 11.6
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/8355/timeline,,,aloysius-lim,3433970,MDQ6VXNlcjM0MzM5NzA=,https://avatars.githubusercontent.com/u/3433970?v=4,,https://api.github.com/users/aloysius-lim,https://github.com/aloysius-lim,https://api.github.com/users/aloysius-lim/followers,https://api.github.com/users/aloysius-lim/following{/other_user},https://api.github.com/users/aloysius-lim/gists{/gist_id},https://api.github.com/users/aloysius-lim/starred{/owner}{/repo},https://api.github.com/users/aloysius-lim/subscriptions,https://api.github.com/users/aloysius-lim/orgs,https://api.github.com/users/aloysius-lim/repos,https://api.github.com/users/aloysius-lim/events{/privacy},https://api.github.com/users/aloysius-lim/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8355/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,ian-r-rose,5728311.0,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False
514,https://api.github.com/repos/dask/dask/issues/8357,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8357/labels{/name},https://api.github.com/repos/dask/dask/issues/8357/comments,https://api.github.com/repos/dask/dask/issues/8357/events,https://github.com/dask/dask/issues/8357,1047537630,I_kwDOAbcwm84-cCfe,8357,Support Dask Dataframe Transpose,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,2,2021-11-08T14:45:10Z,2022-08-25T17:20:54Z,,NONE,,Please add API-support for DataFrame transpose as we do in pandas with DataFrame.transpose(),,https://api.github.com/repos/dask/dask/issues/8357/timeline,,,mohamedniyaz1996,36036555,MDQ6VXNlcjM2MDM2NTU1,https://avatars.githubusercontent.com/u/36036555?v=4,,https://api.github.com/users/mohamedniyaz1996,https://github.com/mohamedniyaz1996,https://api.github.com/users/mohamedniyaz1996/followers,https://api.github.com/users/mohamedniyaz1996/following{/other_user},https://api.github.com/users/mohamedniyaz1996/gists{/gist_id},https://api.github.com/users/mohamedniyaz1996/starred{/owner}{/repo},https://api.github.com/users/mohamedniyaz1996/subscriptions,https://api.github.com/users/mohamedniyaz1996/orgs,https://api.github.com/users/mohamedniyaz1996/repos,https://api.github.com/users/mohamedniyaz1996/events{/privacy},https://api.github.com/users/mohamedniyaz1996/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8357/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
515,https://api.github.com/repos/dask/dask/issues/8361,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8361/labels{/name},https://api.github.com/repos/dask/dask/issues/8361/comments,https://api.github.com/repos/dask/dask/issues/8361/events,https://github.com/dask/dask/issues/8361,1047842440,I_kwDOAbcwm84-dM6I,8361,Optimized groupby aggregations when grouping by a sorted index,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,"[{'login': 'jcrist', 'id': 2783717, 'node_id': 'MDQ6VXNlcjI3ODM3MTc=', 'avatar_url': 'https://avatars.githubusercontent.com/u/2783717?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/jcrist', 'html_url': 'https://github.com/jcrist', 'followers_url': 'https://api.github.com/users/jcrist/followers', 'following_url': 'https://api.github.com/users/jcrist/following{/other_user}', 'gists_url': 'https://api.github.com/users/jcrist/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/jcrist/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/jcrist/subscriptions', 'organizations_url': 'https://api.github.com/users/jcrist/orgs', 'repos_url': 'https://api.github.com/users/jcrist/repos', 'events_url': 'https://api.github.com/users/jcrist/events{/privacy}', 'received_events_url': 'https://api.github.com/users/jcrist/received_events', 'type': 'User', 'site_admin': False}]",,11,2021-11-08T19:33:20Z,2022-03-24T16:02:37Z,,MEMBER,,"Similar request to https://github.com/dask/dask/issues/2999

When grouping by the index, and the index has known divisions, most aggregations could be a simple `map_partitions`. Since each partition already contains all the values for an output group[^1], there's no need to exchange data between partitions.

However in these cases, we still do `apply_concat_apply`, `_cum_agg`, etc. and generate complex graphs that involve a lot of data transfer.

In normal pandas use, I'm not sure how common it is to groupby the index versus a column. However, in dask, using the known divisions of the index is highly recommended (see [best practices](https://docs.dask.org/en/stable/dataframe-best-practices.html#use-the-index)) and something users should try to do, especially with large datasets. In particular, once shuffling performs better (xref https://github.com/dask/distributed/pull/5435), a pattern of doing one `set_index` up front (or using a partitioned data format like Parquet) and then many fast operations on that should be effective.

I'd want something like this to involve minimal data transfer after the `set_index` step:
```python
import dask.dataframe as dd
df = dd.read_parquet(...)
# a savvy user recognizes this is worthwhile since there are multiple date ops to do next
df_by_day = df.set_index(""date"")

daily_users = df_by_day.groupby([""date"", ""user_id""]).count()
daily_sales = df_by_day.groupby([""date"", ""sale_amt""]).sum()

daily_summary = daily_counts.merge(daily_sales, on=""date"")
# ^ this should be fast since both groupbys have retained their `divisions`
```

Someday, it might be nice if users didn't even have to do the `set_index`, and we had an optimization that could recognize that multiple groupbys would benefit from a pre-shuffle and insert one automatically. However, that's a hard optimization to implement (might require HLEs https://github.com/dask/dask/issues/7933) and a ways off. Getting users to understand that they should use `set_index` more carefully than in pandas, and its importance as a performance tool, seems easier. As we do that, let's make sure we're taking as much advantage of it as possible.

[^1] When all the rows in a partition have the same index value, then you do need to combine partitions. For example: in `divisions=[0, 1, 2, 2, 4, 5]`, the partitions containing 1-2, 2-2, and 2-4 would need to be combined, probably using the normal `apply_concat_apply` logic. However, since we know the divisions, we can be more selective about where we do this and reduce some transfer. With well-balanced partitions, this should be a relatively rare case, and there usually shouldn't be more than a handful of consecutive partitions with the same value.",,https://api.github.com/repos/dask/dask/issues/8361/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8361/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,jcrist,2783717.0,MDQ6VXNlcjI3ODM3MTc=,https://avatars.githubusercontent.com/u/2783717?v=4,,https://api.github.com/users/jcrist,https://github.com/jcrist,https://api.github.com/users/jcrist/followers,https://api.github.com/users/jcrist/following{/other_user},https://api.github.com/users/jcrist/gists{/gist_id},https://api.github.com/users/jcrist/starred{/owner}{/repo},https://api.github.com/users/jcrist/subscriptions,https://api.github.com/users/jcrist/orgs,https://api.github.com/users/jcrist/repos,https://api.github.com/users/jcrist/events{/privacy},https://api.github.com/users/jcrist/received_events,User,False
516,https://api.github.com/repos/dask/dask/issues/8377,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8377/labels{/name},https://api.github.com/repos/dask/dask/issues/8377/comments,https://api.github.com/repos/dask/dask/issues/8377/events,https://github.com/dask/dask/issues/8377,1051764708,I_kwDOAbcwm84-sKfk,8377,"Thoughts on ""Getting Started"" section","[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2021-11-12T09:36:27Z,2021-12-20T01:50:32Z,,MEMBER,,"Currently the ""Getting Started"" section does a few things really well. It explains how to install Dask and shows how to work with some synthetic data. Then it jumps to talks and tutorials, which are useful, but maybe a little time consuming (and possibly should be at the end of the section or a different one). While ""Best Practices"" is also useful, this is pretty heady for someone getting started (at least should be later in the listing). The ""How To"" part seems mostly to be deployment, which useful, but maybe we should just rename it that way? The FAQ part still seems useful (maybe the title can be clarified).

<hr>

As a starting user, my thought process would be:

* What does this do? Why do I need it? ""10 Minutes to Dask"" answers this
* How do I install it? ""Install Dask"" also answers this
* How do I load my data? .... (unanswered) in fact this requires a deep dive in the docs to answer (just did this to help a new user)
* How does this work for larger than memory data or distributed data? ... (unanswered)
* How do I deploy Dask on my local HPC env or in the cloud? Answered in ""How To"". Maybe we should rename to ""Deployment""?
* What should I watch out for? ""Best Practices"" should go here
* Where should I go if I have more questions? Maybe have an ""Additional Resources"" section with ""Talks Tutorials"", ""FAQ"", links to GH, Discourse, Stack Overflow, etc.

Sorry if this comes off as overly opinionated. Just thinking through how we can improve this when trying to leverage this info myself to share with someone else. Please feel free to share other thoughts :)",,https://api.github.com/repos/dask/dask/issues/8377/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8377/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
517,https://api.github.com/repos/dask/dask/issues/8380,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8380/labels{/name},https://api.github.com/repos/dask/dask/issues/8380/comments,https://api.github.com/repos/dask/dask/issues/8380/events,https://github.com/dask/dask/issues/8380,1053960824,I_kwDOAbcwm84-0ip4,8380,da.store loses dependency information,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,12,2021-11-15T18:10:00Z,2022-12-09T15:38:41Z,,CONTRIBUTOR,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:

I'm trying to take the result from a `map_blocks` function and store one slice of the resulting array in one zarr array and another slice in another array. I set `compute=False` on the `da.store` calls so that I can compute them together later and avoid computing the array multiple times. However, it seems the map blocks function is called for each store operation. From what I can tell the dependency graph is getting lost.

**What you expected to happen**:

Two `da.store` calls with shared tasks on their dask graphs should share computations when computed at the same time.

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.array as da
import numpy as np

TOTAL_CALLS = 0


def shared_task2(arr1):
    global TOTAL_CALLS
    TOTAL_CALLS += 1
    return np.stack([arr1 + 1, arr1 + 2])


if __name__ == ""__main__"":
    start = da.zeros((2, 2), chunks=1)
    src = da.map_blocks(shared_task2, start, dtype=start.dtype,
                        meta=np.array((), dtype=start.dtype),
                        new_axis=[0],
                        chunks=(2,) + start.chunks)
    target1 = np.zeros((2, 2))
    target2 = np.zeros((2, 2))

    with dask.config.set(schedulers='single-threaded'):
        store_res1 = da.store(src[0], target1, compute=False)
        store_res2 = da.store(src[1], target2, compute=False)
        da.compute(store_res1, store_res2)
    # one call per chunk
    assert TOTAL_CALLS == start.blocks.size
```

**Anything else we need to know?**:

As mentioned above, I'm actually trying to use `to_zarr` to save some dask arrays. I want to write them to zarr and then get the resulting loaded zarr arrays as results, but I couldn't find a way to do that with the combination of `return_stored` and `compute=False` as you need to compute to write to the zarr arrays, but that then returns the resulting numpy arrays.

Also note that my map_blocks function is returning the `np.stack` because it is actually returning two results. 

**Environment**:

- Dask version: 2021.11.1
- Python version: 3.9
- Operating System: Ubuntu/PopOS
- Install method (conda, pip, source): conda-forge
",,https://api.github.com/repos/dask/dask/issues/8380/timeline,,,djhoese,1828519,MDQ6VXNlcjE4Mjg1MTk=,https://avatars.githubusercontent.com/u/1828519?v=4,,https://api.github.com/users/djhoese,https://github.com/djhoese,https://api.github.com/users/djhoese/followers,https://api.github.com/users/djhoese/following{/other_user},https://api.github.com/users/djhoese/gists{/gist_id},https://api.github.com/users/djhoese/starred{/owner}{/repo},https://api.github.com/users/djhoese/subscriptions,https://api.github.com/users/djhoese/orgs,https://api.github.com/users/djhoese/repos,https://api.github.com/users/djhoese/events{/privacy},https://api.github.com/users/djhoese/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8380/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
518,https://api.github.com/repos/dask/dask/issues/8415,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8415/labels{/name},https://api.github.com/repos/dask/dask/issues/8415/comments,https://api.github.com/repos/dask/dask/issues/8415/events,https://github.com/dask/dask/issues/8415,1061129156,I_kwDOAbcwm84_P4vE,8415,"Documentation for `set_index(col, compute=True)` is unclear/inaccurate","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,13,2021-11-23T11:16:03Z,2022-03-01T17:55:55Z,,CONTRIBUTOR,,"I think the documentation is currently unclear/inaccurate about the nature of the `compute` parameter for `set_index`:

```python
df.set_index(col, compute=True)
```

The documentation currently contains this description:
> compute: bool, default False
> - Whether or not to trigger an immediate computation. Defaults to False. Note, that even if you set compute=False, an immediate computation will still be triggered if divisions is None.

This would suggest that if I provide divisions and set `compute=True`, immediate computation will be triggered. This only seems to be the case when using `shuffle=disk`, however. Even then, it's not clear to me what is actually being computed.

Examples from the SO question where I originally asked about this ([What does set_index(col, compute=True) do in Dask?](https://stackoverflow.com/questions/70012274/what-does-set-indexcol-compute-true-do-in-dask)):

```python
import dask.datasets
df = dask.datasets.timeseries()

# Nothing gets submitted to the scheduler
df.set_index(
    'name', 
    divisions=('Alice', 'Michael', 'Zelda'), 
    compute=True
) 
```

Going down the stack of functions `set_index` actually calls, it appears that the only place where `compute` is actually used in [`rearrange_by_column_disk`](https://github.com/dask/dask/blob/8aea537d925b794a94f828d35211a5da05ad9dce/dask/dataframe/shuffle.py#L501). And indeed:

```python
# Still, nothing gets submitted
df.set_index(
    'name', 
    divisions=('Alice', 'Michael', 'Zelda'), 
    shuffle='tasks',
    compute=True
) 

# Something is computed here
df.set_index(
    'name', 
    divisions=('Alice', 'Michael', 'Zelda'), 
    shuffle='disk',
    compute=True
) 
```

If I'm correct, then I believe the documentation should reflect the fact that this setting only affects the `shuffle=disk` case. Also, I can't work out from the documentation what is actually being computed  ""immediate computation"" of what?",,https://api.github.com/repos/dask/dask/issues/8415/timeline,,,DahnJ,18722560,MDQ6VXNlcjE4NzIyNTYw,https://avatars.githubusercontent.com/u/18722560?v=4,,https://api.github.com/users/DahnJ,https://github.com/DahnJ,https://api.github.com/users/DahnJ/followers,https://api.github.com/users/DahnJ/following{/other_user},https://api.github.com/users/DahnJ/gists{/gist_id},https://api.github.com/users/DahnJ/starred{/owner}{/repo},https://api.github.com/users/DahnJ/subscriptions,https://api.github.com/users/DahnJ/orgs,https://api.github.com/users/DahnJ/repos,https://api.github.com/users/DahnJ/events{/privacy},https://api.github.com/users/DahnJ/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8415/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
519,https://api.github.com/repos/dask/dask/issues/8421,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8421/labels{/name},https://api.github.com/repos/dask/dask/issues/8421/comments,https://api.github.com/repos/dask/dask/issues/8421/events,https://github.com/dask/dask/issues/8421,1063915604,I_kwDOAbcwm84_ahBU,8421,DataFrame.groupby sorts group keys even with sort=False,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}, {'id': 3798450422, 'node_id': 'LA_kwDOAbcwm87iZ8D2', 'url': 'https://api.github.com/repos/dask/dask/labels/p3', 'name': 'p3', 'color': 'ffff33', 'default': False, 'description': 'Affects a small number of users or is largely cosmetic'}]",open,False,,"[{'login': 'ian-r-rose', 'id': 5728311, 'node_id': 'MDQ6VXNlcjU3MjgzMTE=', 'avatar_url': 'https://avatars.githubusercontent.com/u/5728311?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/ian-r-rose', 'html_url': 'https://github.com/ian-r-rose', 'followers_url': 'https://api.github.com/users/ian-r-rose/followers', 'following_url': 'https://api.github.com/users/ian-r-rose/following{/other_user}', 'gists_url': 'https://api.github.com/users/ian-r-rose/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/ian-r-rose/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/ian-r-rose/subscriptions', 'organizations_url': 'https://api.github.com/users/ian-r-rose/orgs', 'repos_url': 'https://api.github.com/users/ian-r-rose/repos', 'events_url': 'https://api.github.com/users/ian-r-rose/events{/privacy}', 'received_events_url': 'https://api.github.com/users/ian-r-rose/received_events', 'type': 'User', 'site_admin': False}]",,1,2021-11-25T20:57:25Z,2022-08-25T17:12:35Z,,NONE,,"**What happened**:
The row with group key/index `A` is sorted before `B` after the `.last()` computation, even though `sort=False` is passed and the doc states ""Sort group keys. Get better performance by turning this off."".

I'm guessing this has to do with the fact that Dask does not implement the `as_index` parameter, so the group keys are always the index and therefore sorted. But this should be reflected in the `sort` doc, removed completely, or `as_index=False` should be supported.

**What you expected to happen**:
The row with group key/index `B` is still sorted before `A` after the `.last()` computation.

```python
import pandas as pd
from dask.dataframe import from_pandas

df = pd.DataFrame([['2021-11-24', 'B'], ['2021-11-25', 'A']], columns=['DATE', 'HASH'])

result = from_pandas(df, npartitions=1).groupby('HASH', sort=False).last().compute()
print(result)
```
```
            DATE
HASH            
A     2021-11-25
B     2021-11-24
```


**Anything else we need to know?**:
I also tried it with [Dask 2.11.0 / 2020-02-19](https://docs.dask.org/en/latest/changelog.html#id128) where the `sort` argument was first exposed for `groupby`, and even there it is not working as intended.

**Environment**:

- Dask version: 2021.11.2
- Python version: 3.9
- Operating System: Window 10
- Install method: pip
",,https://api.github.com/repos/dask/dask/issues/8421/timeline,,,ghost,10137,MDQ6VXNlcjEwMTM3,https://avatars.githubusercontent.com/u/10137?v=4,,https://api.github.com/users/ghost,https://github.com/ghost,https://api.github.com/users/ghost/followers,https://api.github.com/users/ghost/following{/other_user},https://api.github.com/users/ghost/gists{/gist_id},https://api.github.com/users/ghost/starred{/owner}{/repo},https://api.github.com/users/ghost/subscriptions,https://api.github.com/users/ghost/orgs,https://api.github.com/users/ghost/repos,https://api.github.com/users/ghost/events{/privacy},https://api.github.com/users/ghost/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8421/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,ian-r-rose,5728311.0,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False
520,https://api.github.com/repos/dask/dask/issues/8430,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8430/labels{/name},https://api.github.com/repos/dask/dask/issues/8430/comments,https://api.github.com/repos/dask/dask/issues/8430/events,https://github.com/dask/dask/pull/8430,1066545676,PR_kwDOAbcwm84vJ0qc,8430,Make sort on groupby also affect the groupby sort on the chunk,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2021-11-29T21:59:19Z,2022-03-23T17:35:56Z,,MEMBER,,"- [x] Closes #8421
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/8430/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8430/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8430,https://github.com/dask/dask/pull/8430,https://github.com/dask/dask/pull/8430.diff,https://github.com/dask/dask/pull/8430.patch,,,,,,,,,,,,,,,,,,,
521,https://api.github.com/repos/dask/dask/issues/8435,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8435/labels{/name},https://api.github.com/repos/dask/dask/issues/8435/comments,https://api.github.com/repos/dask/dask/issues/8435/events,https://github.com/dask/dask/issues/8435,1067687316,I_kwDOAbcwm84_o52U,8435,[Discussion] Don't compute divisions by default in `set_index`?,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,8,2021-11-30T21:21:24Z,2022-03-03T19:41:18Z,,MEMBER,,"Calling `df.set_index('foo')` currently calculates all of `df` immediately, in order to pick values for `divisions`. This is helpful, but also makes it very easy to trigger a large computation, and the eagerness is inconsistent with Dask's lazy API.

Downsides of this are illustrated in [this blog post](https://targomo.medium.com/how-we-learned-to-love-dask-and-achieved-a-40x-speedup-aa14e72d99c0#534f) by @DahnJ. This default behavior makes it very easy for you to do something that's very not performant, and relatively hard to figure out why it's happening.

If you're running a whole script (versus a notebook with separate cells), it would not be immediately clear that `set_index` is even calling compute internally, and you'll be left puzzling over the dashboard about why the ""calculation seems to re-set and begin again"".

Additionally, since it's so easy to compute divisions automatically, users rarely interact with them. This makes the idea of setting them manually intimidating, when in fact it's actually pretty straightforward. (Hopefully better documentation helps with this https://github.com/dask/dask/pull/8379). And since users don't interact with them, they wouldn't realize there's even an option to avoid this computation until they read the docstring of `set_index`.

Basically, I think _not_ passing divisions to `set_index` should be considered an antipattern. There are only a few cases where it's unavoidable and you need to calculate divisions, and it's always far less performant.

Therefore, if we agree it's an antipattern, we should have our API guide users away from it (the ""pit of success"").

So I propose:
```python-traceback
>>> df.set_index('foo')
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
...
ValueError: No divisions specified. Pass `divisions=[...]` to specify the ""dividing lines"" used to split
the new index into partitions.

Alternatively, pass `divisions=""compute""` to have Dask compute good divisions for you right now.
This can be expensive, since it computes the entire DataFrame eagerly.
If you use `divisions=""compute""`, we recommend printing the `.divisions` of the resulting DataFrame
and copy-pasting them back into this line of code, so if you re-run it, divisions won't be re-calculated.

For more information, see https://docs.dask.org/en/stable/generated/dask.dataframe.DataFrame.set_index.html.
```

This way:
1. Users have to be explicitly aware of the eager compute, and have to ask for it.
2. Users can't pick the antipattern without first being presented with the recommended alternative.
3. The `""compute""` in the code is hopefully a flag to other readers that some computation is going on; you don't have to know `set_index`'s default behavior to recognize this.

Of course, we'd have a deprecation cycle with a warning before this became an error. I'd also be excited to add some tools to help users:
1. Generate reasonable divisions when they know something about the data (save typing)
2. Check whether the divisions they've picked are good
3. Suggest ""how"" to pick divisions?

cc @jsignell @scharlottej13 @ian-r-rose @jrbourbeau @jcrist ",,https://api.github.com/repos/dask/dask/issues/8435/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8435/reactions,4,4,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
522,https://api.github.com/repos/dask/dask/issues/8437,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8437/labels{/name},https://api.github.com/repos/dask/dask/issues/8437/comments,https://api.github.com/repos/dask/dask/issues/8437/events,https://github.com/dask/dask/issues/8437,1067879313,I_kwDOAbcwm84_pouR,8437,"When `divisions` has repeats, `set_index` puts all data in the last partition instead of balancing it","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2021-12-01T02:25:16Z,2021-12-01T09:14:44Z,,MEMBER,,"Reported in https://stackoverflow.com/a/70178087/17100540 by @DahnJ.

Given imbalanced data, you want the same value to be split across multiple output partitions:
```python
In [1]: import dask.dataframe as dd
In [2]: import pandas as pd
In [3]: df = pd.DataFrame({""A"": [0] * 10, ""B"": range(10)})
In [4]: ddf = dd.from_pandas(df, npartitions=5)
In [5]: s = ddf.set_index(""A"")
In [6]: s.divisions
(0, 0, 0, 0, 0, 0)
```

However, when the shuffle actually happens, all the data ends up in the last possible partition:
```python
In [6]: dask.compute(*s.to_delayed())
Out[6]: 
(Empty DataFrame
 Columns: [B]
 Index: [],
 Empty DataFrame
 Columns: [B]
 Index: [],
 Empty DataFrame
 Columns: [B]
 Index: [],
 Empty DataFrame
 Columns: [B]
 Index: [],
    B
 A   
 0  2
 0  3
 0  4
 0  5
 0  8
 0  9
 0  0
 0  1
 0  6
 0  7)
```

_EDIT: I realized that although `set_index` will calculate `(0, 0, 0, 0, 0, 0)` as good divisions, if you pass in `divisions=(0, 0, 0, 0, 0, 0)`, you'll get `ValueError: New division must be unique, except for the last element`. So clearly there's some disagreement about whether repeated values are even valid divisions (xref https://github.com/dask/dask/pull/8393, cc @charlesbluca). This, plus @SultanOrazbayev's last code snippet [on SO](https://stackoverflow.com/a/69616798/17100540), makes me think DataFrame generally doesn't support duplicate divisions, and it's simply a bug that `set_index` doesn't deduplicate the output of `partition_quantiles`. That said, I think we should support duplicate divisions, since it's a reasonable thing to need when you have imbalanced data._

The problem is in the [`set_partitions_pre`](https://github.com/dask/dask/blob/a5aecac8313fea30c5503f534c71f325b1775b9c/dask/dataframe/shuffle.py#L793-L813) step of `set_index`, where we calculate which output partition number each row should belong to. We call `searchsorted` on `divisions` (as a Series); `s` is the values we're reindexing by:
https://github.com/dask/dask/blob/a5aecac8313fea30c5503f534c71f325b1775b9c/dask/dataframe/shuffle.py#L796

Because of `side=""right""`, when there are duplicate values in `divisions`, `searchsorted` always returns the index of the last duplicatehence why all the data ends up in the last possible partition. With `side=""left""`, it would be the other way around (all data in the first partition).

With some clever counting, I think we could deal with this while still using `searchsorted`. We'd probably want to remove duplicates from `divisions` and keep an auxiliary list of how many duplicates each division has (basically [compute a run-length encoding](https://stackoverflow.com/a/69693227/17100540)). Then, if the output partition for a row has duplicates, we pick randomly between the N options? Or something like that.

The way the output partition is selected from N options is probably the trickiest part. Assuming that `divisions` represents an approximately uniform partitioning of the data, then I _think_ picking from the N options at random would maintain that desired distribution.

Though I'm not sure how to handle the ""edge"" partitions. For `divisions=(0, 1, 1, 2)`, a value of `1` could go to any of the three output partitions. However, the first and last partitions will also get `0`s and `2`s, respectively, whereas the middle partition will only get `1`s. So to maintain uniform partition sizes, you'd want to send more `1`s to the middle partition than the othersbasically bias the random selection towards that? The problem is, you don't know how much to do so, because you don't know how many `1`s there are relative to `0`s and `2`s, or even how many other values there are between `0` and `1`.

**Environment**:

- Dask version: a5aecac8313fea30c5503f534c71f325b1775b9c
- Python version: 3.8.8
- Operating System: macOS
- Install method (conda, pip, source): source",,https://api.github.com/repos/dask/dask/issues/8437/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8437/reactions,4,2,0,0,0,0,0,2,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
523,https://api.github.com/repos/dask/dask/issues/8442,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8442/labels{/name},https://api.github.com/repos/dask/dask/issues/8442/comments,https://api.github.com/repos/dask/dask/issues/8442/events,https://github.com/dask/dask/pull/8442,1069744779,PR_kwDOAbcwm84vUW_h,8442,Optimize groupby when `by` contains `ddf.index`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,10,2021-12-02T16:26:00Z,2022-04-19T12:52:50Z,,MEMBER,,"- [x] Closes #8361
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/8442/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8442/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8442,https://github.com/dask/dask/pull/8442,https://github.com/dask/dask/pull/8442.diff,https://github.com/dask/dask/pull/8442.patch,,,,,,,,,,,,,,,,,,,
524,https://api.github.com/repos/dask/dask/issues/8447,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8447/labels{/name},https://api.github.com/repos/dask/dask/issues/8447/comments,https://api.github.com/repos/dask/dask/issues/8447/events,https://github.com/dask/dask/issues/8447,1070091934,I_kwDOAbcwm84_yE6e,8447,Consider reactivating low-level DataFrame optimization when not all layers are Blockwise,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2021-12-03T00:10:05Z,2021-12-03T02:57:35Z,,MEMBER,,"Since https://github.com/dask/dask/pull/7620, we've seen a few instances where users have gotten burned by root-task overproduction (see https://github.com/dask/distributed/issues/5555, https://github.com/dask/distributed/issues/5223 for background) because certain DataFrame optimizations still use low-level graphs, and therefore aren't getting fused anymore. Examples:
* https://github.com/dask/dask/issues/8445
* https://github.com/dask/dask/issues/8309
* https://github.com/dask/dask/issues/8306

We do want to get everything to Blockwise eventually, but our bandwith to track these down and fix them is limited. In the interim, I propose that by default, we still do low-level fusion when any of the layers in the graph are materialized.

cc @rjzamora @ian-r-rose @jrbourbeau ",,https://api.github.com/repos/dask/dask/issues/8447/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8447/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
525,https://api.github.com/repos/dask/dask/issues/8448,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8448/labels{/name},https://api.github.com/repos/dask/dask/issues/8448/comments,https://api.github.com/repos/dask/dask/issues/8448/events,https://github.com/dask/dask/issues/8448,1070096130,I_kwDOAbcwm84_yF8C,8448,Add fusion optimization for Delayed,"[{'id': 1968982461, 'node_id': 'MDU6TGFiZWwxOTY4OTgyNDYx', 'url': 'https://api.github.com/repos/dask/dask/labels/delayed', 'name': 'delayed', 'color': '4f6edd', 'default': False, 'description': ''}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,4,2021-12-03T00:18:42Z,2022-11-16T21:58:35Z,,MEMBER,,"We're starting to realize how critical the task fusion optimization is for avoiding task overproduction (see dask/distributed#5555, dask/distributed#5223 for background). 

In light of this and https://github.com/dask/dask/issues/8447, I think we should add the `fuse` optimization for `delayed` as well, which currently doesn't have it: https://github.com/dask/dask/blob/a5aecac8313fea30c5503f534c71f325b1775b9c/dask/delayed.py#L472-L478

I could see the counterargument that Delayed is lower-level, and users expect each of their delayed functions to run as a separate task. I'm not sure how much users want this, versus want help avoiding the very poor scheduling we currently have for unfused chains. We could always take the https://github.com/dask/dask/pull/7620 approach and have `optimization.fuse.active=None` fuse Delayed by default, but turn off fusion if explicitly set to False.

cc @rjzamora @ian-r-rose @jcrist @jrbourbeau ",,https://api.github.com/repos/dask/dask/issues/8448/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8448/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
526,https://api.github.com/repos/dask/dask/issues/8451,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8451/labels{/name},https://api.github.com/repos/dask/dask/issues/8451/comments,https://api.github.com/repos/dask/dask/issues/8451/events,https://github.com/dask/dask/pull/8451,1070167080,PR_kwDOAbcwm84vVvn9,8451,DataFrame fusion when some layers are materialized,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2021-12-03T02:55:19Z,2022-01-03T01:50:41Z,,MEMBER,,"Change the DataFrame optimization default so that DataFrames that may need low-level fusion still get it.

cc @rjzamora @ian-r-rose @jrbourbeau

- [x] Closes #8447
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/8451/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8451/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8451,https://github.com/dask/dask/pull/8451,https://github.com/dask/dask/pull/8451.diff,https://github.com/dask/dask/pull/8451.patch,,,,,,,,,,,,,,,,,,,
527,https://api.github.com/repos/dask/dask/issues/8460,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8460/labels{/name},https://api.github.com/repos/dask/dask/issues/8460/comments,https://api.github.com/repos/dask/dask/issues/8460/events,https://github.com/dask/dask/issues/8460,1072427127,I_kwDOAbcwm84_6_B3,8460,Assignment using 1D dask Array index,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2021-12-06T17:45:37Z,2022-05-10T16:16:24Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
I get a `ValueError` when I use a 1D dask index array to make an assignment on another dask array.

**Minimal Complete Verifiable Example**:

This
```python
import dask.array as da

x = da.zeros(10)
x[da.arange(3)] = 1
```

raises the following error:

```python
ValueError                                Traceback (most recent call last)
~/Documents/FOSS/dask-tlouf/dask/array/core.py in __setitem__(self, key, value)
   1720             try:
-> 1721                 y = where(key, value, self)
   1722             except ValueError as e:

~/Documents/FOSS/dask-tlouf/dask/array/routines.py in where(condition, x, y)
   2037     else:
-> 2038         return elemwise(np.where, condition, x, y)
   2039 

~/Documents/FOSS/dask-tlouf/dask/array/core.py in elemwise(op, out, where, dtype, name, *args, **kwargs)
   4441     out_ndim = len(
-> 4442         broadcast_shapes(*shapes)
   4443     )  # Raises ValueError if dimensions mismatch

~/Documents/FOSS/dask-tlouf/dask/array/core.py in broadcast_shapes(*shapes)
   4369         if any(i not in [-1, 0, 1, dim] and not np.isnan(i) for i in sizes):
-> 4370             raise ValueError(
   4371                 ""operands could not be broadcast together with ""

ValueError: operands could not be broadcast together with shapes (3,) () (10,)

The above exception was the direct cause of the following exception:

ValueError                                Traceback (most recent call last)
<ipython-input-9-7ccc3d8dfd86> in <module>
      1 x = da.zeros(10)
----> 2 x[da.arange(3)] = 1

~/Documents/FOSS/dask-tlouf/dask/array/core.py in __setitem__(self, key, value)
   1721                 y = where(key, value, self)
   1722             except ValueError as e:
-> 1723                 raise ValueError(
   1724                     ""Boolean index assignment in Dask ""
   1725                     ""expects equally shaped arrays.\nExample: da1[da2] = da3 ""

ValueError: Boolean index assignment in Dask expects equally shaped arrays.
Example: da1[da2] = da3 where da1.shape == (4,), da2.shape == (4,) and da3.shape == (4,).
```


while curiously this does not:
```python
x = da.zeros(10)
x[da.arange(3),] = 1
```


**Environment**:

- Dask version: 2021.11.2+18.g43247806 (just pulled)
- Python version: 3.9.5
- Operating System: Pop!_OS 21.04 x86_64
- Install method (conda, pip, source): source",,https://api.github.com/repos/dask/dask/issues/8460/timeline,,,TLouf,31036680,MDQ6VXNlcjMxMDM2Njgw,https://avatars.githubusercontent.com/u/31036680?v=4,,https://api.github.com/users/TLouf,https://github.com/TLouf,https://api.github.com/users/TLouf/followers,https://api.github.com/users/TLouf/following{/other_user},https://api.github.com/users/TLouf/gists{/gist_id},https://api.github.com/users/TLouf/starred{/owner}{/repo},https://api.github.com/users/TLouf/subscriptions,https://api.github.com/users/TLouf/orgs,https://api.github.com/users/TLouf/repos,https://api.github.com/users/TLouf/events{/privacy},https://api.github.com/users/TLouf/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8460/reactions,3,3,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
528,https://api.github.com/repos/dask/dask/issues/8474,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8474/labels{/name},https://api.github.com/repos/dask/dask/issues/8474/comments,https://api.github.com/repos/dask/dask/issues/8474/events,https://github.com/dask/dask/issues/8474,1077294726,I_kwDOAbcwm85ANjaG,8474,Cross-scheduler inconsistent result structure,"[{'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,11,2021-12-10T22:57:09Z,2023-01-10T13:15:43Z,,NONE,,"**What happened**:

Due to a mistake in our code, we were persisting a dask dataframe in one scheduler, but then ran the compute while specifying threads scheduler. What was weird was that the computation returned a pandas Series of Futures instead of the expected DataFrame (or exception).

**What you expected to happen**:

I'm not sure what the best behavior is. Could be erroring on conflicting scheduler, running on the original scheduler, or running on the specified scheduler. Either way, the result structure should be consistent.

**Minimal Complete Verifiable Example**:

```python
from distributed import Client, LocalCluster
import pandas as pd
import dask.dataframe as dd

cluster = LocalCluster()
client=Client(cluster)

df = pd.DataFrame({'a': [1,2,3]})

ddf = dd.from_pandas(df, npartitions=3)

ddf = client.persist(ddf)

# Works, and returns a DF as expected
print(ddf.compute())

# Returns a pandas Series with a row per-partition with a future as the result
print(ddf.compute(scheduler=""threads""))
```

**Anything else we need to know?**:

**Environment**:

- Dask version:
- Python version:
- Operating System:
- Install method (conda, pip, source):
",,https://api.github.com/repos/dask/dask/issues/8474/timeline,,reopened,davidhao3300,5534398,MDQ6VXNlcjU1MzQzOTg=,https://avatars.githubusercontent.com/u/5534398?v=4,,https://api.github.com/users/davidhao3300,https://github.com/davidhao3300,https://api.github.com/users/davidhao3300/followers,https://api.github.com/users/davidhao3300/following{/other_user},https://api.github.com/users/davidhao3300/gists{/gist_id},https://api.github.com/users/davidhao3300/starred{/owner}{/repo},https://api.github.com/users/davidhao3300/subscriptions,https://api.github.com/users/davidhao3300/orgs,https://api.github.com/users/davidhao3300/repos,https://api.github.com/users/davidhao3300/events{/privacy},https://api.github.com/users/davidhao3300/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8474/reactions,0,0,0,0,0,0,0,0,0,jsignell,4806877.0,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
529,https://api.github.com/repos/dask/dask/issues/8476,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8476/labels{/name},https://api.github.com/repos/dask/dask/issues/8476/comments,https://api.github.com/repos/dask/dask/issues/8476/events,https://github.com/dask/dask/pull/8476,1078341241,PR_kwDOAbcwm84vv9tC,8476,Avoid materialization for ArrayOverlapLayer in methods __len__ & get_output_keys,[],open,False,,[],,0,2021-12-13T10:20:43Z,2021-12-22T16:21:47Z,,MEMBER,,"Follow up work to https://github.com/dask/dask/pull/7595#pullrequestreview-670702731

We need to avoid materializing the task graph for the new `ArrayOverlapLayer`, most particularly for the `__len__` and `get_output_keys` methods. Currently, it is much too easy to accidentally materialize the layer (for example, the HTML repr triggers a call to `__len__`). This PR addresses that.

- [x] Closes https://github.com/dask/dask/issues/7788 and closes https://github.com/dask/dask/issues/7791
- [x] Tests ~~added~~ / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/8476/timeline,,,GenevieveBuckley,30920819,MDQ6VXNlcjMwOTIwODE5,https://avatars.githubusercontent.com/u/30920819?v=4,,https://api.github.com/users/GenevieveBuckley,https://github.com/GenevieveBuckley,https://api.github.com/users/GenevieveBuckley/followers,https://api.github.com/users/GenevieveBuckley/following{/other_user},https://api.github.com/users/GenevieveBuckley/gists{/gist_id},https://api.github.com/users/GenevieveBuckley/starred{/owner}{/repo},https://api.github.com/users/GenevieveBuckley/subscriptions,https://api.github.com/users/GenevieveBuckley/orgs,https://api.github.com/users/GenevieveBuckley/repos,https://api.github.com/users/GenevieveBuckley/events{/privacy},https://api.github.com/users/GenevieveBuckley/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8476/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8476,https://github.com/dask/dask/pull/8476,https://github.com/dask/dask/pull/8476.diff,https://github.com/dask/dask/pull/8476.patch,,,,,,,,,,,,,,,,,,,
530,https://api.github.com/repos/dask/dask/issues/8480,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8480/labels{/name},https://api.github.com/repos/dask/dask/issues/8480/comments,https://api.github.com/repos/dask/dask/issues/8480/events,https://github.com/dask/dask/issues/8480,1079018198,I_kwDOAbcwm85AUILW,8480,`test_scheduler_highlevel_graph_unpack_import` flaky,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,1,2021-12-13T20:55:50Z,2022-02-16T20:11:41Z,,MEMBER,,"From time to time `dask/tests/test_layers.py::test_scheduler_highlevel_graph_unpack_import` will fail in CI with the following error (see the traceback further below):

```python
                # Check whether we imported `lib` on the scheduler
>               assert not any(module.startswith(lib) for module in new_modules)
E               assert not True
E                +  where True = any(<generator object test_scheduler_highlevel_graph_unpack_import.<locals>.<genexpr> at 0x0000017314F18C80>)
```

<details>
<summary>Full traceback:</summary>

```python
================================== FAILURES ===================================
___ test_scheduler_highlevel_graph_unpack_import[False-_pq_pyarrow-pandas.] ___
[gw1] win32 -- Python 3.8.12 C:\Miniconda3\envs\test-environment\python.exe

op = <function _pq_pyarrow at 0x000001730E265670>, lib = 'pandas.'
optimize_graph = False
loop = <tornado.platform.asyncio.AsyncIOLoop object at 0x00000173150F8730>
tmpdir = local('C:\\Users\\runneradmin\\AppData\\Local\\Temp\\pytest-of-runneradmin\\pytest-0\\popen-gw1\\test_scheduler_highlevel_graph6')

    @pytest.mark.parametrize(
        ""op,lib"",
        [
            (_dataframe_shuffle, ""pandas.""),
            (_dataframe_broadcast_join, ""pandas.""),
            (_pq_pyarrow, ""pandas.""),
            (_pq_fastparquet, ""pandas.""),
            (_read_csv, ""pandas.""),
            (_array_creation, ""numpy.""),
            (_array_map_overlap, ""numpy.""),
        ],
    )
    @pytest.mark.parametrize(""optimize_graph"", [True, False])
    def test_scheduler_highlevel_graph_unpack_import(op, lib, optimize_graph, loop, tmpdir):
        # Test that array/dataframe-specific modules are not imported
        # on the scheduler when an HLG layers are unpacked/materialized.
    
        with cluster(scheduler_kwargs={""plugins"": [SchedulerImportCheck(lib)]}) as (
            scheduler,
            workers,
        ):
            with Client(scheduler[""address""], loop=loop) as c:
                # Perform a computation using a HighLevelGraph Layer
                c.compute(op(tmpdir), optimize_graph=optimize_graph)
    
                # Get the new modules which were imported on the scheduler during the computation
                end_modules = c.run_on_scheduler(lambda: set(sys.modules))
                start_modules = c.run_on_scheduler(
                    lambda dask_scheduler: dask_scheduler.plugins[
                        SchedulerImportCheck.name
                    ].start_modules
                )
                new_modules = end_modules - start_modules
    
                # Check that the scheduler didn't start with `lib`
                # (otherwise we arent testing anything)
                assert not any(module.startswith(lib) for module in start_modules)
    
                # Check whether we imported `lib` on the scheduler
>               assert not any(module.startswith(lib) for module in new_modules)
E               assert not True
E                +  where True = any(<generator object test_scheduler_highlevel_graph_unpack_import.<locals>.<genexpr> at 0x0000017314F18C80>)

dask\tests\test_layers.py:188: AssertionError
---------------------------- Captured stderr call -----------------------------
distributed.http.proxy - INFO - To route to workers diagnostics web server please install jupyter-server-proxy: python -m pip install jupyter-server-proxy

C:\Miniconda3\envs\test-environment\lib\site-packages\distributed\node.py:160: UserWarning: Port 8787 is already in use.

Perhaps you already have a cluster running?

Hosting the HTTP server on port 53842 instead

  warnings.warn(

distributed.scheduler - INFO - Clear task state

distributed.scheduler - INFO -   Scheduler at:     tcp://127.0.0.1:53843

distributed.scheduler - INFO -   dashboard at:           127.0.0.1:53842

distributed.worker - INFO -       Start worker at:      tcp://127.0.0.1:53844

distributed.worker - INFO -          Listening to:      tcp://127.0.0.1:53844

distributed.worker - INFO -          dashboard at:            127.0.0.1:53845

distributed.worker - INFO - Waiting to connect to:      tcp://127.0.0.1:53843

distributed.worker - INFO - -------------------------------------------------

distributed.worker - INFO -               Threads:                          1

distributed.worker - INFO -                Memory:                   7.00 GiB

distributed.worker - INFO -       Local Directory: D:\a\dask\dask\_test_worker-2d864e31-db54-4f34-8d0e-0a362ad8a84b\dask-worker-space\worker-vluf95em

distributed.worker - INFO - -------------------------------------------------

distributed.scheduler - INFO - Register worker <WorkerState 'tcp://127.0.0.1:53844', name: tcp://127.0.0.1:53844, status: undefined, memory: 0, processing: 0>

distributed.worker - INFO -         Registered to:      tcp://127.0.0.1:53843

distributed.worker - INFO - -------------------------------------------------

distributed.scheduler - INFO - Starting worker compute stream, tcp://127.0.0.1:53844

distributed.core - INFO - Starting established connection

distributed.core - INFO - Starting established connection

distributed.worker - INFO -       Start worker at:      tcp://127.0.0.1:53851

distributed.worker - INFO -          Listening to:      tcp://127.0.0.1:53851

distributed.worker - INFO -          dashboard at:            127.0.0.1:53852

distributed.worker - INFO - Waiting to connect to:      tcp://127.0.0.1:53843

distributed.worker - INFO - -------------------------------------------------

distributed.worker - INFO -               Threads:                          1

distributed.worker - INFO -                Memory:                   7.00 GiB

distributed.worker - INFO -       Local Directory: D:\a\dask\dask\_test_worker-52400da1-4b9c-4e1b-92e2-6b03a81db034\dask-worker-space\worker-wdah6tcy

distributed.worker - INFO - -------------------------------------------------

distributed.scheduler - INFO - Register worker <WorkerState 'tcp://127.0.0.1:53851', name: tcp://127.0.0.1:53851, status: undefined, memory: 0, processing: 0>

distributed.scheduler - INFO - Starting worker compute stream, tcp://127.0.0.1:53851

distributed.core - INFO - Starting established connection

distributed.worker - INFO -         Registered to:      tcp://127.0.0.1:53843

distributed.worker - INFO - -------------------------------------------------

distributed.core - INFO - Starting established connection

distributed.scheduler - INFO - Receive client connection: Client-e6d1e9ae-5c41-11ec-9070-6045bd7a8291

distributed.core - INFO - Starting established connection

distributed.worker - INFO - Run out-of-band function 'lambda'

distributed.worker - INFO - Run out-of-band function 'lambda'

distributed.scheduler - INFO - Remove client Client-e6d1e9ae-5c41-11ec-9070-6045bd7a8291

distributed.scheduler - INFO - Remove client Client-e6d1e9ae-5c41-11ec-9070-6045bd7a8291

distributed.scheduler - INFO - Close client connection: Client-e6d1e9ae-5c41-11ec-9070-6045bd7a8291

distributed.worker - INFO - Stopping worker at tcp://127.0.0.1:53851

distributed.worker - INFO - Stopping worker at tcp://127.0.0.1:53844

distributed.scheduler - INFO - Remove worker <WorkerState 'tcp://127.0.0.1:53844', name: tcp://127.0.0.1:53844, status: running, memory: 0, processing: 0>

distributed.core - INFO - Removing comms to tcp://127.0.0.1:53844

____ test_scheduler_highlevel_graph_unpack_import[False-_read_csv-pandas.] ____
[gw1] win32 -- Python 3.8.12 C:\Miniconda3\envs\test-environment\python.exe

op = <function _read_csv at 0x000001730E265790>, lib = 'pandas.'
optimize_graph = False
loop = <tornado.platform.asyncio.AsyncIOLoop object at 0x0000017314F577F0>
tmpdir = local('C:\\Users\\runneradmin\\AppData\\Local\\Temp\\pytest-of-runneradmin\\pytest-0\\popen-gw1\\test_scheduler_highlevel_graph8')

    @pytest.mark.parametrize(
        ""op,lib"",
        [
            (_dataframe_shuffle, ""pandas.""),
            (_dataframe_broadcast_join, ""pandas.""),
            (_pq_pyarrow, ""pandas.""),
            (_pq_fastparquet, ""pandas.""),
            (_read_csv, ""pandas.""),
            (_array_creation, ""numpy.""),
            (_array_map_overlap, ""numpy.""),
        ],
    )
    @pytest.mark.parametrize(""optimize_graph"", [True, False])
    def test_scheduler_highlevel_graph_unpack_import(op, lib, optimize_graph, loop, tmpdir):
        # Test that array/dataframe-specific modules are not imported
        # on the scheduler when an HLG layers are unpacked/materialized.
    
        with cluster(scheduler_kwargs={""plugins"": [SchedulerImportCheck(lib)]}) as (
            scheduler,
            workers,
        ):
            with Client(scheduler[""address""], loop=loop) as c:
                # Perform a computation using a HighLevelGraph Layer
                c.compute(op(tmpdir), optimize_graph=optimize_graph)
    
                # Get the new modules which were imported on the scheduler during the computation
                end_modules = c.run_on_scheduler(lambda: set(sys.modules))
                start_modules = c.run_on_scheduler(
                    lambda dask_scheduler: dask_scheduler.plugins[
                        SchedulerImportCheck.name
                    ].start_modules
                )
                new_modules = end_modules - start_modules
    
                # Check that the scheduler didn't start with `lib`
                # (otherwise we arent testing anything)
                assert not any(module.startswith(lib) for module in start_modules)
    
                # Check whether we imported `lib` on the scheduler
>               assert not any(module.startswith(lib) for module in new_modules)
E               assert not True
E                +  where True = any(<generator object test_scheduler_highlevel_graph_unpack_import.<locals>.<genexpr> at 0x000001731435D4A0>)

dask\tests\test_layers.py:188: AssertionError
---------------------------- Captured stderr call -----------------------------
distributed.http.proxy - INFO - To route to workers diagnostics web server please install jupyter-server-proxy: python -m pip install jupyter-server-proxy

C:\Miniconda3\envs\test-environment\lib\site-packages\distributed\node.py:160: UserWarning: Port 8787 is already in use.

Perhaps you already have a cluster running?

Hosting the HTTP server on port 53912 instead

  warnings.warn(

distributed.scheduler - INFO - Clear task state

distributed.scheduler - INFO -   Scheduler at:     tcp://127.0.0.1:53913

distributed.scheduler - INFO -   dashboard at:           127.0.0.1:53912

distributed.worker - INFO -       Start worker at:      tcp://127.0.0.1:53914

distributed.worker - INFO -          Listening to:      tcp://127.0.0.1:53914

distributed.worker - INFO -          dashboard at:            127.0.0.1:53915

distributed.worker - INFO - Waiting to connect to:      tcp://127.0.0.1:53913

distributed.worker - INFO - -------------------------------------------------

distributed.worker - INFO -               Threads:                          1

distributed.worker - INFO -                Memory:                   7.00 GiB

distributed.worker - INFO -       Local Directory: D:\a\dask\dask\_test_worker-8101a517-fdfe-49d9-a1b7-96142cd7142f\dask-worker-space\worker-w913isno

distributed.worker - INFO - -------------------------------------------------

distributed.scheduler - INFO - Register worker <WorkerState 'tcp://127.0.0.1:53914', name: tcp://127.0.0.1:53914, status: undefined, memory: 0, processing: 0>

distributed.scheduler - INFO - Starting worker compute stream, tcp://127.0.0.1:53914

distributed.core - INFO - Starting established connection

distributed.worker - INFO -         Registered to:      tcp://127.0.0.1:53913

distributed.worker - INFO - -------------------------------------------------

distributed.core - INFO - Starting established connection

distributed.worker - INFO -       Start worker at:      tcp://127.0.0.1:53921

distributed.worker - INFO -          Listening to:      tcp://127.0.0.1:53921

distributed.worker - INFO -          dashboard at:            127.0.0.1:53922

distributed.worker - INFO - Waiting to connect to:      tcp://127.0.0.1:53913

distributed.worker - INFO - -------------------------------------------------

distributed.worker - INFO -               Threads:                          1

distributed.worker - INFO -                Memory:                   7.00 GiB

distributed.worker - INFO -       Local Directory: D:\a\dask\dask\_test_worker-05a9730f-b3ce-4f8a-88b8-35fa94c0a60d\dask-worker-space\worker-abxa6lx5

distributed.worker - INFO - -------------------------------------------------

distributed.scheduler - INFO - Register worker <WorkerState 'tcp://127.0.0.1:53921', name: tcp://127.0.0.1:53921, status: undefined, memory: 0, processing: 0>

distributed.scheduler - INFO - Starting worker compute stream, tcp://127.0.0.1:53921

distributed.core - INFO - Starting established connection

distributed.worker - INFO -         Registered to:      tcp://127.0.0.1:53913

distributed.worker - INFO - -------------------------------------------------

distributed.core - INFO - Starting established connection

distributed.scheduler - INFO - Receive client connection: Client-ee1c03db-5c41-11ec-9070-6045bd7a8291

distributed.core - INFO - Starting established connection

distributed.worker - INFO - Run out-of-band function 'lambda'

distributed.worker - INFO - Run out-of-band function 'lambda'

distributed.scheduler - INFO - Remove client Client-ee1c03db-5c41-11ec-9070-6045bd7a8291

distributed.scheduler - INFO - Remove client Client-ee1c03db-5c41-11ec-9070-6045bd7a8291

distributed.scheduler - INFO - Close client connection: Client-ee1c03db-5c41-11ec-9070-6045bd7a8291

distributed.worker - INFO - Stopping worker at tcp://127.0.0.1:53914

distributed.scheduler - INFO - Remove worker <WorkerState 'tcp://127.0.0.1:53914', name: tcp://127.0.0.1:53914, status: running, memory: 0, processing: 0>

distributed.core - INFO - Removing comms to tcp://127.0.0.1:53914

distributed.worker - INFO - Stopping worker at tcp://127.0.0.1:53921

distributed.scheduler - INFO - Scheduler closing...
```

</details>",,https://api.github.com/repos/dask/dask/issues/8480/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8480/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
531,https://api.github.com/repos/dask/dask/issues/8481,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8481/labels{/name},https://api.github.com/repos/dask/dask/issues/8481/comments,https://api.github.com/repos/dask/dask/issues/8481/events,https://github.com/dask/dask/pull/8481,1079028820,PR_kwDOAbcwm84vyR5M,8481,Array/DataFrame optimization requires HLG,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2021-12-13T21:05:07Z,2021-12-14T20:49:19Z,,MEMBER,,"In https://github.com/dask/dask/pull/8452 I realized that an incorrect pattern had emerged from https://github.com/dask/dask/pull/6510 of including
```python
    if not isinstance(dsk, HighLevelGraph):
        dsk = HighLevelGraph.from_collections(id(dsk), dsk, dependencies=())
```
in optimization functions. Specifically, `id(dsk)` is incorrect as the layer name here. The layer name must match the `.name` of the resulting collection that gets created by `__dask_postpersist__()` in `dask.optimize`, otherwise `__dask_layers__()` on the optimized collection will be wrong. Since `optimize` doesn't know about collections and isn't passed a layer name, the only reasonable thing to do here is to error when given a low-level graph.
This is safe to do for Arrays and DataFrames, since their constructors convert any low-level graphs to HLGs.

This PR doesn't really fix anythingthe code path removed should be unusedbut it eliminates a confusing pattern that has already wandered its way into other places https://github.com/dask/dask/pull/8316#discussion_r740570242.

cc @ian-r-rose @madsbk 

- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`",,https://api.github.com/repos/dask/dask/issues/8481/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8481/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8481,https://github.com/dask/dask/pull/8481,https://github.com/dask/dask/pull/8481.diff,https://github.com/dask/dask/pull/8481.patch,,,,,,,,,,,,,,,,,,,
532,https://api.github.com/repos/dask/dask/issues/8499,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8499/labels{/name},https://api.github.com/repos/dask/dask/issues/8499/comments,https://api.github.com/repos/dask/dask/issues/8499/events,https://github.com/dask/dask/issues/8499,1084257733,I_kwDOAbcwm85AoHXF,8499,test_development_guidelines_matches_ci fails from sdist,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2021-12-20T01:23:54Z,2022-03-08T17:33:01Z,,MEMBER,,"**What happened**:
The test fails when building from an sdist. This is because the GitHub workflows are not included in the sdist.
```
____________________ test_development_guidelines_matches_ci ____________________
[gw0] linux -- Python 3.10.1 /usr/bin/python3

    def test_development_guidelines_matches_ci():
        """"""When the environment.yaml changes in CI, make sure to change it in the docs as well""""""
        root_dir = Path(__file__).parent.parent.parent
    
        development_doc_file = root_dir / ""docs"" / ""source"" / ""develop.rst""
        additional_ci_file = root_dir / "".github"" / ""workflows"" / ""additional.yml""
        upstream_ci_file = root_dir / "".github"" / ""workflows"" / ""upstream.yml""
        latest_env = ""environment-3.9.yaml""
    
        for filename in [development_doc_file, additional_ci_file, upstream_ci_file]:
>           with open(filename, encoding=""utf8"") as f:
E           FileNotFoundError: [Errno 2] No such file or directory: '/builddir/build/BUILD/dask-2021.12.0/.github/workflows/additional.yml'

dask/tests/test_docs.py:14: FileNotFoundError
```

**What you expected to happen**: Tests pass or are skipped if not relevant.

**Environment**:

- Dask version: 2021.12.0
- Python version: 3.10
- Operating System: Fedora Rawhide
- Install method (conda, pip, source): source",,https://api.github.com/repos/dask/dask/issues/8499/timeline,,,QuLogic,302469,MDQ6VXNlcjMwMjQ2OQ==,https://avatars.githubusercontent.com/u/302469?v=4,,https://api.github.com/users/QuLogic,https://github.com/QuLogic,https://api.github.com/users/QuLogic/followers,https://api.github.com/users/QuLogic/following{/other_user},https://api.github.com/users/QuLogic/gists{/gist_id},https://api.github.com/users/QuLogic/starred{/owner}{/repo},https://api.github.com/users/QuLogic/subscriptions,https://api.github.com/users/QuLogic/orgs,https://api.github.com/users/QuLogic/repos,https://api.github.com/users/QuLogic/events{/privacy},https://api.github.com/users/QuLogic/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8499/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
533,https://api.github.com/repos/dask/dask/issues/8506,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8506/labels{/name},https://api.github.com/repos/dask/dask/issues/8506/comments,https://api.github.com/repos/dask/dask/issues/8506/events,https://github.com/dask/dask/issues/8506,1085207048,I_kwDOAbcwm85ArvII,8506,Failing Windows tests,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2021-12-20T21:11:45Z,2022-01-24T01:49:10Z,,MEMBER,,"There have been 2 to 5 failing windows Python 3.7 tests for the last few days (or weeks?).  This  is an example of how they look:


```python-traceback
================================== FAILURES ===================================
__________________________ test_temporary_directory ___________________________
[gw2] win32 -- Python 3.7.12 C:\Miniconda3\envs\test-environment\python.exe

tmpdir = local('C:\\Users\\runneradmin\\AppData\\Local\\Temp\\pytest-of-runneradmin\\pytest-0\\popen-gw2\\test_temporary_directory0')

    def test_temporary_directory(tmpdir):
        b = db.range(10, npartitions=4)
    
        # We use a pool to avoid a race condition between the pool close
        # cleaning up files, and the assert below.
        with ProcessPoolExecutor(4) as pool:
            with dask.config.set(temporary_directory=str(tmpdir), pool=pool):
                b2 = b.groupby(lambda x: x % 2)
>               b2.compute()

dask\bag\tests\test_bag.py:1469: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
dask\base.py:288: in compute
    (result,) = compute(self, traverse=False, **kwargs)
dask\base.py:571: in compute
    results = schedule(dsk, keys, **kwargs)
dask\multiprocessing.py:230: in get
    **kwargs,
dask\local.py:496: in get_async
    for key, res_info, failed in queue_get(queue).result():
C:\Miniconda3\envs\test-environment\lib\concurrent\futures\_base.py:428: in result
    return self.__get_result()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Future at 0x17401a0b7c8 state=finished raised BrokenProcessPool>

    def __get_result(self):
        if self._exception:
>           raise self._exception
E           concurrent.futures.process.BrokenProcessPool: A process in the process pool was terminated abruptly while the future was running or pending.

C:\Miniconda3\envs\test-environment\lib\concurrent\futures\_base.py:384: BrokenProcessPool
_____________________ test_set_index_consistent_divisions _____________________
[gw1] win32 -- Python 3.7.12 C:\Miniconda3\envs\test-environment\python.exe

    @pytest.mark.slow
    def test_set_index_consistent_divisions():
        # See https://github.com/dask/dask/issues/3867
        df = pd.DataFrame(
            {""x"": np.random.random(100), ""y"": np.random.random(100) // 0.2},
            index=np.random.random(100),
        )
        ddf = dd.from_pandas(df, npartitions=4)
        ddf = ddf.clear_divisions()
    
        ctx = mp.get_context(""spawn"")
        with ProcessPoolExecutor(8, ctx) as pool:
            func = partial(_set_index, df=ddf, idx=""x"")
>           divisions_set = set(pool.map(func, range(100)))

dask\dataframe\tests\test_shuffle.py:451: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Miniconda3\envs\test-environment\lib\concurrent\futures\process.py:483: in _chain_from_iterable_of_lists
    for element in iterable:
C:\Miniconda3\envs\test-environment\lib\concurrent\futures\_base.py:598: in result_iterator
    yield fs.pop().result()
C:\Miniconda3\envs\test-environment\lib\concurrent\futures\_base.py:435: in result
    return self.__get_result()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Future at 0x1d7c432f0c8 state=finished raised BrokenProcessPool>

    def __get_result(self):
        if self._exception:
>           raise self._exception
E           concurrent.futures.process.BrokenProcessPool: A process in the process pool was terminated abruptly while the future was running or pending.

C:\Miniconda3\envs\test-environment\lib\concurrent\futures\_base.py:384: BrokenProcessPool
```

From: https://github.com/dask/dask/runs/4587205293?check_suite_focus=true",,https://api.github.com/repos/dask/dask/issues/8506/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8506/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
534,https://api.github.com/repos/dask/dask/issues/8528,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8528/labels{/name},https://api.github.com/repos/dask/dask/issues/8528/comments,https://api.github.com/repos/dask/dask/issues/8528/events,https://github.com/dask/dask/issues/8528,1093459110,I_kwDOAbcwm85BLNym,8528,From Delayed throws exception when column names are out of order,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2022-01-04T15:20:19Z,2022-01-19T17:11:44Z,,NONE,,"**Exception**
```
ValueError: The columns in the computed data do not match the columns in the provided metadataOrder of columns does not match
```
**Repro code**
```
from dask.dataframe import from_delayed
from dask.delayed import delayed
import numpy as np
import cudf
 
def make_df(x):
    a = [['a', 'b', 'c'], ['b', 'a', 'c'], ['b', 'c', 'a']]
    df = cudf.DataFrame()
    for c in a[x]:
        df[c] = np.random.randint(20, size=10)
    return df
 
xx = from_delayed([delayed(make_df)(i%3) for i in range(100)])
xx.compute()
```
**Note**: Same issue happens with pandas dfs too.

This happens in our library when we try to read multiple files as delayed dataframes and when partitions data in hive as columns in these data frames. For example:
```
def fun(f):
    df = cudf.read_orc(f)
    return df
 
from_delayed([delayed(fun)(f) for f in files]).compute()
```

Works fine but if I pass in partition param and add it to df I run into the error.
```
def fun(f, col, val): 
    df = cudf.read_orc(f)
 df[col] =val
 return df[cols]

from_delayed([delayed(fun)(f, date, 2020-11-12) for f in files]).compute()

```",,https://api.github.com/repos/dask/dask/issues/8528/timeline,,,mlahir1,24844705,MDQ6VXNlcjI0ODQ0NzA1,https://avatars.githubusercontent.com/u/24844705?v=4,,https://api.github.com/users/mlahir1,https://github.com/mlahir1,https://api.github.com/users/mlahir1/followers,https://api.github.com/users/mlahir1/following{/other_user},https://api.github.com/users/mlahir1/gists{/gist_id},https://api.github.com/users/mlahir1/starred{/owner}{/repo},https://api.github.com/users/mlahir1/subscriptions,https://api.github.com/users/mlahir1/orgs,https://api.github.com/users/mlahir1/repos,https://api.github.com/users/mlahir1/events{/privacy},https://api.github.com/users/mlahir1/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8528/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
535,https://api.github.com/repos/dask/dask/issues/8530,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8530/labels{/name},https://api.github.com/repos/dask/dask/issues/8530/comments,https://api.github.com/repos/dask/dask/issues/8530/events,https://github.com/dask/dask/issues/8530,1093877813,I_kwDOAbcwm85BM0A1,8530,dask.dataframe.describe error with nullable data types,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450422, 'node_id': 'LA_kwDOAbcwm87iZ8D2', 'url': 'https://api.github.com/repos/dask/dask/labels/p3', 'name': 'p3', 'color': 'ffff33', 'default': False, 'description': 'Affects a small number of users or is largely cosmetic'}]",open,False,,[],,2,2022-01-05T00:54:17Z,2022-03-24T17:50:31Z,,MEMBER,,"**What happened**:
Error with `dask.dataframe.describe()` when columns contain nullable data types.

**What you expected to happen**:
Similar output as `pandas.dataframe.describe()` (which works)

**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import dask.dataframe as dd

n = 10
test = pd.DataFrame({
    '1': pd.Series(['a', pd.NA]*n, dtype = pd.StringDtype()), 
    '2': pd.Series([1, pd.NA]*n, dtype = pd.Int64Dtype()),
    '3': pd.Series([0.56, pd.NA]*n, dtype = pd.Float64Dtype())
})
test.describe() # works no problem

ddf = dd.from_pandas(test, npartitions=2)
ddf.describe().compute() # error
```
<details>
<summary> full traceback </summary>

```python traceback
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
AttributeError: 'NAType' object has no attribute 'conjugate'

The above exception was the direct cause of the following exception:

TypeError                                 Traceback (most recent call last)
/var/folders/hf/2s7qjx7j5ndc5220_qxv8y800000gn/T/ipykernel_4176/3509056714.py in <module>
----> 1 dd_df[['2']].describe().compute()

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/dataframe/core.py in describe(self, split_every, percentiles, percentiles_method, include, exclude, datetime_is_numeric)
   2522                 bools_and_times = self._meta.select_dtypes(include=_include)
   2523                 if len(bools_and_times.columns) == 0:
-> 2524                     return self._describe_numeric(
   2525                         self,
   2526                         split_every,

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/dataframe/core.py in _describe_numeric(self, data, split_every, percentiles, percentiles_method, is_timedelta_column, is_datetime_column)
   2630             num.count(split_every=split_every),
   2631             num.mean(split_every=split_every),
-> 2632             num.std(split_every=split_every),
   2633             num.min(split_every=split_every),
   2634             num.quantile(percentiles, method=percentiles_method),

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/dataframe/core.py in wrapper(self, *args, **kwargs)
     94         elif kwargs.get(""numeric_only"") is True:
     95             self = self._get_numeric_data()
---> 96         return func(self, *args, **kwargs)
     97 
     98     return wrapper

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/dataframe/core.py in std(self, axis, skipna, ddof, split_every, dtype, out, numeric_only)
   2148             return handle_out(out, result)
   2149         else:
-> 2150             v = self.var(skipna=skipna, ddof=ddof, split_every=split_every)
   2151             name = self._token_prefix + ""std""
   2152             result = map_partitions(

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/dataframe/core.py in wrapper(self, *args, **kwargs)
     94         elif kwargs.get(""numeric_only"") is True:
     95             self = self._get_numeric_data()
---> 96         return func(self, *args, **kwargs)
     97 
     98     return wrapper

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/dataframe/core.py in var(self, axis, skipna, ddof, split_every, dtype, out, numeric_only)
   2007 
   2008             # pandas 1.0+ does not implement var on timedelta
-> 2009             result = self._var_numeric(skipna, ddof, split_every)
   2010 
   2011             if isinstance(self, DataFrame):

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/dataframe/core.py in _var_numeric(self, skipna, ddof, split_every)
   2028         cols = num._meta.columns if is_dataframe_like(num) else None
   2029 
-> 2030         var_shape = num._meta_nonempty.values.var(axis=0).shape
   2031         array_var_name = (array_var._name,) + (0,) * len(var_shape)
   2032 

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/numpy/core/_methods.py in _var(a, axis, dtype, out, ddof, keepdims, where)
    239     # numbers and complex types with non-native byteorder
    240     else:
--> 241         x = um.multiply(x, um.conjugate(x), out=x).real
    242 
    243     ret = umr_sum(x, axis, dtype, out, keepdims=keepdims, where=where)

TypeError: loop of ufunc does not support argument 0 of type NAType which has no callable conjugate method
```
</details>

**Anything else we need to know?**:
Individually calling the methods in `describe`, `std` and `quantile` throw `TypeError: Cannot interpret 'Int64Dtype()' as a data type`

<details>
<summary> full traceback </summary>

```python traceback
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
/var/folders/hf/2s7qjx7j5ndc5220_qxv8y800000gn/T/ipykernel_4176/418681936.py in <module>
----> 1 ddf['2'].quantile().compute()

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/base.py in compute(self, **kwargs)
    286         dask.base.compute
    287         """"""
--> 288         (result,) = compute(self, traverse=False, **kwargs)
    289         return result
    290 

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/base.py in compute(traverse, optimize_graph, scheduler, get, *args, **kwargs)
    569         postcomputes.append(x.__dask_postcompute__())
    570 
--> 571     results = schedule(dsk, keys, **kwargs)
    572     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
    573 

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/threaded.py in get(dsk, result, cache, num_workers, pool, **kwargs)
     77             pool = MultiprocessingPoolExecutor(pool)
     78 
---> 79     results = get_async(
     80         pool.submit,
     81         pool._max_workers,

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/local.py in get_async(submit, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, chunksize, **kwargs)
    505                             _execute_task(task, data)  # Re-execute locally
    506                         else:
--> 507                             raise_exception(exc, tb)
    508                     res, worker_id = loads(res_info)
    509                     state[""cache""][key] = res

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/local.py in reraise(exc, tb)
    313     if exc.__traceback__ is not tb:
    314         raise exc.with_traceback(tb)
--> 315     raise exc
    316 
    317 

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/local.py in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    218     try:
    219         task, data = loads(task_info)
--> 220         result = _execute_task(task, data)
    221         id = get_id()
    222         result = dumps((result, id))

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/core.py in _execute_task(arg, cache, dsk)
    117         # temporaries by their reference count and can execute certain
    118         # operations in-place.
--> 119         return func(*(_execute_task(a, cache) for a in args))
    120     elif not ishashable(arg):
    121         return arg

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/utils.py in __call__(self, arg, *args, **kwargs)
    619         """"""
    620         meth = self.dispatch(type(arg))
--> 621         return meth(arg, *args, **kwargs)
    622 
    623     @property

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/dataframe/backends.py in percentile(a, q, interpolation)
    531 @percentile_lookup.register((pd.Series, pd.Index))
    532 def percentile(a, q, interpolation=""linear""):
--> 533     return _percentile(a, q, interpolation)
    534 
    535 

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/array/percentile.py in _percentile(a, q, interpolation)
     29             a = a.values
     30 
---> 31     if np.issubdtype(a.dtype, np.datetime64):
     32         values = a
     33         a2 = values.view(""i8"")

~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/numpy/core/numerictypes.py in issubdtype(arg1, arg2)
    417     """"""
    418     if not issubclass_(arg1, generic):
--> 419         arg1 = dtype(arg1).type
    420     if not issubclass_(arg2, generic):
    421         arg2 = dtype(arg2).type

TypeError: Cannot interpret 'Int64Dtype()' as a data type

```

</details>

**Environment**:

- Dask version: 2021.11.2
- Python version: 3.9.7
- Operating System: MacOS
- Install method (conda, pip, source): conda",,https://api.github.com/repos/dask/dask/issues/8530/timeline,,,scharlottej13,8620816,MDQ6VXNlcjg2MjA4MTY=,https://avatars.githubusercontent.com/u/8620816?v=4,,https://api.github.com/users/scharlottej13,https://github.com/scharlottej13,https://api.github.com/users/scharlottej13/followers,https://api.github.com/users/scharlottej13/following{/other_user},https://api.github.com/users/scharlottej13/gists{/gist_id},https://api.github.com/users/scharlottej13/starred{/owner}{/repo},https://api.github.com/users/scharlottej13/subscriptions,https://api.github.com/users/scharlottej13/orgs,https://api.github.com/users/scharlottej13/repos,https://api.github.com/users/scharlottej13/events{/privacy},https://api.github.com/users/scharlottej13/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8530/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
536,https://api.github.com/repos/dask/dask/issues/8546,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8546/labels{/name},https://api.github.com/repos/dask/dask/issues/8546/comments,https://api.github.com/repos/dask/dask/issues/8546/events,https://github.com/dask/dask/issues/8546,1096690121,I_kwDOAbcwm85BXinJ,8546,Allow coroutines to be used in dask.bag operations,"[{'id': 242862273, 'node_id': 'MDU6TGFiZWwyNDI4NjIyNzM=', 'url': 'https://api.github.com/repos/dask/dask/labels/bag', 'name': 'bag', 'color': '0052cc', 'default': False, 'description': None}]",open,False,,[],,3,2022-01-07T21:41:29Z,2022-01-19T20:40:21Z,,NONE,,"<!-- Please do a quick search of existing issues to make sure that this has not been asked before. -->
Would be nice if dask allowed to pass coroutines directly to dask bag operations, such as map, filter, foldby, etc.

Seems like https://github.com/dask/distributed/pull/5151 added the ability to submit coroutines on the client object.

I've submitted this request here first: https://dask.discourse.group/t/is-it-possible-to-map-coroutines-in-a-dask-bag/174",,https://api.github.com/repos/dask/dask/issues/8546/timeline,,,ianliu,30196,MDQ6VXNlcjMwMTk2,https://avatars.githubusercontent.com/u/30196?v=4,,https://api.github.com/users/ianliu,https://github.com/ianliu,https://api.github.com/users/ianliu/followers,https://api.github.com/users/ianliu/following{/other_user},https://api.github.com/users/ianliu/gists{/gist_id},https://api.github.com/users/ianliu/starred{/owner}{/repo},https://api.github.com/users/ianliu/subscriptions,https://api.github.com/users/ianliu/orgs,https://api.github.com/users/ianliu/repos,https://api.github.com/users/ianliu/events{/privacy},https://api.github.com/users/ianliu/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8546/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
537,https://api.github.com/repos/dask/dask/issues/8549,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8549/labels{/name},https://api.github.com/repos/dask/dask/issues/8549/comments,https://api.github.com/repos/dask/dask/issues/8549/events,https://github.com/dask/dask/issues/8549,1097928403,I_kwDOAbcwm85BcQ7T,8549,OSError: Could not load shared object file: llvmlite.dll,"[{'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}]",open,False,,[],,4,2022-01-10T13:53:16Z,2022-02-04T15:08:12Z,,MEMBER,,"There's an upstream bug in llvmlite on Windows that will cause test_set_index_consistent_divisions and probably the process scheduler to randomly fail:

https://github.com/numba/llvmlite/issues/808


",,https://api.github.com/repos/dask/dask/issues/8549/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8549/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
538,https://api.github.com/repos/dask/dask/issues/8560,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8560/labels{/name},https://api.github.com/repos/dask/dask/issues/8560/comments,https://api.github.com/repos/dask/dask/issues/8560/events,https://github.com/dask/dask/pull/8560,1099782981,PR_kwDOAbcwm84w1H8l,8560,Array optimization: cull before `fuse_roots`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2022-01-12T01:39:11Z,2022-07-14T20:21:56Z,,MEMBER,,"Because `fuse_roots` materializes Blockwise layers, if you have a situation where you're sub-selecting a few items out of a large initial Blockwise array, culling the graph (cheap) before materializing it (slow) can be massively more performant. As more becomes Blockwise (https://github.com/dask/dask/pull/7417), this will become more relevant. For example:

```python
a = da.from_zarr(""s3://10-trillion-chunk-dataset/a"")
b = da.from_zarr(""s3://10-trillion-chunk-dataset/b"")
metric = a / b
tiny_part = metric[:10]
# Without this PR, optimizing `tiny_part` could require materializing the 10-trillion-chunk
# `from_array` graphs, just to cull them down to nothing a moment later
``` 

I doubt this is exactly correctmaybe we need to cull again after `fuse_roots`? (Culling is cheap but not _that_ cheap; I'd like to not do it twice if possible.)

Because it materializes, I also think `fuse_roots` should perhaps go after the `if config.get(""optimization.fuse.active"") is False: return dsk` bailout.

Frankly, I don't understand `fuse_roots`. The situation described in https://github.com/dask/dask/pull/5451#issuecomment-552983458, and the test for it, are already handled by plain Blockwise fusion. In fact, if I remove `fuse_roots` entirely, `test_fuse_roots` still passes!

cc @rjzamora @ian-r-rose 

- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/8560/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8560/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/8560,https://github.com/dask/dask/pull/8560,https://github.com/dask/dask/pull/8560.diff,https://github.com/dask/dask/pull/8560.patch,,,,,,,,,,,,,,,,,,,
539,https://api.github.com/repos/dask/dask/issues/8567,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8567/labels{/name},https://api.github.com/repos/dask/dask/issues/8567/comments,https://api.github.com/repos/dask/dask/issues/8567/events,https://github.com/dask/dask/issues/8567,1102346261,I_kwDOAbcwm85BtHgV,8567,Show names of layer dependencies in HLG JupyterLab repr,"[{'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,0,2022-01-13T20:45:52Z,2022-02-25T21:55:06Z,,MEMBER,,"Similar to https://github.com/dask/dask/issues/8497. The interactive HLG repr displays the layers in topological order, but you can't actually tell if a layer depends on just the one layer before it, or on multiple.

A proper graph layout would of course be cool, but that's unnecessary and far out of scope.

For now, it would be nice to just list the names of the layers that each layer depends on.",,https://api.github.com/repos/dask/dask/issues/8567/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8567/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
540,https://api.github.com/repos/dask/dask/issues/8570,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8570/labels{/name},https://api.github.com/repos/dask/dask/issues/8570/comments,https://api.github.com/repos/dask/dask/issues/8570/events,https://github.com/dask/dask/issues/8570,1103969405,I_kwDOAbcwm85BzTx9,8570,"Culling massive Blockwise graphs is very slow, not constant-time","[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,10,2022-01-14T18:03:17Z,2022-09-20T22:12:51Z,,MEMBER,,"**tl;dr: Could `get_all_external_keys` and `get_output_keys` be avoided in HLG culling?**

In some workflows, it can be desirable to create a dask Array/DataFrame structure representing some full-size, enormous dataset, then immediately use slicing to sub-select out only a tiny part of it, then work with that. Now that we can use Blockwise for IO (xref https://github.com/dask/dask/pull/7417), this is an especially appealing pattern, because it should be constant-time to construct the massive graph, since nothing has to be materialized.

I had hoped it would also be linear-time to cull this massive graph, but it appears currently that it's not.

Here's an example where I'm trying to create an xarray representing the [Landsat-8](https://planetarycomputer.microsoft.com/dataset/landsat-8-c2-l2) collection at full resolution over the entire continental US. This is a 10PB, 136-million-chunk array that involves 1.3 billion data loading tasks. Here I'm using https://github.com/gjoseph92/stackstac/pull/116 (so the data loading graph is fully blockwise) and https://github.com/dask/dask/pull/8560 (so we know `fuse_roots` isn't materializing the graph unnecessarily).

![Screen Shot 2022-01-14 at 10 37 54 AM](https://user-images.githubusercontent.com/3309802/149560244-8b8bec05-f3e5-4427-a079-3714677e77a7.png)

Then I'm sub-selecting a single chunk out of those 136 million. Based on what I know of the graph, this should cull down to 4 tasks.

![Screen Shot 2022-01-14 at 10 37 59 AM](https://user-images.githubusercontent.com/3309802/149560279-e40a3d55-aedf-449b-b931-a9f2fd2a1645.png)

<details><summary>Here's the HLG for reference</summary>

You can see the first layer is materialized with ~100,000 tasks, but the _big_, 100-million-task one is Blockwise. (https://github.com/dask/dask/issues/8497 sure would be nice here!)

![Screen Shot 2022-01-14 at 10 30 55 AM](https://user-images.githubusercontent.com/3309802/149559272-8f5e0f13-863e-49ac-8482-5876cd2b9617.png)

</details>

But when I try to optimize this graph, I see memory usage shoot up until it crashes the kernel on the 32GB machine. Interrupting the kernel after a few seconds makes it pretty clear what's going on: `HighLevelGraph.cull` is calling `get_all_external_keys`, which is forcing the generation of all 1.3 billion keys (or 136 million keys? not sure).

![Screen Shot 2022-01-14 at 10 23 19 AM](https://user-images.githubusercontent.com/3309802/149558357-d981f103-cea9-44bb-b44e-ed7070003b77.png)

Even if it didn't call `get_all_external_keys`, I see that `HighLevelGraph.cull` is still calling `get_output_keys` on every layer. For reference: https://github.com/dask/dask/blob/358a5e367eedc8f2963651071a72f43e0ac4f887/dask/highlevelgraph.py#L944-L970

Why is it necessary for HLG.cull to ask the layer for all its keys, intersect them itself, then pass that back into the layer? And why is it necessary for cull functions to take `all_hlg_keys`?

I had thought the interface would be simply: HLG.cull tells each layer the necessary output keys; the layer figures out the rest on its own. If it needs to generate all its keys internally and do that intersection, fine, but for layers that don't need to do this, shouldn't the optimization be available?

@rjzamora @madsbk why does culling work this way? Would it be possible to write Blockwise culling without this, in a way that's truly linear-time to only the number of final keys?

cc @ian-r-rose @TomAugspurger ",,https://api.github.com/repos/dask/dask/issues/8570/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8570/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
541,https://api.github.com/repos/dask/dask/issues/8579,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8579/labels{/name},https://api.github.com/repos/dask/dask/issues/8579/comments,https://api.github.com/repos/dask/dask/issues/8579/events,https://github.com/dask/dask/issues/8579,1105519417,I_kwDOAbcwm85B5OM5,8579,Type inference failure when column type is np.ndarray,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450421, 'node_id': 'LA_kwDOAbcwm87iZ8D1', 'url': 'https://api.github.com/repos/dask/dask/labels/hygiene', 'name': 'hygiene', 'color': 'b5ccfa', 'default': False, 'description': 'Improve code quality and reduce maintenance overhead'}]",open,False,,[],,1,2022-01-17T08:21:42Z,2022-03-14T01:57:07Z,,NONE,,"
**Minimal Complete Verifiable Example**:

```python
import numpy as np
import pandas as pd
import dask.dataframe as dd

df = pd.DataFrame([[4,np.asarray([[2, 7]])],[2,np.asarray([[0,5],[1,1]])],[9,np.asarray([])]], columns=[""value"",""arrays""])

# expected
print(df[""value""] + df[""arrays""])

# in Dask
ddf = dd.from_pandas(df, npartitions=1)
print((ddf[""value""] + ddf[""arrays""]).compute())
```

It seems that Dask incorrectly assumes the type of df[""arrays""] to be str, and therefore complains when doing the addition:
```
TypeError                                 Traceback (most recent call last)
.../python3.9/site-packages/pandas/core/ops/array_ops.py in _na_arithmetic_op(left, right, op, is_cmp)
    165     try:
--> 166         result = func(left, right)
    167     except TypeError:

.../python3.9/site-packages/pandas/core/computation/expressions.py in evaluate(op, a, b, use_numexpr)
    238             # error: ""None"" not callable
--> 239             return _evaluate(op, op_str, a, b)  # type: ignore[misc]
    240     return _evaluate_standard(op, op_str, a, b)

.../python3.9/site-packages/pandas/core/computation/expressions.py in _evaluate_standard(op, op_str, a, b)
     68         _store_test_result(False)
---> 69     return op(a, b)
     70 

TypeError: unsupported operand type(s) for +: 'int' and 'str'
```



**Environment**:

- Dask version: '2022.01.0'
- Python version: 3.9
- Operating System: linux
- Install method (conda, pip, source): pip


",,https://api.github.com/repos/dask/dask/issues/8579/timeline,,,alcinos,7438704,MDQ6VXNlcjc0Mzg3MDQ=,https://avatars.githubusercontent.com/u/7438704?v=4,,https://api.github.com/users/alcinos,https://github.com/alcinos,https://api.github.com/users/alcinos/followers,https://api.github.com/users/alcinos/following{/other_user},https://api.github.com/users/alcinos/gists{/gist_id},https://api.github.com/users/alcinos/starred{/owner}{/repo},https://api.github.com/users/alcinos/subscriptions,https://api.github.com/users/alcinos/orgs,https://api.github.com/users/alcinos/repos,https://api.github.com/users/alcinos/events{/privacy},https://api.github.com/users/alcinos/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8579/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
542,https://api.github.com/repos/dask/dask/issues/8581,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8581/labels{/name},https://api.github.com/repos/dask/dask/issues/8581/comments,https://api.github.com/repos/dask/dask/issues/8581/events,https://github.com/dask/dask/issues/8581,1107043820,I_kwDOAbcwm85B_CXs,8581,Blockwise serialization can fail with LocalCluster(processes=False),"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2022-01-18T15:28:28Z,2022-05-13T20:02:53Z,,MEMBER,,"This issue is an attempt to clearly highlight an existing bug in Dask that has been (less-clearly) reported in a number of places (e.g. #7449 and #7777): The current serialization machinery used in Dask and Distributed does not work when `LocalCluster` is used with `processes=False`.

This bug shows up any time a `Blockwise`-based `HighevelGraph` (HLG) layer contains a local graph with nested tasks.  In cases like this, Dask will mark the sub-task as `Serialize`, but since `processes=False` skips the Distributed-comms interface, the `Serialize` object is never serialized/deserialized before making its way to the worker.

As correctly suggested by @snowoody [here](https://github.com/dask/dask/issues/7777#issuecomment-994509162), the short term workaround for this bug is either of the following:

1. Avoid using `processes=False`.  If the distributed-communication layer is actually used, the `Serialize` objects will be properly serialized and deserialized.
2. Ensure the HLG is materialized into a dict-based task graph before it is sent to the scheduler. This can be done by executing your code in a `dask.config.set({""optimization.fuse.active"": True})` context.

The best long term solution to this problem is probably the serialization generalization/overhaul described in [distributed#5581](https://github.com/dask/distributed/issues/5581).  The current Distributed serialization design requires an ill-defined (and clumsy) partial-serialization procedure for HLG-communication to the scheduler.  That is, the definition of each HLG Layer is required to mark objects that it will include in the materialized task graph as `to_serialize` (alias for `Serialize`) when said objects cannot be serialized with msgpack. This is the only way to ensure that objects requiring pickling will (1) be passed from the client to the scheduler, (2) be injected into the graph by the scheduler, and then (3) be interpreted correctly by the worker.  If we moved to distributed#5581, the HLG-Layer code could avoid marking anything as `to_serialize`, because the comm layers would automatically use pickle when necessary.

**Reproducers**:

- [read_csv](https://github.com/dask/dask/issues/7777#issue-916010856)
- array + [blockwise](https://github.com/dask/dask/issues/7449#issue-838479072)",,https://api.github.com/repos/dask/dask/issues/8581/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8581/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
543,https://api.github.com/repos/dask/dask/issues/8585,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8585/labels{/name},https://api.github.com/repos/dask/dask/issues/8585/comments,https://api.github.com/repos/dask/dask/issues/8585/events,https://github.com/dask/dask/issues/8585,1107352933,I_kwDOAbcwm85CAN1l,8585,Make meta publicly accessible,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-01-18T20:54:33Z,2022-03-14T01:57:06Z,,MEMBER,,"There have been some issues coming up with how we handle `meta`. I think they boil down to users needing a way to control the meta on their dask.dataframe objects. 

1. add public methods for setting/getting meta.
2. add meta as a kwarg on all functions so people can optionally specify what their output looks like
3. preserve as much info as possible on meta (things like setting meta to a subset of the data on read).
4. improve error messages so that issues that come up are less cryptic, this will often look like suggesting that users pass meta in as a kwarg. 

This idea is kind of related to https://github.com/dask/dask/issues/8435",,https://api.github.com/repos/dask/dask/issues/8585/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8585/reactions,4,4,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
544,https://api.github.com/repos/dask/dask/issues/8616,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8616/labels{/name},https://api.github.com/repos/dask/dask/issues/8616/comments,https://api.github.com/repos/dask/dask/issues/8616/events,https://github.com/dask/dask/issues/8616,1112981857,I_kwDOAbcwm85CVsFh,8616,[DISCUSSION] Layer-by-Layer Graph Execution,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,10,2022-01-24T18:13:42Z,2022-03-14T01:57:06Z,,MEMBER,,"### TLDR

**Rough Proposal**: In order to overlap graph communication with scheduling and computation, we should enable **partial** task-graph execution. Further details are discussed below, but the ultimate goals is to completely remove the need to send HLGs to the scheduler (while hopefully improving Dask's ability to handle large-scale graphs).

**NOTE:** The ideas here are mostly a combination of suggestions made in the past by others like @madsbk, @gjoseph92, @ian-r-rose (and probably others)

## Background

Most methods in the Dask-Dataframe and Dask-Array APIs produce an abstract `HighLevelGraph` (HLG) instead of a fully-materialized dictionary-based task graph. The general purpose of this HLG approach is two-fold:

1. To enable critical graph-optimization operations **before** the full (dictionary-based) task graph is materialized. These optimizations include blockwise task fusion, culling, and partial-IO optimizations like column projection (and hopefully predicate pushdown in the near future).
2. To avoid sending large materialized task graphs over the wire from the client process to the scheduler. We expected (and indeed observe) much smaller graph-communication latency when the HLG-to-dictionary materialization was moved from the client to the scheduler.

Although HLGs have demonstrated some success in achieving both of the above goals, there have also been clear challenges:

- HLG fusion has relied on existing optimizations in `Blockwise`, requiring all fusible DataFrame and Array Layers (including IO) to be reformulated as `Blockwise`-based HLG Layers.  The complexity in `Blockwise` has made this transition a bit difficult.  I will not focus on this specific challenge in the remainder of this proposal (but I felt it was important enough to mention).
- The need to deserialize and materialize HLGs on the scheduler has proved to be a complete headache (see [distributed#5581](https://github.com/dask/distributed/issues/5581) and [this summary](https://github.com/dask/dask/pull/8468#discussion_r771752382)). The existing serialization and communication infrastructure was designed with the low-level (dictionary) graph in mind.  We quickly discovered that it can be quite painful to construct a low-level graph on the scheduler without being able to call `pickle.loads` on functions and non-msgpack serializable arguments (a security concern).
- Sending HLGs to the scheduler reduced the graph communication time (important for high-latency client-scheduler connections), but it barely made a dent in typical end-to-end run times for systems with decent client-scheduler latency. This is because large client-side graph materialization costs were simply converted into comparable scheduler-side graph materialization costs.  We originally hoped that Cython or C++ on the scheduler would make this graph-materialization cost negligible, but I am skeptical that this is something we can/should rely on.

What I take away from the challenges above is that: (1) Sending HLGs to the scheduler is a headache, and (2) The only reason we are still doing this is to minimize client-to-scheduler communication latency.

## Proposal

After a long (but fun) discussion with @madsbk, we generally agreed that we may be able to avoid sending HLGs to the scheduler altogether. Our primary (and probably lone) reason for dealing with HLGs on the scheduler now is graph-communication latency.  Therefore, we will no longer have any motivation to send the HLG to the scheduler if this overhead is sufficiently reduced or hidden.  One possible way to do this is by overlapping graph communication with scheduling and execution.  That is, we may be able to graph communication delays by taking the following steps:

### Step 1 - Enable partial graph scheduling

The first and most-critical step is to ensure that the scheduler is capable of executing a partial graph.  I am hoping someone like @madsbk will have the bandwidth and interest to prototype this machinery, but I would expect the client to be able to submit a graph without specifying the keys it wants to `get`.  Instead, the client should be able to mark specific keys as active dependencies.  Note that I am very open to suggestions here, but the overall goal is to begin assigning tasks to workers before the scheduler has finished receiving the full task graph.

### Step 2 - Send the materialized graph Layer-by-Layer

Once the scheduler has a mechanism for processing partial task-graphs, we will want to add a mechanism in the client to actually send large graphs in phases. For the initial pass, I propose that we simply use the existing HLG `Layer` as a single sub-graph unit.  In other words, after the HLG optimization pass, we can simply send the materialized graph to the scheduler one `Layer` at a time.  After we confirm that this works, we can avoid the obvious small-message problem by aggregating adjacent `Layers` on the client until an optimal sub-graph size is reached. 

If we are able to implement these first two steps without critical road blocks, then I suspect we will be highly motivated to discuss the future (or lack thereof) of HLG serialization.  If we can decouple the serialization design from that of HLGs, then I suspect we will find it much easier to improve the two separately.

## Possible Follow-On Work

Although Layer-by-Layer graph communication/execution may largely reduce our need to send HLGs to the scheduler, we may still want to send something other than the low-level graph is special cases.  For example, if the user is willing to **opt in** to full (`dumps` and `loads`) pickle support on the scheduler, then we may want to enable the client to pickle a single generator function for an HLG Layer, and the scheduler could simply unpickle this object and then pass in a required set of output keys to get the necessary tasks.  This would allow the scheduler to break up the materialization and scheduling of extremely large graphs (even when a single layer contains billions of keys).  Such an optimization would clearly take considerable design and development effort, but it may provide us with a reasonable path toward the handling of extreme-scale graphs (note that this idea belongs entirely to @madsbk, so he makes want to clarify and/or expand)
",,https://api.github.com/repos/dask/dask/issues/8616/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8616/reactions,1,0,0,0,0,0,1,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
545,https://api.github.com/repos/dask/dask/issues/8620,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8620/labels{/name},https://api.github.com/repos/dask/dask/issues/8620/comments,https://api.github.com/repos/dask/dask/issues/8620/events,https://github.com/dask/dask/issues/8620,1113974911,I_kwDOAbcwm85CZeh_,8620,`read_sql_query` with meta converts dtypes from 32 to 64. ,"[{'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}, {'id': 3798450422, 'node_id': 'LA_kwDOAbcwm87iZ8D2', 'url': 'https://api.github.com/repos/dask/dask/labels/p3', 'name': 'p3', 'color': 'ffff33', 'default': False, 'description': 'Affects a small number of users or is largely cosmetic'}]",open,False,,[],,9,2022-01-25T14:42:50Z,2022-08-17T13:42:49Z,,MEMBER,,"After https://github.com/dask/dask/pull/8158 there is one test that doesn't quite pass on win32 I think it is because `read_sql_query` converts int32 to int64. I am not quite sure where the issue lies. Here is the failing test:

```python-traceback
================================== FAILURES ===================================
____________________________ test_query_with_meta _____________________________
[gw1] win32 -- Python 3.8.12 C:\Miniconda3\envs\test-environment\python.exe

db = 'sqlite:///C:\\Users\\RUNNER~1\\AppData\\Local\\Temp\\tmpwxx4978a'

    def test_query_with_meta(db):
        from sqlalchemy import sql
    
        data = {
            ""name"": pd.Series([], name=""name"", dtype=""str""),
            ""age"": pd.Series([], name=""age"", dtype=""int""),
        }
        index = pd.Index([], name=""number"", dtype=""int"")
        meta = pd.DataFrame(data, index=index)
    
        s1 = sql.select(
            [sql.column(""number""), sql.column(""name""), sql.column(""age"")]
        ).select_from(sql.table(""test""))
        out = read_sql_query(s1, db, npartitions=2, index_col=""number"", meta=meta)
>       assert_eq(out, df[[""name"", ""age""]])

dask\dataframe\io\tests\test_sql.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

a =            name  age
number              
0         Alice   33
1           Bob   40
2         Chris   22
3          Dora   16
4         Edith   53
5       Francis   30
6       Garreth   20
b =            name  age
number              
0         Alice   33
1           Bob   40
2         Chris   22
3          Dora   16
4         Edith   53
5       Francis   30
6       Garreth   20
check_names = True, check_dtype = True, check_divisions = True
check_index = True, scheduler = 'sync', kwargs = {}

    def assert_eq(
        a,
        b,
        check_names=True,
        check_dtype=True,
        check_divisions=True,
        check_index=True,
        scheduler=""sync"",
        **kwargs,
    ):
        if check_divisions:
            assert_divisions(a, scheduler=scheduler)
            assert_divisions(b, scheduler=scheduler)
            if hasattr(a, ""divisions"") and hasattr(b, ""divisions""):
                at = type(np.asarray(a.divisions).tolist()[0])  # numpy to python
                bt = type(np.asarray(b.divisions).tolist()[0])  # scalar conversion
                assert at == bt, (at, bt)
        assert_sane_keynames(a)
        assert_sane_keynames(b)
        a = _check_dask(
            a, check_names=check_names, check_dtypes=check_dtype, scheduler=scheduler
        )
        b = _check_dask(
            b, check_names=check_names, check_dtypes=check_dtype, scheduler=scheduler
        )
        if hasattr(a, ""to_pandas""):
            a = a.to_pandas()
        if hasattr(b, ""to_pandas""):
            b = b.to_pandas()
        if isinstance(a, (pd.DataFrame, pd.Series)):
            a = _maybe_sort(a, check_index)
            b = _maybe_sort(b, check_index)
        if not check_index:
            a = a.reset_index(drop=True)
            b = b.reset_index(drop=True)
        if isinstance(a, pd.DataFrame):
>           tm.assert_frame_equal(
                a, b, check_names=check_names, check_dtype=check_dtype, **kwargs
E               AssertionError: Attributes of DataFrame.iloc[:, 1] (column name=""age"") are different
E               
E               Attribute ""dtype"" are different
E               [left]:  int32
E               [right]: int64

dask\dataframe\utils.py:560: AssertionError
```",,https://api.github.com/repos/dask/dask/issues/8620/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8620/reactions,0,0,0,0,0,0,0,0,0,jrbourbeau,11656932.0,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
546,https://api.github.com/repos/dask/dask/issues/8635,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8635/labels{/name},https://api.github.com/repos/dask/dask/issues/8635/comments,https://api.github.com/repos/dask/dask/issues/8635/events,https://github.com/dask/dask/issues/8635,1117844117,I_kwDOAbcwm85CoPKV,8635,"Blockwise optimization doesn't combine task names, like low-level fusion does","[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,7,2022-01-28T21:01:36Z,2023-01-31T11:32:19Z,,MEMBER,,"Users may be confused why tasks that they expect to run don't show up on the dashboard.

With low-level fusion, we concatenate the names of all the tasks together, so at least the name of the task (like `read_csv-assign-getitem-add`) gives you some hint that all those things are still happening. But with blockwise fusion, that same task would just be named `add`, which gives you no indication that your `read_csv`, `assign`, or `getitem` are contained within it.

```python
In [1]: import dask.dataframe as dd

# long, all-blockwise operation
In [2]: df = dd.demo.make_timeseries().assign(z=lambda df: df.x + df.y).pipe(lambda df: df[[""x"", ""y"", ""z""]] + 1)

In [3]: import distributed
In [4]: client = distributed.Client()

In [4]: pdf = df.persist()
```
![Screen Shot 2022-01-28 at 1 33 53 PM](https://user-images.githubusercontent.com/3309802/151618248-1a677fc1-5e4b-447b-a3da-e143fc5b8335.png)

On the dashboard, the tasks just show up as `add`, so you might be confused what happened to all the other operations.

This could arguably be solved with better documentation (xref https://github.com/dask/dask/issues/8627), but I do think having the concatenated names is more user-friendly than having to find some obscure docs to understand this.

However, I recognize that if you change the name of the layer, you also have to change the names referenced in the dependent layers. That's just not currently possible with HLG layerswe could feasibly do it to MaterializedLayers, but in general, there's no `rename_input_key` interface on a Layer.

Furthermore, this is actually slightly violating the scheduler's assumptions about TaskPrefix keys. In my example above, the scheduler is going to learn a duration estimate for `add` tasks which actually includes that whole chain of operations, and will be quite wrong if I later submit `(df + 1).compute()`.

Maybe we could add a `task-group-key` and `task-prefix-key` annotation to the rewritten layer, which the scheduler would recognize and use instead of `key_split` and `key_split_group` (and would ultimately be displayed on the dashboard)?

cc @rjzamora @jrbourbeau",,https://api.github.com/repos/dask/dask/issues/8635/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8635/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
547,https://api.github.com/repos/dask/dask/issues/8638,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8638/labels{/name},https://api.github.com/repos/dask/dask/issues/8638/comments,https://api.github.com/repos/dask/dask/issues/8638/events,https://github.com/dask/dask/issues/8638,1118193372,I_kwDOAbcwm85Cpkbc,8638,Allow some boolean indexing operations to return correct shape,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,3,2022-01-29T11:37:26Z,2022-08-04T13:51:10Z,,CONTRIBUTOR,,"For some masking operations it's very easy to figure out the shape of the array:

```python
import dask.array as da

a = da.arange(0, 10)

# shape=(10,):
m = da.ones(10, dtype=bool)
a[m] 
Out[46]: dask.array<getitem, shape=(nan,), dtype=int32, chunksize=(nan,), chunktype=numpy.ndarray>

# shape=(10-1,):
m = da.ones(10, dtype=bool)
m[0] = False
a[m]
Out[48]: dask.array<getitem, shape=(nan,), dtype=int32, chunksize=(nan,), chunktype=numpy.ndarray>

# shape=(10-n,):
n = 2
m = da.ones(10, dtype=bool)
m[0:n] = False
a[m]
Out[48]: dask.array<getitem, shape=(nan,), dtype=int32, chunksize=(nan,), chunktype=numpy.ndarray>
```

Not having to do `.compute_chunk_sizes()` after these simple operations seems like a nice feature and will make duck typing with other 3rd party numpy-like packages easier.",,https://api.github.com/repos/dask/dask/issues/8638/timeline,,,Illviljan,14371165,MDQ6VXNlcjE0MzcxMTY1,https://avatars.githubusercontent.com/u/14371165?v=4,,https://api.github.com/users/Illviljan,https://github.com/Illviljan,https://api.github.com/users/Illviljan/followers,https://api.github.com/users/Illviljan/following{/other_user},https://api.github.com/users/Illviljan/gists{/gist_id},https://api.github.com/users/Illviljan/starred{/owner}{/repo},https://api.github.com/users/Illviljan/subscriptions,https://api.github.com/users/Illviljan/orgs,https://api.github.com/users/Illviljan/repos,https://api.github.com/users/Illviljan/events{/privacy},https://api.github.com/users/Illviljan/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8638/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
548,https://api.github.com/repos/dask/dask/issues/8645,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8645/labels{/name},https://api.github.com/repos/dask/dask/issues/8645/comments,https://api.github.com/repos/dask/dask/issues/8645/events,https://github.com/dask/dask/issues/8645,1121009474,I_kwDOAbcwm85C0T9C,8645,[DISCUSSION] What to do about `None` vs `no_default` as a pandas kwargs,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,8,2022-02-01T17:39:10Z,2023-04-26T18:10:29Z,,MEMBER,,"Pandas has started to use a pattern where `None` means something different than `no_default`. So far we've been handling these as they come up (for example: https://github.com/dask/dask/pull/8554), but we should probably figure out what we want to do more generally. 

I've been holding off on the general solution until we can get some feedback from cudf people (cc @quasiben)
",,https://api.github.com/repos/dask/dask/issues/8645/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8645/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
549,https://api.github.com/repos/dask/dask/issues/8656,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8656/labels{/name},https://api.github.com/repos/dask/dask/issues/8656/comments,https://api.github.com/repos/dask/dask/issues/8656/events,https://github.com/dask/dask/issues/8656,1123324440,I_kwDOAbcwm85C9JIY,8656,docs - autogenerate API ,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,"[{'login': 'bryanwweber', 'id': 4396228, 'node_id': 'MDQ6VXNlcjQzOTYyMjg=', 'avatar_url': 'https://avatars.githubusercontent.com/u/4396228?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/bryanwweber', 'html_url': 'https://github.com/bryanwweber', 'followers_url': 'https://api.github.com/users/bryanwweber/followers', 'following_url': 'https://api.github.com/users/bryanwweber/following{/other_user}', 'gists_url': 'https://api.github.com/users/bryanwweber/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/bryanwweber/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/bryanwweber/subscriptions', 'organizations_url': 'https://api.github.com/users/bryanwweber/orgs', 'repos_url': 'https://api.github.com/users/bryanwweber/repos', 'events_url': 'https://api.github.com/users/bryanwweber/events{/privacy}', 'received_events_url': 'https://api.github.com/users/bryanwweber/received_events', 'type': 'User', 'site_admin': False}, {'login': 'scharlottej13', 'id': 8620816, 'node_id': 'MDQ6VXNlcjg2MjA4MTY=', 'avatar_url': 'https://avatars.githubusercontent.com/u/8620816?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/scharlottej13', 'html_url': 'https://github.com/scharlottej13', 'followers_url': 'https://api.github.com/users/scharlottej13/followers', 'following_url': 'https://api.github.com/users/scharlottej13/following{/other_user}', 'gists_url': 'https://api.github.com/users/scharlottej13/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/scharlottej13/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/scharlottej13/subscriptions', 'organizations_url': 'https://api.github.com/users/scharlottej13/orgs', 'repos_url': 'https://api.github.com/users/scharlottej13/repos', 'events_url': 'https://api.github.com/users/scharlottej13/events{/privacy}', 'received_events_url': 'https://api.github.com/users/scharlottej13/received_events', 'type': 'User', 'site_admin': False}]",,1,2022-02-03T16:51:21Z,2022-04-19T16:19:02Z,,MEMBER,,"Currently, when new methods are created they have to be manually added to the docs, leading to issues where things are missing (e.g. #8599). This process is also a blocker for moving the Distributed docs into Dask.

One option is to use the [recursive option](https://sphinx-autosummary-recursion.readthedocs.io/en/latest/) in [sphinx-autosummary](https://www.sphinx-doc.org/en/master/usage/extensions/autosummary.html) released in June 2020.

cc @jsignell",,https://api.github.com/repos/dask/dask/issues/8656/timeline,,,scharlottej13,8620816,MDQ6VXNlcjg2MjA4MTY=,https://avatars.githubusercontent.com/u/8620816?v=4,,https://api.github.com/users/scharlottej13,https://github.com/scharlottej13,https://api.github.com/users/scharlottej13/followers,https://api.github.com/users/scharlottej13/following{/other_user},https://api.github.com/users/scharlottej13/gists{/gist_id},https://api.github.com/users/scharlottej13/starred{/owner}{/repo},https://api.github.com/users/scharlottej13/subscriptions,https://api.github.com/users/scharlottej13/orgs,https://api.github.com/users/scharlottej13/repos,https://api.github.com/users/scharlottej13/events{/privacy},https://api.github.com/users/scharlottej13/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8656/reactions,2,0,0,0,0,0,2,0,0,,,,,,,,,,,,,,,,,,,,,,,,,bryanwweber,4396228.0,MDQ6VXNlcjQzOTYyMjg=,https://avatars.githubusercontent.com/u/4396228?v=4,,https://api.github.com/users/bryanwweber,https://github.com/bryanwweber,https://api.github.com/users/bryanwweber/followers,https://api.github.com/users/bryanwweber/following{/other_user},https://api.github.com/users/bryanwweber/gists{/gist_id},https://api.github.com/users/bryanwweber/starred{/owner}{/repo},https://api.github.com/users/bryanwweber/subscriptions,https://api.github.com/users/bryanwweber/orgs,https://api.github.com/users/bryanwweber/repos,https://api.github.com/users/bryanwweber/events{/privacy},https://api.github.com/users/bryanwweber/received_events,User,False
550,https://api.github.com/repos/dask/dask/issues/8658,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8658/labels{/name},https://api.github.com/repos/dask/dask/issues/8658/comments,https://api.github.com/repos/dask/dask/issues/8658/events,https://github.com/dask/dask/issues/8658,1123396358,I_kwDOAbcwm85C9asG,8658,Groupby Rank,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,2,2022-02-03T18:02:14Z,2023-07-05T23:42:34Z,,MEMBER,,"Similar to https://github.com/dask/dask/issues/7095 , I'd also like to be able to use `rank` on groupby Series and DataFrame objects to create per-group rank columns. Today, I can do this in pandas but not Dask.

```python
import pandas as pd
import dask.dataframe as dd

pdf = pd.DataFrame(
    {""a"": [0, 1, 0, 1, 1, 0], ""b"": range(6), ""c"": [""a"", ""b"", ""c"", ""d"", ""e"", ""f""]}
)
ddf = dd.from_pandas(pdf, 2)

print(pdf.groupby(""a"").b.rank())
ddf.groupby(""a"").b.rank()

0    1.0
1    1.0
2    2.0
3    2.0
4    3.0
5    3.0
Name: b, dtype: float64
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Input In [1], in <module>
      7 ddf = dd.from_pandas(pdf, 2)
      9 print(pdf.groupby(""a"").b.rank())
---> 10 ddf.groupby(""a"").b.rank()

AttributeError: 'SeriesGroupBy' object has no attribute 'rank'
```

```
conda list | grep ""pandas\|dask""
dask                      2022.1.0           pyhd8ed1ab_0    conda-forge
dask-core                 2022.1.0           pyhd8ed1ab_0    conda-forge
dask-cuda                 22.04.00a220201          py38_8    rapidsai-nightly
dask-cudf                 22.04.00a220201 cuda_11_py38_g2c6b0dac61_95    rapidsai-nightly
geopandas                 0.9.0              pyhd8ed1ab_1    conda-forge
geopandas-base            0.9.0              pyhd8ed1ab_1    conda-forge
pandas                    1.3.5            py38h43a58ef_0    conda-forge
```",,https://api.github.com/repos/dask/dask/issues/8658/timeline,,,beckernick,8457388,MDQ6VXNlcjg0NTczODg=,https://avatars.githubusercontent.com/u/8457388?v=4,,https://api.github.com/users/beckernick,https://github.com/beckernick,https://api.github.com/users/beckernick/followers,https://api.github.com/users/beckernick/following{/other_user},https://api.github.com/users/beckernick/gists{/gist_id},https://api.github.com/users/beckernick/starred{/owner}{/repo},https://api.github.com/users/beckernick/subscriptions,https://api.github.com/users/beckernick/orgs,https://api.github.com/users/beckernick/repos,https://api.github.com/users/beckernick/events{/privacy},https://api.github.com/users/beckernick/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8658/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
551,https://api.github.com/repos/dask/dask/issues/8659,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8659/labels{/name},https://api.github.com/repos/dask/dask/issues/8659/comments,https://api.github.com/repos/dask/dask/issues/8659/events,https://github.com/dask/dask/pull/8659,1123464853,PR_kwDOAbcwm84yC7GT,8659,Add Groupby.rank for DataFrame and Series GroupBy,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,10,2022-02-03T19:20:26Z,2022-11-21T11:03:57Z,,MEMBER,,"This PR implements `{Series, DataFrame}.groupby.rank` based on the same hash partition pattern used by `groupby.{shift, transform, apply}`.

- [x] Closes #8658
- [x] Tests added / passed (locally)
- [x] Passes `pre-commit run --all-files` (locally)

Quick question: It seems like there is a fair bit of duplication of semantics in the various `_groupby_slice_*` functions. Perhaps some of this could be refactored into an internal utility? If desired, please let me know.
",,https://api.github.com/repos/dask/dask/issues/8659/timeline,,,beckernick,8457388,MDQ6VXNlcjg0NTczODg=,https://avatars.githubusercontent.com/u/8457388?v=4,,https://api.github.com/users/beckernick,https://github.com/beckernick,https://api.github.com/users/beckernick/followers,https://api.github.com/users/beckernick/following{/other_user},https://api.github.com/users/beckernick/gists{/gist_id},https://api.github.com/users/beckernick/starred{/owner}{/repo},https://api.github.com/users/beckernick/subscriptions,https://api.github.com/users/beckernick/orgs,https://api.github.com/users/beckernick/repos,https://api.github.com/users/beckernick/events{/privacy},https://api.github.com/users/beckernick/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8659/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8659,https://github.com/dask/dask/pull/8659,https://github.com/dask/dask/pull/8659.diff,https://github.com/dask/dask/pull/8659.patch,,,,,,,,,,,,,,,,,,,
552,https://api.github.com/repos/dask/dask/issues/8750,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8750/labels{/name},https://api.github.com/repos/dask/dask/issues/8750/comments,https://api.github.com/repos/dask/dask/issues/8750/events,https://github.com/dask/dask/pull/8750,1148385372,PR_kwDOAbcwm84zW_Ck,8750,Array API implementation,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,29,2022-02-23T17:38:52Z,2023-02-23T20:15:23Z,,MEMBER,,"- [ ] Closes https://github.com/dask/community/issues/109
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`

This is a Dask implementation of the [Python Array API standard](https://data-apis.org/array-api/latest/), discussed in https://github.com/dask/community/issues/109.

It is provided in the `dask.array_api` namespace, so it is independent of the existing `dask.array` implementation.

There are a few parts of the API that are not implemented since they don't exist in Dask (such as [sorting functions](https://data-apis.org/array-api/latest/API_specification/sorting_functions.html), and [in-place operations](https://data-apis.org/array-api/latest/API_specification/array_object.html#in-place-operators)), and these are excluded when running the test suite. Apart from these tests there are [two failures](https://github.com/tomwhite/dask/runs/5306535598?check_suite_focus=true): one (`test_array_object.py::test_getitem_masking`) looks like it is a shape problem in the test suite, the other should be fixed by #8676. (Note that more edge-case failures will be found when we get Hypothesis to try more examples.)

I've included a GitHub action to run the [array API test suite](https://github.com/data-apis/array-api-tests), but I've configured it to be [triggered manually](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch) for the time being since not all tests are passing yet.",,https://api.github.com/repos/dask/dask/issues/8750/timeline,,,tomwhite,85085,MDQ6VXNlcjg1MDg1,https://avatars.githubusercontent.com/u/85085?v=4,,https://api.github.com/users/tomwhite,https://github.com/tomwhite,https://api.github.com/users/tomwhite/followers,https://api.github.com/users/tomwhite/following{/other_user},https://api.github.com/users/tomwhite/gists{/gist_id},https://api.github.com/users/tomwhite/starred{/owner}{/repo},https://api.github.com/users/tomwhite/subscriptions,https://api.github.com/users/tomwhite/orgs,https://api.github.com/users/tomwhite/repos,https://api.github.com/users/tomwhite/events{/privacy},https://api.github.com/users/tomwhite/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8750/reactions,7,0,0,0,7,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8750,https://github.com/dask/dask/pull/8750,https://github.com/dask/dask/pull/8750.diff,https://github.com/dask/dask/pull/8750.patch,,,,,,,,,,,,,,,,,,,
553,https://api.github.com/repos/dask/dask/issues/8760,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8760/labels{/name},https://api.github.com/repos/dask/dask/issues/8760/comments,https://api.github.com/repos/dask/dask/issues/8760/events,https://github.com/dask/dask/issues/8760,1151024140,I_kwDOAbcwm85EmzwM,8760,Error pickling h5py objects with multiprocessing scheduler,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}, {'id': 3798450422, 'node_id': 'LA_kwDOAbcwm87iZ8D2', 'url': 'https://api.github.com/repos/dask/dask/labels/p3', 'name': 'p3', 'color': 'ffff33', 'default': False, 'description': 'Affects a small number of users or is largely cosmetic'}]",open,False,,[],,3,2022-02-26T01:34:30Z,2022-06-30T14:39:48Z,,MEMBER,,"**What happened**:
This issue first came up on [discourse](https://dask.discourse.group/t/h5py-objects-cannot-be-pickled-or-slow-processing/229). When using the multiprocessing scheduler with `h5py` objects, there is a `TypeError: h5py objects cannot be pickled`. This does not happen when using the distributed scheduler.

**Minimal Complete Verifiable Example**:
```python
import h5py
import dask.array as da

# create fake hdf5 for testing
f = h5py.File(""tmp/mytestfile.hdf5"", ""w"")
dset = f.create_dataset(""mydataset"", (1000, 3), dtype='i')

# read it back in
f = h5py.File('tmp/mytestfile.hdf5', 'r')
dset = f['mydataset']

# send dask array result to map_blocks
dask_array = da.from_array(dset, chunks=(dset.shape[0], 1))

doubled = dask_array.map_blocks(lambda x: x * 2)
doubled.compute(scheduler='processes')
```
<details>
 <summary>Full traceback</summary>

```python-traceback
  ---------------------------------------------------------------------------
  TypeError                                 Traceback (most recent call last)
  /var/folders/hf/2s7qjx7j5ndc5220_qxv8y800000gn/T/ipykernel_8250/2047040186.py in <module>
       17 
       18 # compute
  ---> 19 doubled.compute(scheduler='processes')
  
  ~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/base.py in compute(self, **kwargs)
      288         dask.base.compute
      289         """"""
  --> 290         (result,) = compute(self, traverse=False, **kwargs)
      291         return result
      292 
  
  ~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/base.py in compute(traverse, optimize_graph, scheduler, get, *args, **kwargs)
      571         postcomputes.append(x.__dask_postcompute__())
      572 
  --> 573     results = schedule(dsk, keys, **kwargs)
      574     return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
      575 
  
  ~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/multiprocessing.py in get(dsk, keys, num_workers, func_loads, func_dumps, optimize_graph, pool, chunksize, **kwargs)
      218     try:
      219         # Run
  --> 220         result = get_async(
      221             pool.submit,
      222             pool._max_workers,
  
  ~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/local.py in get_async(submit, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, chunksize, **kwargs)
      492             # Main loop, wait on tasks to finish, insert new ones
      493             while state[""waiting""] or state[""ready""] or state[""running""]:
  --> 494                 fire_tasks(chunksize)
      495                 for key, res_info, failed in queue_get(queue).result():
      496                     if failed:
  
  ~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/dask/local.py in fire_tasks(chunksize)
      474                         (
      475                             key,
  --> 476                             dumps((dsk[key], data)),
      477                             dumps,
      478                             loads,
  
  ~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/cloudpickle/cloudpickle_fast.py in dumps(obj, protocol, buffer_callback)
       71                 file, protocol=protocol, buffer_callback=buffer_callback
       72             )
  ---> 73             cp.dump(obj)
       74             return file.getvalue()
       75 
  
  ~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/cloudpickle/cloudpickle_fast.py in dump(self, obj)
      600     def dump(self, obj):
      601         try:
  --> 602             return Pickler.dump(self, obj)
      603         except RuntimeError as e:
      604             if ""recursion"" in e.args[0]:
  
  ~/mambaforge/envs/dask-mini-tutorial/lib/python3.9/site-packages/h5py/_hl/base.py in __getnewargs__(self)
      366         limitations, look at the h5pickle project on PyPI.
      367         """"""
  --> 368         raise TypeError(""h5py objects cannot be pickled"")
      369 
      370     def __getstate__(self):
  
  TypeError: h5py objects cannot be pickled
  ```
</details>


**Anything else we need to know?**:
I tried the same with zarr and there was no error:
```python
import zarr
import dask.array as da

# create fake zarr array
zarr_array = zarr.zeros((1000, 3), chunks=(1000, 1), dtype='i')

# convert to dask array
dask_array = da.from_zarr(zarr_array, chunks=(zarr_array.shape[0], 1))

# apply function
doubled = dask_array.map_blocks(lambda x: x * 2)

# compute
doubled.compute(scheduler='processes')
```

**Environment**:

- Dask version: 2022.02.1
- Python version: 3.9
- Operating System: Mac
- Install method (conda, pip, source): conda",,https://api.github.com/repos/dask/dask/issues/8760/timeline,,,scharlottej13,8620816,MDQ6VXNlcjg2MjA4MTY=,https://avatars.githubusercontent.com/u/8620816?v=4,,https://api.github.com/users/scharlottej13,https://github.com/scharlottej13,https://api.github.com/users/scharlottej13/followers,https://api.github.com/users/scharlottej13/following{/other_user},https://api.github.com/users/scharlottej13/gists{/gist_id},https://api.github.com/users/scharlottej13/starred{/owner}{/repo},https://api.github.com/users/scharlottej13/subscriptions,https://api.github.com/users/scharlottej13/orgs,https://api.github.com/users/scharlottej13/repos,https://api.github.com/users/scharlottej13/events{/privacy},https://api.github.com/users/scharlottej13/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8760/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
554,https://api.github.com/repos/dask/dask/issues/8769,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8769/labels{/name},https://api.github.com/repos/dask/dask/issues/8769/comments,https://api.github.com/repos/dask/dask/issues/8769/events,https://github.com/dask/dask/issues/8769,1156185195,I_kwDOAbcwm85E6fxr,8769,DataFrame merge: clarify that merging on column puts all matching values into one partition,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2022-03-02T02:01:55Z,2022-04-27T18:05:03Z,,MEMBER,,"I naively tried to do `dd.merge(a, b, on=""column_with_ten_values"")`, where `a` and `b` were both large DataFrames with thousands of partitions each.

Eventually the compute failed with:
```python-traceback
[File /opt/conda/envs/coiled/lib/python3.9/site-packages/dask/dataframe/multi.py:275, in merge_chunk()

File /opt/conda/envs/coiled/lib/python3.9/site-packages/pandas/core/frame.py:9329, in merge()

File /opt/conda/envs/coiled/lib/python3.9/site-packages/pandas/core/reshape/merge.py:122, in merge()

File /opt/conda/envs/coiled/lib/python3.9/site-packages/pandas/core/reshape/merge.py:716, in get_result()

File /opt/conda/envs/coiled/lib/python3.9/site-packages/pandas/core/reshape/merge.py:967, in _get_join_info()

File /opt/conda/envs/coiled/lib/python3.9/site-packages/pandas/core/reshape/merge.py:941, in _get_join_indexers()

File /opt/conda/envs/coiled/lib/python3.9/site-packages/pandas/core/reshape/merge.py:1509, in get_join_indexers()

File ~/Library/Caches/pypoetry/virtualenvs/workshop-one-3dbJnD_1-py3.9/lib/python3.9/site-packages/pandas/_libs/join.pyx:48, in pandas._libs.join.inner_join()
     ]()[46](file:///~/Library/Caches/pypoetry/virtualenvs/workshop-one-3dbJnD_1-py3.9/lib/python3.9/site-packages/pandas/_libs/join.pyx?line=45)[             count += lc * rc
     ]()[47](file:///~/Library/Caches/pypoetry/virtualenvs/workshop-one-3dbJnD_1-py3.9/lib/python3.9/site-packages/pandas/_libs/join.pyx?line=46)[ 
---> ]()[48](file:///~/Library/Caches/pypoetry/virtualenvs/workshop-one-3dbJnD_1-py3.9/lib/python3.9/site-packages/pandas/_libs/join.pyx?line=47)[ left_indexer = np.empty(count, dtype=np.intp)
     ]()[49](file:///~/Library/Caches/pypoetry/virtualenvs/workshop-one-3dbJnD_1-py3.9/lib/python3.9/site-packages/pandas/_libs/join.pyx?line=48)[ right_indexer = np.empty(count, dtype=np.intp)
     ]()[50](file:///~/Library/Caches/pypoetry/virtualenvs/workshop-one-3dbJnD_1-py3.9/lib/python3.9/site-packages/pandas/_libs/join.pyx?line=49)[ 

MemoryError: Unable to allocate 224. TiB for an array with shape (30824647463820,) and data type int64]()
```

I was confused why a 224 TiB array needed to be allocated. As a user, this was a strange and concerning error to see. Eventually I realized that my `on` column had only a few unique values, so (I think) it was trying to concatenate all those values across all partitions into one during the shuffle stage of the hash join. Because the shuffle ensures that:

> After this operation all elements that have the same index will be in the same partition.

It would be good to:
1. Document clearly that when merging on a column, every row with the same value needs to be able to fit into one partition. If there are only a few unique values for the column, but many rows, you'll likely encounter an error.
2. Catch/preemptively check for this error at runtime, and reraise a more informative error to users. Not sure what alternative we'd suggest though. The fact that divisions, and by extension shuffling, can't handle repeated values (xref https://github.com/dask/dask/issues/8437) I think makes this fundamentally unsupported right now?

cc @jsignell ",,https://api.github.com/repos/dask/dask/issues/8769/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8769/reactions,0,0,0,0,0,0,0,0,0,jsignell,4806877.0,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
555,https://api.github.com/repos/dask/dask/issues/8800,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8800/labels{/name},https://api.github.com/repos/dask/dask/issues/8800/comments,https://api.github.com/repos/dask/dask/issues/8800/events,https://github.com/dask/dask/issues/8800,1166448525,I_kwDOAbcwm85FhpeN,8800,`groupby.transform` failing on dataframe with duplicates in column,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,3,2022-03-11T13:59:56Z,2022-03-24T22:43:31Z,,NONE,,"I'm trying to process parquet files stored in AWS S3.

The files are read simply with
```python
with Client(n_workers=6) as client:
    df = dd.read_parquet('s3://lightnings_*.gzip.parquet')
    df['time_plot'] = df.time.dt.round(freq='15 min')
```
It looks like this 

| time                             |   latitude |   longitude | time_plot                 |
|:---------------------------------|-----------:|------------:|:--------------------------|
| 2021-04-01 00:00:30.688104+00:00 |    36.4179 |     34.1496 | 2021-04-01 00:00:00+00:00 |
| 2021-04-01 00:25:24.591956+00:00 |    37.7171 |    -10.604  | 2021-04-01 00:30:00+00:00 |

There are some duplicated rows (not shown here)!

When trying to apply a `groupby` operation

```python
    df['seconds_elapsed'] = df.groupby(""time_plot"").time.transform(
            lambda x: (x - x.min()).dt.seconds)
```

I get an error: `ValueError: cannot reindex on an axis with duplicate labels`.
The same code runs fine on a normal `pandas.DataFrame` by calling `.compute()` before. 

As I thought the problem was related to the duplicates I tried to remove them before calling the `groupby.transform`, i.e.

```python
    df = df.drop_duplicates(subset=['time'], split_out=6)
```

This takes a long time, uses a lot of memory and still does not fix the problem as I still get the error reported before. Note that I had to use `split_out` otherwise the workers were running out of memory. 

As workaround I'm currently loading the dataset into memory (`df.compute()`) before passing it to the `groupby` operations, but this is quite slow as this is applied serially so it would be good to adapt the workflow with Dask. 

Anyone has suggestions on what I'm doing wrong? ",,https://api.github.com/repos/dask/dask/issues/8800/timeline,,,guidocioni,12760310,MDQ6VXNlcjEyNzYwMzEw,https://avatars.githubusercontent.com/u/12760310?v=4,,https://api.github.com/users/guidocioni,https://github.com/guidocioni,https://api.github.com/users/guidocioni/followers,https://api.github.com/users/guidocioni/following{/other_user},https://api.github.com/users/guidocioni/gists{/gist_id},https://api.github.com/users/guidocioni/starred{/owner}{/repo},https://api.github.com/users/guidocioni/subscriptions,https://api.github.com/users/guidocioni/orgs,https://api.github.com/users/guidocioni/repos,https://api.github.com/users/guidocioni/events{/privacy},https://api.github.com/users/guidocioni/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8800/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
556,https://api.github.com/repos/dask/dask/issues/8808,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8808/labels{/name},https://api.github.com/repos/dask/dask/issues/8808/comments,https://api.github.com/repos/dask/dask/issues/8808/events,https://github.com/dask/dask/issues/8808,1168896529,I_kwDOAbcwm85Fq_IR,8808,Periodic distributed test failures on osx,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,1,2022-03-14T20:58:52Z,2022-03-16T16:27:36Z,,MEMBER,,"We've been seeing some periodic test failures on osx CI for the last couple days. Example failure report: https://github.com/dask/dask/runs/5543476482?check_suite_focus=true.

The error indicates that no event loop is found in the executing thread:

```python
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x7fa58c843a90>

    def get_event_loop(self):
        """"""Get the event loop for the current context.
    
        Returns an instance of EventLoop or raises an exception.
        """"""
        if (self._local._loop is None and
                not self._local._set_called and
                isinstance(threading.current_thread(), threading._MainThread)):
            self.set_event_loop(self.new_event_loop())
    
        if self._local._loop is None:
>           raise RuntimeError('There is no current event loop in thread %r.'
                               % threading.current_thread().name)
E           RuntimeError: There is no current event loop in thread 'Dummy-1'.

../../../miniconda3/envs/test-environment/lib/python3.8/asyncio/events.py:639: RuntimeError
```

I touched code related to this several months ago, (https://github.com/dask/distributed/pull/5531, https://github.com/dask/distributed/pull/5593), but am not sure what (if anything) changed recently. cc @fjetter.",,https://api.github.com/repos/dask/dask/issues/8808/timeline,,,jcrist,2783717,MDQ6VXNlcjI3ODM3MTc=,https://avatars.githubusercontent.com/u/2783717?v=4,,https://api.github.com/users/jcrist,https://github.com/jcrist,https://api.github.com/users/jcrist/followers,https://api.github.com/users/jcrist/following{/other_user},https://api.github.com/users/jcrist/gists{/gist_id},https://api.github.com/users/jcrist/starred{/owner}{/repo},https://api.github.com/users/jcrist/subscriptions,https://api.github.com/users/jcrist/orgs,https://api.github.com/users/jcrist/repos,https://api.github.com/users/jcrist/events{/privacy},https://api.github.com/users/jcrist/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8808/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
557,https://api.github.com/repos/dask/dask/issues/8813,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8813/labels{/name},https://api.github.com/repos/dask/dask/issues/8813/comments,https://api.github.com/repos/dask/dask/issues/8813/events,https://github.com/dask/dask/issues/8813,1170070214,I_kwDOAbcwm85FvdrG,8813,Some `dt` accessor methods applied to an Index may result in invalid divisions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2022-03-15T19:02:54Z,2022-03-16T16:25:07Z,,MEMBER,,"Specifically, I found that `index.dt.floor(...)` can result in invalid divisions if the divisions already align with the period passed to floor. For example:

```python
import dask.dataframe as dd
import pandas as pd

date_index = pd.date_range(start=""2022-02-22"", freq=""16h"", periods=12)
df = pd.Series(range(12), index=date_index)
ddf = dd.from_pandas(df, npartitions=3)

res = ddf.index.dt.floor(""D"")
sol = df.index.floor(""D"")

dd.assert_eq(res, sol)
```

Results in 

```python-traceback
Traceback (most recent call last):
  File ""/home/jcristharif/Code/dask/test.py"", line 11, in <module>
    dd.assert_eq(res, sol)
  File ""/home/jcristharif/Code/dask/dask/dataframe/utils.py"", line 537, in assert_eq
    assert_divisions(a, scheduler=scheduler)
  File ""/home/jcristharif/Code/dask/dask/dataframe/utils.py"", line 616, in assert_divisions
    assert index(df).max() < ddf.divisions[i + 1]
AssertionError
```

This error indicates that the max of a partition isn't less than the upper bound for that partition as stated by the divisions. This is because the divisions were adjusted by `map_partitions` (with `.floor(""D"")` applied), and that adjustment is non-linear (multiple values all mapped to the same output). `ceil` is also broken for the same reason, and there may be other `dt` methods with the same issue.

Action items:

- [ ] Special case `ceil` & `floor` methods in the `DatetimeAccessor` class to properly adjust the divisions given an `Index` with known divisions
- [ ] Evaluate other `dt` methods for similar bugs, and fix those as well (or create specific issues for them as found)
- [ ] Improve our test coverage for the `DatetimeAccessor`, covering both `Series.dt` and `Index.dt` (with known and unknown divisions).",,https://api.github.com/repos/dask/dask/issues/8813/timeline,,,jcrist,2783717,MDQ6VXNlcjI3ODM3MTc=,https://avatars.githubusercontent.com/u/2783717?v=4,,https://api.github.com/users/jcrist,https://github.com/jcrist,https://api.github.com/users/jcrist/followers,https://api.github.com/users/jcrist/following{/other_user},https://api.github.com/users/jcrist/gists{/gist_id},https://api.github.com/users/jcrist/starred{/owner}{/repo},https://api.github.com/users/jcrist/subscriptions,https://api.github.com/users/jcrist/orgs,https://api.github.com/users/jcrist/repos,https://api.github.com/users/jcrist/events{/privacy},https://api.github.com/users/jcrist/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8813/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
558,https://api.github.com/repos/dask/dask/issues/8815,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8815/labels{/name},https://api.github.com/repos/dask/dask/issues/8815/comments,https://api.github.com/repos/dask/dask/issues/8815/events,https://github.com/dask/dask/issues/8815,1170152453,I_kwDOAbcwm85FvxwF,8815,`test_partition_on_duplicates` failure on windows python3.8 CI,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-03-15T20:00:49Z,2022-04-18T02:12:04Z,,MEMBER,,"Just noticed this in CI so I wanted to document it. Mild ping to @martindurant in case something has changed on the fastparquet side. 

```python-traceback
__________________ test_partition_on_duplicates[fastparquet] __________________
[gw3] win32 -- Python 3.8.12 C:\Miniconda3\envs\test-environment\python.exe

tmpdir = 'C:\\Users\\runneradmin\\AppData\\Local\\Temp\\pytest-of-runneradmin\\pytest-0\\popen-gw3\\test_partition_on_duplicates_f0'
engine = 'fastparquet'

    def test_partition_on_duplicates(tmpdir, engine):
        # https://github.com/dask/dask/issues/6445
        tmpdir = str(tmpdir)
        df = pd.DataFrame(
            {
                ""a1"": np.random.choice([""A"", ""B"", ""C""], size=100),
                ""a2"": np.random.choice([""X"", ""Y"", ""Z""], size=100),
                ""data"": np.random.random(size=100),
            }
        )
        d = dd.from_pandas(df, npartitions=2)
    
        for _ in range(2):
            d.to_parquet(tmpdir, partition_on=[""a1"", ""a2""], engine=engine)
    
>       out = dd.read_parquet(tmpdir, engine=engine).compute()

dask\dataframe\io\tests\test_parquet.py:1298: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
dask\base.py:292: in compute
    (result,) = compute(self, traverse=False, **kwargs)
dask\base.py:575: in compute
    results = schedule(dsk, keys, **kwargs)
dask\threaded.py:81: in get
    results = get_async(
dask\local.py:508: in get_async
    raise_exception(exc, tb)
dask\local.py:316: in reraise
    raise exc
dask\local.py:221: in execute_task
    result = _execute_task(task, data)
dask\core.py:119: in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
dask\optimization.py:990: in __call__
    return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
dask\core.py:149: in get
    result = _execute_task(task, cache)
dask\core.py:119: in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
dask\dataframe\io\parquet\core.py:90: in __call__
    return read_parquet_part(
dask\dataframe\io\parquet\core.py:498: in read_parquet_part
    dfs = [
dask\dataframe\io\parquet\core.py:499: in <listcomp>
    func(fs, rg, columns.copy(), index, **toolz.merge(kwargs, kw))
dask\dataframe\io\parquet\fastparquet.py:1027: in read_partition
    return cls.pf_to_pandas(
dask\dataframe\io\parquet\fastparquet.py:1119: in pf_to_pandas
    pf.read_row_group_file(
C:\Miniconda3\envs\test-environment\lib\site-packages\fastparquet\api.py:336: in read_row_group_file
    core.read_row_group(
C:\Miniconda3\envs\test-environment\lib\site-packages\fastparquet\core.py:608: in read_row_group
    read_row_group_arrays(file, rg, columns, categories, schema_helper,
C:\Miniconda3\envs\test-environment\lib\site-packages\fastparquet\core.py:580: in read_row_group_arrays
    read_col(column, schema_helper, file, use_cat=name+'-catdef' in out,
C:\Miniconda3\envs\test-environment\lib\site-packages\fastparquet\core.py:435: in read_col
    se = schema_helper.schema_element(cmd.path_in_schema)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Parquet Schema with 3 entries>, name = ['__null_dask_index__']

    def schema_element(self, name):
        """"""Get the schema element with the given name or path""""""
        root = self.root
        if isinstance(name, str):
            name = name.split('.')
        for part in name:
>           root = root[""children""][part]
E           KeyError: '__null_dask_index__'

C:\Miniconda3\envs\test-environment\lib\site-packages\fastparquet\schema.py:119: KeyError
```",,https://api.github.com/repos/dask/dask/issues/8815/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8815/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
559,https://api.github.com/repos/dask/dask/issues/8816,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8816/labels{/name},https://api.github.com/repos/dask/dask/issues/8816/comments,https://api.github.com/repos/dask/dask/issues/8816/events,https://github.com/dask/dask/issues/8816,1170191912,I_kwDOAbcwm85Fv7Yo,8816,`test_blockwise_dataframe_io[True-False-hdf]` is flaky on osx CI,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,"[{'login': 'jrbourbeau', 'id': 11656932, 'node_id': 'MDQ6VXNlcjExNjU2OTMy', 'avatar_url': 'https://avatars.githubusercontent.com/u/11656932?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/jrbourbeau', 'html_url': 'https://github.com/jrbourbeau', 'followers_url': 'https://api.github.com/users/jrbourbeau/followers', 'following_url': 'https://api.github.com/users/jrbourbeau/following{/other_user}', 'gists_url': 'https://api.github.com/users/jrbourbeau/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/jrbourbeau/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/jrbourbeau/subscriptions', 'organizations_url': 'https://api.github.com/users/jrbourbeau/orgs', 'repos_url': 'https://api.github.com/users/jrbourbeau/repos', 'events_url': 'https://api.github.com/users/jrbourbeau/events{/privacy}', 'received_events_url': 'https://api.github.com/users/jrbourbeau/received_events', 'type': 'User', 'site_admin': False}]",,15,2022-03-15T20:21:29Z,2022-08-04T19:09:03Z,,MEMBER,,"I noticed this test periodically failing due to a pytables locking issue today (may have started earlier). 

<details>
<summary>Traceback </summary>

```
_________________ test_blockwise_dataframe_io[True-False-hdf] __________________
[gw0] darwin -- Python 3.8.12 /Users/runner/miniconda3/envs/test-environment/bin/python

c = <Client: 'tcp://127.0.0.1:50922' processes=2 threads=2, memory=28.00 GiB>
tmpdir = local('/private/var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/pytest-of-runner/pytest-0/popen-gw0/test_blockwise_dataframe_io_Tr3')
io = 'hdf', fuse = False, from_futures = True

    @pytest.mark.filterwarnings(
        ""ignore:Running on a single-machine scheduler when a distributed client ""
        ""is active might lead to unexpected results.""
    )
    @pytest.mark.parametrize(
        ""io"",
        [""parquet-pyarrow"", ""parquet-fastparquet"", ""csv"", ""hdf""],
    )
    @pytest.mark.parametrize(""fuse"", [True, False, None])
    @pytest.mark.parametrize(""from_futures"", [True, False])
    def test_blockwise_dataframe_io(c, tmpdir, io, fuse, from_futures):
        pd = pytest.importorskip(""pandas"")
        dd = pytest.importorskip(""dask.dataframe"")
    
        df = pd.DataFrame({""x"": [1, 2, 3] * 5, ""y"": range(15)})
    
        if from_futures:
            parts = [df.iloc[:5], df.iloc[5:10], df.iloc[10:15]]
            futs = c.scatter(parts)
            ddf0 = dd.from_delayed(futs, meta=parts[0])
        else:
            ddf0 = dd.from_pandas(df, npartitions=3)
    
        if io.startswith(""parquet""):
            if io == ""parquet-pyarrow"":
                pytest.importorskip(""pyarrow.parquet"")
                engine = ""pyarrow""
            else:
                pytest.importorskip(""fastparquet"")
                engine = ""fastparquet""
            ddf0.to_parquet(str(tmpdir), engine=engine)
            ddf = dd.read_parquet(str(tmpdir), engine=engine)
        elif io == ""csv"":
            ddf0.to_csv(str(tmpdir), index=False)
            ddf = dd.read_csv(os.path.join(str(tmpdir), ""*""))
        elif io == ""hdf"":
            pytest.importorskip(""tables"")
            fn = str(tmpdir.join(""h5""))
>           ddf0.to_hdf(fn, ""/data*"")

dask/tests/test_distributed.py:370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dask/dataframe/core.py:1620: in to_hdf
    return to_hdf(self, path_or_buf, key, mode, append, **kwargs)
dask/dataframe/io/hdf.py:251: in to_hdf
    compute_as_if_collection(
dask/base.py:319: in compute_as_if_collection
    return schedule(dsk2, keys, **kwargs)
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/distributed/client.py:3015: in get
    results = self.gather(packed, asynchronous=asynchronous, direct=direct)
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/distributed/client.py:2167: in gather
    return self.sync(
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/distributed/utils.py:311: in sync
    return sync(
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/distributed/utils.py:378: in sync
    raise exc.with_traceback(tb)
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/distributed/utils.py:351: in f
    result = yield future
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/tornado/gen.py:762: in run
    value = future.result()
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/distributed/client.py:2030: in _gather
    raise exception.with_traceback(traceback)
dask/dataframe/io/hdf.py:27: in _pd_to_hdf
    pd_to_hdf(*args, **kwargs)
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/pandas/core/generic.py:2606: in to_hdf
    pytables.to_hdf(
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/pandas/io/pytables.py:277: in to_hdf
    with HDFStore(
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/pandas/io/pytables.py:561: in __init__
    self.open(mode=mode, **kwargs)
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/pandas/io/pytables.py:710: in open
    self._handle = tables.open_file(self._path, self._mode, **kwargs)
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/tables/file.py:300: in open_file
    return File(filename, mode, title, root_uep, filters, **kwargs)
../../../miniconda3/envs/test-environment/lib/python3.8/site-packages/tables/file.py:750: in __init__
    self._g_new(filename, mode, **params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   tables.exceptions.HDF5ExtError: HDF5 error back trace
E   
E     File ""H5F.c"", line 620, in H5Fopen
E       unable to open file
E     File ""H5VLcallback.c"", line 3502, in H5VL_file_open
E       failed to iterate over available VOL connector plugins
E     File ""H5PLpath.c"", line 579, in H5PL__path_table_iterate
E       can't iterate over plugins in plugin path '(null)'
E     File ""H5PLpath.c"", line 620, in H5PL__path_table_iterate_process_path
E       can't open directory: /Users/runner/miniconda3/envs/test-environment/lib/hdf5/plugin
E     File ""H5VLcallback.c"", line 3351, in H5VL__file_open
E       open failed
E     File ""H5VLnative_file.c"", line 97, in H5VL__native_file_open
E       unable to open file
E     File ""H5Fint.c"", line 1898, in H5F_open
E       unable to lock the file
E     File ""H5FD.c"", line 1625, in H5FD_lock
E       driver lock request failed
E     File ""H5FDsec2.c"", line 1002, in H5FD__sec2_lock
E       unable to lock file, errno = 35, error message = 'Resource temporarily unavailable'
E   
E   End of HDF5 error back trace
E   
E   Unable to open/create file '/private/var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/pytest-of-runner/pytest-0/popen-gw0/test_blockwise_dataframe_io_Tr3/h5'

tables/hdf5extension.pyx:486: HDF5ExtError
```

</details>

Log from failing test: https://github.com/dask/dask/runs/5558289646?check_suite_focus=true#step:6:21912",,https://api.github.com/repos/dask/dask/issues/8816/timeline,,,jcrist,2783717,MDQ6VXNlcjI3ODM3MTc=,https://avatars.githubusercontent.com/u/2783717?v=4,,https://api.github.com/users/jcrist,https://github.com/jcrist,https://api.github.com/users/jcrist/followers,https://api.github.com/users/jcrist/following{/other_user},https://api.github.com/users/jcrist/gists{/gist_id},https://api.github.com/users/jcrist/starred{/owner}{/repo},https://api.github.com/users/jcrist/subscriptions,https://api.github.com/users/jcrist/orgs,https://api.github.com/users/jcrist/repos,https://api.github.com/users/jcrist/events{/privacy},https://api.github.com/users/jcrist/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8816/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,jrbourbeau,11656932.0,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False
560,https://api.github.com/repos/dask/dask/issues/8821,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8821/labels{/name},https://api.github.com/repos/dask/dask/issues/8821/comments,https://api.github.com/repos/dask/dask/issues/8821/events,https://github.com/dask/dask/pull/8821,1171917955,PR_kwDOAbcwm840k0a9,8821,Update Dask configuration reference with undocumented options,"[{'id': 1012929478, 'node_id': 'MDU6TGFiZWwxMDEyOTI5NDc4', 'url': 'https://api.github.com/repos/dask/dask/labels/config', 'name': 'config', 'color': '1586c0', 'default': False, 'description': ''}]",open,False,,[],,1,2022-03-17T04:27:51Z,2022-03-24T19:51:12Z,,MEMBER,,"I noticed that there are a lot of configuration options that are used throughout Dask's code that aren't actually mentioned on the configuration reference page, which is where I'd imagine a lot of users would go immediately to see what a specific option controls.

This PR is an attempt to enumerate all of those undocumented options, and give them descriptions / a default value in the config YAML if that makes sense. Some other out of scope, but also useful things that could be done:

- making sure that all `config.get`/`set` calls are using an existing / consistent config option; in looking through the codebase, I noticed [some typos](https://github.com/dask/dask/blob/4e5dfe7463028a39a90e026c7fb9220969093ab3/dask/dataframe/tests/test_shuffle.py#L301) when setting config options, and others that are referred to by different names (i.e. `array.slicing.split-large-chunks` vs `array.slicing.split_large_chunks`)
- Adding a simple Python test (or, if mandatory, CI job) to check that if a new config option is added, it is referenced in the schema

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/8821/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8821/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/8821,https://github.com/dask/dask/pull/8821,https://github.com/dask/dask/pull/8821.diff,https://github.com/dask/dask/pull/8821.patch,,,,,,,,,,,,,,,,,,,
561,https://api.github.com/repos/dask/dask/issues/8829,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8829/labels{/name},https://api.github.com/repos/dask/dask/issues/8829/comments,https://api.github.com/repos/dask/dask/issues/8829/events,https://github.com/dask/dask/issues/8829,1174841234,I_kwDOAbcwm85GBqeS,8829,dask DataFrame.read_parquet doesn't preserve the paths order,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,13,2022-03-21T03:31:49Z,2022-03-25T21:28:28Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
Dask doesn't honor the order of files listed in the path

**What you expected to happen**:
I would have expected the partition ordering to be consistent with list of paths in read_parquet. Seems like the input path is automatically sorted internally without choice. 

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import pandas as pd
df1=pd.DataFrame({'i': [1, 1], 'A': [1.0, 2.0], 'B': [11.0, 12.0]})
df1.to_parquet(""df1.parquet"")
df2=pd.DataFrame({'i': [0, 0], 'A':  [3.0, 4.0], 'B': [13.0, 14.0]})
df2.to_parquet(""df2.parquet"")
forward_df = dd.read_parquet([""df1.parquet"", ""df2.parquet""], engine='pyarrow')
reverse_df = dd.read_parquet([""df2.parquet"", ""df1.parquet""], engine='pyarrow')
forward_df.npartitions  # 2
reverse_df.npartitions  # 2

forward_df.get_partition(0).compute() # returns df1
reverse_df.get_partition(0).compute() # Also returns df1. Expected to return df2


```

**Anything else we need to know?**:

**Environment**:

- Dask version:
- Python version:
- Operating System:
- Install method (conda, pip, source):

<!-- If you are reporting an issue such as scale stability, cluster deadlock.
Please provide a cluster dump state with this issue, by running client.dump_cluster_state()

https://distributed.dask.org/en/stable/api.html?highlight=dump_cluster_state#distributed.Client.dump_cluster_state

-->

<details>
<summary>Cluster Dump State:</summary>

</details>",,https://api.github.com/repos/dask/dask/issues/8829/timeline,,,rajeee,12487392,MDQ6VXNlcjEyNDg3Mzky,https://avatars.githubusercontent.com/u/12487392?v=4,,https://api.github.com/users/rajeee,https://github.com/rajeee,https://api.github.com/users/rajeee/followers,https://api.github.com/users/rajeee/following{/other_user},https://api.github.com/users/rajeee/gists{/gist_id},https://api.github.com/users/rajeee/starred{/owner}{/repo},https://api.github.com/users/rajeee/subscriptions,https://api.github.com/users/rajeee/orgs,https://api.github.com/users/rajeee/repos,https://api.github.com/users/rajeee/events{/privacy},https://api.github.com/users/rajeee/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8829/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
562,https://api.github.com/repos/dask/dask/issues/8842,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8842/labels{/name},https://api.github.com/repos/dask/dask/issues/8842/comments,https://api.github.com/repos/dask/dask/issues/8842/events,https://github.com/dask/dask/issues/8842,1179986148,I_kwDOAbcwm85GVSjk,8842,Getting string[pyarrow] from experimental to production ready,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,2,2022-03-24T19:56:37Z,2022-06-24T17:05:53Z,,CONTRIBUTOR,,"Pandas 1.3 includes an experimental `string[pyarrow]` dtype that's much more memory efficient than `object` columns.

Rocklin [made a video on this new dtype](https://www.youtube.com/watch?v=_zoPmQ6J1aE&t=145s&ab_channel=Coiled) which shows how the `string[pyarrow]` type greatly reduced memory usage and query times.  He shows a better than 2x query speed improvement in his little notebook example with `string[pyarrow]`.  I ran some experimentation on my end and found that the `string[pyarrow]` type reduced the memory usage of an `object` column by 6.7x.

These are huge improvements and the progress is really exciting.

The purpose of this issue is to brainstorm the additional work that needs to be performed to get `string[pyarrow]` out of ""experimental"" and make it generally available.  @mrocklin - can you share your thoughts on the challenges and the next steps?",,https://api.github.com/repos/dask/dask/issues/8842/timeline,,,MrPowers,2722395,MDQ6VXNlcjI3MjIzOTU=,https://avatars.githubusercontent.com/u/2722395?v=4,,https://api.github.com/users/MrPowers,https://github.com/MrPowers,https://api.github.com/users/MrPowers/followers,https://api.github.com/users/MrPowers/following{/other_user},https://api.github.com/users/MrPowers/gists{/gist_id},https://api.github.com/users/MrPowers/starred{/owner}{/repo},https://api.github.com/users/MrPowers/subscriptions,https://api.github.com/users/MrPowers/orgs,https://api.github.com/users/MrPowers/repos,https://api.github.com/users/MrPowers/events{/privacy},https://api.github.com/users/MrPowers/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8842/reactions,1,0,0,0,0,0,0,0,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
563,https://api.github.com/repos/dask/dask/issues/8843,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8843/labels{/name},https://api.github.com/repos/dask/dask/issues/8843/comments,https://api.github.com/repos/dask/dask/issues/8843/events,https://github.com/dask/dask/issues/8843,1180228772,I_kwDOAbcwm85GWNyk,8843,DOC: Explain that `delayed` can be used on any object (not just functions),"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,"[{'login': 'phobson', 'id': 1163939, 'node_id': 'MDQ6VXNlcjExNjM5Mzk=', 'avatar_url': 'https://avatars.githubusercontent.com/u/1163939?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/phobson', 'html_url': 'https://github.com/phobson', 'followers_url': 'https://api.github.com/users/phobson/followers', 'following_url': 'https://api.github.com/users/phobson/following{/other_user}', 'gists_url': 'https://api.github.com/users/phobson/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/phobson/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/phobson/subscriptions', 'organizations_url': 'https://api.github.com/users/phobson/orgs', 'repos_url': 'https://api.github.com/users/phobson/repos', 'events_url': 'https://api.github.com/users/phobson/events{/privacy}', 'received_events_url': 'https://api.github.com/users/phobson/received_events', 'type': 'User', 'site_admin': False}]",,2,2022-03-25T01:10:52Z,2022-04-25T02:10:38Z,,MEMBER,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:

Recently, a customer had an issue running a Dask-based PyTorch workflow that would quietly and inexplicably (no errors or worker logs) kill kernels on clusters or even operating systems when working locally. 

That workflow roughly looked like this:

```python
import dask
import dask.bag as db
from dask.distributed import Client
from transformers import BertForSequenceClassification, BertTokenizer

cluster = ...
client = Client(cluster)

model = BertForSequenceClassification.from_pretrained('bert-base-uncased')
tokenizer = BertTokenizer.from_pretrained(""bert-base-uncased"")

# create the top level bag
bag_of_text = db.read_text('s3://<somebucket>/reviews.*.json', blocksize='500kB')

dangerous = (
    bag_of_reviews
        .map(detect_task, model, tokenizer, danger_threshold)
        .filter(lambda x: x is not None)
)
flagged_reviews = dangerous.compute()
```

The catch here is that `model` and `tokenizer` are fairly large (~0.5 GB) objects, so creating them and passing them to all of the workers. @jcrist quickly recognized this and recommended that pass the objects to `dask.delayed` lets the scheduler make smarter decisions about how to create and re-use them.


```python
d_model, d_tokenizer = dask.delayed(model), dask.delayed(tokenizer)
dangerous = (
    bag_of_reviews
        .map(detect_task, d_model, d_tokenizer, danger_threshold)
        .filter(lambda x: x is not None)
)
flagged_reviews = dangerous.compute()
```

This strategy worked great and allowed us to go back to the customer with really good advice. 

However, reading the [`delayed` docs](https://docs.dask.org/en/latest/delayed.html) don't mention this as a viable strategy. I walked away from those docs thinking that `delayed` only worked on function. 

**What you expected to happen**:

We should add a section to the docs explaining cases where `delayed` is useful on non-function objects.

",,https://api.github.com/repos/dask/dask/issues/8843/timeline,,,phobson,1163939,MDQ6VXNlcjExNjM5Mzk=,https://avatars.githubusercontent.com/u/1163939?v=4,,https://api.github.com/users/phobson,https://github.com/phobson,https://api.github.com/users/phobson/followers,https://api.github.com/users/phobson/following{/other_user},https://api.github.com/users/phobson/gists{/gist_id},https://api.github.com/users/phobson/starred{/owner}{/repo},https://api.github.com/users/phobson/subscriptions,https://api.github.com/users/phobson/orgs,https://api.github.com/users/phobson/repos,https://api.github.com/users/phobson/events{/privacy},https://api.github.com/users/phobson/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8843/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,phobson,1163939.0,MDQ6VXNlcjExNjM5Mzk=,https://avatars.githubusercontent.com/u/1163939?v=4,,https://api.github.com/users/phobson,https://github.com/phobson,https://api.github.com/users/phobson/followers,https://api.github.com/users/phobson/following{/other_user},https://api.github.com/users/phobson/gists{/gist_id},https://api.github.com/users/phobson/starred{/owner}{/repo},https://api.github.com/users/phobson/subscriptions,https://api.github.com/users/phobson/orgs,https://api.github.com/users/phobson/repos,https://api.github.com/users/phobson/events{/privacy},https://api.github.com/users/phobson/received_events,User,False
564,https://api.github.com/repos/dask/dask/issues/8844,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8844/labels{/name},https://api.github.com/repos/dask/dask/issues/8844/comments,https://api.github.com/repos/dask/dask/issues/8844/events,https://github.com/dask/dask/issues/8844,1180542633,I_kwDOAbcwm85GXaap,8844,Unexpected behavior using apply_gufunc with axes argument,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,2,2022-03-25T09:24:55Z,2022-04-25T02:10:37Z,,NONE,,"**What happened**:

Using the `axes` argument of `dask.array.apply_gufunc` produces unexpected behavior. I have a few seemingly distinct examples, but I will focus on the simplest one. The attached MCVE is supposed to reduce the core dimension (axis 0), hence the custom function `sum_axis_0` reduces this axis, however, the array block passed to `sum_axis_0` by `apply_gufunc` is transposed, hence leading to summing over the wrong axis. 

When I briefly looked over the source code, I see that the arrays are very deliberately transposed, hence my expectation may simply be wrong.

**Minimal Complete Verifiable Example**:

The following example is supposed to reduce the core dimension (0)
```python
import dask.array as da

def sum_axis_0(array):
    return array.sum(0)

array = da.zeros((5, 5), chunks=(5,1))

signature = '(i)->()'

axes = [0]

out = da.apply_gufunc(
    sum_axis_0,
    signature,
    array,
    axes=axes,
)

print('dask array shape (as expected):', out.shape) 
print('computed array shape (unexpected):', out.compute().shape)
```
producing the following output
```
dask array shape (as expected): (5,)
computed array shape (unexpected): (25,)
```",,https://api.github.com/repos/dask/dask/issues/8844/timeline,,,jacobjma,17334286,MDQ6VXNlcjE3MzM0Mjg2,https://avatars.githubusercontent.com/u/17334286?v=4,,https://api.github.com/users/jacobjma,https://github.com/jacobjma,https://api.github.com/users/jacobjma/followers,https://api.github.com/users/jacobjma/following{/other_user},https://api.github.com/users/jacobjma/gists{/gist_id},https://api.github.com/users/jacobjma/starred{/owner}{/repo},https://api.github.com/users/jacobjma/subscriptions,https://api.github.com/users/jacobjma/orgs,https://api.github.com/users/jacobjma/repos,https://api.github.com/users/jacobjma/events{/privacy},https://api.github.com/users/jacobjma/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8844/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
565,https://api.github.com/repos/dask/dask/issues/8845,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8845/labels{/name},https://api.github.com/repos/dask/dask/issues/8845/comments,https://api.github.com/repos/dask/dask/issues/8845/events,https://github.com/dask/dask/issues/8845,1180687339,I_kwDOAbcwm85GX9vr,8845,Concat clears divisions when it shouldn't,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,6,2022-03-25T11:35:09Z,2022-05-02T02:15:00Z,,CONTRIBUTOR,,"**What happened**:

When concatenating row-wise dataframes (`[ddf1, ddf2, ..., ddfN]`) that do not have any overlap, but that naturally follow each other (so `ddf1.divisions[-1] == ddf2.divisions[0]`, and `ddf2.divisions[-1] == ddf3.divisions[0]`, and so on), `dd.multi.concat` clears divisions when it shouldn't.

**What you expected to happen**:

The concatenated result should have divisions (`[ddf1.divisions[0], ..., ddf1.divisions[-2], ddf2.divisions[0], ..., ddf2.divisions[-2], ddf3.divisions[0], ..., ddfN.divisions[-2], ddfN.divisions[-1]]`).

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import pandas as pd

# Initial data
df = pd.DataFrame({
    ""date"": pd.date_range(""2019-01-01"", ""2019-01-10""), 
    ""col1"": range(0, 10), 
    ""col2"": range(9, -1, -1)
}) 

# To Dask, but it's not partitioned properly...
ddf = dd.from_pandas(df, npartitions=10)           # this causes 9 partitions instead of 10!
if ddf.npartitions != 10:
    print(f""ddf has {ddf.npartitions} partitions instead of 10!"")         # print instead of raising error, but why does this happen?
    print(ddf.divisions)                   # (0, 1, 2, 3, 4, 5, 6, 7, 8, 9),  but a 10 should have been added as divisions[-1]!

# Index by date forcing 10 partitions
ddf = ddf.set_index(""date"", divisions=tuple(pd.date_range(""2019-01-01"", ""2019-01-11"")))     # note the 11th here!
assert ddf.npartitions == 10, ""After repartitioning doesn't have 10 partitions!""
assert ddf.known_divisions, ""Divisions should be known!""
assert list(ddf.divisions[:-1]) == df[""date""].to_list(), ""There should be one division per day!""    # note last one omitted!

# Concatenate its partitions (Dask dataframes themselves) row-wise
dfs = [p for p in ddf.partitions]
res = dd.concat(dfs, axis=0)
if ddf.npartitions != 10:
    print(f""concatenated has {res.npartitions} partitions instead of 10!"")
assert res.known_divisions, ""Should have kept divisions!""         # this raises AssertionError
```

**Anything else we need to know?**:

Looking into [concat code](https://github.com/dask/dask/blob/36e243ca79f6babdd46f293a2700d23928bba2b6/dask/dataframe/multi.py#L1255), I think the solution is really simple. Here is the conflictive part:

```python
if all(df.known_divisions for df in dasks):
    # each DataFrame's division must be greater than previous one
    if all(
        dfs[i].divisions[-1] < dfs[i + 1].divisions[0]
        for i in range(len(dfs) - 1)
    ):
        divisions = []
        for df in dfs[:-1]:
            # remove last to concatenate with next
            divisions += df.divisions[:-1]
        divisions += dfs[-1].divisions
        return stack_partitions(dfs, divisions, join=join, ignore_order=ignore_order, **kwargs)
    elif interleave_partitions:
        return concat_indexed_dataframes(dfs, join=join, ignore_order=ignore_order, **kwargs)
    else:
        divisions = [None] * (sum(df.npartitions for df in dfs) + 1)
        return stack_partitions(dfs, divisions, join=join, ignore_order=ignore_order, **kwargs)
```

The thing is that <u>the check in `all` uses a strict `<`, but if would suffice with `<=`, because **it's fine that the beginning of the next frame equals the last division of the previous frame, since that last division is NOT included in the previous frame**</u>.

To prove this, if I call `stack_partitions` properly in the example above, things work:

```python
from dask.dataframe.multi import stack_partitions
res = stack_partitions(dfs, divisions=tuple(pd.date_range(""2019-01-01"", ""2019-01-11"")), join=""inner"", ignore_order=False)
assert res.known_divisions, ""Should have kept divisions!""         # this is fine
assert list(res.divisions[:-1]) == df[""date""].to_list(), ""There should be one division per day!""      # this is fine too
```

I don't know if this has been addressed in #8517 (@jsignell @gjoseph92), but in my opinion the example above proves that there's space for improvement:
* The delicate point is that `divisions[-1]` by definition is a value that is **NOT present in data** (it should be the first value NOT to include), so **it cannot be properly inferred** unless it's a very easy case (e.g. a range).
* Because of this, `from_pandas` in the above example yields 9 partitions instead of 10 (with the last partition having 2 rows), even if the most natural way to partition that is 1 row per partition. This is a consequence of the fact that `divisions[-1]` cannot be inferred, plus the fact that `from_pandas` doesn't accept a `divisions` argument!
* Because of this, if I do afterwards `set_index` without specifying proper divisions, it keeps on having 9 partitions, and `partition_quantiles` yields a strange result: 
```python
ddf.divisions
(Timestamp('2019-01-01 00:00:00'), Timestamp('2019-01-01 21:36:00'), Timestamp('2019-01-02 19:12:00'), Timestamp('2019-01-03 16:48:00'), Timestamp('2019-01-04 14:24:00'), Timestamp('2019-01-05 12:00:00'), Timestamp('2019-01-06 09:36:00'), Timestamp('2019-01-07 07:12:00'), Timestamp('2019-01-08 04:48:00'), Timestamp('2019-01-09 02:24:00'), Timestamp('2019-01-10 00:00:00'))
```

So I suggest this course of action:

1. Change the code of `concat` with `<=`.
2. See if there are other parts of code where this same error could be present.
3. Think about whether `divisions[-1]` is really necessary. Do we need to have it? 
    * For searching, I think it should suffice to know that `partitions[i]` has values in its index in the interval `[divisions[i], divisions[i+1])`, for all partitions except the last one. The last one we know it starts in `divisions[-2]`, but it's open-ended.
    * However, this raises a symmetry question in the 1st partition. Perhaps there should be two `divisions` arrays:
        * Beginning of partitions: this would be the current `[divisions[0], ..., divisions[-2]]`, which is the same as `[partitions[0].index[0], ..., partitions[-1].index[0]]`.
        * End of partitions: this would be last values actually present in each partition's index: `[partitions[0].index[-1], ..., partitions[-1].index[-1]]`.
    * So that we know that the `i`-th partition has values in the **closed (not semi-open) interval** `[beginning[i], end[i]]`. 
    * As a side effect, these 2 arrays have the same length than `partitions`, instead of the current situation where `len(divisions) == len(partitions) + 1`.
4. If we ignore the previous point and stick to one `divisions` array whose size is `npartitions + 1`, in my opinion:
    * `from_pandas` should accept a `divisions` argument. 
    * If it doesn't receive `divisions` and turns out that the resulting `npartitions` isn't the one requested by the user, at least **raise a warning. In the example above, the user should know that instead of 10 partitions it decided to take 9!**

**Environment**:

- Dask version: 2022.02.1
- Python version: 3.9.10
- Operating System: Ubuntu
- Install method (conda, pip, source): Pip",,https://api.github.com/repos/dask/dask/issues/8845/timeline,,,jorloplaz,12827365,MDQ6VXNlcjEyODI3MzY1,https://avatars.githubusercontent.com/u/12827365?v=4,,https://api.github.com/users/jorloplaz,https://github.com/jorloplaz,https://api.github.com/users/jorloplaz/followers,https://api.github.com/users/jorloplaz/following{/other_user},https://api.github.com/users/jorloplaz/gists{/gist_id},https://api.github.com/users/jorloplaz/starred{/owner}{/repo},https://api.github.com/users/jorloplaz/subscriptions,https://api.github.com/users/jorloplaz/orgs,https://api.github.com/users/jorloplaz/repos,https://api.github.com/users/jorloplaz/events{/privacy},https://api.github.com/users/jorloplaz/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8845/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
566,https://api.github.com/repos/dask/dask/issues/8853,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8853/labels{/name},https://api.github.com/repos/dask/dask/issues/8853/comments,https://api.github.com/repos/dask/dask/issues/8853/events,https://github.com/dask/dask/issues/8853,1181751825,I_kwDOAbcwm85GcBoR,8853,"Type hints doesn't work as expected, because they aren't present in dask source code.","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,7,2022-03-26T13:07:04Z,2024-01-11T02:46:34Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:

I'm trying to make a function which accepts dask.dataframe. Type hints doesn't work as expected however. If I switch back to pandas, then type hints works ok.


**What you expected to happen**:

No red underlines in vscode indicating errors.

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd

def func1(
    df: dd.DataFrame
) -> dd.DataFrame:

    df = df.set_index(""aaa"")

    df = df.rename(columns=lambda x: str(x).strip())

    return df
```
![image](https://user-images.githubusercontent.com/11590960/160240465-79fb13a0-3326-4da3-8b42-d70c8696cfae.png)


![image](https://user-images.githubusercontent.com/11590960/160240462-bbe5d7c1-f7d4-414c-bedb-edccb9c6e0d1.png)



**Anything else we need to know?**:

I use vscode and:

![image](https://user-images.githubusercontent.com/11590960/160240698-b92e733f-081e-43ba-812a-2facfe8f6883.png)

It seems that dask (unlike pandas) doesn't have type hints defined, and they are generated by pylance...

**Environment**:

- Dask version: 2022.3.0
- Python version: 3.10.4
- Operating System: W10
- Install method (conda, pip, source): conda

<!-- If you are reporting an issue such as scale stability, cluster deadlock.
Please provide a cluster dump state with this issue, by running client.dump_cluster_state()

https://distributed.dask.org/en/stable/api.html?highlight=dump_cluster_state#distributed.Client.dump_cluster_state



<details>
<summary>Cluster Dump State:</summary>

</details>
-->",,https://api.github.com/repos/dask/dask/issues/8853/timeline,,,karolzlot,11590960,MDQ6VXNlcjExNTkwOTYw,https://avatars.githubusercontent.com/u/11590960?v=4,,https://api.github.com/users/karolzlot,https://github.com/karolzlot,https://api.github.com/users/karolzlot/followers,https://api.github.com/users/karolzlot/following{/other_user},https://api.github.com/users/karolzlot/gists{/gist_id},https://api.github.com/users/karolzlot/starred{/owner}{/repo},https://api.github.com/users/karolzlot/subscriptions,https://api.github.com/users/karolzlot/orgs,https://api.github.com/users/karolzlot/repos,https://api.github.com/users/karolzlot/events{/privacy},https://api.github.com/users/karolzlot/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8853/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
567,https://api.github.com/repos/dask/dask/issues/8864,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8864/labels{/name},https://api.github.com/repos/dask/dask/issues/8864/comments,https://api.github.com/repos/dask/dask/issues/8864/events,https://github.com/dask/dask/pull/8864,1187064397,PR_kwDOAbcwm841WCoY,8864,Remove dask_distributed_pack methods from HighLevelGraphs and Layers,[],open,False,,[],,0,2022-03-30T22:18:08Z,2022-08-26T21:49:56Z,,MEMBER,,"In https://github.com/dask/distributed/pull/6028 we propose shipping the
entire graph to the scheduler with pickle.  This removes the need for
this custom protocol.",,https://api.github.com/repos/dask/dask/issues/8864/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8864/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/8864,https://github.com/dask/dask/pull/8864,https://github.com/dask/dask/pull/8864.diff,https://github.com/dask/dask/pull/8864.patch,,,,,,,,,,,,,,,,,,,
568,https://api.github.com/repos/dask/dask/issues/8870,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8870/labels{/name},https://api.github.com/repos/dask/dask/issues/8870/comments,https://api.github.com/repos/dask/dask/issues/8870/events,https://github.com/dask/dask/pull/8870,1188341975,PR_kwDOAbcwm841aYY9,8870,Don't let ``map_blocks`` ``drop_axis`` target an axis that is chunked,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2022-03-31T16:28:21Z,2022-04-13T18:05:55Z,,MEMBER,,"- [x] Closes #8830
- [ ] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/8870/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8870/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/8870,https://github.com/dask/dask/pull/8870,https://github.com/dask/dask/pull/8870.diff,https://github.com/dask/dask/pull/8870.patch,,,,,,,,,,,,,,,,,,,
569,https://api.github.com/repos/dask/dask/issues/8873,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8873/labels{/name},https://api.github.com/repos/dask/dask/issues/8873/comments,https://api.github.com/repos/dask/dask/issues/8873/events,https://github.com/dask/dask/issues/8873,1190153481,I_kwDOAbcwm85G8E0J,8873,"`dd.concat(..., interleave_partitions=False)` doesn't raise error as documented","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2022-04-01T18:44:48Z,2022-04-06T15:24:23Z,,MEMBER,,"**What happened**:

The docs for [`dd.concat`](https://docs.dask.org/en/latest/generated/dask.dataframe.multi.concat.html#dask.dataframe.multi.concat) indicate an error will be raised if `interleave_partitions=False` and the inputs aren't ordered:

```
    Unable to concatenate if divisions are not ordered.

    >>> a                                               # doctest: +SKIP
    dd.DataFrame<x, divisions=(1, 3, 5)>
    >>> b                                               # doctest: +SKIP
    dd.DataFrame<y, divisions=(2, 3, 6)>
    >>> dd.concat([a, b])                               # doctest: +SKIP
    ValueError: All inputs have known divisions which cannot be concatenated
    in order. Specify interleave_partitions=True to ignore order
```

But this actually succeeds, just results in unknown divisions.

I'd prefer the behavior of the error (with instructions on how to avoid it)silently dropping divisions isn't great, and the more complex graph of `interleave_partitions=True` may not be something to take lightly either.

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
df = dd.demo.make_timeseries()
a, b, c = df.partitions[0], df.partitions[1], df.partitions[2]

dd.concat([b, a, c]).divisions  # should raise an error
# (None, None, None, None)
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 63d608e6a21fa1b56b01e560c9b87b4019eaf12c
- Python version: 3.8.8
- Operating System: macOS
- Install method (conda, pip, source): source",,https://api.github.com/repos/dask/dask/issues/8873/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8873/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
570,https://api.github.com/repos/dask/dask/issues/8876,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8876/labels{/name},https://api.github.com/repos/dask/dask/issues/8876/comments,https://api.github.com/repos/dask/dask/issues/8876/events,https://github.com/dask/dask/issues/8876,1190259814,I_kwDOAbcwm85G8exm,8876,"`dd.concat(..., interleave_partitions=True)` graph adds unnecessary communication and complexity","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,2,2022-04-01T20:52:55Z,2022-04-07T17:46:17Z,,MEMBER,,"(Real-world use case) Say you have 10,000 single-partition dask DataFrames, each with known divisions. You want to combine them into one. Some don't overlap at all, but say 40% of them do overlap with a handful of the others. The obvious way to do this is `dd.concat(sorted(inputs, key=lambda df: df.divisions), interleave_partitions=True)`. You would expect that 60% of the resulting partitions would simply be a pass-through from the original input, and the others would just be a few tasks each combining those overlapping inputs.

However, `dd.concat` seems to add significant complexity to the graph when _any_ inputs overlap_even to partitions that don't need to be combined with any others_. Here's a smaller reproducer.

```python
import pandas as pd
import dask.dataframe as dd
import dask

# Our three inputs don't overlap at all
a = pd.DataFrame({'n': 'a'}, index=range(1, 5))
b = pd.DataFrame({'n': 'b'}, index=range(10, 15))
c = pd.DataFrame({'n': 'c'}, index=range(20, 25))

a = dd.from_pandas(a, npartitions=1)
b = dd.from_pandas(b, npartitions=1)
c = dd.from_pandas(c, npartitions=1)
```
If you combine these, the graph is good: just a pass-through of the originals.
```python
x = dd.concat([a, b, c], interleave_partitions=True)
x.divisions
# (1, 10, 20, 24)
x.visualize(optimize_graph=True)
```
![mydask](https://user-images.githubusercontent.com/3309802/161332623-cad8a9c7-0a55-41d3-9ee5-035184016faa.png)

However, if even one of the inputs overlap, then all of them go sideways:

```python
# Last element in `b` is 14; make `c` overlap with it
c = pd.DataFrame({'n': 'c'}, index=range(14, 20))
c = dd.from_pandas(c, npartitions=1)

x = dd.concat([a, b, c], interleave_partitions=True)
x.visualize(optimize_graph=True)
```
![mydask](https://user-images.githubusercontent.com/3309802/161336088-a191802d-8ac2-432b-a941-da15e184dcf6.png)
That graph seems unnecessarily convoluted! What's going on here?

```python
x.divisions
# (1, 4, 10, 14, 19)
```
First, an extra partition was added! Why is there now a split at `4` between 1 and 10? Our first input partition still overlaps with nothing, so it should still be a pass-through.

Here's what each output partition looks like:
```python
dask.compute([x.partitions[i] for i in range(x.npartitions)])
# ([   n
#   1  a
#   2  a
#   3  a,
#      n
#   4  a,
#       n
#   10  b
#   11  b
#   12  b
#   13  b,
#       n
#   14  b
#   14  c
#   15  c
#   16  c
#   17  c
#   18  c
#   19  c],)
```
For some reason, 4 was split into its own single-row partition. There's probably an off-by-one error in the `concat_indexed_dataframes` logic somewhere; there's no good reason to do this. But this means partition 0 must no longer a pass-through operation.

But that's actually not the main problem. Let's look at the graph for just partition 0 (which again, overlaps with nothing, and should have been a pass-through operation):
```python
x.partitions[0].visualize(optimize_graph=True)
```
![mydask](https://user-images.githubusercontent.com/3309802/161336712-037d6036-1e59-4fcb-ae3e-d75c5b5a5ff4.png)

Notice how there are three separate `[ 0 ]` boxes as our root tasks. The fact that `visualize` displays them the same is misleadingthese are actually our three input partitions.

**Our task that should have been a pass-through operation instead depends on every single other input dataframe!**

<details><summary>If we dig into the graph, we can see what's happening</summary>

```python
o, = dask.optimize(x.partitions[0])
dict(o.dask)
```
```python
{('blocks-fb54414703cd9f8c0b37fb039bc4f1b7',
  0): ('concat-indexed-c623aeea3b4baf4272f1b15381c926b5', 0),
 ('concat-indexed-c623aeea3b4baf4272f1b15381c926b5',
  0): (<function dask.dataframe.dispatch.concat(dfs, axis=0, join='outer', uniform=False, filter_warning=True, ignore_index=False, **kwargs)>,
  [('repartition-merge-cb44e3c757ac1087e6bb6801dfc7afac', 0),
   ('repartition-merge-8596e038e334d6729b9486e4b0ecec92', 0),
   ('repartition-merge-1f6d669e193038e9e5ab917a2295c588', 0)],
  0,
  'outer',
  False,
  True,
  {'ignore_order': False}),
 ('repartition-merge-cb44e3c757ac1087e6bb6801dfc7afac',
  0): ('repartition-split-cb44e3c757ac1087e6bb6801dfc7afac', 0),
 ('repartition-merge-1f6d669e193038e9e5ab917a2295c588',
  0): (<function dask.dataframe.methods.boundary_slice(df, start, stop, right_boundary=True, left_boundary=True, kind=None)>,
  ('from_pandas-cde2bda2bd6ad57faa7bd54164e47d74', 0),
  14,
  14,
  False),
 ('from_pandas-cde2bda2bd6ad57faa7bd54164e47d74',
  0):     n
 14  c
 15  c
 16  c
 17  c
 18  c
 19  c,
 ('repartition-split-cb44e3c757ac1087e6bb6801dfc7afac',
  0): (<function dask.dataframe.methods.boundary_slice(df, start, stop, right_boundary=True, left_boundary=True, kind=None)>, ('from_pandas-b6aa54b407dedd16e7128d4b817cbaef',
   0), 1, 4, False),
 ('repartition-merge-8596e038e334d6729b9486e4b0ecec92',
  0): (<function dask.dataframe.methods.boundary_slice(df, start, stop, right_boundary=True, left_boundary=True, kind=None)>, ('from_pandas-915f88967ee362178affd913ada85f7b',
   0), 10, 10, False),
 ('from_pandas-915f88967ee362178affd913ada85f7b',
  0):     n
 10  b
 11  b
 12  b
 13  b
 14  b,
 ('from_pandas-b6aa54b407dedd16e7128d4b817cbaef',
  0):    n
 1  a
 2  a
 3  a
 4  a}
```
First, notice that all three of our pandas DataFrames show up in the optimized graph for the first pass-through output partition. That's a dead giveaway that there's unnecessary communication going on.

You see the final `concat-indexed-c623aeea3b4baf4272f1b15381c926b5` depends on the three `repartition-merge`s. 2/3 of those are tasks that look like:

```
(<function dask.dataframe.methods.boundary_slice(df, start, stop, right_boundary=True, left_boundary=True, kind=None)>,
  ('from_pandas-cde2bda2bd6ad57faa7bd54164e47d74', 0),
  14,
  14,
  False)
```
That's basically `boundary_slice(x, 14, 14)`aka make an empty DataFrame, aka a no-op. So even though the dependency exists in the graph, its entire contents will be thrown away as soon as it arrives.

This should definitely be avoided.
</details>

------

So it seems like the [`concat_indexed_dataframes`](https://github.com/dask/dask/blob/63d608e6a21fa1b56b01e560c9b87b4019eaf12c/dask/dataframe/multi.py#L1001-L1033) logic could definitely be improved. I'm not sure whether the overall approach of `align_partitions` and then concat will make sense if we want to avoid these problemsis the problem in `align_partitions` itself, or in how `concat_indexed_dataframes` is using it?

If there's an underlying issue with `align_partitions`, that would be especially important to look into since it's used in a few paces (such as `merge_indexed_dataframes`). These sorts of ""merge-by-known-divisions"" operations are supposed to be the idiomatic, performant way to use dask, so the fact that this actually results in all-to-all communication is problematic.

cc @jsignell @jrbourbeau @jcrist ",,https://api.github.com/repos/dask/dask/issues/8876/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8876/reactions,3,3,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
571,https://api.github.com/repos/dask/dask/issues/8877,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8877/labels{/name},https://api.github.com/repos/dask/dask/issues/8877/comments,https://api.github.com/repos/dask/dask/issues/8877/events,https://github.com/dask/dask/issues/8877,1190289111,I_kwDOAbcwm85G8l7X,8877,Windows distributed tests - periodic `PermissionError`,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-04-01T21:29:10Z,2022-05-09T02:12:50Z,,MEMBER,,"We started seeing periodic `PermissionError`s in the `test_distributed.py` tests a few days ago. Example failure in https://github.com/dask/dask/runs/5793620996?check_suite_focus=true#step:6:21867.

```
=================================== ERRORS ====================================
________ ERROR at teardown of test_blockwise_array_creation[None-ones] ________
[gw2] win32 -- Python 3.10.4 C:\Miniconda3\envs\test-environment\python.exe

loop = <tornado.platform.asyncio.AsyncIOLoop object at 0x000001FB03165690>

    @pytest.fixture
    def cluster_fixture(loop):
>       with cluster() as (scheduler, workers):

C:\Miniconda3\envs\test-environment\lib\site-packages\distributed\utils_test.py:538: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Miniconda3\envs\test-environment\lib\contextlib.py:142: in __exit__
    next(self.gen)
C:\Miniconda3\envs\test-environment\lib\site-packages\distributed\utils_test.py:654: in cluster
    with contextlib.ExitStack() as stack:
C:\Miniconda3\envs\test-environment\lib\contextlib.py:576: in __exit__
    raise exc_details[1]
C:\Miniconda3\envs\test-environment\lib\contextlib.py:561: in __exit__
    if cb(*exc_details):
C:\Miniconda3\envs\test-environment\lib\contextlib.py:449: in _exit_wrapper
    callback(*args, **kwds)
C:\Miniconda3\envs\test-environment\lib\site-packages\distributed\utils_test.py:611: in _terminate_join
    proc.terminate()
C:\Miniconda3\envs\test-environment\lib\multiprocessing\process.py:133: in terminate
    self._popen.terminate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <multiprocessing.popen_spawn_win32.Popen object at 0x000001FB0316AEF0>

    def terminate(self):
        if self.returncode is None:
            try:
>               _winapi.TerminateProcess(int(self._handle), TERMINATE)
E               PermissionError: [WinError 5] Access is denied

C:\Miniconda3\envs\test-environment\lib\multiprocessing\popen_spawn_win32.py:123: PermissionError
```",,https://api.github.com/repos/dask/dask/issues/8877/timeline,,,jcrist,2783717,MDQ6VXNlcjI3ODM3MTc=,https://avatars.githubusercontent.com/u/2783717?v=4,,https://api.github.com/users/jcrist,https://github.com/jcrist,https://api.github.com/users/jcrist/followers,https://api.github.com/users/jcrist/following{/other_user},https://api.github.com/users/jcrist/gists{/gist_id},https://api.github.com/users/jcrist/starred{/owner}{/repo},https://api.github.com/users/jcrist/subscriptions,https://api.github.com/users/jcrist/orgs,https://api.github.com/users/jcrist/repos,https://api.github.com/users/jcrist/events{/privacy},https://api.github.com/users/jcrist/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8877/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
572,https://api.github.com/repos/dask/dask/issues/8910,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8910/labels{/name},https://api.github.com/repos/dask/dask/issues/8910/comments,https://api.github.com/repos/dask/dask/issues/8910/events,https://github.com/dask/dask/issues/8910,1200186467,I_kwDOAbcwm85HiWRj,8910,Add empty partition testing utility,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450422, 'node_id': 'LA_kwDOAbcwm87iZ8D2', 'url': 'https://api.github.com/repos/dask/dask/labels/p3', 'name': 'p3', 'color': 'ffff33', 'default': False, 'description': 'Affects a small number of users or is largely cosmetic'}]",open,False,,[],,0,2022-04-11T15:59:02Z,2022-05-16T02:07:51Z,,MEMBER,,"We have several tests, e.g. `dask/dataframe/tests/test_dataframe.py::test_dataframe_groupby_cumsum_agg_empty_partitions`, that ensure our collections algorithm's can handle empty partitions. 

https://github.com/dask/dask/blob/1270f068c03c3162102da1f606397c5d958c9b85/dask/dataframe/tests/test_dataframe.py#L4855-L4859

However, these tests often don't have an explicit check that empty partitions are present. I'd like to see us add a new testing utility function that we can use to help ensure we're testing the corner case that we intent to. For example, something like (the snippet below is untested):

```python
def assert_empty_partitions(df):
    assert df.map_partitions(lambda x: x.empty).compute().all()
```

Marking this as a nice-to-have, but low priority item ",,https://api.github.com/repos/dask/dask/issues/8910/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8910/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
573,https://api.github.com/repos/dask/dask/issues/8917,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8917/labels{/name},https://api.github.com/repos/dask/dask/issues/8917/comments,https://api.github.com/repos/dask/dask/issues/8917/events,https://github.com/dask/dask/issues/8917,1201976003,I_kwDOAbcwm85HpLLD,8917,Python Array API in Dask issue tracking,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2022-04-12T14:56:26Z,2023-06-30T09:12:29Z,,MEMBER,,"This is an umbrella issue to track the implementation of the [Array API](https://data-apis.org/array-api/latest/) in Dask. See also the earlier discussion in https://github.com/dask/community/issues/109, and a possible implementation in #8750.

Compatible changes to make `dask.array` more consistent with `numpy`
* [x] #8667
* [x] #8668 
* [x] #8669
* [x] #8947
* [x] #8670 
* [x] #8914
* [x] #8915
* [x] #8916
* [x] #8929
* [ ] #8931
* [ ] #8948

Breaking changes to make `dask.array` more consistent with `numpy`
* [ ] #8934

Compatible changes to make `dask.array` more consistent with `numpy.array_api` (see [Array API Standard Compatibility](https://numpy.org/devdocs/reference/array_api.html))
* [ ] Add `correction` keyword argument as a synonym for `ddof` in `std` and `var`
* [ ] Add `copy` keyword argument to `asarray`
",,https://api.github.com/repos/dask/dask/issues/8917/timeline,,,tomwhite,85085,MDQ6VXNlcjg1MDg1,https://avatars.githubusercontent.com/u/85085?v=4,,https://api.github.com/users/tomwhite,https://github.com/tomwhite,https://api.github.com/users/tomwhite/followers,https://api.github.com/users/tomwhite/following{/other_user},https://api.github.com/users/tomwhite/gists{/gist_id},https://api.github.com/users/tomwhite/starred{/owner}{/repo},https://api.github.com/users/tomwhite/subscriptions,https://api.github.com/users/tomwhite/orgs,https://api.github.com/users/tomwhite/repos,https://api.github.com/users/tomwhite/events{/privacy},https://api.github.com/users/tomwhite/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8917/reactions,1,0,0,0,1,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
574,https://api.github.com/repos/dask/dask/issues/8918,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8918/labels{/name},https://api.github.com/repos/dask/dask/issues/8918/comments,https://api.github.com/repos/dask/dask/issues/8918/events,https://github.com/dask/dask/pull/8918,1202243636,PR_kwDOAbcwm842H3NI,8918,parametrize tests over Zarr protocol versions 2 and 3,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,4,2022-04-12T18:34:08Z,2022-04-29T04:01:49Z,,CONTRIBUTOR,,"This PR parametrizes the Zarr-based tests to test both the current v2 protocol as well as the [draft v3 spec](https://zarr-specs.readthedocs.io/en/core-protocol-v3.0-dev/protocol/core/v3.0.html). The v3 spec is still in development, so this PR will need to stay a WIP until there is a release we can test against on CI.

The two changes needed to use v3 are:
- `dask.array.to_zarr`/`dask.array.from_zarr` **must** specify the `component` (aka a `path` in Zarr terms).
- If a file path string rather than an existing zarr store (mapper) is being used to create/open an array, then a `zarr_version` kwarg must be passed so that Zarr knows which version of the protocol to use (the default is currently version 2).

Note that all changes in this PR are purely to the tests. It is possible to use v3 support as long as the `component` kwarg and `zarr_version` kwarg are specified.

This is not yet ready to merge as there is not an upstream Zarr release with v3 support to test against. I did test locally against the zarr `main` branch (after commenting out the `> parse_version('3.0')` version check) and all tests pass for both v2 and v3 stores. The only test case that involves a difference in the tested behavior between the two protocol versions is `test_zarr_group` (see ""Note: "" comments in that test case). If any difference in behavior is problematic, please bring it up to discuss! 

cc @joshmoore, @jakirkham, @rabernat, @MSanKeys963


- [ ] Closes #xxxx
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/8918/timeline,,,grlee77,6528957,MDQ6VXNlcjY1Mjg5NTc=,https://avatars.githubusercontent.com/u/6528957?v=4,,https://api.github.com/users/grlee77,https://github.com/grlee77,https://api.github.com/users/grlee77/followers,https://api.github.com/users/grlee77/following{/other_user},https://api.github.com/users/grlee77/gists{/gist_id},https://api.github.com/users/grlee77/starred{/owner}{/repo},https://api.github.com/users/grlee77/subscriptions,https://api.github.com/users/grlee77/orgs,https://api.github.com/users/grlee77/repos,https://api.github.com/users/grlee77/events{/privacy},https://api.github.com/users/grlee77/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8918/reactions,2,0,0,0,0,0,2,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/8918,https://github.com/dask/dask/pull/8918,https://github.com/dask/dask/pull/8918.diff,https://github.com/dask/dask/pull/8918.patch,,,,,,,,,,,,,,,,,,,
575,https://api.github.com/repos/dask/dask/issues/8922,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8922/labels{/name},https://api.github.com/repos/dask/dask/issues/8922/comments,https://api.github.com/repos/dask/dask/issues/8922/events,https://github.com/dask/dask/issues/8922,1203257782,I_kwDOAbcwm85HuEG2,8922,Dask Dataframe groupby-fillna for other value types,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,0,2022-04-13T12:50:30Z,2022-05-16T02:07:49Z,,MEMBER,,"#8869 implements groupby-fillna for Dask DataFrame for value=scalar.

We can add functionality for value = dict, pandas Series, and pandas DataFrame [similar to pandas](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.DataFrameGroupBy.fillna.html).

This was considered out-of-scope for #8869 because pandas=1.3.5 create a multi-index for value=dict, which isn't consistent with the behavior for value=scalar.

Reproducer:
```python
import numpy as np
import pandas as pd
import dask.dataframe as dd

df = pd.DataFrame({
    ""A"": [1, 1, 2, 2],
    ""B"": [3, 4, 3, 4],
    ""C"": [np.nan, 3, np.nan, np.nan],
    ""D"": [4, np.nan, 5, np.nan],
    ""E"": [6, np.nan, 7, np.nan],
})

d = {""C"": 1, ""D"": 2, ""E"": 3}

df.groupby(""A"").fillna(d)
# Output:
# 
# B    C    D    E
# A                    
# 1 0  3  1.0  4.0  6.0
#   1  4  3.0  2.0  3.0
# 2 2  3  1.0  5.0  7.0
#   3  4  1.0  2.0  3.0

df.groupby(""A"").fillna(0)
# Output:
#
#    B    C    D    E
# 0  3  0.0  4.0  6.0
# 1  4  3.0  0.0  0.0
# 2  3  0.0  5.0  7.0
# 3  4  0.0  0.0  0.0
```

But note that for pandas=1.4.2, value=scalar and value=scalar produce consistent outputs.",,https://api.github.com/repos/dask/dask/issues/8922/timeline,,,pavithraes,33131404,MDQ6VXNlcjMzMTMxNDA0,https://avatars.githubusercontent.com/u/33131404?v=4,,https://api.github.com/users/pavithraes,https://github.com/pavithraes,https://api.github.com/users/pavithraes/followers,https://api.github.com/users/pavithraes/following{/other_user},https://api.github.com/users/pavithraes/gists{/gist_id},https://api.github.com/users/pavithraes/starred{/owner}{/repo},https://api.github.com/users/pavithraes/subscriptions,https://api.github.com/users/pavithraes/orgs,https://api.github.com/users/pavithraes/repos,https://api.github.com/users/pavithraes/events{/privacy},https://api.github.com/users/pavithraes/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8922/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
576,https://api.github.com/repos/dask/dask/issues/8931,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8931/labels{/name},https://api.github.com/repos/dask/dask/issues/8931/comments,https://api.github.com/repos/dask/dask/issues/8931/events,https://github.com/dask/dask/issues/8931,1204421444,I_kwDOAbcwm85HygNE,8931,Add constants to `dask.array` for consistency with NumPy and array API,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,1,2022-04-14T11:39:44Z,2022-05-24T17:16:20Z,,MEMBER,,"Add `e`, `inf`, `nan`, `pi`, and `newaxis` to match the constants defined by both [NumPy](https://numpy.org/doc/stable/reference/constants.html) and the new [Array API](https://data-apis.org/array-api/latest/API_specification/constants.html).

Note `newaxis` is not in the spec yet, but is being added in https://github.com/data-apis/array-api/pull/414",,https://api.github.com/repos/dask/dask/issues/8931/timeline,,,tomwhite,85085,MDQ6VXNlcjg1MDg1,https://avatars.githubusercontent.com/u/85085?v=4,,https://api.github.com/users/tomwhite,https://github.com/tomwhite,https://api.github.com/users/tomwhite/followers,https://api.github.com/users/tomwhite/following{/other_user},https://api.github.com/users/tomwhite/gists{/gist_id},https://api.github.com/users/tomwhite/starred{/owner}{/repo},https://api.github.com/users/tomwhite/subscriptions,https://api.github.com/users/tomwhite/orgs,https://api.github.com/users/tomwhite/repos,https://api.github.com/users/tomwhite/events{/privacy},https://api.github.com/users/tomwhite/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8931/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
577,https://api.github.com/repos/dask/dask/issues/8934,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8934/labels{/name},https://api.github.com/repos/dask/dask/issues/8934/comments,https://api.github.com/repos/dask/dask/issues/8934/events,https://github.com/dask/dask/issues/8934,1204558353,I_kwDOAbcwm85HzBoR,8934,Make `eye` signature consistent with NumPy,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,5,2022-04-14T13:52:36Z,2022-04-20T11:14:27Z,,MEMBER,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:

Dask's signature for `eye` is

```
dask.array.eye(N, chunks='auto', M=None, k=0, dtype=<class 'float'>)
```

Whereas NumPy's is

```
numpy.eye(N, M=None, k=0, dtype=<class 'float'>, order='C', *, like=None)
```

The position of the `chunks` parameter in Dask means that a call like `eye(3, 2)` means different things in Dask and NumPy.


**What you expected to happen**: Behaviour the same as NumPy.

**Minimal Complete Verifiable Example**:

```python
>>> import numpy as np
>>> np.eye(3, 2).shape
(3, 2)
>>> import dask.array as da
>>> da.eye(3, 2).shape
(3, 3)
```

**Anything else we need to know?**:

**Environment**:

- Dask version: main
- Python version: 3.8
- Operating System: mac
- Install method (conda, pip, source): source

<!-- If you are reporting an issue such as scale stability, cluster deadlock.
Please provide a cluster dump state with this issue, by running client.dump_cluster_state()

https://distributed.dask.org/en/stable/api.html?highlight=dump_cluster_state#distributed.Client.dump_cluster_state

-->

<details>
<summary>Cluster Dump State:</summary>

</details>",,https://api.github.com/repos/dask/dask/issues/8934/timeline,,,tomwhite,85085,MDQ6VXNlcjg1MDg1,https://avatars.githubusercontent.com/u/85085?v=4,,https://api.github.com/users/tomwhite,https://github.com/tomwhite,https://api.github.com/users/tomwhite/followers,https://api.github.com/users/tomwhite/following{/other_user},https://api.github.com/users/tomwhite/gists{/gist_id},https://api.github.com/users/tomwhite/starred{/owner}{/repo},https://api.github.com/users/tomwhite/subscriptions,https://api.github.com/users/tomwhite/orgs,https://api.github.com/users/tomwhite/repos,https://api.github.com/users/tomwhite/events{/privacy},https://api.github.com/users/tomwhite/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8934/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
578,https://api.github.com/repos/dask/dask/issues/8948,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8948/labels{/name},https://api.github.com/repos/dask/dask/issues/8948/comments,https://api.github.com/repos/dask/dask/issues/8948/events,https://github.com/dask/dask/issues/8948,1208249145,I_kwDOAbcwm85IBGs5,8948,`matmul` doesn't fail fast for shape mismatches in some cases,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2022-04-19T11:53:42Z,2022-08-02T16:12:55Z,,MEMBER,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**: calling `matmul` with incompatible array sizes doesn't always fail immediately

**What you expected to happen**: if the array sizes are incompatible, then the operation should (consistently) fail immediately, and not wait until `compute` is called in some cases.

**Minimal Complete Verifiable Example**:

```python
>>> import dask.array as da
>>> da.matmul(da.ones(1), da.ones(3))
dask.array<getitem, shape=(), dtype=float64, chunksize=(), chunktype=numpy.ndarray>
>>> da.matmul(da.ones(1), da.ones(3)).compute() # fails on compute
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""/Users/tom/projects-workspace/dask/dask/base.py"", line 292, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/Users/tom/projects-workspace/dask/dask/base.py"", line 575, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/Users/tom/projects-workspace/dask/dask/threaded.py"", line 81, in get
    results = get_async(
  File ""/Users/tom/projects-workspace/dask/dask/local.py"", line 508, in get_async
    raise_exception(exc, tb)
  File ""/Users/tom/projects-workspace/dask/dask/local.py"", line 316, in reraise
    raise exc
  File ""/Users/tom/projects-workspace/dask/dask/local.py"", line 221, in execute_task
    result = _execute_task(task, data)
  File ""/Users/tom/projects-workspace/dask/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/Users/tom/projects-workspace/dask/dask/core.py"", line 119, in <genexpr>
    return func(*(_execute_task(a, cache) for a in args))
  File ""/Users/tom/projects-workspace/dask/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/Users/tom/projects-workspace/dask/dask/optimization.py"", line 990, in __call__
    return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
  File ""/Users/tom/projects-workspace/dask/dask/core.py"", line 149, in get
    result = _execute_task(task, cache)
  File ""/Users/tom/projects-workspace/dask/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/Users/tom/projects-workspace/dask/dask/array/routines.py"", line 402, in _matmul
    chunk = xp.matmul(a, b)
ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)->(n?,m?) (size 3 is different from 1)
>>> da.matmul(da.ones(2), da.ones(3)) # fails without compute
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""/Users/tom/projects-workspace/dask/dask/array/routines.py"", line 446, in matmul
    out = blockwise(
  File ""/Users/tom/projects-workspace/dask/dask/array/blockwise.py"", line 174, in blockwise
    chunkss, arrays = unify_chunks(*args)
  File ""/Users/tom/projects-workspace/dask/dask/array/core.py"", line 3812, in unify_chunks
    arrays.append(a.rechunk(chunks))
  File ""/Users/tom/projects-workspace/dask/dask/array/core.py"", line 2647, in rechunk
    return rechunk(self, chunks, threshold, block_size_limit, balance)
  File ""/Users/tom/projects-workspace/dask/dask/array/rechunk.py"", line 297, in rechunk
    chunks = normalize_chunks(
  File ""/Users/tom/projects-workspace/dask/dask/array/core.py"", line 2958, in normalize_chunks
    raise ValueError(
ValueError: Chunks do not add up to shape. Got chunks=((1,), (3,)), shape=(1, 2)
```

**Anything else we need to know?**: there may be similar problems with `dot` and `tensordot` (needs investigation)

**Environment**:

- Dask version: main
- Python version: 3.8
- Operating System: mac
- Install method (conda, pip, source): source

<!-- If you are reporting an issue such as scale stability, cluster deadlock.
Please provide a cluster dump state with this issue, by running client.dump_cluster_state()

https://distributed.dask.org/en/stable/api.html?highlight=dump_cluster_state#distributed.Client.dump_cluster_state

-->

<details>
<summary>Cluster Dump State:</summary>

</details>",,https://api.github.com/repos/dask/dask/issues/8948/timeline,,,tomwhite,85085,MDQ6VXNlcjg1MDg1,https://avatars.githubusercontent.com/u/85085?v=4,,https://api.github.com/users/tomwhite,https://github.com/tomwhite,https://api.github.com/users/tomwhite/followers,https://api.github.com/users/tomwhite/following{/other_user},https://api.github.com/users/tomwhite/gists{/gist_id},https://api.github.com/users/tomwhite/starred{/owner}{/repo},https://api.github.com/users/tomwhite/subscriptions,https://api.github.com/users/tomwhite/orgs,https://api.github.com/users/tomwhite/repos,https://api.github.com/users/tomwhite/events{/privacy},https://api.github.com/users/tomwhite/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8948/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
579,https://api.github.com/repos/dask/dask/issues/8958,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8958/labels{/name},https://api.github.com/repos/dask/dask/issues/8958/comments,https://api.github.com/repos/dask/dask/issues/8958/events,https://github.com/dask/dask/issues/8958,1210081404,I_kwDOAbcwm85IIGB8,8958, Support dask objects as indexers for `dask.array.Array.vindex`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,1,2022-04-20T18:49:38Z,2023-01-07T15:04:45Z,,NONE,,"This came from a discussion in #8928, where [this message](https://github.com/dask/dask/issues/8928#issuecomment-1102606265) from @jsignell contains useful hints on how to start working on this.",,https://api.github.com/repos/dask/dask/issues/8958/timeline,,,gcaria,44147817,MDQ6VXNlcjQ0MTQ3ODE3,https://avatars.githubusercontent.com/u/44147817?v=4,,https://api.github.com/users/gcaria,https://github.com/gcaria,https://api.github.com/users/gcaria/followers,https://api.github.com/users/gcaria/following{/other_user},https://api.github.com/users/gcaria/gists{/gist_id},https://api.github.com/users/gcaria/starred{/owner}{/repo},https://api.github.com/users/gcaria/subscriptions,https://api.github.com/users/gcaria/orgs,https://api.github.com/users/gcaria/repos,https://api.github.com/users/gcaria/events{/privacy},https://api.github.com/users/gcaria/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8958/reactions,3,3,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
580,https://api.github.com/repos/dask/dask/issues/8959,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8959/labels{/name},https://api.github.com/repos/dask/dask/issues/8959/comments,https://api.github.com/repos/dask/dask/issues/8959/events,https://github.com/dask/dask/issues/8959,1210155003,I_kwDOAbcwm85IIX_7,8959,DataFrame groupby+apply/transform/shift on index results in unwanted shuffle,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-04-20T20:02:11Z,2022-05-23T02:11:37Z,,MEMBER,,"**What happened**:

I'm working on pandas 1.5 compatibility (cf #8776) and came across this apparent bug in groupby + transform/apply/shift.
If we are grouping on the dataframe index, we should be able to avoid a shuffle, since the dataframe is already ordered in the way we want. Indeed, the groupby code has a check to avoid shuffling: 
https://github.com/dask/dask/blob/99e260081f51ce368bf0456c66c9d3c2f20e8c9b/dask/dataframe/groupby.py#L1724

However, this check does not succeed when you pass in the dask dataframe index directly, as the check only looks for column names.

I think we can fix this by also checking if the `dd.Index` *dask* name matches the grouped-by object's name (pseudocode, since `by` could be a string):

```python
 should_shuffle = not (
    df.known_divisions and
    (df._contains_index_name(self.by) or df.index._name == self.by._name)
) 
```
**What you expected to happen**:

Grouping by `ddf.index` should avoid a shuffle.

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.dataframe as dd
import pandas

# use task-based rather than disk based for easier introspection.
# Not otherwise important here
dask.config.set({""shuffle"": ""tasks""})

df = pandas.DataFrame(
    {""x"": [1, 2, 3, 4]},
    index=pandas.Index([""a"", ""a"", ""b"", ""b""], name=""idx""),
)
ddf = dd.from_pandas(df, npartitions=2)

# Groupby index name avoids shuffle
ddf = ddf.groupby(""idx"").apply(lambda x: x, meta=ddf._meta)
assert not any(isinstance(l, dask.layers.SimpleShuffleLayer) for l in ddf.dask.layers.values())

# Groupby index object shuffles!
ddf = ddf.groupby(ddf.index).apply(lambda x: x, meta=ddf._meta)
assert not any(isinstance(l, dask.layers.SimpleShuffleLayer) for l in ddf.dask.layers.values())
```

**Anything else we need to know?**:

**Environment**:

- Dask version: `main`
- Python version: 3.8
- Operating System: ubuntu
- Install method (conda, pip, source): source",,https://api.github.com/repos/dask/dask/issues/8959/timeline,,,ian-r-rose,5728311,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8959/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
581,https://api.github.com/repos/dask/dask/issues/8960,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8960/labels{/name},https://api.github.com/repos/dask/dask/issues/8960/comments,https://api.github.com/repos/dask/dask/issues/8960/events,https://github.com/dask/dask/issues/8960,1210230990,I_kwDOAbcwm85IIqjO,8960,Implement `DataFrame.quantile` for time-like dtypes,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,1,2022-04-20T21:30:29Z,2022-05-30T02:14:58Z,,MEMBER,,"[`pandas.DataFrame.quantile`](https://pandas.pydata.org/docs/dev/whatsnew/v1.5.0.html#other-deprecations) is switching it's default for `numeric_only` from `True` to `False`. In particular, this changes the behavior for quantiles on dataframes datetime/timedelta columns. Previously, they would be dropped by default, soon they will be included in the quantile'd columns.

```python
import pandas as pd
import dask.dataframe as dd

df = pd.DataFrame(
    {
        ""date"": pd.date_range(start=""20100101"", periods=20),
         ""value"": np.linspace(0, 100, 20),
    }
)
df.quantile(numeric_only=False)   # Succeeds, will become default

ddf = dd.from_pandas(df, npartitions=4)
ddf.quantile(numeric_only=False).compute()   # Fails, not implemented
```

We should implement `numeric_only` for `dd.DataFrame.quantile` and default to `False`. I know that @jsignell has thought a bunch about `numeric_only`, and may have an idea of the possible pitfalls.",,https://api.github.com/repos/dask/dask/issues/8960/timeline,,,ian-r-rose,5728311,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8960/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
582,https://api.github.com/repos/dask/dask/issues/8965,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8965/labels{/name},https://api.github.com/repos/dask/dask/issues/8965/comments,https://api.github.com/repos/dask/dask/issues/8965/events,https://github.com/dask/dask/pull/8965,1211137011,PR_kwDOAbcwm842kF7U,8965,[Experiment][WIP] Perform culling optimization before fuse_roots,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2022-04-21T14:36:09Z,2022-04-21T16:14:05Z,,MEMBER,,"While working on a PR to move Dask-DataFrame's `from_delayed` to `Blockwise` @ian-r-rose [pointed out that `fuse_roots`
will always materialize a Blockwise layer when root-fusion is successful](https://github.com/dask/dask/pull/8852#discussion_r854625813).  My intuition is that this is probably okay if we move things around so that culling is performed while the Layer is still `Blockwise`.  This PR makes this small change for `dask.array` and `dask.dataframe`.",,https://api.github.com/repos/dask/dask/issues/8965/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8965/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/8965,https://github.com/dask/dask/pull/8965,https://github.com/dask/dask/pull/8965.diff,https://github.com/dask/dask/pull/8965.patch,,,,,,,,,,,,,,,,,,,
583,https://api.github.com/repos/dask/dask/issues/8980,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8980/labels{/name},https://api.github.com/repos/dask/dask/issues/8980/comments,https://api.github.com/repos/dask/dask/issues/8980/events,https://github.com/dask/dask/issues/8980,1215075103,I_kwDOAbcwm85IbJMf,8980,High level layer structure,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,7,2022-04-25T21:40:11Z,2022-05-12T20:08:38Z,,MEMBER,,"After https://github.com/dask/distributed/pull/6028 we'll be able to remove a lot of the cruft around pack/unpack of high level layers.  (woo!).  Now is probably also a good time to rethink that interface.  Currently the interface seems to be the following:

- Mapping, so getitem, list keys, len
- Cull

What would make more sense?  I'd like to solicit information about what constraints on a design should be.  What do we need minimally?  Then after that (in a separate issue) let's think about what we might add on top.

cc @rjzamora @ian-r-rose @jcrist ",,https://api.github.com/repos/dask/dask/issues/8980/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8980/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
584,https://api.github.com/repos/dask/dask/issues/8983,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/8983/labels{/name},https://api.github.com/repos/dask/dask/issues/8983/comments,https://api.github.com/repos/dask/dask/issues/8983/events,https://github.com/dask/dask/issues/8983,1216146620,I_kwDOAbcwm85IfOy8,8983,partition_size not respected after `ddf.repartition()`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,2,2022-04-26T15:40:41Z,2022-05-30T02:14:56Z,,MEMBER,,"According to the `ddf.repartition` docs `partition_size`: Max number of bytes of memory for each partition. Use numbers or strings like 5MB. If specified npartitions and divisions will be ignored.

However, when running the following example, after setting `partition_size=100MB` I end up with a `partition_size` bigger than `100MB`

**Minimal Complete Verifiable Example**:

```python
from dask.distributed import Client
import dask.dataframe as dd
client = Client()

#this data is public and it's 0.5GB so it shouldn't be a problem to reproduce
csv_dir = ""s3://coiled-datasets/h2o-benchmark/N_1e7_K_1e2/""
ddf = dd.read_csv(f""{csv_dir}*.csv"", 
            dtype={
            ""id1"": ""category"",
            ""id2"": ""category"",
            ""id3"": ""category"",
            ""id4"": ""Int32"",
            ""id5"": ""Int32"",
            ""id6"": ""Int32"",
            ""v1"": ""Int32"",
            ""v2"": ""Int32"",
            ""v3"": ""float64"",
        })
ddf.memory_usage_per_partition(deep=True).compute() / 1e6
```
 The original memory usage per partition
 
 ```
 0    48.034095
1    48.034302
2    48.034233
3    48.034233
4    48.034302
5    48.034164
6    48.034371
7    48.034164
8    48.034233
9    48.034164
dtype: float64
 ```
Now we try to repartition
```python 
new_ddf = ddf.repartition(partition_size=""100MB"")
new_ddf.memory_usage_per_partition(deep=True).compute() / 1e6
```
Results in: 
```
0    103.034312
1    103.034312
2    103.034312
3    103.034312
4    103.034312
dtype: float64
```

If I try to set  `partition_size=90MB` I see something weird, 
```python
new_ddf_2 = ddf.repartition(partition_size=""90MB"")
new_ddf_2.memory_usage_per_partition(deep=True).compute() / 1e6
```
I get the same amount of partitions as the original `ddf`, but 2 of them are of a smaller size than the original.
```
0    48.034095
1    48.034302
2    48.034233
3    48.034233
4    45.912390  # this one
5    45.912252  # this one
6    48.034371
7    48.034164
8    48.034233
9    48.034164
```
**Anything else we need to know?**:

I was not able to reproduce this using something like `dask.datasets.timeseries()`

**Environment**:

- Dask version: 2022.4.1
- Python version: 3.9.12
- Operating System: macOS 12.1
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/8983/timeline,,,ncclementi,7526622,MDQ6VXNlcjc1MjY2MjI=,https://avatars.githubusercontent.com/u/7526622?v=4,,https://api.github.com/users/ncclementi,https://github.com/ncclementi,https://api.github.com/users/ncclementi/followers,https://api.github.com/users/ncclementi/following{/other_user},https://api.github.com/users/ncclementi/gists{/gist_id},https://api.github.com/users/ncclementi/starred{/owner}{/repo},https://api.github.com/users/ncclementi/subscriptions,https://api.github.com/users/ncclementi/orgs,https://api.github.com/users/ncclementi/repos,https://api.github.com/users/ncclementi/events{/privacy},https://api.github.com/users/ncclementi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/8983/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
585,https://api.github.com/repos/dask/dask/issues/9007,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9007/labels{/name},https://api.github.com/repos/dask/dask/issues/9007/comments,https://api.github.com/repos/dask/dask/issues/9007/events,https://github.com/dask/dask/issues/9007,1221884761,I_kwDOAbcwm85I1HtZ,9007,`.dt.tz` method fails on a timezone-aware datetime column,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,2,2022-04-30T17:48:35Z,2022-05-02T21:07:45Z,,CONTRIBUTOR,,"It seems there is a bug preventing `dt.tz` method from working on a timezone-aware column. Consider this example:

```python
from dask.dataframe import from_pandas, to_datetime
from pandas import DataFrame

df = from_pandas(
    DataFrame(
        {
            ""timestamp_local"": [
                ""2021-01-01 09:01:12"",
                ""2021-01-01 19:01:12"",
                ""2021-01-01 09:01:12"",
            ]
        }
    ),
    npartitions=1,
)

ddf[""converted_date""] = to_datetime(ddf[""timestamp_local""], utc=False).dt.tz_localize(
    ""Asia/Almaty""
)

# pandas version works
print(ddf[""converted_date""].compute().dt.tz) 

# dask version fails
print(ddf[""converted_date""].dt.tz)
```

- Dask version: 2022.4.2
- Python version: 3.10
- Install method (conda, pip, source): Conda
",,https://api.github.com/repos/dask/dask/issues/9007/timeline,,,SultanOrazbayev,20208402,MDQ6VXNlcjIwMjA4NDAy,https://avatars.githubusercontent.com/u/20208402?v=4,,https://api.github.com/users/SultanOrazbayev,https://github.com/SultanOrazbayev,https://api.github.com/users/SultanOrazbayev/followers,https://api.github.com/users/SultanOrazbayev/following{/other_user},https://api.github.com/users/SultanOrazbayev/gists{/gist_id},https://api.github.com/users/SultanOrazbayev/starred{/owner}{/repo},https://api.github.com/users/SultanOrazbayev/subscriptions,https://api.github.com/users/SultanOrazbayev/orgs,https://api.github.com/users/SultanOrazbayev/repos,https://api.github.com/users/SultanOrazbayev/events{/privacy},https://api.github.com/users/SultanOrazbayev/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9007/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
586,https://api.github.com/repos/dask/dask/issues/9008,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9008/labels{/name},https://api.github.com/repos/dask/dask/issues/9008/comments,https://api.github.com/repos/dask/dask/issues/9008/events,https://github.com/dask/dask/issues/9008,1222185046,I_kwDOAbcwm85I2RBW,9008,"Metadata error when dropping a list of columns, and then later updating that list of columns","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,8,2022-05-01T15:04:58Z,2023-09-21T13:10:26Z,,CONTRIBUTOR,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:

A metadata error:
```
ValueError: The columns in the computed data do not match the columns in the provided metadata
  Extra:   []
  Missing: ['b']
```

**What you expected to happen**:

Only `""a""` to be dropped, since it was the only column in the `to_drop` list at the time I called `drop()`

**Minimal Complete Verifiable Example**:

```python
>>> import pandas as pd
>>> import dask.dataframe as dd
>>> df = dd.from_pandas(pd.DataFrame({""a"": [1], ""b"":[2]}), npartitions=1)
>>> to_drop = [""a""]
>>> df = df.drop(columns=to_drop)
>>> to_drop.append(""b"")
>>> to_drop
['a', 'b']
>>> df.compute()
ValueError: The columns in the computed data do not match the columns in the provided metadata
  Extra:   []
  Missing: ['b']
>>> 
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2022.2.1
- Python version: Python 3.9.5
- Operating System: Ubuntu
- Install method pip

<!-- If you are reporting an issue such as scale stability, cluster deadlock.
Please provide a cluster dump state with this issue, by running client.dump_cluster_state()

https://distributed.dask.org/en/stable/api.html?highlight=dump_cluster_state#distributed.Client.dump_cluster_state

-->

<details>
<summary>Cluster Dump State:</summary>

</details>",,https://api.github.com/repos/dask/dask/issues/9008/timeline,,,multimeric,5019367,MDQ6VXNlcjUwMTkzNjc=,https://avatars.githubusercontent.com/u/5019367?v=4,,https://api.github.com/users/multimeric,https://github.com/multimeric,https://api.github.com/users/multimeric/followers,https://api.github.com/users/multimeric/following{/other_user},https://api.github.com/users/multimeric/gists{/gist_id},https://api.github.com/users/multimeric/starred{/owner}{/repo},https://api.github.com/users/multimeric/subscriptions,https://api.github.com/users/multimeric/orgs,https://api.github.com/users/multimeric/repos,https://api.github.com/users/multimeric/events{/privacy},https://api.github.com/users/multimeric/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9008/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
587,https://api.github.com/repos/dask/dask/issues/9020,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9020/labels{/name},https://api.github.com/repos/dask/dask/issues/9020/comments,https://api.github.com/repos/dask/dask/issues/9020/events,https://github.com/dask/dask/pull/9020,1224881476,PR_kwDOAbcwm843RAv9,9020,Fix ddf.groupby with scalar group_keys and falsy column slicing,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,6,2022-05-04T03:17:19Z,2022-07-18T12:57:27Z,,CONTRIBUTOR,,"When working with some `ddf`s recently containing integer columns, I noticed a couple issues when slicing column `0`, which is ""falsy"" - depending on the operation, sometimes I would get the wrong column output (eg: `.groupby(...)[0].agg(...)` would return a different column, _if_ `0` wasn't the first) or get a dataframe back instead of a series. These were mostly caused by `if self._slice` checks which should be `if self._slice is None` checks.

While looking into this, I also discovered issues with `ddf.groupby(scalar_value).cov()` (`'int' object is not iterable`). I think this is mostly isolated to `.cov`, but there's a lot of other logic checking or converting `self.by` to a list elsewhere, so harder to say.

The added tests fail when run without the changes, but aren't particularly clear/tidy - any suggestions on a better way (or an existing test)?

- [ ] Closes #xxxx
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9020/timeline,,,JacobHayes,2555532,MDQ6VXNlcjI1NTU1MzI=,https://avatars.githubusercontent.com/u/2555532?v=4,,https://api.github.com/users/JacobHayes,https://github.com/JacobHayes,https://api.github.com/users/JacobHayes/followers,https://api.github.com/users/JacobHayes/following{/other_user},https://api.github.com/users/JacobHayes/gists{/gist_id},https://api.github.com/users/JacobHayes/starred{/owner}{/repo},https://api.github.com/users/JacobHayes/subscriptions,https://api.github.com/users/JacobHayes/orgs,https://api.github.com/users/JacobHayes/repos,https://api.github.com/users/JacobHayes/events{/privacy},https://api.github.com/users/JacobHayes/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9020/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9020,https://github.com/dask/dask/pull/9020,https://github.com/dask/dask/pull/9020.diff,https://github.com/dask/dask/pull/9020.patch,,,,,,,,,,,,,,,,,,,
588,https://api.github.com/repos/dask/dask/issues/9021,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9021/labels{/name},https://api.github.com/repos/dask/dask/issues/9021/comments,https://api.github.com/repos/dask/dask/issues/9021/events,https://github.com/dask/dask/issues/9021,1225013353,I_kwDOAbcwm85JBDhp,9021,`corrcoef` with Sparse Arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,4,2022-05-04T07:29:14Z,2022-06-03T17:44:59Z,,NONE,," **What happened**:
I am trying to compute a correlation matrix and am getting some errors.

**What you expected to happen**:
The matrix should be computed.

Thanks for any help!  Hopefully this is just me being dumb!

**Minimal Complete Verifiable Example**:

```python
from scipy.sparse import csr_matrix
import sparse
import dask.array as da

x = csr_matrix([[0,1],[2,2]])
x = sparse.COO.from_scipy_sparse(x)
dask_data = da.from_array(x, asarray=False)
corr = da.corrcoef(dask_data)
corr.compute()
```
Error:
```
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/base.py"", line 292, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/base.py"", line 575, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/threaded.py"", line 81, in get
    results = get_async(
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/local.py"", line 508, in get_async
    raise_exception(exc, tb)
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/local.py"", line 316, in reraise
    raise exc
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/local.py"", line 221, in execute_task
    result = _execute_task(task, data)
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/core.py"", line 119, in <genexpr>
    return func(*(_execute_task(a, cache) for a in args))
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/core.py"", line 119, in <genexpr>
    return func(*(_execute_task(a, cache) for a in args))
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/core.py"", line 119, in <genexpr>
    return func(*(_execute_task(a, cache) for a in args))
  File ""/Users/ilangold/Library/Caches/pypoetry/virtualenvs/scfglue--xSM6sHX-py3.9/lib/python3.9/site-packages/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""<__array_function__ internals>"", line 5, in diag
TypeError: no implementation found for 'numpy.diag' on types that implement __array_function__: [<class 'sparse._coo.core.COO'>
```

**Environment**:

- Dask version: `2022.4.1`
- Python version: `3.9`
- Operating System: Mac OS
- Install method (conda, pip, source): `pip`/`poetry`",,https://api.github.com/repos/dask/dask/issues/9021/timeline,,,ilan-gold,43999641,MDQ6VXNlcjQzOTk5NjQx,https://avatars.githubusercontent.com/u/43999641?v=4,,https://api.github.com/users/ilan-gold,https://github.com/ilan-gold,https://api.github.com/users/ilan-gold/followers,https://api.github.com/users/ilan-gold/following{/other_user},https://api.github.com/users/ilan-gold/gists{/gist_id},https://api.github.com/users/ilan-gold/starred{/owner}{/repo},https://api.github.com/users/ilan-gold/subscriptions,https://api.github.com/users/ilan-gold/orgs,https://api.github.com/users/ilan-gold/repos,https://api.github.com/users/ilan-gold/events{/privacy},https://api.github.com/users/ilan-gold/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9021/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
589,https://api.github.com/repos/dask/dask/issues/9028,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9028/labels{/name},https://api.github.com/repos/dask/dask/issues/9028/comments,https://api.github.com/repos/dask/dask/issues/9028/events,https://github.com/dask/dask/issues/9028,1226719232,I_kwDOAbcwm85JHkAA,9028,Arithmetic operations involving masked `numpy` and `dask` arrays result in inconsistent masks,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,3,2022-05-05T14:03:09Z,2022-07-12T13:05:44Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

Hi, @bettina-gier and I found a possible bug regarding masked arrays:

**What happened**:
When performing arithmetic operations (I tested `+`, `-`, `*`, and `/`) between masked `numpy` and `dask` arrays I noticed that the mask of the resulting array might be wrong. In particular, the resulting mask when using `compute()` **before** the combination of the input arrays differs to the resulting mask when using `compute()` **after** the combination of the input arrays.

**What you expected to happen**:
The mask should be independent of the order in which `compute()` and the arithmetic operation are used, i.e., all four examples below should return the same result. 

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.array as da
import numpy as np

# Numpy & Numpy
arr_1 = np.ma.masked_less(np.arange(3), 2)  # [-- -- 2]
arr_2 = np.ma.masked_less(np.arange(3) + 1, 2)  # [-- 2 3]
diff_1 = arr_1 - arr_2
diff_2 = arr_2 - arr_1
print(diff_1)  # [-- -- -1]
print(diff_2)  # [-- -- 1]

# Computed (Dask & Dask)
arr_1 = da.ma.masked_less(da.arange(3), 2)  # [-- -- 2]
arr_2 = da.ma.masked_less(da.arange(3) + 1, 2)  # [-- 2 3]
diff_1 = (arr_1 - arr_2).compute()
diff_2 = (arr_2 - arr_1).compute()
print(diff_1)  # [-- -- -1]
print(diff_2)  # [-- -- 1]

# (Numpy & computed Dask)
arr_1 = da.ma.masked_less(da.arange(3), 2).compute()  # [-- -- 2]
arr_2 = np.ma.masked_less(np.arange(3) + 1, 2)  # [-- 2 3]
diff_1 = arr_1 - arr_2
diff_2 = arr_2 - arr_1
print(diff_1)  # [-- -- -1]
print(diff_2)  # [-- -- 1]

# Computed (Numpy & Dask)
arr_1 = da.ma.masked_less(da.arange(3), 2)  # [-- -- 2]
arr_2 = np.ma.masked_less(np.arange(3) + 1, 2)  # [-- 2 3]
diff_1 = (arr_1 - arr_2).compute()
diff_2 = arr_2 - arr_1
print(diff_1)  # [-- -- -1]
print(diff_2)  # [-- 1 1]
```

As you can see in this example, the mask in the last computation differs from the first three computations.

**Environment**:

- Dask version: `2022.5.0` (build `pyhd8ed1ab_0`)
- Python version: `3.10.4` (build `h2660328_0_cpython`)
- Operating System: openSUSE Tumbleweed 20220428
- Install method (conda, pip, source): `mamba` (conda-forge)

Thanks for your help!",,https://api.github.com/repos/dask/dask/issues/9028/timeline,,,schlunma,32543114,MDQ6VXNlcjMyNTQzMTE0,https://avatars.githubusercontent.com/u/32543114?v=4,,https://api.github.com/users/schlunma,https://github.com/schlunma,https://api.github.com/users/schlunma/followers,https://api.github.com/users/schlunma/following{/other_user},https://api.github.com/users/schlunma/gists{/gist_id},https://api.github.com/users/schlunma/starred{/owner}{/repo},https://api.github.com/users/schlunma/subscriptions,https://api.github.com/users/schlunma/orgs,https://api.github.com/users/schlunma/repos,https://api.github.com/users/schlunma/events{/privacy},https://api.github.com/users/schlunma/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9028/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
590,https://api.github.com/repos/dask/dask/issues/9030,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9030/labels{/name},https://api.github.com/repos/dask/dask/issues/9030/comments,https://api.github.com/repos/dask/dask/issues/9030/events,https://github.com/dask/dask/issues/9030,1226771088,I_kwDOAbcwm85JHwqQ,9030,Cannot slice a string index,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,2,2022-05-05T14:43:58Z,2022-08-25T17:34:04Z,,MEMBER,,"**What happened**:

I attempted to use the slicing string method on a Dask index and it ran into trouble:

```python
import dask.dataframe as dd
import pandas

df = pandas.DataFrame(
    {
        ""A"": [1, 2, 3, 4, 5, 6]
    },
    index = [""aa"", ""aa"", ""bb"", ""bb"", ""cc"", ""cc""]
)
ddf = dd.from_pandas(df, npartitions=2)

ddf.index.str.slice(0,1).compute()
```
produces

<details>

```python-traceback
AttributeError                            Traceback (most recent call last)
Input In [13], in <cell line: 1>()
----> 1 ddf.index.str.slice(0,1).compute()

File ~/miniconda3/envs/census/lib/python3.9/site-packages/dask/base.py:292, in DaskMethodsMixin.compute(self, **kwargs)
    268 def compute(self, **kwargs):
    269     """"""Compute this dask collection
    270 
    271     This turns a lazy Dask collection into its in-memory equivalent.
   (...)
    290     dask.base.compute
    291     """"""
--> 292     (result,) = compute(self, traverse=False, **kwargs)
    293     return result

File ~/miniconda3/envs/census/lib/python3.9/site-packages/dask/base.py:575, in compute(traverse, optimize_graph, scheduler, get, *args, **kwargs)
    572     keys.append(x.__dask_keys__())
    573     postcomputes.append(x.__dask_postcompute__())
--> 575 results = schedule(dsk, keys, **kwargs)
    576 return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])

File ~/miniconda3/envs/census/lib/python3.9/site-packages/dask/threaded.py:81, in get(dsk, result, cache, num_workers, pool, **kwargs)
     78     elif isinstance(pool, multiprocessing.pool.Pool):
     79         pool = MultiprocessingPoolExecutor(pool)
---> 81 results = get_async(
     82     pool.submit,
     83     pool._max_workers,
     84     dsk,
     85     result,
     86     cache=cache,
     87     get_id=_thread_get_id,
     88     pack_exception=pack_exception,
     89     **kwargs,
     90 )
     92 # Cleanup pools associated to dead threads
     93 with pools_lock:

File ~/miniconda3/envs/census/lib/python3.9/site-packages/dask/local.py:508, in get_async(submit, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, chunksize, **kwargs)
    506         _execute_task(task, data)  # Re-execute locally
    507     else:
--> 508         raise_exception(exc, tb)
    509 res, worker_id = loads(res_info)
    510 state[""cache""][key] = res

File ~/miniconda3/envs/census/lib/python3.9/site-packages/dask/local.py:316, in reraise(exc, tb)
    314 if exc.__traceback__ is not tb:
    315     raise exc.with_traceback(tb)
--> 316 raise exc

File ~/miniconda3/envs/census/lib/python3.9/site-packages/dask/local.py:221, in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    219 try:
    220     task, data = loads(task_info)
--> 221     result = _execute_task(task, data)
    222     id = get_id()
    223     result = dumps((result, id))

File ~/miniconda3/envs/census/lib/python3.9/site-packages/dask/core.py:119, in _execute_task(arg, cache, dsk)
    115     func, args = arg[0], arg[1:]
    116     # Note: Don't assign the subtask results to a variable. numpy detects
    117     # temporaries by their reference count and can execute certain
    118     # operations in-place.
--> 119     return func(*(_execute_task(a, cache) for a in args))
    120 elif not ishashable(arg):
    121     return arg

File ~/miniconda3/envs/census/lib/python3.9/site-packages/dask/dataframe/methods.py:88, in boundary_slice(df, start, stop, right_boundary, left_boundary, kind)
     56 def boundary_slice(df, start, stop, right_boundary=True, left_boundary=True, kind=None):
     57     """"""Index slice start/stop. Can switch include/exclude boundaries.
     58 
     59     Examples
   (...)
     86     Index: []
     87     """"""
---> 88     if len(df.index) == 0:
     89         return df
     91     if PANDAS_GT_131:

AttributeError: 'Index' object has no attribute 'index'
```

</details>

- Dask version: `main`
- Python version: `3.8`
- Operating System: `ubuntu`
- Install method (conda, pip, source): source
",,https://api.github.com/repos/dask/dask/issues/9030/timeline,,,ian-r-rose,5728311,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9030/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
591,https://api.github.com/repos/dask/dask/issues/9033,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9033/labels{/name},https://api.github.com/repos/dask/dask/issues/9033/comments,https://api.github.com/repos/dask/dask/issues/9033/events,https://github.com/dask/dask/issues/9033,1226831620,I_kwDOAbcwm85JH_cE,9033,Build Dash/Zeal docset and publish a docset feed,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,4,2022-05-05T15:28:56Z,2022-09-02T14:08:21Z,,MEMBER,,"In addition to the existing published documentation, it would be great to build documentation for [Dash.app](https://kapeli.com/dash)-compatible docsets and publish a feed for those. Personally, I prefer keeping all my relevant information in there instead of Googling or searching directly on the website and it helps for developing with an unstable internet connection.

Docsets can be build using [doc2dash](https://github.com/hynek/doc2dash) and it looks like someone has already gone through this effort at some point in time, though the contributed docsets for [dask](https://github.com/Kapeli/Dash-User-Contributions/tree/master/docsets/Dask) and [distributed](https://github.com/Kapeli/Dash-User-Contributions/tree/master/docsets/Distributed) are outdated. To avoid the PR-based publishing workflow on the [Dash-User-Contributions](https://github.com/Kapeli/Dash-User-Contributions/) repo, I'd also suggest publishing our own docset feed (see [https://kapeli.com/docsets#sharedocsetfeed](https://kapeli.com/docsets#sharedocsetfeed) for more information).

**cc** @jsignell, @jacobtomlinson and @scharlottej13 ",,https://api.github.com/repos/dask/dask/issues/9033/timeline,,,hendrikmakait,2699097,MDQ6VXNlcjI2OTkwOTc=,https://avatars.githubusercontent.com/u/2699097?v=4,,https://api.github.com/users/hendrikmakait,https://github.com/hendrikmakait,https://api.github.com/users/hendrikmakait/followers,https://api.github.com/users/hendrikmakait/following{/other_user},https://api.github.com/users/hendrikmakait/gists{/gist_id},https://api.github.com/users/hendrikmakait/starred{/owner}{/repo},https://api.github.com/users/hendrikmakait/subscriptions,https://api.github.com/users/hendrikmakait/orgs,https://api.github.com/users/hendrikmakait/repos,https://api.github.com/users/hendrikmakait/events{/privacy},https://api.github.com/users/hendrikmakait/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9033/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
592,https://api.github.com/repos/dask/dask/issues/9034,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9034/labels{/name},https://api.github.com/repos/dask/dask/issues/9034/comments,https://api.github.com/repos/dask/dask/issues/9034/events,https://github.com/dask/dask/issues/9034,1226838397,I_kwDOAbcwm85JIBF9,9034,Handle empty dataframes and/or mismatched columns in `dd.from_delayed`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 3798450422, 'node_id': 'LA_kwDOAbcwm87iZ8D2', 'url': 'https://api.github.com/repos/dask/dask/labels/p3', 'name': 'p3', 'color': 'ffff33', 'default': False, 'description': 'Affects a small number of users or is largely cosmetic'}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,3,2022-05-05T15:32:52Z,2022-08-25T17:27:13Z,,MEMBER,,"I notice that if I'm looping through several arguments to a Dask-delayed function and building a dataframe, I get an error when the dataframe is empty or if the columns are slightly different.

The following demonstrates the two cases:

```python
import pandas
from dask import delayed
import dask.dataframe as dd


@delayed
def make_dataframe_with_empty(n):
    if n != 5:
        return pandas.DataFrame({""a"": [n] * 2, ""b"": [n*2] * 2})
    else:
        return pandas.DataFrame()
    
    
ddf1 = dd.from_delayed([make_dataframe_with_empty(n) for n in range(10)])
ddf1.compute()
```

Which makes:

<details>

```
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Input In [5], in <module>
     11         return pandas.DataFrame()
     14 ddf1 = dd.from_delayed([make_dataframe_with_empty(n) for n in range(10)])
---> 15 ddf1.compute()

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/base.py:290, in DaskMethodsMixin.compute(self, **kwargs)
    266 def compute(self, **kwargs):
    267     """"""Compute this dask collection
    268 
    269     This turns a lazy Dask collection into its in-memory equivalent.
   (...)
    288     dask.base.compute
    289     """"""
--> 290     (result,) = compute(self, traverse=False, **kwargs)
    291     return result

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/base.py:573, in compute(traverse, optimize_graph, scheduler, get, *args, **kwargs)
    570     keys.append(x.__dask_keys__())
    571     postcomputes.append(x.__dask_postcompute__())
--> 573 results = schedule(dsk, keys, **kwargs)
    574 return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/threaded.py:81, in get(dsk, result, cache, num_workers, pool, **kwargs)
     78     elif isinstance(pool, multiprocessing.pool.Pool):
     79         pool = MultiprocessingPoolExecutor(pool)
---> 81 results = get_async(
     82     pool.submit,
     83     pool._max_workers,
     84     dsk,
     85     result,
     86     cache=cache,
     87     get_id=_thread_get_id,
     88     pack_exception=pack_exception,
     89     **kwargs,
     90 )
     92 # Cleanup pools associated to dead threads
     93 with pools_lock:

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/local.py:506, in get_async(submit, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, chunksize, **kwargs)
    504         _execute_task(task, data)  # Re-execute locally
    505     else:
--> 506         raise_exception(exc, tb)
    507 res, worker_id = loads(res_info)
    508 state[""cache""][key] = res

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/local.py:314, in reraise(exc, tb)
    312 if exc.__traceback__ is not tb:
    313     raise exc.with_traceback(tb)
--> 314 raise exc

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/local.py:219, in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    217 try:
    218     task, data = loads(task_info)
--> 219     result = _execute_task(task, data)
    220     id = get_id()
    221     result = dumps((result, id))

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/core.py:119, in _execute_task(arg, cache, dsk)
    115     func, args = arg[0], arg[1:]
    116     # Note: Don't assign the subtask results to a variable. numpy detects
    117     # temporaries by their reference count and can execute certain
    118     # operations in-place.
--> 119     return func(*(_execute_task(a, cache) for a in args))
    120 elif not ishashable(arg):
    121     return arg

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/dataframe/utils.py:407, in check_meta(x, meta, funcname, numeric_equal)
    401         return x
    402     errmsg = ""Partition type: `{}`\n{}"".format(
    403         typename(type(meta)),
    404         asciitable(["""", ""dtype""], [(""Found"", x.dtype), (""Expected"", meta.dtype)]),
    405     )
--> 407 raise ValueError(
    408     ""Metadata mismatch found%s.\n\n""
    409     ""%s"" % (("" in `%s`"" % funcname if funcname else """"), errmsg)
    410 )

```

</details>

```
ValueError: Metadata mismatch found in `from_delayed`.

Partition type: `pandas.core.frame.DataFrame`
+--------+-------+----------+
| Column | Found | Expected |
+--------+-------+----------+
| 'a'    | -     | int64    |
| 'b'    | -     | int64    |
+--------+-------+----------+

```

And then:

```python
@delayed
def make_dataframe_diff_col_order(n):
    df = pandas.DataFrame({""a"": [n] * 2, ""b"": [n*2] * 2})
    
    if n == 5:
        df = df.loc[:, [""b"", ""a""]]
    
    return df
    

ddf2 = dd.from_delayed([make_dataframe_diff_col_order(n) for n in range(10)])
ddf2.compute()
```

<details>

```
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Input In [3], in <module>
     11     return df
     13 ddf2 = dd.from_delayed([
     14       make_dataframe_diff_col_order(n) for n in range(10)
     15 ])
---> 17 ddf2.compute()

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/base.py:290, in DaskMethodsMixin.compute(self, **kwargs)
    266 def compute(self, **kwargs):
    267     """"""Compute this dask collection
    268 
    269     This turns a lazy Dask collection into its in-memory equivalent.
   (...)
    288     dask.base.compute
    289     """"""
--> 290     (result,) = compute(self, traverse=False, **kwargs)
    291     return result

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/base.py:573, in compute(traverse, optimize_graph, scheduler, get, *args, **kwargs)
    570     keys.append(x.__dask_keys__())
    571     postcomputes.append(x.__dask_postcompute__())
--> 573 results = schedule(dsk, keys, **kwargs)
    574 return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/threaded.py:81, in get(dsk, result, cache, num_workers, pool, **kwargs)
     78     elif isinstance(pool, multiprocessing.pool.Pool):
     79         pool = MultiprocessingPoolExecutor(pool)
---> 81 results = get_async(
     82     pool.submit,
     83     pool._max_workers,
     84     dsk,
     85     result,
     86     cache=cache,
     87     get_id=_thread_get_id,
     88     pack_exception=pack_exception,
     89     **kwargs,
     90 )
     92 # Cleanup pools associated to dead threads
     93 with pools_lock:

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/local.py:506, in get_async(submit, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, chunksize, **kwargs)
    504         _execute_task(task, data)  # Re-execute locally
    505     else:
--> 506         raise_exception(exc, tb)
    507 res, worker_id = loads(res_info)
    508 state[""cache""][key] = res

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/local.py:314, in reraise(exc, tb)
    312 if exc.__traceback__ is not tb:
    313     raise exc.with_traceback(tb)
--> 314 raise exc

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/local.py:219, in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    217 try:
    218     task, data = loads(task_info)
--> 219     result = _execute_task(task, data)
    220     id = get_id()
    221     result = dumps((result, id))

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/core.py:119, in _execute_task(arg, cache, dsk)
    115     func, args = arg[0], arg[1:]
    116     # Note: Don't assign the subtask results to a variable. numpy detects
    117     # temporaries by their reference count and can execute certain
    118     # operations in-place.
--> 119     return func(*(_execute_task(a, cache) for a in args))
    120 elif not ishashable(arg):
    121     return arg

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/dataframe/utils.py:397, in check_meta(x, meta, funcname, numeric_equal)
    392         errmsg = ""Partition type: `{}`\n{}"".format(
    393             typename(type(meta)),
    394             asciitable([""Column"", ""Found"", ""Expected""], bad_dtypes),
    395         )
    396     else:
--> 397         check_matching_columns(meta, x)
    398         return x
    399 else:

File ~/mambaforge/envs/dask-use/lib/python3.9/site-packages/dask/dataframe/utils.py:422, in check_matching_columns(meta, actual)
    420 else:
    421     extra_info = ""Order of columns does not match""
--> 422 raise ValueError(
    423     ""The columns in the computed data do not match""
    424     "" the columns in the provided metadata\n""
    425     f""{extra_info}""
    426 )

```

</details>

```
ValueError: The columns in the computed data do not match the columns in the provided metadata
Order of columns does not match
```


Coming from pandas I (likely wrongly) view `from_delayed` as an async analog to `pandas.concat`

In the first case of a truly empty dataframe, I could be convinced that users could be steered to write function that return an zero-row dataframe with the columns specified. (Counterpoint: it might be difficult to know exactly what the columns and their order will be). 

In the second case, I feels more like something that we could handle, though I see how complexity will sneak its way in.",,https://api.github.com/repos/dask/dask/issues/9034/timeline,,,phobson,1163939,MDQ6VXNlcjExNjM5Mzk=,https://avatars.githubusercontent.com/u/1163939?v=4,,https://api.github.com/users/phobson,https://github.com/phobson,https://api.github.com/users/phobson/followers,https://api.github.com/users/phobson/following{/other_user},https://api.github.com/users/phobson/gists{/gist_id},https://api.github.com/users/phobson/starred{/owner}{/repo},https://api.github.com/users/phobson/subscriptions,https://api.github.com/users/phobson/orgs,https://api.github.com/users/phobson/repos,https://api.github.com/users/phobson/events{/privacy},https://api.github.com/users/phobson/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9034/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
593,https://api.github.com/repos/dask/dask/issues/9044,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9044/labels{/name},https://api.github.com/repos/dask/dask/issues/9044/comments,https://api.github.com/repos/dask/dask/issues/9044/events,https://github.com/dask/dask/issues/9044,1227276174,I_kwDOAbcwm85JJr-O,9044,Output files with .csv file extension instead of .part when to_csv is used,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,6,2022-05-05T23:38:16Z,2022-08-25T17:23:39Z,,CONTRIBUTOR,,"The `to_csv` method outputs filenames with a `.part` extension by default.  This post argues that `to_csv` should output CSV files with a `.csv` extension by default.

Let's create a DataFrame and write it out to a directory and see the default behavior.

```python
import pandas as pd
import dask.dataframe as dd

pdf = pd.DataFrame(
    {""num1"": [1, 2, 3, 4], ""num2"": [7, 8, 9, 10]},
)

ddf = dd.from_pandas(pdf, npartitions=2)

ddf.to_csv(""./data/csv_simple"")
```

Here are the files that are output:

```
csv_simple/
  0.part
  1.part
```

Downstream readers need to do something like `dd.read_csv(""./data/csv_simple/*.part"")` to read these CSV files into a DataFrame.

Here's the work-around to output the files with the `.csv` file extension:

```python
ddf.to_csv(""./data/csv_simple2/whatever-*-hi.csv"")
```

Here are the files that are output:

```
csv_simple2/
  whatever-0-hi.csv
  whatever-1-hi.csv
```

I don't believe there is a work around to customize the file extension and avoid writing `.part` when you use the `name_function` argument.  Take a look at this example:

```python
ddf.to_csv(""./data/csv_simple3"", name_function = lambda x: f""i-like-{x}.csv"")
```

Here's what's output:

```
csv_simple3/
  i-like-0.csv.part
  i-like-1.csv.part
```

I'd personally prefer for files to be written with a `.csv` extension by default.  That'd be more intuitive for me.

Think it's also more consistent with the Parquet writers.  For example `ddf.to_parquet(""./data/parquet_simple"")` outputs files like `part.0.parquet` and `part.1.parquet`.  Let me know what you think!",,https://api.github.com/repos/dask/dask/issues/9044/timeline,,,MrPowers,2722395,MDQ6VXNlcjI3MjIzOTU=,https://avatars.githubusercontent.com/u/2722395?v=4,,https://api.github.com/users/MrPowers,https://github.com/MrPowers,https://api.github.com/users/MrPowers/followers,https://api.github.com/users/MrPowers/following{/other_user},https://api.github.com/users/MrPowers/gists{/gist_id},https://api.github.com/users/MrPowers/starred{/owner}{/repo},https://api.github.com/users/MrPowers/subscriptions,https://api.github.com/users/MrPowers/orgs,https://api.github.com/users/MrPowers/repos,https://api.github.com/users/MrPowers/events{/privacy},https://api.github.com/users/MrPowers/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9044/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
594,https://api.github.com/repos/dask/dask/issues/9047,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9047/labels{/name},https://api.github.com/repos/dask/dask/issues/9047/comments,https://api.github.com/repos/dask/dask/issues/9047/events,https://github.com/dask/dask/issues/9047,1227488991,I_kwDOAbcwm85JKf7f,9047,Mechanism for naming tasks generated by high level collections,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,4,2022-05-06T06:55:37Z,2022-08-25T17:17:59Z,,CONTRIBUTOR,,"This is a discussion originating from the discourse: https://dask.discourse.group/t/provide-a-custom-task-name-for-dataframe-tasks/669.

Basically, a lot of the reporting tools including the dashboard and error messages use the task keys/names. When these are generated by high level `DataFrame` methods, we get uninformative keys like `apply-82c6e19adcd3da8d269920ee38886065`. The issue with these is that it's hard to tell what part of your code is actually running, since you probably `apply()` several times in your code.

For example, in the dashboard, you might want to look at what tasks your worker is running, but this tells you basically nothing:
![image](https://user-images.githubusercontent.com/5019367/167081436-51d2e8b5-d59f-4e31-9b4f-f5c267db57e3.png)

Therefore I would like to request a mechanism for adding a task name prefix or suffix to auto-generated tasks. The API doesn't particularly matter, but I would envisage something like this:
```python
from dask.dataframe import read_parquet, task_prefix

df = read_parquet
with task_prefix(""calc-foo"")
    df.assign(foo = df.apply(...))

with task_prefix(""aggregate-bar"")
    df.groupby(""bar"").agg(...)
```

And then we get informative keys like:
```
calc-foo-assign-82c6e19adcd3da8d269920ee38886065
calc-foo-apply-82c6e19adcd3da8d269920ee38886065
aggregate-bar-groupby-82c6e19adcd3da8d269920ee38886065
aggregate-bar-agg-82c6e19adcd3da8d269920ee38886065
```",,https://api.github.com/repos/dask/dask/issues/9047/timeline,,,multimeric,5019367,MDQ6VXNlcjUwMTkzNjc=,https://avatars.githubusercontent.com/u/5019367?v=4,,https://api.github.com/users/multimeric,https://github.com/multimeric,https://api.github.com/users/multimeric/followers,https://api.github.com/users/multimeric/following{/other_user},https://api.github.com/users/multimeric/gists{/gist_id},https://api.github.com/users/multimeric/starred{/owner}{/repo},https://api.github.com/users/multimeric/subscriptions,https://api.github.com/users/multimeric/orgs,https://api.github.com/users/multimeric/repos,https://api.github.com/users/multimeric/events{/privacy},https://api.github.com/users/multimeric/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9047/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
595,https://api.github.com/repos/dask/dask/issues/9049,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9049/labels{/name},https://api.github.com/repos/dask/dask/issues/9049/comments,https://api.github.com/repos/dask/dask/issues/9049/events,https://github.com/dask/dask/issues/9049,1228012769,I_kwDOAbcwm85JMfzh,9049,Adding `from_map` like API for Dask Arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,6,2022-05-06T15:33:48Z,2022-08-25T17:15:19Z,,MEMBER,,"Recently @rjzamora did some work to add a `from_map` API for Dask DataFrames in PR ( https://github.com/dask/dask/pull/8911 ). It might be interesting to consider a similar API for Dask Array. The [approach taken in Dask-Image's `imread`]( https://github.com/dask/dask-image/blob/890933e35f4f03157a7c3074dfc3cf2de2ab8b2e/dask_image/imread/__init__.py#L76-L99 ) might be a starting point for thinking about this.

cc @dask/array",,https://api.github.com/repos/dask/dask/issues/9049/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9049/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
596,https://api.github.com/repos/dask/dask/issues/9051,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9051/labels{/name},https://api.github.com/repos/dask/dask/issues/9051/comments,https://api.github.com/repos/dask/dask/issues/9051/events,https://github.com/dask/dask/issues/9051,1228166857,I_kwDOAbcwm85JNFbJ,9051,Should we deprecate aggregate_files from read_parquet?,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,3,2022-05-06T17:58:57Z,2022-05-18T15:15:05Z,,MEMBER,,"This issue is similar to #8937 (already done) and #9043 in the sense that it aims to remove unnecessary (and rarely-utilized) options from `dd.read_parquet`.

TLDR: Id like to propose that we deprecate the `aggregate_files` argument from `dd.read_parquet`.

Although I do believe there is strong motivation for a file-aggregation feature (especially for hive/directory-partitioned datasets), the current implementation of this feature actually aggregates row-groups (rather than files), which is extremely inefficient at scale (or on remote storage). This implementation snafu is my own fault. However, rather than directly changing the current behavior, I suggest that we simply remove the option altogether.  Removing both `aggregate_files` and `chunksize` (see #9043) should allow us to cut out a lot of unnecessarily-complex core/engine code and reduce general maintenance burden.

In the future, we may wish to re-introduce an `aggregate_files`-like feature, but that (simpler) feature should be designed to aggregate full files (rather than arbitrary row-groups). Users (or down-stream libraries) that need more flexibility than simple per-row-groups or per-files partitioning should be able to feed their own custom logic into the new `from_map` API.",,https://api.github.com/repos/dask/dask/issues/9051/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9051/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
597,https://api.github.com/repos/dask/dask/issues/9055,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9055/labels{/name},https://api.github.com/repos/dask/dask/issues/9055/comments,https://api.github.com/repos/dask/dask/issues/9055/events,https://github.com/dask/dask/issues/9055,1228472566,I_kwDOAbcwm85JOQD2,9055,"Maintain dask-pandas parity for read_ methods (read_excel, etc)","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,4,2022-05-07T00:25:17Z,2022-05-23T15:16:08Z,,NONE,,Trying to use `read_excel` on a dask dataframe results in `module 'dask.dataframe' has no attribute 'read_excel'`. Could we add those methods and just return `dask.delayed(pd.read_excel)` to maintain parity with pandas?,,https://api.github.com/repos/dask/dask/issues/9055/timeline,,,hungcs,85463385,MDQ6VXNlcjg1NDYzMzg1,https://avatars.githubusercontent.com/u/85463385?v=4,,https://api.github.com/users/hungcs,https://github.com/hungcs,https://api.github.com/users/hungcs/followers,https://api.github.com/users/hungcs/following{/other_user},https://api.github.com/users/hungcs/gists{/gist_id},https://api.github.com/users/hungcs/starred{/owner}{/repo},https://api.github.com/users/hungcs/subscriptions,https://api.github.com/users/hungcs/orgs,https://api.github.com/users/hungcs/repos,https://api.github.com/users/hungcs/events{/privacy},https://api.github.com/users/hungcs/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9055/reactions,5,5,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
598,https://api.github.com/repos/dask/dask/issues/9056,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9056/labels{/name},https://api.github.com/repos/dask/dask/issues/9056/comments,https://api.github.com/repos/dask/dask/issues/9056/events,https://github.com/dask/dask/issues/9056,1228574860,I_kwDOAbcwm85JOpCM,9056,"Is it intended? Column loaded twice if listed twice in ""columns="" when reading a Parquet file.","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,2,2022-05-07T09:02:21Z,2022-06-02T10:48:51Z,,NONE,,"**What happened**: When loading a Parquet file, I specified a column twice in the ""columns="" argument and the column was loaded twice, that is, there were two columns in the resulting DataFrame with the same name and data.

**What you expected to happen**: Even though I specified the column twice, I expected that the column would only be loaded once.

**Minimal Complete Verifiable Example**:

```python
# assume a Parquet file has a column called ""test"" and then load it twice
ddf = dd.read_parquet(""file.parquet"", columns=['test', 'test'])
ddf.head()
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2022.05.0
- Python version: 3.8.13
- Operating System: Windows Server 2016
- Install method (conda, pip, source): conda",,https://api.github.com/repos/dask/dask/issues/9056/timeline,,,bsesar,620131,MDQ6VXNlcjYyMDEzMQ==,https://avatars.githubusercontent.com/u/620131?v=4,,https://api.github.com/users/bsesar,https://github.com/bsesar,https://api.github.com/users/bsesar/followers,https://api.github.com/users/bsesar/following{/other_user},https://api.github.com/users/bsesar/gists{/gist_id},https://api.github.com/users/bsesar/starred{/owner}{/repo},https://api.github.com/users/bsesar/subscriptions,https://api.github.com/users/bsesar/orgs,https://api.github.com/users/bsesar/repos,https://api.github.com/users/bsesar/events{/privacy},https://api.github.com/users/bsesar/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9056/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
599,https://api.github.com/repos/dask/dask/issues/9067,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9067/labels{/name},https://api.github.com/repos/dask/dask/issues/9067/comments,https://api.github.com/repos/dask/dask/issues/9067/events,https://github.com/dask/dask/issues/9067,1232794941,I_kwDOAbcwm85JevU9,9067,Unexpected `AttributeError` on `Series.cumsum`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,2,2022-05-11T15:00:06Z,2022-07-22T12:16:26Z,,MEMBER,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
When attempting to compute `cumsum` on a series that is the result of a `map_partitions` call, I am getting an unexpected `AttributeError`:

```python
Traceback (most recent call last):
  File ""/datasets/charlesb/dev/rapids/dask-sql/test.py"", line 6, in <module>
    res = ddf.map_partitions(lambda x: 1).cumsum().compute()
  File ""/datasets/charlesb/dev/rapids/dask/dask/base.py"", line 311, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/datasets/charlesb/dev/rapids/dask/dask/base.py"", line 599, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/datasets/charlesb/dev/rapids/dask/dask/threaded.py"", line 81, in get
    results = get_async(
  File ""/datasets/charlesb/dev/rapids/dask/dask/local.py"", line 508, in get_async
    raise_exception(exc, tb)
  File ""/datasets/charlesb/dev/rapids/dask/dask/local.py"", line 316, in reraise
    raise exc
  File ""/datasets/charlesb/dev/rapids/dask/dask/local.py"", line 221, in execute_task
    result = _execute_task(task, data)
  File ""/datasets/charlesb/dev/rapids/dask/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/datasets/charlesb/dev/rapids/dask/dask/optimization.py"", line 990, in __call__
    return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
  File ""/datasets/charlesb/dev/rapids/dask/dask/core.py"", line 149, in get
    result = _execute_task(task, cache)
  File ""/datasets/charlesb/dev/rapids/dask/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/datasets/charlesb/dev/rapids/dask/dask/utils.py"", line 40, in apply
    return func(*args, **kwargs)
  File ""/datasets/charlesb/dev/rapids/dask/dask/dataframe/core.py"", line 6429, in apply_and_enforce
    df = func(*args, **kwargs)
  File ""/datasets/charlesb/dev/rapids/dask/dask/utils.py"", line 1046, in __call__
    return getattr(__obj, self.method)(*args, **kwargs)
AttributeError: 'int' object has no attribute 'cumsum'
```

**What you expected to happen**:
The same code works if I compute the result of the `map_partitions` call prior to computing `cumsum`, so I would expect that result regardless of intermediate computes.

**Minimal Complete Verifiable Example**:
This fails:

```python
import dask.dataframe as dd
import pandas as pd

ddf = dd.from_pandas(pd.DataFrame({""a"": range(10)}), 2)

res = ddf.map_partitions(lambda x: len(x)).cumsum().compute()
```

While this succeeds:

```python
res = ddf.map_partitions(lambda x: len(x)).compute().cumsum()
```

**Environment**:

- Dask version: latest `main`
- Python version: 3.9
- Operating System: ubuntu 20.04
- Install method (conda, pip, source): source",,https://api.github.com/repos/dask/dask/issues/9067/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9067/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
600,https://api.github.com/repos/dask/dask/issues/9069,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9069/labels{/name},https://api.github.com/repos/dask/dask/issues/9069/comments,https://api.github.com/repos/dask/dask/issues/9069/events,https://github.com/dask/dask/issues/9069,1233226161,I_kwDOAbcwm85JgYmx,9069,Clearer colourmap / labels when showing task order in visualize,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,3,2022-05-11T22:02:00Z,2022-06-01T15:06:12Z,,NONE,,"After a helpful suggestion from @TomAugspurger, I'm trying to examine the static task order of my DAG. This is harder than it should be just because

1) The current way of applying the colour map means sequential tasks have the most similar colours
2) There is no key to tell me which colour is first
3) I don't know of any other way to access this information
4) This definitely isn't colourblind-friendly (I'm not colourblind, but ~8% of men are)

My looks like this, which I'm finding hard to parse - for example I'm finding hard to tell if 30 occurs before 37.

![image](https://user-images.githubusercontent.com/35968931/167953949-4586ade1-9f57-44b0-9284-ef5deb7657a9.png)

Q's:

1) Is there another way for me to easily find out the static task order?
2) Can we add an (optional) key to help me differentiate?
3) Is there a html version of this graph that can tell me this info with a mouseover?

Thanks

",,https://api.github.com/repos/dask/dask/issues/9069/timeline,,,TomNicholas,35968931,MDQ6VXNlcjM1OTY4OTMx,https://avatars.githubusercontent.com/u/35968931?v=4,,https://api.github.com/users/TomNicholas,https://github.com/TomNicholas,https://api.github.com/users/TomNicholas/followers,https://api.github.com/users/TomNicholas/following{/other_user},https://api.github.com/users/TomNicholas/gists{/gist_id},https://api.github.com/users/TomNicholas/starred{/owner}{/repo},https://api.github.com/users/TomNicholas/subscriptions,https://api.github.com/users/TomNicholas/orgs,https://api.github.com/users/TomNicholas/repos,https://api.github.com/users/TomNicholas/events{/privacy},https://api.github.com/users/TomNicholas/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9069/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
601,https://api.github.com/repos/dask/dask/issues/9076,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9076/labels{/name},https://api.github.com/repos/dask/dask/issues/9076/comments,https://api.github.com/repos/dask/dask/issues/9076/events,https://github.com/dask/dask/pull/9076,1234396863,PR_kwDOAbcwm843vfD6,9076,[WIP][POC] Rough implementation of HLG/Layer Alternative,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,11,2022-05-12T19:28:18Z,2022-05-24T17:25:13Z,,MEMBER,,"**WARNING: DO NOT MERGE**

This is a rough/experimental implementation of the plan suggested in [here](https://github.com/dask/dask/issues/8980#issuecomment-1122832415) in https://github.com/dask/dask/issues/8980. The specific design needs a lot of work, but I am hoping this PR will eventually serve as a basic reference implementation for the general ""plan"" if we eventually decide to pursue it.

**General Idea**: Rather than depending on the `HighLevelGraph`/`Layer` for graph optimization and materialization, this PR proposes that we add a `Layer`-like class, called `CollectionOperation`, and use it to manage collection metadata **and** graph materialization/optimization logic.  The key advantage being that we resolve the longstanding challenge of having the HLG know nothing about the  collection that created it.

**What this POC has so far**:

So far, this PR only implements `CollectionOperation` support for DataFrame collections, and it only supports `read_parquet`, `from_map`, and element-wise operations (via `elemwise`). The following limitations are also important to consider:

- In order to use the `CollectionOperation` backend, `use_operation_api=True` must be passed to the IO function.
- After the collection is already created, the other supported operations will automatically use the `CollectionOperation` backend if is not a place-holder `CompatFrameOperation` (which simply wraps a traditional `HighLevelGraph`. Operations that do **not** support the `CollectionOperation` backend will simply force input collection(s) to generate an HLG (with a single `MaterializedLayer`) (when their `dask` attribute is called). In the future, when HLG-Pickle support is finished, we can define a special compatibiliy `Layer` object to avoid premature materialization.
- When the `dask` attribute is called on a `CollectionOperation`-based collection, the raw graph is materialized with culling and fusion baked into the `generate_graph` logic defined in the `CollectionOperation`. In the future, it probably makes sense to add an option to avoid fusion, but the long-term plan is to avoid the need for an explicit `cull` operation.
- The current PR enables column porjection, but does not include predicate pusdown yet.

Basic usage example:

```python
import dask.dataframe as dd
from dask.datasets import timeseries

timeseries().to_parquet(""timeseries"")
ddf = dd.read_parquet(
    [""timeseries/part.0.parquet"", ""timeseries/part.1.parquet""],
    use_operation_api=True,
)

# Various elemwise operations
ddf2 = ddf[operator.and_(ddf[""id""] > 995, ddf[""id""] < 1005)]
ddf3 = ddf2[[""id""]]
ddf3 += 1
ddf4 = ddf3.assign(new=""A"")

# Visualize underlying CollectionOperation
ddf4.operation.visualize()
```

![Screen Shot 2022-05-12 at 2 01 02 PM](https://user-images.githubusercontent.com/20461013/168149146-3da1f5ff-fa2f-478c-8c92-9b1427458a5b.png)

Note that, since element-wise operations will be automatically fused at graph materialization time, using `ddf4.visualize()` shows something a bit different:

![Screen Shot 2022-05-12 at 2 02 11 PM](https://user-images.githubusercontent.com/20461013/168149351-e0c01664-773a-444d-bfb7-37c313242fef.png)

Note that we can also call `optimize_operation` on the `CollectionOperation`-based collection to perform column projection:

```python
ddf4 = ddf4.optimize_operation()
ddf4.operation.projected_columns
```

```
{'id'}
```

**What is still missing**:

A lot. This is not even close to ready.

Still need to iterate on this design (probably a lot) to get an idea if it will both simplify development **and** enable useful graph optimizations in the future. I could certainly use help from people with expertise related to high-level expressions (cc @eriknw)",,https://api.github.com/repos/dask/dask/issues/9076/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9076/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9076,https://github.com/dask/dask/pull/9076,https://github.com/dask/dask/pull/9076.diff,https://github.com/dask/dask/pull/9076.patch,,,,,,,,,,,,,,,,,,,
602,https://api.github.com/repos/dask/dask/issues/9079,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9079/labels{/name},https://api.github.com/repos/dask/dask/issues/9079/comments,https://api.github.com/repos/dask/dask/issues/9079/events,https://github.com/dask/dask/issues/9079,1234567774,I_kwDOAbcwm85JlgJe,9079,dd.concat crashes with unhelpful error message when column types are incompatible,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-05-12T23:07:48Z,2022-07-14T18:00:53Z,,NONE,,"# Repro

Run:

```
import dask.dataframe as dd
import pandas as pd

ddf1 = dd.from_pandas(pd.DataFrame([{'foo': float('nan')}]), npartitions=1)
ddf2 = dd.from_pandas(pd.DataFrame([{'foo': ['string']}]), npartitions=1)
ddf2['foo'] = ddf2['foo'].astype('category')

dd.concat([ddf1, ddf2])
```

You will get the following error:

```
Traceback (most recent call last)
[<ipython-input-13-9c00824f1f78>](https://localhost:8080/#) in <module>()
----> 1 dd.concat([ddf1, ddf2])

5 frames
[/usr/local/lib/python3.7/dist-packages/pandas/core/dtypes/concat.py](https://localhost:8080/#) in <genexpr>(.0)
    272     if not all(
    273         is_dtype_equal(other.categories.dtype, first.categories.dtype)
--> 274         for other in to_union[1:]
    275     ):
    276         raise TypeError(""dtype of categories must be the same"")

AttributeError: 'numpy.ndarray' object has no attribute 'categories'
```

# Why is this painful?

The error gives no indication that there's a column type mismatch. In the actual situation where I encountered this error, the dataframes were much more complex, so I initially had no suspicion that the column types were the issue. I had to spend about 20 minutes poking around before I finally realized what was going on.",,https://api.github.com/repos/dask/dask/issues/9079/timeline,,,eric-yu-snorkel,89039681,MDQ6VXNlcjg5MDM5Njgx,https://avatars.githubusercontent.com/u/89039681?v=4,,https://api.github.com/users/eric-yu-snorkel,https://github.com/eric-yu-snorkel,https://api.github.com/users/eric-yu-snorkel/followers,https://api.github.com/users/eric-yu-snorkel/following{/other_user},https://api.github.com/users/eric-yu-snorkel/gists{/gist_id},https://api.github.com/users/eric-yu-snorkel/starred{/owner}{/repo},https://api.github.com/users/eric-yu-snorkel/subscriptions,https://api.github.com/users/eric-yu-snorkel/orgs,https://api.github.com/users/eric-yu-snorkel/repos,https://api.github.com/users/eric-yu-snorkel/events{/privacy},https://api.github.com/users/eric-yu-snorkel/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9079/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
603,https://api.github.com/repos/dask/dask/issues/9085,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9085/labels{/name},https://api.github.com/repos/dask/dask/issues/9085/comments,https://api.github.com/repos/dask/dask/issues/9085/events,https://github.com/dask/dask/issues/9085,1235701628,I_kwDOAbcwm85Jp098,9085,Poor performance when combining many blockwise operations,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,"[{'login': 'ian-r-rose', 'id': 5728311, 'node_id': 'MDQ6VXNlcjU3MjgzMTE=', 'avatar_url': 'https://avatars.githubusercontent.com/u/5728311?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/ian-r-rose', 'html_url': 'https://github.com/ian-r-rose', 'followers_url': 'https://api.github.com/users/ian-r-rose/followers', 'following_url': 'https://api.github.com/users/ian-r-rose/following{/other_user}', 'gists_url': 'https://api.github.com/users/ian-r-rose/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/ian-r-rose/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/ian-r-rose/subscriptions', 'organizations_url': 'https://api.github.com/users/ian-r-rose/orgs', 'repos_url': 'https://api.github.com/users/ian-r-rose/repos', 'events_url': 'https://api.github.com/users/ian-r-rose/events{/privacy}', 'received_events_url': 'https://api.github.com/users/ian-r-rose/received_events', 'type': 'User', 'site_admin': False}]",,3,2022-05-13T20:52:44Z,2022-06-24T16:00:43Z,,MEMBER,,"## The Problem

I was doing some performance tests and ran into some pretty poor behavior when a lot (>100) of `Blockwise` operations are applied in series. The same example framed with a single `map_partitions` call performs *much* better. A minimal reproducer:

```python
import distributed
import dask.dataframe as dd
from dask.datasets import timeseries

# A dataframe with a lot of columns to mess with
ddf = timeseries(
    dtypes={
        **{f""name-{i}"": str for i in range(25)},
        **{f""price-{i}"": float for i in range(25)},
        **{f""id-{i}"": int for i in range(25)},
        **{f""cat-{i}"": ""category"" for i in range(25)},
    },
    freq=""5s""
)

def transform(df):
    """"""
    Transform the columns of a pandas or dask dataframe.
    """"""
    transform = {}
    for c in df.columns:
        dtype = str(df[c].dtype)
        if dtype == ""object"":
            transform[c] = df[c].str.upper()
        elif dtype == ""int64"":
            transform[c] = df[c] * 2
        elif dtype == ""float64"":
            transform[c] = df[c] / 2
    return df.assign(**transform)

ddf.map_partitions(transform).compute()  # does okay!
transform(ddf).compute()  # does *very* badly

```

This reproduces on both local and distributed schedulers, but a comparison of the two from the dask dashboard is shown here (purple is `map_partitions`, teal uses the top-level dataframe API):

![image](https://user-images.githubusercontent.com/5728311/168383651-0d08100b-e479-44b4-a6d6-818b9939b9b5.png)

Not only does using the top-level Dask APIs take several times longer, but it also takes several times as much memory, and it's not hard to knock over workers with the second approach.

A bit of exploration and reflection reveals what's going on: the `Blockwise` layers are being correctly fused into a single layer as we want during optimization. But the resulting local subgraph is pretty complex, and has a ton of intermediate results! If I drill into the layer and plot the subgraph, I get the following:
![subgraph](https://user-images.githubusercontent.com/5728311/168386197-cd839a4c-3aa7-41e0-bfe6-d33f1f0d359b.png)

The performance characteristics of this graph are way worse than just bundling them into the one `map_partitions` call and letting pandas handle intermediate results internally.

Does this matter? I think so. I don't think what I'm doing is too far from ""best practices"". It is embarrassingly parallel, has immutable operations, and batches all of my transformations together into a single `compute()` call. From an API design perspective, I want to be able to tell users to use the top level API and use `map_partitions` as an escape hatch. I'm not really sure what to do about this behavior right now. It's not necessarily a bug, since `Blockwise` is more-or-less doing the right thing. But it's performing so much worse that I thought I'd write this up for discussion. Fixing cases like this might be worth considering in any HLG redesign we do (cf #8980, #9076).

### Appendix: why am I using `DataFrame.assign?

I don't see too many people using `DataFrame.assign` like I am here. But I like it for a few reasons:
* It is immutable as opposed to `__setitem__`
* It makes it easier to use method chaining
* I understand it, and `__setitem__` is too complicated.",,https://api.github.com/repos/dask/dask/issues/9085/timeline,,,ian-r-rose,5728311,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9085/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,ian-r-rose,5728311.0,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False
604,https://api.github.com/repos/dask/dask/issues/9088,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9088/labels{/name},https://api.github.com/repos/dask/dask/issues/9088/comments,https://api.github.com/repos/dask/dask/issues/9088/events,https://github.com/dask/dask/issues/9088,1236139006,I_kwDOAbcwm85Jrfv-,9088,to_csv save mode default & options,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2022-05-14T23:04:48Z,2022-06-20T02:12:57Z,,CONTRIBUTOR,,"This issue summarizes the current behavior of the `mode` flag in `to_csv`, when it behaves unexpectedly, and what options users are likely to want.

The default `to_csv` save mode is ""wt"", but the docs say ""w"", so that's a little typo to fix.

pandas has different `to_csv` write modes like w+, w, and a.

Dask `to_csv` uses fsspec `open_files` under the hood, which has write modes like rb, wt, etc.

It's hard to decipher the exhaustive list of write modes in the [pandas docs](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html), [fsspec docs](https://filesystem-spec.readthedocs.io/en/latest/api.html), and [Dask docs](https://docs.dask.org/en/stable/generated/dask.dataframe.to_csv.html).  It doesn't seem like any of the docs are providing complete lists.

My first goal is to create the list of all the write modes available to Dask users and get them in the docs.  Dask users can presumably use the ""rb"" write mode, but I'm not actually sure what that stands for.

I did some experimentation and here's the behavior of the save modes I'm observing.  Let's start by writing some data.

```python
import dask.dataframe as dd
import pandas as pd

df = pd.DataFrame(
    {""num1"": [1, 2, 3, 4], ""num2"": [7, 8, 9, 10]},
)

df = dd.from_pandas(df, npartitions=2)

df.to_csv(""csv_danger"")
```

This will output the following files:

```
csv_danger/
  0.part
  1.part
```

We cannot append to a directory so the following code will correctly error out with `IsADirectoryError`:

```python
df = pd.DataFrame(
    {""firstname"": [""cat""], ""lastname"": [""dog""]},
)

ddf = dd.from_pandas(df, npartitions=1)

ddf.to_csv(""csv_danger"", mode=""a"")
```

We can append to a file:

```python
df = pd.DataFrame(
    {""num1"": [10, 20], ""num2"": [70, 80]},
)

df = dd.from_pandas(df, npartitions=1)

df.to_csv(""csv_danger/0.part"", mode=""a"")
```

Appending to a file probably only works on localhost and not in a cloud storage system.  I suppose that's alright.

Now let's try `w+` save mode:

```python
df = pd.DataFrame(
    {""num1"": [10, 20], ""num2"": [70, 80]},
)

df = dd.from_pandas(df, npartitions=1)

df.to_csv(""csv_danger"", mode=""w+"")
```

`w+` save mode will overwrite `0.part` and leave `1.part` unchanged.  I would have expected for all the files in the `csv_danger` to get deleted.

Let's try `w` save mode.

```python
df = pd.DataFrame(
    {""num1"": [88, 99], ""num2"": [2, 3]},
)

df = dd.from_pandas(df, npartitions=1)

df.to_csv(""csv_danger"", mode=""w"")
```

This also overwrites `0.part` and leaves `1.part` unchanged.

Let's try `wt` save mode, which is the default:

```python
df = pd.DataFrame(
    {""num1"": [66, 77], ""num2"": [5, 6]},
)

df = dd.from_pandas(df, npartitions=1)

df.to_csv(""csv_danger"", mode=""wt"")
```

This also only overwrites `0.part` and doesn't touch `1.part`.

As a user, here are the save modes I would like:

* overwrite: delete all the existing files and perform a write with new data
* append: append files to the existing directory (without touching the existing files).  Append is a bad word here because Dask uses append to indicate appending data to an existing file.  Not sure what to call this.  I don't want filenames to conflict when adding additional files to a folder.
* errorifexists: if the directory already contains data, then error out and don't perform a write

I don't personally ever want the current Dask default behavior which is overwriting some files and leaving the others untouched.  The ""partial clobber"" write mode is something I'd like to avoid.

Next steps:

* Let's figure out all the current write mode options & document their behavior
* Let's decide on if other write modes should be exposed to users.
* Let's think about how we can be compatible with other Dask writer APIs.  Users can run `ddf.to_parquet(""some/dir"", overwrite=True)` for example.  

My preference will probably be to add a separate option to all writers with consistent options.  `ddf.to_csv(""something"", save_mode=""overwrite"")` and `ddf.to_parquet(""something"", save_mode=""overwrite"")` would be nice.  The pandas writer APIs aren't consistent so they'll be of limited use here (`pandas.DataFrame.to_parquet`, `pandas.DataFrame.to_json`, and `pandas.DataFrame.to_csv` don't have a unified `save_mode` with options that are consistent throughout).",,https://api.github.com/repos/dask/dask/issues/9088/timeline,,,MrPowers,2722395,MDQ6VXNlcjI3MjIzOTU=,https://avatars.githubusercontent.com/u/2722395?v=4,,https://api.github.com/users/MrPowers,https://github.com/MrPowers,https://api.github.com/users/MrPowers/followers,https://api.github.com/users/MrPowers/following{/other_user},https://api.github.com/users/MrPowers/gists{/gist_id},https://api.github.com/users/MrPowers/starred{/owner}{/repo},https://api.github.com/users/MrPowers/subscriptions,https://api.github.com/users/MrPowers/orgs,https://api.github.com/users/MrPowers/repos,https://api.github.com/users/MrPowers/events{/privacy},https://api.github.com/users/MrPowers/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9088/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
605,https://api.github.com/repos/dask/dask/issues/9093,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9093/labels{/name},https://api.github.com/repos/dask/dask/issues/9093/comments,https://api.github.com/repos/dask/dask/issues/9093/events,https://github.com/dask/dask/issues/9093,1237393141,I_kwDOAbcwm85JwR71,9093,`GroupBy.agg()` fails when grouping by all columns,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,3,2022-05-16T16:19:49Z,2022-06-20T02:12:57Z,,MEMBER,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
While attempting to compute a groupby aggregation on all columns using `agg`, I either get the incorrect result (single-column case), or run into the following stacktrace (multi-column case):

```
*** ValueError: Metadata inference failed in `_agg_finalize`.

You have supplied a custom function and Dask is unable to 
determine the type of output that that function returns. 

To resolve this please provide a meta= keyword.
The docstring of the Dask function you ran should have more information.

Original error is below:
------------------------
ValueError('multiple levels only valid with MultiIndex')

Traceback:
---------
  File ""/datasets/charlesb/dev/rapids/dask/dask/dataframe/utils.py"", line 182, in raise_on_meta_error
    yield
  File ""/datasets/charlesb/dev/rapids/dask/dask/dataframe/core.py"", line 6337, in _emulate
    return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))
  File ""/datasets/charlesb/dev/rapids/dask/dask/dataframe/groupby.py"", line 977, in _agg_finalize
    df = _groupby_apply_funcs(
  File ""/datasets/charlesb/dev/rapids/dask/dask/dataframe/groupby.py"", line 943, in _groupby_apply_funcs
    grouped = _groupby_raise_unaligned(df, **kwargs)
  File ""/datasets/charlesb/dev/rapids/dask/dask/dataframe/groupby.py"", line 159, in _groupby_raise_unaligned
    return df.groupby(**kwargs)
  File ""/datasets/charlesb/dev/rapids/compose/etc/conda/cuda_11.5/envs/rapids/lib/python3.9/site-packages/pandas/core/frame.py"", line 7631, in groupby
    return DataFrameGroupBy(
  File ""/datasets/charlesb/dev/rapids/compose/etc/conda/cuda_11.5/envs/rapids/lib/python3.9/site-packages/pandas/core/groupby/groupby.py"", line 889, in __init__
    grouper, exclusions, obj = get_grouper(
  File ""/datasets/charlesb/dev/rapids/compose/etc/conda/cuda_11.5/envs/rapids/lib/python3.9/site-packages/pandas/core/groupby/grouper.py"", line 746, in get_grouper
    raise ValueError(""multiple levels only valid with MultiIndex"")
(Pdb) pdf.groupby([""x"", ""y""]).agg(""min"").reset_index()
      x         y
0     0 -4.096571
1     0 -3.809079
2     0 -3.673187
3     0 -3.585573
4     0 -3.118980
...  ..       ...
9995  4  2.692826
9996  4  2.735398
9997  4  2.884176
9998  4  2.899671
9999  4  3.113834

[10000 rows x 2 columns]
(Pdb) ddf.groupby([""x"", ""y""]).agg(""min"")
*** ValueError: Metadata inference failed in `_agg_finalize`.

You have supplied a custom function and Dask is unable to 
determine the type of output that that function returns. 

To resolve this please provide a meta= keyword.
The docstring of the Dask function you ran should have more information.

Original error is below:
------------------------
ValueError('multiple levels only valid with MultiIndex')

Traceback:
---------
  File ""/datasets/charlesb/dev/rapids/dask/dask/dataframe/utils.py"", line 182, in raise_on_meta_error
    yield
  File ""/datasets/charlesb/dev/rapids/dask/dask/dataframe/core.py"", line 6337, in _emulate
    return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))
  File ""/datasets/charlesb/dev/rapids/dask/dask/dataframe/groupby.py"", line 977, in _agg_finalize
    df = _groupby_apply_funcs(
  File ""/datasets/charlesb/dev/rapids/dask/dask/dataframe/groupby.py"", line 943, in _groupby_apply_funcs
    grouped = _groupby_raise_unaligned(df, **kwargs)
  File ""/datasets/charlesb/dev/rapids/dask/dask/dataframe/groupby.py"", line 159, in _groupby_raise_unaligned
    return df.groupby(**kwargs)
  File ""/datasets/charlesb/dev/rapids/compose/etc/conda/cuda_11.5/envs/rapids/lib/python3.9/site-packages/pandas/core/frame.py"", line 7631, in groupby
    return DataFrameGroupBy(
  File ""/datasets/charlesb/dev/rapids/compose/etc/conda/cuda_11.5/envs/rapids/lib/python3.9/site-packages/pandas/core/groupby/groupby.py"", line 889, in __init__
    grouper, exclusions, obj = get_grouper(
  File ""/datasets/charlesb/dev/rapids/compose/etc/conda/cuda_11.5/envs/rapids/lib/python3.9/site-packages/pandas/core/groupby/grouper.py"", line 746, in get_grouper
    raise ValueError(""multiple levels only valid with MultiIndex"")
```

**What you expected to happen**:
I would assume doing a groupby `agg` on all columns would give me an empty dataframe, with an `Index` of all groups; this works on Pandas and also works when using the equivalent aggregation method. 


**Minimal Complete Verifiable Example**:

Single-column case:

```python
import dask.dataframe as dd
import pandas as pd

pdf = pd.DataFrame(
    {
        ""x"": list(range(10)),
    }
)

ddf = dd.from_pandas(pdf, npartitions=5)

dd.assert_eq(
    pdf.groupby([""x""]).min(),
    ddf.groupby([""x""]).min()
)

dd.assert_eq(                       # DataFrame shape mismatch
    pdf.groupby([""x""]).agg(""min""),  # [left]:  (10, 0)
    ddf.groupby([""x""]).agg(""min"")   # [right]: (0, 0)
)
```

Multi-column case:

```python
import dask.dataframe as dd
import pandas as pd

pdf = pd.DataFrame(
    {
        ""x"": list(range(10)),
        ""y"": list(range(10, 20)),
    }
)

ddf = dd.from_pandas(pdf, npartitions=5)


pdf.groupby([""x"", ""y""]).agg(""min"")
ddf.groupby([""x"", ""y""]).min()
ddf.groupby([""x"", ""y""]).agg(""min"")  # errors
```


**Anything else we need to know?**:
Encountered this while working on implementing this functionality for dask-cudf; see https://github.com/rapidsai/cudf/issues/10863 for more context.

**Environment**:

- Dask version: latest `main`
- Python version: 3.9
- Operating System: ubuntu 20.04
- Install method (conda, pip, source): source",,https://api.github.com/repos/dask/dask/issues/9093/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9093/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
606,https://api.github.com/repos/dask/dask/issues/9096,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9096/labels{/name},https://api.github.com/repos/dask/dask/issues/9096/comments,https://api.github.com/repos/dask/dask/issues/9096/events,https://github.com/dask/dask/issues/9096,1238905689,I_kwDOAbcwm85J2DNZ,9096,Support pandas options when displaying metas,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,3,2022-05-17T16:42:04Z,2022-06-30T12:13:42Z,,CONTRIBUTOR,,"Displaying a dask dataframe with a lot of columns in a Jupyter notebook can be very time, memory and space (ie: scroll) consuming for the browser. By default, all columns of the meta are shown, unlike regular pandas df.

It would be useful to implement a few pandas [options](https://pandas.pydata.org/docs/user_guide/options.html) when displaying the meta
- min,max_rows
- min,max_columns
- etc

![image](https://user-images.githubusercontent.com/1694892/168864110-678e64e3-7913-4d0d-b438-d7fa01c9ee04.png)
",,https://api.github.com/repos/dask/dask/issues/9096/timeline,,,epizut,1694892,MDQ6VXNlcjE2OTQ4OTI=,https://avatars.githubusercontent.com/u/1694892?v=4,,https://api.github.com/users/epizut,https://github.com/epizut,https://api.github.com/users/epizut/followers,https://api.github.com/users/epizut/following{/other_user},https://api.github.com/users/epizut/gists{/gist_id},https://api.github.com/users/epizut/starred{/owner}{/repo},https://api.github.com/users/epizut/subscriptions,https://api.github.com/users/epizut/orgs,https://api.github.com/users/epizut/repos,https://api.github.com/users/epizut/events{/privacy},https://api.github.com/users/epizut/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9096/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
607,https://api.github.com/repos/dask/dask/issues/9105,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9105/labels{/name},https://api.github.com/repos/dask/dask/issues/9105/comments,https://api.github.com/repos/dask/dask/issues/9105/events,https://github.com/dask/dask/pull/9105,1242250580,PR_kwDOAbcwm844JRQC,9105,[WIP] Add groupby support when grouping by all columns,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,0,2022-05-19T19:51:27Z,2022-07-26T21:31:24Z,,MEMBER,,"Attempts to unblock issues with `_GroupBy.agg` when grouping on all of a dataframe's columns.

Right now this is done by just using `_GroupBy._aca_agg` in cases where we have no non-group columns, as the aggregation function doesn't really matter much past this point (we should be returning an empty DataFrame and are more concerned with the index); we might find it better to do a refactor of `_groupby_apply_funcs`/`_agg_finalize` instead so that we're still using the expected `agg` codepath, just didn't see any immediate solutions with that approach.

- [x] Closes #9093
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9105/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9105/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9105,https://github.com/dask/dask/pull/9105,https://github.com/dask/dask/pull/9105.diff,https://github.com/dask/dask/pull/9105.patch,,,,,,,,,,,,,,,,,,,
608,https://api.github.com/repos/dask/dask/issues/9109,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9109/labels{/name},https://api.github.com/repos/dask/dask/issues/9109/comments,https://api.github.com/repos/dask/dask/issues/9109/events,https://github.com/dask/dask/issues/9109,1243227574,I_kwDOAbcwm85KGiW2,9109,Test HLG unmaterialized layers remain unmaterialized after repr,"[{'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,1,2022-05-20T14:27:40Z,2022-05-22T09:58:22Z,,MEMBER,,"Based on @gjoseph92's comment https://github.com/dask/dask/pull/9061#discussion_r869358866 :)

> There should probably be a test confirming that after the repr/HTML repr of an HLG, any unmaterialized layers are still unmaterialized.
",,https://api.github.com/repos/dask/dask/issues/9109/timeline,,,pavithraes,33131404,MDQ6VXNlcjMzMTMxNDA0,https://avatars.githubusercontent.com/u/33131404?v=4,,https://api.github.com/users/pavithraes,https://github.com/pavithraes,https://api.github.com/users/pavithraes/followers,https://api.github.com/users/pavithraes/following{/other_user},https://api.github.com/users/pavithraes/gists{/gist_id},https://api.github.com/users/pavithraes/starred{/owner}{/repo},https://api.github.com/users/pavithraes/subscriptions,https://api.github.com/users/pavithraes/orgs,https://api.github.com/users/pavithraes/repos,https://api.github.com/users/pavithraes/events{/privacy},https://api.github.com/users/pavithraes/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9109/reactions,2,0,0,0,0,0,2,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
609,https://api.github.com/repos/dask/dask/issues/9117,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9117/labels{/name},https://api.github.com/repos/dask/dask/issues/9117/comments,https://api.github.com/repos/dask/dask/issues/9117/events,https://github.com/dask/dask/issues/9117,1245314536,I_kwDOAbcwm85KOf3o,9117,[Discussion] Dask-collection refactor plan,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,0,2022-05-23T15:05:40Z,2022-06-08T19:04:07Z,,MEMBER,,"The purpose of this issue is to agree on a development plan for the design I have roughly prototyped in dask#8980.  The addition of a new `CollectionOperation` class (or similar) corresponds to a significant design change in Dask. Therefore, I propose that we push on this work in a new branch of dask/dask. 

**NOTE**: The text below should be modified if/when the development plan changes.  Also, links should also be added for ongoing or completed PRs.

# Development Plan

### Step 1: Create a new `collection-refactor` branch in dask/dask

- [x] **Link**: https://github.com/dask/dask/tree/collection-refactor

Although it may be a bit painful to keep this new branch in sync with `main`, I don't think it would be very wise for me (or others) to attempt a complete refactor within a single giant pull request.  I think we are much more likely to produce a good design if we attack this work in small **reviewable** steps.

The assumption here is that we will be able to run CI for PRs submitted to this branch.

## DataFrame Development

### Step 2: Adopt *compatibility* version of `CollectionOperation` in Dask-DataFrame (Initial PR)

- [x] **Link**: https://github.com/dask/dask/pull/9119

- Add base `CollectionOperation` class
- Add `FrameOperation` and `CompatFrameOperation` classes to Dask-DataFrame
- Refactor `_Frame` (and subclasses) to reference a central `operation` attribute for `name`/`meta`/`divisions`/`dask`
    - Long-term goal will remove `dask` (or make `dask` synonymous with `operation`), but my preference is that we delay this change until after the entire Dask-DataFrame API has migrated away from the HLG/Layer design.

This PR will **not** introduce any `CollectionOperation` optimization or graph-materialization logic, but it will provide the foundation to implement these features.

### Step 3: Migrate Dask-DataFrame API to CollectionOperation design (Multiple PRs)

This step will not attempt to enable any new features or optimizations (like predicate pushdown), but will result in `CollectionOperation` coverage of the existing DataFrame `Layer` definitions:

- DataFrameIOLayer
- Blockwise
- ShuffleLayer/SimpleShuffleLayer
- BroadcastJoinLayer
- DataFrameTreeReduction

The completion of this step should also capture the existing HLG optimization pass (culling, fusion, column projection).

### Step 4: Add new `CollectionOperation` optimizations

Add predicate-pushdown optimization (and others - TBD).  Should be prioritized **after** general serialization/communication (steps 5-7).

## Array Development

### Step 2: Adopt *compatibility* version of `CollectionOperation` in Dask-Array

- Add `ArrayOperation` and `CompatArrayOperation` classes to Dask-Array
- Refactor `Array` to reference a central `operation` attribute for `name`/`meta`/`chunks`/`dask`

### Step 3: Migrate Dask-Array API to CollectionOperation design

Specifics TBD

### Step 4: Add new `CollectionOperation` optimizations

Specifics TBD.  Should be prioritized after general serialization/communication (steps 5-7).

## General Development

At this point, the DataFrame and Array APIs should be completely based on `CollectionOperation`. However, the APIs will still return a single-layer `HighLevelGraph` object when the `.dask` attribute is queried, and will still be using the HighLevelGraph API for graph communication and materialization. Therefore, most remaining work will be related

### Step 5: Change `.dask` queries to expect `HighLevelGraph` **or** `CollectionOperation` object

### Step 6: Create a new `collection-refactor` branch in dask/distributed

### Step 7: Support client-scheduler communication of a `CollectionOperation`

In order to replace the HLG/Layer infrastructure in Dask, we need to be able to send `CollectionOperation` objects to the scheduler (and use them to materialize the graph).

### Step 8: Merge changes into `main`

Once there is sufficient agreement (perhaps using a ""Dask Design Proposal"" in addition to a PR to `main`), these changes should be merged into the main branches of dask/dask dask/distributed.

### Step 9: Migrate Dask-Bag

### Step 10: Deprecate HighLevelGraph/Layer APIs",,https://api.github.com/repos/dask/dask/issues/9117/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9117/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
610,https://api.github.com/repos/dask/dask/issues/9121,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9121/labels{/name},https://api.github.com/repos/dask/dask/issues/9121/comments,https://api.github.com/repos/dask/dask/issues/9121/events,https://github.com/dask/dask/issues/9121,1246134601,I_kwDOAbcwm85KRoFJ,9121,2022.04.0: sphinx warnings `reference target not found`,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,10,2022-05-24T07:55:20Z,2022-05-26T18:26:01Z,,NONE,,"On building my packages I'm using `sphinx-build` command with `-n` switch which shows warmings about missing references. These are not critical issues.

Before sphinx starts reporting broken refs it reports problems with importing `dask` submodules. All it is despite correct `sys.path` alteration in
https://github.com/dask/dask/blob/4c0cdfdbdb013cc57cd702c8d79b52f37203f8f3/docs/source/conf.py#L29-L32
",,https://api.github.com/repos/dask/dask/issues/9121/timeline,,reopened,kloczek,31284574,MDQ6VXNlcjMxMjg0NTc0,https://avatars.githubusercontent.com/u/31284574?v=4,,https://api.github.com/users/kloczek,https://github.com/kloczek,https://api.github.com/users/kloczek/followers,https://api.github.com/users/kloczek/following{/other_user},https://api.github.com/users/kloczek/gists{/gist_id},https://api.github.com/users/kloczek/starred{/owner}{/repo},https://api.github.com/users/kloczek/subscriptions,https://api.github.com/users/kloczek/orgs,https://api.github.com/users/kloczek/repos,https://api.github.com/users/kloczek/events{/privacy},https://api.github.com/users/kloczek/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9121/reactions,0,0,0,0,0,0,0,0,0,pavithraes,33131404.0,MDQ6VXNlcjMzMTMxNDA0,https://avatars.githubusercontent.com/u/33131404?v=4,,https://api.github.com/users/pavithraes,https://github.com/pavithraes,https://api.github.com/users/pavithraes/followers,https://api.github.com/users/pavithraes/following{/other_user},https://api.github.com/users/pavithraes/gists{/gist_id},https://api.github.com/users/pavithraes/starred{/owner}{/repo},https://api.github.com/users/pavithraes/subscriptions,https://api.github.com/users/pavithraes/orgs,https://api.github.com/users/pavithraes/repos,https://api.github.com/users/pavithraes/events{/privacy},https://api.github.com/users/pavithraes/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
611,https://api.github.com/repos/dask/dask/issues/9123,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9123/labels{/name},https://api.github.com/repos/dask/dask/issues/9123/comments,https://api.github.com/repos/dask/dask/issues/9123/events,https://github.com/dask/dask/issues/9123,1246405726,I_kwDOAbcwm85KSqRe,9123,"Some datetime-properties (e.g., `tz`, `freq`, `freqstr`) not working","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-05-24T11:33:37Z,2022-06-27T02:14:40Z,,CONTRIBUTOR,,"**What happened**: trying to access some datetime properties via the `.dt` accessor crashes.

**What you expected to happen**: this shouldn't happen. Actually, in Pandas if we do `.compute().dt.<property>` it works, but in Dask if we do `.dt.<property>.compute()` it doesn't.

**Minimal Complete Verifiable Example**:

```python
import dask
ddf = dask.datasets.timeseries()
ddf.index.dt.freq
```

Crashes with this:

<details>

```
Traceback (most recent call last):
  File ""/home/jorge.lopez/anaconda3/envs/AML-dev/lib/python3.9/site-packages/dask/dataframe/dispatch.py"", line 126, in make_meta
    return make_meta_dispatch(x, index=index)
  File ""/home/jorge.lopez/anaconda3/envs/AML-dev/lib/python3.9/site-packages/dask/utils.py"", line 605, in __call__
    meth = self.dispatch(type(arg))
  File ""/home/jorge.lopez/anaconda3/envs/AML-dev/lib/python3.9/site-packages/dask/utils.py"", line 599, in dispatch
    raise TypeError(f""No dispatch for {cls}"")
TypeError: No dispatch for <class 'pandas._libs.tslibs.offsets.Hour'>

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""/home/jorge.lopez/anaconda3/envs/AML-dev/lib/python3.9/site-packages/dask/dataframe/accessor.py"", line 26, in func
    return self._property_map(attr)
  File ""/home/jorge.lopez/anaconda3/envs/AML-dev/lib/python3.9/site-packages/dask/dataframe/accessor.py"", line 95, in _property_map
    return self._series.map_partitions(
  File ""/home/jorge.lopez/anaconda3/envs/AML-dev/lib/python3.9/site-packages/dask/dataframe/core.py"", line 845, in map_partitions
    return map_partitions(func, self, *args, **kwargs)
  File ""/home/jorge.lopez/anaconda3/envs/AML-dev/lib/python3.9/site-packages/dask/dataframe/core.py"", line 6319, in map_partitions
    meta = make_meta(meta, index=meta_index, parent_meta=parent_meta)
  File ""/home/jorge.lopez/anaconda3/envs/AML-dev/lib/python3.9/site-packages/dask/dataframe/dispatch.py"", line 130, in make_meta
    return func(x, index=index)
  File ""/home/jorge.lopez/anaconda3/envs/AML-dev/lib/python3.9/site-packages/dask/dataframe/backends.py"", line 150, in make_meta_object
    return _nonempty_scalar(x)
  File ""/home/jorge.lopez/anaconda3/envs/AML-dev/lib/python3.9/site-packages/dask/dataframe/utils.py"", line 326, in _nonempty_scalar
    raise TypeError(f""Can't handle meta of type '{typename(type(x))}'"")
TypeError: Can't handle meta of type 'pandas._libs.tslibs.offsets.Hour'
```

</details>

**Anything else we need to know?**: this problem arises both in any datetime index or datetime column. Doing above `ddf.reset_index()['timestamp'].dt.freq` gives a similar trace.

Note that the problem happens before actually computing anything, it seems a problem related with meta types or meta inference.

**Environment**:

- Dask version: 2022.05.0
- Python version: 3.9.12
- Operating System: Ubuntu
- Install method (conda, pip, source): Pip
",,https://api.github.com/repos/dask/dask/issues/9123/timeline,,,jorloplaz,12827365,MDQ6VXNlcjEyODI3MzY1,https://avatars.githubusercontent.com/u/12827365?v=4,,https://api.github.com/users/jorloplaz,https://github.com/jorloplaz,https://api.github.com/users/jorloplaz/followers,https://api.github.com/users/jorloplaz/following{/other_user},https://api.github.com/users/jorloplaz/gists{/gist_id},https://api.github.com/users/jorloplaz/starred{/owner}{/repo},https://api.github.com/users/jorloplaz/subscriptions,https://api.github.com/users/jorloplaz/orgs,https://api.github.com/users/jorloplaz/repos,https://api.github.com/users/jorloplaz/events{/privacy},https://api.github.com/users/jorloplaz/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9123/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
612,https://api.github.com/repos/dask/dask/issues/9129,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9129/labels{/name},https://api.github.com/repos/dask/dask/issues/9129/comments,https://api.github.com/repos/dask/dask/issues/9129/events,https://github.com/dask/dask/issues/9129,1249019905,I_kwDOAbcwm85KcogB,9129,hyphen and dash aren't interchangeable in dask config keys,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 1012929478, 'node_id': 'MDU6TGFiZWwxMDEyOTI5NDc4', 'url': 'https://api.github.com/repos/dask/dask/labels/config', 'name': 'config', 'color': '1586c0', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,3,2022-05-26T02:43:38Z,2022-07-11T02:13:43Z,,CONTRIBUTOR,,"The docs say

> Note that the get function treats underscores and hyphens identically

(https://docs.dask.org/en/stable/configuration.html)

Strictly speaking that's true, but it doesn't mean that you can use `_` and `-` interchangeably.

If you set a key using a `-` it stays a hyphen, even if you later set key with `_`. And likewise, if you first set it using a `_` it says an underscore.

```
# first session

dask.config.set({""foo.a_b"": 123})
dask.config.get(""foo"")  # {'a_b': 123}

dask.config.set({""foo.a-b"": 123})
dask.config.get(""foo"")  # still a_b, keeps original underscore

# new session

dask.config.set({""foo.a-b"": 123})
dask.config.get(""foo"")  # now it's {'a-b': 123}

dask.config.set({""foo.a_b"": 123})
dask.config.get(""foo"")  # still a-b, keeps original hyphen
```

Maybe this is a bug in `xgboost`, but the code there does `dask.config.get(""xgboost"", default=None)` and then throws an error if you have `scheduler-address` instead of `scheduler_address`:

https://github.com/dmlc/xgboost/blob/606be9e6639dc3b24a5af1e8a131673f90aabdca/python-package/xgboost/dask.py

Even if this is a bug in `xgboost` it seems like the expectation around `-` and `_` needs to be better communicated and/or enforced.",,https://api.github.com/repos/dask/dask/issues/9129/timeline,,,ntabris,46289310,MDQ6VXNlcjQ2Mjg5MzEw,https://avatars.githubusercontent.com/u/46289310?v=4,,https://api.github.com/users/ntabris,https://github.com/ntabris,https://api.github.com/users/ntabris/followers,https://api.github.com/users/ntabris/following{/other_user},https://api.github.com/users/ntabris/gists{/gist_id},https://api.github.com/users/ntabris/starred{/owner}{/repo},https://api.github.com/users/ntabris/subscriptions,https://api.github.com/users/ntabris/orgs,https://api.github.com/users/ntabris/repos,https://api.github.com/users/ntabris/events{/privacy},https://api.github.com/users/ntabris/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9129/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
613,https://api.github.com/repos/dask/dask/issues/9137,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9137/labels{/name},https://api.github.com/repos/dask/dask/issues/9137/comments,https://api.github.com/repos/dask/dask/issues/9137/events,https://github.com/dask/dask/issues/9137,1251009259,I_kwDOAbcwm85KkOLr,9137,Can't find `cleanup` pytest fixture,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,3,2022-05-27T17:07:13Z,2022-07-04T02:14:48Z,,MEMBER,,"We started seeing

```
___________ ERROR at setup of test_blockwise_different_optimization ____________
[gw2] linux -- Python 3.9.12 /usr/share/miniconda3/envs/test-environment/bin/python
file /home/runner/work/dask/dask/dask/tests/test_distributed.py, line 472
  def test_blockwise_different_optimization(c):
file /usr/share/miniconda3/envs/test-environment/lib/python3.9/site-packages/distributed/utils_test.py, line 617
  @pytest.fixture
  def client(loop, cluster_fixture):
file /usr/share/miniconda3/envs/test-environment/lib/python3.9/site-packages/distributed/utils_test.py, line 138
  @pytest.fixture
  def loop(cleanup):
E       fixture 'cleanup' not found
>       available fixtures: c, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, cluster_fixture, cov, doctest_namespace, loop, monkeypatch, no_cover, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, shuffle_method, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, worker_id
>       use 'pytest --fixtures [testpath]' for help on them.

/usr/share/miniconda3/envs/test-environment/lib/python3.9/site-packages/distributed/utils_test.py:138
```

on `main` in all our `distributed`-related tests. Probably related to https://github.com/dask/distributed/pull/6231 cc @graingert ",,https://api.github.com/repos/dask/dask/issues/9137/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9137/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
614,https://api.github.com/repos/dask/dask/issues/9155,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9155/labels{/name},https://api.github.com/repos/dask/dask/issues/9155/comments,https://api.github.com/repos/dask/dask/issues/9155/events,https://github.com/dask/dask/issues/9155,1256979842,I_kwDOAbcwm85K6_2C,9155,Investigate using `SeedSequence` for random number generation,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2022-06-01T20:35:46Z,2022-07-04T02:14:47Z,,MEMBER,,"NumPy's new API for random number generation has `SeedSequence` for parallel cases. Logic in Dask precedes this addition. Might be worth investigating using this for random number generation in Dask.

https://github.com/data-apis/array-api/issues/431#issuecomment-1143982829",,https://api.github.com/repos/dask/dask/issues/9155/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9155/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
615,https://api.github.com/repos/dask/dask/issues/9158,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9158/labels{/name},https://api.github.com/repos/dask/dask/issues/9158/comments,https://api.github.com/repos/dask/dask/issues/9158/events,https://github.com/dask/dask/issues/9158,1258269320,I_kwDOAbcwm85K_6qI,9158,Update relevant tests to use `sort_results` argument ,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,1,2022-06-02T14:31:43Z,2022-06-18T06:08:48Z,,MEMBER,,"#9130 adds a `sort_results` argument to `assert_eq`, which allows us to assert DataFrame equality _without_ sorting them (by default, `assert_eq` sorts the input DataFrames before checking equality). It'll be nice to identify+update the tests that would benefit from it.

A first step could be to run the dataframe tests with `check_index=False` and `sort_results=False` as defaults.",,https://api.github.com/repos/dask/dask/issues/9158/timeline,,,pavithraes,33131404,MDQ6VXNlcjMzMTMxNDA0,https://avatars.githubusercontent.com/u/33131404?v=4,,https://api.github.com/users/pavithraes,https://github.com/pavithraes,https://api.github.com/users/pavithraes/followers,https://api.github.com/users/pavithraes/following{/other_user},https://api.github.com/users/pavithraes/gists{/gist_id},https://api.github.com/users/pavithraes/starred{/owner}{/repo},https://api.github.com/users/pavithraes/subscriptions,https://api.github.com/users/pavithraes/orgs,https://api.github.com/users/pavithraes/repos,https://api.github.com/users/pavithraes/events{/privacy},https://api.github.com/users/pavithraes/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9158/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
616,https://api.github.com/repos/dask/dask/issues/9159,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9159/labels{/name},https://api.github.com/repos/dask/dask/issues/9159/comments,https://api.github.com/repos/dask/dask/issues/9159/events,https://github.com/dask/dask/issues/9159,1258509309,I_kwDOAbcwm85LA1P9,9159,[Discussion] HighLevelGraph Development Roadmap,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,3,2022-06-02T17:52:29Z,2022-08-30T03:09:05Z,,MEMBER,,"`HighLevelGraph`s (HLGs) are discussed in many places throughout Dasks GitHub organization, but there is no single place with an up-to-date status and outlook.  This issue should be modified if/when the HLG roadmap changes.

**Last Update**: 2022/08/29

## Current status

`HighlevelGraph` development is currently frozen.

The ongoing development of new `highlevelgraph.Layer` classes and/or `HighlevelGraph` optimizations is strongly discouraged. Bug fixes are obviously fine, but expansion of the existing system should be avoided. Dask users and down-stream developers should avoid interactive with `Layer` classes directly.  The motivation for the current development freeze is the fact that there is a consensus that (1) the current design of HLGs is not sufficient for effective graph optimizations, and that (2) HLG Layers are too complicated to implement. 

### Reasons for current pain

- HLG serialization is convoluted and buggy
- The current API design makes it difficult to implement an effective `Layer` class. For example, it can be challenging to implement `cull` without materializing the subgraph
- The current collection/HighLevelGraph/Layer hierarchy makes it nearly impossible to perform general optimizations. Some important optimizations that are missing or significantly limited:
  - Dask does not track **partition metadata** (like Parquet statistics) to optimize simple queries like `len`, `min`, and `max`.
  - Dask does not support automatic **predicate pushdown** (i.e. Dask will not detect filter operations in the task graph, and use them to re-write IO Layers with `filters=`).
  - Dask does not support automatic **column projection** when the implicit or explicit selection and IO operation are separated by non-trivial operations like merge, shuffle and/or groupby. This limitation often requires the user to explicitly define `read_parquet(..., columns=...)` to reduce memory pressure.


## Roadmap

### 1 - Address HLG-serialization

**Relevant PRs**:

- https://github.com/dask/distributed/pull/6028
- https://github.com/dask/dask/pull/8864

Serialization for client-scheduler communication has been a consistent challenge since the introduction of `highlevelgraph.Layer`. Most of this pain can be resolved by adopting Pickle for HLG serialization.

The current plan is to move forward with distributed#6028 and dask#8864, which proposes that we **always** use pickle to send the HLG from the client to scheduler, and therefore remove the problematic `__dask_distributed_pack__` protocol from `HighLevelGraph`/`Layer`.


### 2 - Explore alternate designs for current collection/HLG/Layer API

Even if serialization challenges are addressed by 6028 (and follow-up work), the current collection/HLG/Layer hierarchy and HLG/Layer design will still pose a serious problem for developers. Therefore we probably need to do one of the following:

- **Option A** - Revise the `HighLevelGraph` and `Layer` classes to simplify the implementation of new `Layer` subclasses and to encapsulate the necessary information for high-level optimizations. This may require some refactoring of the collection APIs to move `meta`/`divisions`/`chunks` ownership into the HLG.
- **Option B** - Redesign the collection APIs to use a high-level-expression (HLE) API instead of HLGs/Layers (see *original* HLE discussion in #7933). One possible variation on an HLE-like redesign is under active exploration (see #9117), but that work is still **very** far from reflecting a clear design proposal. In fact, the final outcome of that work **may** be a recommendation to go with option A.

Regardless of the specific path we choose, it seems likely that we will want to manage graph-materialization logic and collection metadata in the same place.  Therefore, it may be difficult to avoid significant changes to the DataFrame and Array APIs.


#### Possible ""Option A"" Poposal 

**Step 1: Simplify the Layer and HLG-culling APIs** (See: https://github.com/dask/dask/issues/9216)

- Remove `Mapping` base to simplify culling and make ""accidental"" Layer materialization highly unlikely.
  - The ""new"" Layer should only be materialized by an explicit method (like `Layer.subgraph(keys)`), which should include implicit culling.
- Remove boiler-plate code related to `Mapping` behavior (`keys()`, `__len__`, etc..)
- Remove `Layer.cull` and `HighLevelGraph.cull`.
- **Outcome**: Layer design and maintenance becomes significantly simpler. HLG-based optimizations (besides culling) are not addressed in any way.

**Step 2: Revise HighLevelGraph/Layer dependency tracking**

- Extend the `Layer` API to track it's own collection dependencies.
- Add an `output_layer` attribute to `HighLevelGraph`, and make this the primary ""state"" of an HLG
  - `HighLevelGraph.layers` and `HighLevelGraph.dependencies` should simply refer to `HighLevelGraph.output_layer` 
- **Outcome**: `Layer` objects track direct *Layer* dependencies by tracking direct *collection* dependencies.

**Step 3: Move collection metadata into Layer**

- Move `name`, `meta`, and `divisions` management from the collection object to `Layer`
  - It *may* be best to store and manage this metadata within a new `CollectionMetadata` class.  This may make it easier to modify/expand the kinds of metadata we track at the `Layer` level (e.g. partition statistics).
- **Outcome**: The ""identity"" of a Dask collections becomes synonymous with the HLG's output layer

**Step 4: Add regeneration mechanism to Layer**

- Add `creation_info` attribute to `Layer`
  - This attribute should specify the `func`, `args`, and `kwargs` needed to re-create the **collection** associated with the current `Layer`.
  - `Layer` dependencies can be regenerated recursively

**Step 5: Re-visit HLG optimizations**


### 3 - Reach consensus on collection/HLG/Layer design

At some point in the medium-term future, it will be necessary to make a decision to pursue option A or option B. If there is no clear reference implementation and/or design document in place for option B, then I suggest we focus on option A (changing the existing HLG/Layer design).  The motivation for making A the default is an acknowledgment that attacking option B in an incremental way is likely to be more difficult without a detailed plan in place. 

### 4 - Develop *new* roadmap

At this point, the existing roadmap should be obsolete, and ready for replacement.",,https://api.github.com/repos/dask/dask/issues/9159/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9159/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
617,https://api.github.com/repos/dask/dask/issues/9164,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9164/labels{/name},https://api.github.com/repos/dask/dask/issues/9164/comments,https://api.github.com/repos/dask/dask/issues/9164/events,https://github.com/dask/dask/issues/9164,1261955716,I_kwDOAbcwm85LN-qE,9164,Persistent caching,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,3,2022-06-06T14:51:23Z,2022-07-11T02:13:41Z,,CONTRIBUTOR,,"I'm interesting in writing distributed code that runs using Dask, but that checkpoints at certain points, so that it can resume from these points in case of a failure. This is distinct from the [opportunistic caching](https://docs.dask.org/en/stable/caching.html) already built into dask, which doesn't persist between restarts of the scheduler.

[Previously I talked about this on Twitter](https://twitter.com/dask_dev/status/1442866143073427465) and there was mention from the dev team that this might be out of scope as Dask is trying to stay low-level, but if we pushed the caching layer down to dask:

* Users don't have to bring in heavyweight frameworks like Prefect when they don't need them
* We can use specific insight into the dask graph to implement this caching in an efficient and clean way
* We can leverage the existing filesystem APIs provided by task (e.g. writing to S3 or local disk)
* Users don't have to define functions or methods (as in Prefect) to get access to caching, which makes the code cleaner and much nicer to use in notebooks

To provide a concrete example, let's say I want to do some very heavy processing on a `dask.DataFrame` `ddf`. In the below example, if the second `apply()` fails here, at least I have the intermediate result from the first `apply()`, but dask doesn't know that it can just load this parquet file instead of re-running the first `apply()`:

```python
ddf.apply(...).to_parquet(""foo"").apply(...)
```

So I could use some conditional logic, but this would get very tedious:

```python
if os.path.exists(""foo""):
    ddf = dd.read_parquet(""foo"")
else:
    ddf = ddf.apply(...)

ddf.apply(...)
```

I could refactor this logic into a decorator (as Prefect has broadly done), and this is much better, but as a user I would rather that this is a stable, public API offered by Dask rather than something I have to write:
```python
@dask.cache(...)
def task_a(ddf):
    return ddf.apply(...)

task_b(task_a(ddf))
```

Unfortunately, the above code is pretty ugly (needing to define a new function, and breaking the method chain), so at this point I'd like to suggest a nice checkpointing API that can be added to all futures (doesn't have to just be DataFrames or even collections):
```python
ddf.apply(...).checkpoint(""foo"", ...).apply(...).checkpoint(""bar"")
```

Since Dask is lazy, this works well, since it doesn't actually compute anything at the time of being called, but rather it would insert the conditional caching logic into the DAG. I'm not sure if it would manipulate the DAG at call time or at compute time (I would need a bit of help here) but either way it should produce a DAG like this: (simplified to treat Apply as a single node):

```mermaid
graph TD;
    A{Does bar exist?}-- Yes -->B[Read Parquet] --> End;
    C{Does foo exist?}-- Yes -->D[Read Parquet] --> I;
    A-- No --> C;
    C-- No -->G[""Apply (1)""] --> H[Save Parquet];
    H --> I[""Apply (2)""] --> J[Save Parquet] --> End;
```

So my questions are:
* Is there any interest in having persistent caching in Dask in general?
* If yes, is there interest in my proposed API?

I think I have some time to dedicate to this, if there is interest in such a feature. But of course I wanted to run it by the maintainers first, since it may still be considered out of scope.",,https://api.github.com/repos/dask/dask/issues/9164/timeline,,,multimeric,5019367,MDQ6VXNlcjUwMTkzNjc=,https://avatars.githubusercontent.com/u/5019367?v=4,,https://api.github.com/users/multimeric,https://github.com/multimeric,https://api.github.com/users/multimeric/followers,https://api.github.com/users/multimeric/following{/other_user},https://api.github.com/users/multimeric/gists{/gist_id},https://api.github.com/users/multimeric/starred{/owner}{/repo},https://api.github.com/users/multimeric/subscriptions,https://api.github.com/users/multimeric/orgs,https://api.github.com/users/multimeric/repos,https://api.github.com/users/multimeric/events{/privacy},https://api.github.com/users/multimeric/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9164/reactions,4,4,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
618,https://api.github.com/repos/dask/dask/issues/9187,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9187/labels{/name},https://api.github.com/repos/dask/dask/issues/9187/comments,https://api.github.com/repos/dask/dask/issues/9187/events,https://github.com/dask/dask/issues/9187,1272218156,I_kwDOAbcwm85L1IIs,9187,Standardize reporting known inconsistencies in `dask.dataframe` API,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,4,2022-06-15T13:12:58Z,2022-06-27T11:02:23Z,,CONTRIBUTOR,,"**Current situation**
Portions of the `dask.dataframe` API are copied over directly from `pandas` using the `@derived_from` decorator. This pulls in the pandas docstring for the corresponding object and adds the ""This docstring was copied from pandas. Some inconsistencies with the Dask version may exist.""

**Problem** 
New users often find the vagueness in this docstring confusing and intimidating -- Are there really inconsistencies? How many of them? What are they?

**Proposed Situation**
- Adopt a standardised method for reporting known inconsistencies. I've made a first attempt in #9177  - this format is very much open to discussion.
- Launch an organised effort to comb through the `dask.dataframe` API systematically to report known inconsistencies wherever possible. I'm not really sure what the best way to do this would be - perhaps a meta-issue or item in the overall Dask project board (if that exists?)

This process could be replicated for `dask.array`

",,https://api.github.com/repos/dask/dask/issues/9187/timeline,,,avriiil,68642378,MDQ6VXNlcjY4NjQyMzc4,https://avatars.githubusercontent.com/u/68642378?v=4,,https://api.github.com/users/avriiil,https://github.com/avriiil,https://api.github.com/users/avriiil/followers,https://api.github.com/users/avriiil/following{/other_user},https://api.github.com/users/avriiil/gists{/gist_id},https://api.github.com/users/avriiil/starred{/owner}{/repo},https://api.github.com/users/avriiil/subscriptions,https://api.github.com/users/avriiil/orgs,https://api.github.com/users/avriiil/repos,https://api.github.com/users/avriiil/events{/privacy},https://api.github.com/users/avriiil/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9187/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
619,https://api.github.com/repos/dask/dask/issues/9197,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9197/labels{/name},https://api.github.com/repos/dask/dask/issues/9197/comments,https://api.github.com/repos/dask/dask/issues/9197/events,https://github.com/dask/dask/pull/9197,1275575058,PR_kwDOAbcwm8454eWH,9197,[WIP] Revise aggregate_files behavior in read_parquet,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,1,2022-06-17T23:17:16Z,2022-11-04T21:35:32Z,,MEMBER,,"Closes #9043
Closes #9051 
Closes #8829

This PR (mostly) preserves the existing `chunksize`/`aggregate_files` options in `read_parquet` by adding two new arguments:

- `sort_input_paths` (default `True`): Whether or not Dask should re-order the files in the dataset to use ""natural"" ordering. Note that this new feature *could* be added in a separate PR, but I wanted to make sure that the new design allows for such an argument to exist.
- `file_groups` (default `None`): A dictionary mapping paths to ""file-group"" indices, or a list of directory-partitioned-column names that must match for two or more files to belong to the same ""file group.""  This PR introduces the **file group** concept to `dd.read_parquet`. The meaning is simple: Two files must belong to the same file group for Dask to consider aggregating them into the same output DataFrame partition.  Matching file-group membership is necessary, but **not** sufficient, for file aggregation. That is, there must be some other option (like `aggregate_files=int|True` or `chunksize`) to specify **how** files should be aggregated within each group. The engines are always allowed to reorder paths by file group to improve file-aggregation behavior (even if `sort_input_paths=False`).  Note that I orginally added this option in order to drop support for `str` arguments to `aggregate_files` in favor of `int` support (explained below). However, it is worth noting that this option is also much more flexible/powerful than the original `aggregate_files=<str>` behavior.

In addition to these new arguments, I also modified the existing `aggregate_files` argument to only accept `bool` or `int` types. That is, the `aggregate_files` option is now the ""file equivalent"" of `split_row_groups`. Specifying `aggregate_files=100` means that 100 files from the same file group may be aggregated into the same output partition.

The most important result of this PR is likely the support for `aggregate_files=<int>` (in combination with `file_groups=`). For example. In `main`, one would need to use `chunksize` (or `split_row_groups`) with `aggregate_files=""year""` to read in a single large partition for each distinct year in a partitioned NYC-taxi dataset:

```python
import dask.dataframe as dd

ddf = dd.read_parquet(
    ""s3://ursa-labs-taxi-data/"",
    engine=""pyarrow"",
    storage_options={""anon"": True},
    dataset={
        ""partitioning"": [""year"", ""month""],
        ""partition_base_dir"": ""ursa-labs-taxi-data"",
    },
    chunksize=""6GB"",
    aggregate_files=""year"",
)
# (takes several seconds on my workstation - but scales poorly with the total number of row groups)
```

However, with this branch, file aggregation *can* be much faster/simpler:

```python
ddf = dd.read_parquet(
    ""s3://ursa-labs-taxi-data/"",
    engine=""pyarrow"",
    storage_options={""anon"": True},
    dataset={
        ""partitioning"": [""year"", ""month""],
        ""partition_base_dir"": ""ursa-labs-taxi-data"",
    },
    file_groups=[""year""],
    aggregate_files=True,
)
# (takes less than 1s on my workstation)
```

",,https://api.github.com/repos/dask/dask/issues/9197/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9197/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9197,https://github.com/dask/dask/pull/9197,https://github.com/dask/dask/pull/9197.diff,https://github.com/dask/dask/pull/9197.patch,,,,,,,,,,,,,,,,,,,
620,https://api.github.com/repos/dask/dask/issues/9198,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9198/labels{/name},https://api.github.com/repos/dask/dask/issues/9198/comments,https://api.github.com/repos/dask/dask/issues/9198/events,https://github.com/dask/dask/pull/9198,1275683202,PR_kwDOAbcwm84540SB,9198,Update dataframe tests to benefit from `sort_results=False`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,3,2022-06-18T06:42:31Z,2022-07-02T04:45:46Z,,FIRST_TIME_CONTRIBUTOR,,"- [ ] Closes #9158 
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`


## Files to identify
Files not using `assert_eq`
- test_format.py
- test_hyperloglog.py
- test_numeric.py
- test_optimize_dataframe.py
- test_pyarrow_compat.py

Checked if all tests are passed.
Only change to default `sort_results=False`
- [x]  test_accessors.py
- [x]  test_arithmetics_reduction.py
- [x]  test_boolean.py
- [x]  test_categorical.py
- test_dataframe.py: 30 tests failed
- [x]  test_extensions.py
- test_groupby.py: 319 tests failed
- [x]  test_hashing.py
- test_indexing.py: except `test_loc_with_non_boolean_series` and `test_loc2d_with_known_divisions`
- test_merge_column_and_index.py: 133 tests failed
- test_multi.py: 8 tests failed
- [x]  test_reshape.py
- test_rolling.py: except `test_groupby_rolling`
- test_shuffle.py: 18 tests failed
- [x]  test_ufunc.py
- test_utils_dataframe.py: except `test_assert_eq_sorts`
",,https://api.github.com/repos/dask/dask/issues/9198/timeline,,,haochunchang,25240528,MDQ6VXNlcjI1MjQwNTI4,https://avatars.githubusercontent.com/u/25240528?v=4,,https://api.github.com/users/haochunchang,https://github.com/haochunchang,https://api.github.com/users/haochunchang/followers,https://api.github.com/users/haochunchang/following{/other_user},https://api.github.com/users/haochunchang/gists{/gist_id},https://api.github.com/users/haochunchang/starred{/owner}{/repo},https://api.github.com/users/haochunchang/subscriptions,https://api.github.com/users/haochunchang/orgs,https://api.github.com/users/haochunchang/repos,https://api.github.com/users/haochunchang/events{/privacy},https://api.github.com/users/haochunchang/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9198/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9198,https://github.com/dask/dask/pull/9198,https://github.com/dask/dask/pull/9198.diff,https://github.com/dask/dask/pull/9198.patch,,,,,,,,,,,,,,,,,,,
621,https://api.github.com/repos/dask/dask/issues/9207,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9207/labels{/name},https://api.github.com/repos/dask/dask/issues/9207/comments,https://api.github.com/repos/dask/dask/issues/9207/events,https://github.com/dask/dask/issues/9207,1280688152,I_kwDOAbcwm85MVcAY,9207,repartitioning dataframe with unknown divisions results in poorly-distributed chunk sizes,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,1,2022-06-22T18:21:14Z,2022-06-22T19:36:48Z,,CONTRIBUTOR,,"When a dask.dataframe has unknown division sizes (because it's been read from file or from delayed), repartition's heuristics for allocating the partitions could probably be a bit smarter. If not, a bit of extra docs might be helpful

MRE:
```python
import dask.dataframe, pandas as pd, numpy as np, dask
from dask.delayed import delayed

ddf = dask.dataframe.from_delayed(
    [delayed(pd.DataFrame({'A': np.arange(100)})) for _ in range(4)]
    + [delayed(pd.DataFrame({'A': np.arange(50)}))]
).persist()
```
This dataframe has 5 chunks of 100 rows each, and a final chunk of 50 rows. This is a pretty common partition structure for a file (e.g. lots of big chunks and a small final one):
```python
In [2]: ddf.map_partitions(len, meta={'A': int}).compute()
Out[2]:
0    100
1    100
2    100
3    100
4     50
dtype: int64
```
Given this data, it might make sense to repartition to 9 partitions, splitting each of the first four in half, and leaving the last one alone. Since the partitions are unknown, it makes sense if dask wouldn't automatically do this exactly how you'd like based on the data, but I'd expect some sort of even allocation of extra partitions to each of the current partitions. However, if we repartition using npartitions _which is not an exact multiple of the current number of partitions_, any extra partitions are allocated to the final partition:
```python
In [3]: ddf.repartition(9).map_partitions(len, meta={'A': int}).compute()
Out[3]:
0    100
1    100
2    100
3    100
4     10
5     10
6     10
7     10
8     10
dtype: int64
```
This results in a sub-optimal case where you still have the original four large partitions, with the last partition being split a number of ways. This is true for larger numbers of partitions as well - it seems the algorithm currently allocates `npartitions % current_npartitions` all to the final chunk.

full disclosure I did run this on `'2022.04.0'`. I didn't see a recent issue for it but it's possible this isn't a current issue?

I don't have bandwidth to tackle this right now but it seems to me like this could be a good first issue.
",,https://api.github.com/repos/dask/dask/issues/9207/timeline,,,delgadom,3698640,MDQ6VXNlcjM2OTg2NDA=,https://avatars.githubusercontent.com/u/3698640?v=4,,https://api.github.com/users/delgadom,https://github.com/delgadom,https://api.github.com/users/delgadom/followers,https://api.github.com/users/delgadom/following{/other_user},https://api.github.com/users/delgadom/gists{/gist_id},https://api.github.com/users/delgadom/starred{/owner}{/repo},https://api.github.com/users/delgadom/subscriptions,https://api.github.com/users/delgadom/orgs,https://api.github.com/users/delgadom/repos,https://api.github.com/users/delgadom/events{/privacy},https://api.github.com/users/delgadom/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9207/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
622,https://api.github.com/repos/dask/dask/issues/9211,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9211/labels{/name},https://api.github.com/repos/dask/dask/issues/9211/comments,https://api.github.com/repos/dask/dask/issues/9211/events,https://github.com/dask/dask/issues/9211,1282592360,I_kwDOAbcwm85Mcs5o,9211,"to_parquet on datetime.date objects works on 2022.5.2, fails on 2022.6.0","[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3931420500, 'node_id': 'LA_kwDOAbcwm87qVLdU', 'url': 'https://api.github.com/repos/dask/dask/labels/regression', 'name': 'regression', 'color': 'B60205', 'default': False, 'description': ''}]",open,False,,[],,8,2022-06-23T15:29:59Z,2022-08-03T14:53:37Z,,NONE,,"```
import dask.dataframe as dd
from datetime import date
ddf = dd.from_pandas(pd.DataFrame({'a':[date.today(), date(2022,6,13)]}), npartitions=1)
ddf.to_parquet(""/tmp/p"")
```

This works OK on 2022.5.2 but regression in 2022.6.0 stops it working. pyarrow is 7.0.0 in both cases.
Really don't want to have to explicitly specify schemas everywhere, that seems unnecessary.
In 2022.5.2, it seems to persist through to_parquet / read_parquet as a proper date object, not convert to string

```
ValueError: Failed to convert partition to expected pyarrow schema:
    `ArrowTypeError(""Expected bytes, got a 'datetime.date' object"", 'Conversion failed for column a with type object')`

Expected partition schema:
    a: string
    __null_dask_index__: int64

Received partition schema:
    a: date32[day]
    __null_dask_index__: int64
```",,https://api.github.com/repos/dask/dask/issues/9211/timeline,,,martinedgefocus,96071256,U_kgDOBbnuWA,https://avatars.githubusercontent.com/u/96071256?v=4,,https://api.github.com/users/martinedgefocus,https://github.com/martinedgefocus,https://api.github.com/users/martinedgefocus/followers,https://api.github.com/users/martinedgefocus/following{/other_user},https://api.github.com/users/martinedgefocus/gists{/gist_id},https://api.github.com/users/martinedgefocus/starred{/owner}{/repo},https://api.github.com/users/martinedgefocus/subscriptions,https://api.github.com/users/martinedgefocus/orgs,https://api.github.com/users/martinedgefocus/repos,https://api.github.com/users/martinedgefocus/events{/privacy},https://api.github.com/users/martinedgefocus/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9211/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
623,https://api.github.com/repos/dask/dask/issues/9216,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9216/labels{/name},https://api.github.com/repos/dask/dask/issues/9216/comments,https://api.github.com/repos/dask/dask/issues/9216/events,https://github.com/dask/dask/issues/9216,1284140078,I_kwDOAbcwm85Mimwu,9216,[Rough Idea] Remove HighLevelGraph/Layer.cull by simplifying Layer,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-06-24T20:05:38Z,2022-07-25T02:13:36Z,,MEMBER,,"After beginning to push on #9117 (and #9159) for a bit, I decided it might be worthwhile to investigate ways to improve the existing `HighLevelGraph`/`Layer` design. In addition to the serialization pains that will hopefully be resolved by [dask/distributed#6028](https://github.com/dask/distributed/pull/6028), my impression is that a key problem with HLGs is that it is unnecessarily difficult to implement a new `Layer`. Others my disagree with my perspective on this, but I suspect that this has a lot to do with (1) `Layer` inheriting from `Mapping`, and (2) the requirement to implement a `cull` method that avoids materialization.

I propose that we consider moving away from `Layer(Mapping)`, and make the `Layer` design a bit simpler. For example, it may make sense to boil the base `Layer` class down to three primary methods: `get_output_keys`, `subgraph`, and `subgraph_dependencies` (where subclasses would only be required to implement `get_output_keys` and `subgraph`):

```python
class Layer:
    """"""Base Layer Class""""""

    def get_output_keys(self) -> Set:
        """"""Return all possible output keys""""""
        raise NotImplementedError

    # NEW
    def subgraph(self, keys: Set) -> Mapping:
        """"""Return the local subgraph required to produce ``keys``""""""
        raise NotImplementedError

    # NEW
    def subgraph_dependencies(
        self,
        output_keys: Set,
        subgraph: Mapping,
        layer_dependencies: Mapping[str, Layer],
    ) -> Mapping[str, Set]:
        """"""Return external key dependencies for this layer""""""
        from dask.core import keys_in_tasks
        
        # Default implementation ignores `output_keys`, but
        # custom Layers may know the dependency keys from
        # the output keys alone
        return {
            dep: keys_in_tasks(
                set(dep_layer.get_output_keys()),
                [subgraph],
            ) for dep, dep_layer in layer_dependencies.items()
        }
```

Using this design, HLG-to-`dict` materialization can easily capture culling automatically. I started experimenting with this in [rjzamora:avoid-cull](https://github.com/rjzamora/dask/tree/avoid-cull) (although that branch still uses `Layer(Mapping)` for now), and I found that [`ensure_dict` can be revised](https://github.com/rjzamora/dask/blob/11534cb588b3d4bfacb1e72ff4ae0d0a88c83e21/dask/utils.py#L1185) so that culling is applied without any `HighLevelGraph.cull` optimization.  Also, if I understand correctly, overriding `subgraph_dependencies` for `Blockwise` would effectively resolve #8570 (the linear scaling of the current culling approach).

To summarize, I propose that we consider moving away from `Layer(Mapping)` and `HighLevelGraph/Layer.cull`, and adopt a simpler `Layer` API. The boiled down API I have in mind would require (1) a method to materialize the subgraph for a specific set of output keys, and (2) a method to return all possible output keys for that layer. I expect the primary benefits to be simplified Layer development, and improved culling performance. However, simplifying the Layer API may also make it more tractable to introduce the necessary collection information and/or metadata we ultimately need for general HLG optimizations.

**NOTE**: Please feel free to poke holes in this idea as aggressively as you want :)",,https://api.github.com/repos/dask/dask/issues/9216/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9216/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
624,https://api.github.com/repos/dask/dask/issues/9220,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9220/labels{/name},https://api.github.com/repos/dask/dask/issues/9220/comments,https://api.github.com/repos/dask/dask/issues/9220/events,https://github.com/dask/dask/issues/9220,1285849774,I_kwDOAbcwm85MpIKu,9220,pandas type stubs,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 3798450421, 'node_id': 'LA_kwDOAbcwm87iZ8D1', 'url': 'https://api.github.com/repos/dask/dask/labels/hygiene', 'name': 'hygiene', 'color': 'b5ccfa', 'default': False, 'description': 'Improve code quality and reduce maintenance overhead'}, {'id': 3798450422, 'node_id': 'LA_kwDOAbcwm87iZ8D2', 'url': 'https://api.github.com/repos/dask/dask/labels/p3', 'name': 'p3', 'color': 'ffff33', 'default': False, 'description': 'Affects a small number of users or is largely cosmetic'}]",open,False,,[],,1,2022-06-27T13:57:27Z,2022-12-06T18:00:13Z,,MEMBER,,"We should add pandas-stubs to mypy type checks:
```diff
--- a/.pre-commit-config.yaml
+++ b/.pre-commit-config.yaml
@@ -46,6 +46,7 @@ repos:
         args: []
         additional_dependencies:
           # Type stubs
+          - pandas-stubs
           - types-docutils
```
The change at the moment causes mypy to produce a wealth of errors (see below).

Matching work on distributed (https://github.com/dask/distributed/pull/6635) showed that using pandas-stubs is not quite a smooth ride yet. However, their benefit to dask/dask would be substantial; we should collaborate with/contribute to upstream to fix any issues.

```
dask/dataframe/_pyarrow_compat.py:142: error: Module has no attribute ""arrays""; maybe ""array""?
dask/dataframe/_pyarrow_compat.py:143: error: Module has no attribute ""arrays""; maybe ""array""?
dask/dataframe/_compat.py:19: error: Unsupported operand types for <= (""Tuple[int, int, int]"" and ""None"")
dask/dataframe/_compat.py:19: note: Left operand is of type ""Optional[Tuple[int, ...]]""
dask/dataframe/tests/test_pyarrow_compat.py:16: error: Module has no attribute ""arrays""; maybe ""array""?
dask/array/core.py:5689: error: Incompatible return value type (got ""signedinteger[_64Bit]"", expected ""int"")
dask/dataframe/core.py:4067: error: Incompatible types in assignment (expression has type ""Type[Index]"", base class ""Series"" defined the type as ""Type[TimestampSeries]"")
dask/dataframe/shuffle.py:97: error: ""List[int]"" has no attribute ""tolist""
dask/dataframe/shuffle.py:98: error: ""List[int]"" has no attribute ""tolist""
dask/dataframe/shuffle.py:326: error: No overload variant of ""isna"" matches argument type ""Sequence[Any]""
dask/dataframe/shuffle.py:326: note: Possible overload variants:
dask/dataframe/shuffle.py:326: note:     def isna(obj: DataFrame) -> DataFrame
dask/dataframe/shuffle.py:326: note:     def isna(obj: Series[Any]) -> Series[bool]
dask/dataframe/shuffle.py:326: note:     def isna(obj: Union[Index, List[Any], Union[ExtensionArray, ndarray[Any, Any]]]) -> ndarray[Any, Any]
dask/dataframe/shuffle.py:326: note:     def isna(obj: Union[str, bytes, date, datetime, timedelta, bool, int, float, complex, Timestamp, Timedelta]) -> bool
dask/dataframe/groupby.py:1390: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1397: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1404: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1410: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1420: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1430: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1436: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1464: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1474: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1482: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1492: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1518: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1576: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1582: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:1588: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:2078: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:2082: error: Module has no attribute ""GroupBy""
dask/dataframe/groupby.py:2119: error: Module has no attribute ""DataFrameGroupBy""
dask/dataframe/groupby.py:2126: error: Module has no attribute ""DataFrameGroupBy""
dask/dataframe/groupby.py:2156: error: Module has no attribute ""SeriesGroupBy""
dask/dataframe/groupby.py:2194: error: Module has no attribute ""SeriesGroupBy""
dask/dataframe/groupby.py:2205: error: Module has no attribute ""SeriesGroupBy""
dask/dataframe/groupby.py:2209: error: Module has no attribute ""SeriesGroupBy""
dask/dataframe/groupby.py:2219: error: Module has no attribute ""SeriesGroupBy""
dask/dataframe/groupby.py:2231: error: Module has no attribute ""SeriesGroupBy""
dask/dataframe/groupby.py:2245: error: Module has no attribute ""SeriesGroupBy""
dask/dataframe/tests/test_categorical.py:26: error: No overload variant of ""Series"" matches argument types ""range"", ""Categorical""
dask/dataframe/tests/test_categorical.py:26: note: Possible overload variants:
dask/dataframe/tests/test_categorical.py:26: note:     def [S1 in (str, bytes, date, datetime, timedelta, bool, int, float, complex, Timestamp, Timedelta, datetime64)] __new__(cls, data: DatetimeIndex, index: Union[str, int, Series[Any], List[Any], Index] = ..., dtype: Any = ..., name: Optional[Hashable] = ..., copy: bool = ..., fastpath: bool = ...) -> TimestampSeries
dask/dataframe/tests/test_categorical.py:26: note:     def [S1 in (str, bytes, date, datetime, timedelta, bool, int, float, complex, Timestamp, Timedelta, datetime64)] __new__(cls, data: object, dtype: Type[S1], index: Union[str, int, Series[Any], List[Any], Index] = ..., name: Optional[Hashable] = ..., copy: bool = ..., fastpath: bool = ...) -> Series[S1]
dask/dataframe/tests/test_categorical.py:26: note:     def [S1 in (str, bytes, date, datetime, timedelta, bool, int, float, complex, Timestamp, Timedelta, datetime64)] __new__(cls, data: object = ..., index: Union[str, int, Series[Any], List[Any], Index] = ..., dtype: Any = ..., name: Optional[Hashable] = ..., copy: bool = ..., fastpath: bool = ...) -> Series[Any]
dask/dataframe/tests/test_hyperloglog.py:61: error: No overload variant of ""Series"" matches argument types ""ndarray[Any, dtype[floating[_64Bit]]]"", ""ndarray[Any, dtype[floating[_64Bit]]]""
dask/dataframe/tests/test_hyperloglog.py:61: note: Possible overload variants:
dask/dataframe/tests/test_hyperloglog.py:61: note:     def [S1 in (str, bytes, date, datetime, timedelta, bool, int, float, complex, Timestamp, Timedelta, datetime64)] __new__(cls, data: DatetimeIndex, index: Union[str, int, Series[Any], List[Any], Index] = ..., dtype: Any = ..., name: Optional[Hashable] = ..., copy: bool = ..., fastpath: bool = ...) -> TimestampSeries
dask/dataframe/tests/test_hyperloglog.py:61: note:     def [S1 in (str, bytes, date, datetime, timedelta, bool, int, float, complex, Timestamp, Timedelta, datetime64)] __new__(cls, data: object, dtype: Type[S1], index: Union[str, int, Series[Any], List[Any], Index] = ..., name: Optional[Hashable] = ..., copy: bool = ..., fastpath: bool = ...) -> Series[S1]
dask/dataframe/tests/test_hyperloglog.py:61: note:     def [S1 in (str, bytes, date, datetime, timedelta, bool, int, float, complex, Timestamp, Timedelta, datetime64)] __new__(cls, data: object = ..., index: Union[str, int, Series[Any], List[Any], Index] = ..., dtype: Any = ..., name: Optional[Hashable] = ..., copy: bool = ..., fastpath: bool = ...) -> Series[Any]
dask/dataframe/tests/test_hyperloglog.py:62: error: No overload variant of ""Series"" matches argument types ""ndarray[Any, dtype[floating[_64Bit]]]"", ""ndarray[Any, dtype[floating[_64Bit]]]""
dask/dataframe/tests/test_hyperloglog.py:62: note: Possible overload variants:
dask/dataframe/tests/test_hyperloglog.py:62: note:     def [S1 in (str, bytes, date, datetime, timedelta, bool, int, float, complex, Timestamp, Timedelta, datetime64)] __new__(cls, data: DatetimeIndex, index: Union[str, int, Series[Any], List[Any], Index] = ..., dtype: Any = ..., name: Optional[Hashable] = ..., copy: bool = ..., fastpath: bool = ...) -> TimestampSeries
dask/dataframe/tests/test_hyperloglog.py:62: note:     def [S1 in (str, bytes, date, datetime, timedelta, bool, int, float, complex, Timestamp, Timedelta, datetime64)] __new__(cls, data: object, dtype: Type[S1], index: Union[str, int, Series[Any], List[Any], Index] = ..., name: Optional[Hashable] = ..., copy: bool = ..., fastpath: bool = ...) -> Series[S1]
dask/dataframe/tests/test_hyperloglog.py:62: note:     def [S1 in (str, bytes, date, datetime, timedelta, bool, int, float, complex, Timestamp, Timedelta, datetime64)] __new__(cls, data: object = ..., index: Union[str, int, Series[Any], List[Any], Index] = ..., dtype: Any = ..., name: Optional[Hashable] = ..., copy: bool = ..., fastpath: bool = ...) -> Series[Any]
Found 38 errors in 9 files (checked 242 source files)
```",,https://api.github.com/repos/dask/dask/issues/9220/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9220/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
625,https://api.github.com/repos/dask/dask/issues/9224,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9224/labels{/name},https://api.github.com/repos/dask/dask/issues/9224/comments,https://api.github.com/repos/dask/dask/issues/9224/events,https://github.com/dask/dask/issues/9224,1287840630,I_kwDOAbcwm85MwuN2,9224,Incorrect partitioning in test_set_index_timezone,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2022-06-28T20:23:59Z,2022-08-01T02:14:59Z,,MEMBER,,"[dask/dataframe/tests/test_shuffle.py::test_set_index_timezone](https://github.com/dask/dask/blob/bc3137d954d71068de4ef00c7c51470bfc69ef43/dask/dataframe/tests/test_shuffle.py#L726) uses `from_pandas(..., 2)`, but (as discussed in #9221) this is actually generating a single-partition DataFrame.

As far as I can tell, `test_set_index_timezone` fails when `d` is a multi-partition DataFrame (For example, if `d = dd.from_pandas(df, chunksize=1)`).

**Action Items**:

- [ ] Determine if multi-partition failure is a bug in `set_index`
- [ ] Fix the test to use a multi-partition DataFrame",,https://api.github.com/repos/dask/dask/issues/9224/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9224/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
626,https://api.github.com/repos/dask/dask/issues/9225,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9225/labels{/name},https://api.github.com/repos/dask/dask/issues/9225/comments,https://api.github.com/repos/dask/dask/issues/9225/events,https://github.com/dask/dask/issues/9225,1287849201,I_kwDOAbcwm85MwwTx,9225,Incorrect partitioning in merge_asof tests,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2022-06-28T20:33:08Z,2022-08-01T02:14:58Z,,MEMBER,,"[dask/dataframe/tests/test_multi.py::test_merge_asof_on_by ](https://github.com/dask/dask/blob/bc3137d954d71068de4ef00c7c51470bfc69ef43/dask/dataframe/tests/test_multi.py#L435) 
 (as well as `test_merge_asof_on_by_tolerance` and `test_merge_asof_on_by_tolerance_no_exact_matches`) uses `from_pandas(..., npartitions=3)`, but (as discussed in #9221) this is actually generating a DataFrame with **two** partitions.

As far as I can tell, `test_merge_asof_on_by` fails when the partitioning of the `b` DataFrame isn't ""just right"" (e.g. `b = dd.from_pandas(B, chunksize=1)`) 

**Action Items**:

- [ ] Determine if partitioning sensitivity is due to a bug in `merge_asof`
- [ ] Fix the test to work with general partitioning, or clearly document ""why"" partitioning is sensitive",,https://api.github.com/repos/dask/dask/issues/9225/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9225/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
627,https://api.github.com/repos/dask/dask/issues/9227,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9227/labels{/name},https://api.github.com/repos/dask/dask/issues/9227/comments,https://api.github.com/repos/dask/dask/issues/9227/events,https://github.com/dask/dask/issues/9227,1287859693,I_kwDOAbcwm85Mwy3t,9227,Incorrect partitioning in test_quantile_missing,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2022-06-28T20:45:04Z,2022-08-01T02:14:56Z,,MEMBER,,"[dask/dataframe/tests/test_dataframe.py::test_quantile_missing](https://github.com/dask/dask/blob/bc3137d954d71068de4ef00c7c51470bfc69ef43/dask/dataframe/tests/test_dataframe.py#L1388) uses `from_pandas(..., npartitions=2)`, but (as discussed in #9221) this is actually produces a single-partition DataFrame.

As far as I can tell, `test_quantile_missing['dask']` fails when there really multiple partitions (e.g. `from_pandas(..., chunksize=1)`).

**Action Items**:

- [ ] Determine if multi-partition failure is a bug in `quantile`
- [ ] Fix the test to cover the multi-partition case",,https://api.github.com/repos/dask/dask/issues/9227/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9227/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
628,https://api.github.com/repos/dask/dask/issues/9236,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9236/labels{/name},https://api.github.com/repos/dask/dask/issues/9236/comments,https://api.github.com/repos/dask/dask/issues/9236/events,https://github.com/dask/dask/pull/9236,1291842198,PR_kwDOAbcwm846u0cO,9236,Ensure integer dtypes are aligned before shuffle-based merge,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-07-01T21:24:40Z,2022-08-08T02:13:28Z,,MEMBER,,"- [x] Addresses https://github.com/rapidsai/cudf/issues/11189
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

This PR modifies the `warn_dtype_mismatch` utility to (1) handle mismatched index dtypes, and (2) automatically resolve mismatch between simple (numpy) integer dtypes. Since the utility does more than ""warn"", I changed the name to `handle_dtype_mismatch`

The motivation for the ""auto casting"" improvement is cudf/dask_cudf: While Pandas' hashing utility (`pd.util.hash_pandas_object`) will produce consistent results for differing precisions (e.g. int32 vs int64), cudf will not be consistent.  Although the dtype-mismatch warning means it should be up to the user to cast join keys explicitly, it seems reasonable to handle the simple case that both columns are numpy integer dtypes (where casting rules are simple). ",,https://api.github.com/repos/dask/dask/issues/9236/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9236/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9236,https://github.com/dask/dask/pull/9236,https://github.com/dask/dask/pull/9236.diff,https://github.com/dask/dask/pull/9236.patch,,,,,,,,,,,,,,,,,,,
629,https://api.github.com/repos/dask/dask/issues/9243,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9243/labels{/name},https://api.github.com/repos/dask/dask/issues/9243/comments,https://api.github.com/repos/dask/dask/issues/9243/events,https://github.com/dask/dask/pull/9243,1296185953,PR_kwDOAbcwm8469K8Z,9243,Add LeafObject layer for simple Delayed objects,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,2,2022-07-06T17:56:39Z,2022-08-24T02:24:42Z,,MEMBER,,"Although new `Layer` developent is currently [""frozen""](https://github.com/dask/dask/issues/9159), I feel that the addition of a simple `LeafObject` layer (for `delayed(<input-object>)` usage) is worthwhile.  This PR will avoid producing a `MaterializedLayer` for a simple `Delayed` pattern, and will instead produce a simpler `LeafObject` layer.

Note that this simple change makes https://github.com/dask-contrib/dask-sql/issues/607 significant easier to address.
",,https://api.github.com/repos/dask/dask/issues/9243/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9243/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9243,https://github.com/dask/dask/pull/9243,https://github.com/dask/dask/pull/9243.diff,https://github.com/dask/dask/pull/9243.patch,,,,,,,,,,,,,,,,,,,
630,https://api.github.com/repos/dask/dask/issues/9245,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9245/labels{/name},https://api.github.com/repos/dask/dask/issues/9245/comments,https://api.github.com/repos/dask/dask/issues/9245/events,https://github.com/dask/dask/issues/9245,1296498794,I_kwDOAbcwm85NRwBq,9245,Client API docs showing on Futures page (documentation),"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,2,2022-07-06T21:23:24Z,2022-08-03T15:53:49Z,,MEMBER,,"I'm not sure if this issue corresponds here or in the distributed repo, but I noticed that at the bottom of the futures page in the docs right below Functions, we have things like `dump_cluster_state` which as result of the 

```
.. autoclass:: Client
   :members:
```

in here https://github.com/dask/dask/blob/main/docs/source/futures.rst#api . But this is a can be confusing. On the other hand picking the `Client.methods` taht are only relevant to Futures can be annoying. 

Thoughts? ",,https://api.github.com/repos/dask/dask/issues/9245/timeline,,,ncclementi,7526622,MDQ6VXNlcjc1MjY2MjI=,https://avatars.githubusercontent.com/u/7526622?v=4,,https://api.github.com/users/ncclementi,https://github.com/ncclementi,https://api.github.com/users/ncclementi/followers,https://api.github.com/users/ncclementi/following{/other_user},https://api.github.com/users/ncclementi/gists{/gist_id},https://api.github.com/users/ncclementi/starred{/owner}{/repo},https://api.github.com/users/ncclementi/subscriptions,https://api.github.com/users/ncclementi/orgs,https://api.github.com/users/ncclementi/repos,https://api.github.com/users/ncclementi/events{/privacy},https://api.github.com/users/ncclementi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9245/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
631,https://api.github.com/repos/dask/dask/issues/9256,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9256/labels{/name},https://api.github.com/repos/dask/dask/issues/9256/comments,https://api.github.com/repos/dask/dask/issues/9256/events,https://github.com/dask/dask/pull/9256,1299727147,PR_kwDOAbcwm847JOXw,9256,Generic delayed,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,3,2022-07-09T17:17:40Z,2022-12-01T12:40:37Z,,CONTRIBUTOR,,"- [x] Closes #7779
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

## Notable Features

* Added a generic `Delayed[T]`
* Added type annotations for the `.visualize()` options
* Added a `DaskGraph` newtype which helps distinguish a plain dict from a graph
* Added type stubs for `tlz`

## Discussion
Feel free to enquire about some of the decisions I made in this process.

I had to reduce the precision of many of the annotations because mypy (as opposed to say pyright) doesn't yet support a lot of the advanced type objects like `Self`, `Unpack`, `ParamSpec` etc. One specific example of this is the `DaskTask` tuples, which are of the form `(func, *args)`. I would love to define it as `tuple[Callable[T, U], *tuple]` so that we can propagate `U`, the function's return value, and also type check that a function is actually present. However this isn't currently possible.

## Questions

* I'm not familiar enough with the API here to be totally comfortable narrowing the types in some cases. For example, I really would like `pack_collections` to take a list of `DaskCollection`, and `persist()` to return a list of `DaskCollection`, but it seems like both functions are so flexible that I can't make that claim.
* Equally, I would like `Delayed[T].compute()` to return a `T` but I'm not even sure if that's true?

## Note

I'm keeping this as a draft until #9237 is merged, since that fixes some of the mypy errors reported here.",,https://api.github.com/repos/dask/dask/issues/9256/timeline,,,multimeric,5019367,MDQ6VXNlcjUwMTkzNjc=,https://avatars.githubusercontent.com/u/5019367?v=4,,https://api.github.com/users/multimeric,https://github.com/multimeric,https://api.github.com/users/multimeric/followers,https://api.github.com/users/multimeric/following{/other_user},https://api.github.com/users/multimeric/gists{/gist_id},https://api.github.com/users/multimeric/starred{/owner}{/repo},https://api.github.com/users/multimeric/subscriptions,https://api.github.com/users/multimeric/orgs,https://api.github.com/users/multimeric/repos,https://api.github.com/users/multimeric/events{/privacy},https://api.github.com/users/multimeric/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9256/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9256,https://github.com/dask/dask/pull/9256,https://github.com/dask/dask/pull/9256.diff,https://github.com/dask/dask/pull/9256.patch,,,,,,,,,,,,,,,,,,,
632,https://api.github.com/repos/dask/dask/issues/9262,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9262/labels{/name},https://api.github.com/repos/dask/dask/issues/9262/comments,https://api.github.com/repos/dask/dask/issues/9262/events,https://github.com/dask/dask/pull/9262,1301168186,PR_kwDOAbcwm847N7lm,9262,Try out some hypothesis tests,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,1,2022-07-11T20:10:32Z,2022-08-10T12:52:27Z,,MEMBER,,"I'm in the [hypothesis](https://hypothesis.readthedocs.io) tutorial at SciPy and wanted to play around with doing some propert-based testing with hypothesis.

It would be fun to add more tests which checks things like array computations give the same result robustly regardless of chunking by letting hypothesis generate the chunk sizes.",,https://api.github.com/repos/dask/dask/issues/9262/timeline,,,jacobtomlinson,1610850,MDQ6VXNlcjE2MTA4NTA=,https://avatars.githubusercontent.com/u/1610850?v=4,,https://api.github.com/users/jacobtomlinson,https://github.com/jacobtomlinson,https://api.github.com/users/jacobtomlinson/followers,https://api.github.com/users/jacobtomlinson/following{/other_user},https://api.github.com/users/jacobtomlinson/gists{/gist_id},https://api.github.com/users/jacobtomlinson/starred{/owner}{/repo},https://api.github.com/users/jacobtomlinson/subscriptions,https://api.github.com/users/jacobtomlinson/orgs,https://api.github.com/users/jacobtomlinson/repos,https://api.github.com/users/jacobtomlinson/events{/privacy},https://api.github.com/users/jacobtomlinson/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9262/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9262,https://github.com/dask/dask/pull/9262,https://github.com/dask/dask/pull/9262.diff,https://github.com/dask/dask/pull/9262.patch,,,,,,,,,,,,,,,,,,,
633,https://api.github.com/repos/dask/dask/issues/9266,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9266/labels{/name},https://api.github.com/repos/dask/dask/issues/9266/comments,https://api.github.com/repos/dask/dask/issues/9266/events,https://github.com/dask/dask/issues/9266,1302661784,I_kwDOAbcwm85NpQqY,9266,New nav content design [docs],"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,3,2022-07-12T21:58:01Z,2022-08-29T02:15:34Z,,MEMBER,,"The nav bar in the docs has too many elements and you can easily get lost or not find things. 
@jsignell and I were taking about this and we are going to rearrange them as:

HOME: Ideally we will have the collections -> TG -> Scheduler image in https://docs.dask.org/en/stable/ to be at the top and it will be clickable, so you can click in let's say ""Dask Array"" and that will lead you to the array page. 

Nav will have:

GETTING STARTED:
- Install Dask
- 10 min to Dask 
- Best practices 
- Diagnostic and Dashboard
- API

FUNDAMENTALS (name pending):
- Collections
- Task Graph
- Scheduling
- Distributed Clusters

REFERENCE:
- Dask Internals
- Distributed Internals
- Configuration
- Changelog
-  Development guidelines",,https://api.github.com/repos/dask/dask/issues/9266/timeline,,,ncclementi,7526622,MDQ6VXNlcjc1MjY2MjI=,https://avatars.githubusercontent.com/u/7526622?v=4,,https://api.github.com/users/ncclementi,https://github.com/ncclementi,https://api.github.com/users/ncclementi/followers,https://api.github.com/users/ncclementi/following{/other_user},https://api.github.com/users/ncclementi/gists{/gist_id},https://api.github.com/users/ncclementi/starred{/owner}{/repo},https://api.github.com/users/ncclementi/subscriptions,https://api.github.com/users/ncclementi/orgs,https://api.github.com/users/ncclementi/repos,https://api.github.com/users/ncclementi/events{/privacy},https://api.github.com/users/ncclementi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9266/reactions,1,0,0,0,0,0,1,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
634,https://api.github.com/repos/dask/dask/issues/9273,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9273/labels{/name},https://api.github.com/repos/dask/dask/issues/9273/comments,https://api.github.com/repos/dask/dask/issues/9273/events,https://github.com/dask/dask/pull/9273,1305249181,PR_kwDOAbcwm847blLt,9273,Revise fuse_roots optimization to avoid Blockwise materialization,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}]",open,False,,[],,0,2022-07-14T20:20:58Z,2022-07-16T01:01:20Z,,MEMBER,,"Following the discussion in https://github.com/dask/dask/pull/8560, I decided to take a pass at revising the `fuse_roots` optimization for `Blockwise` Layers. Whereas the original optimization was relying on low-level fusion, the new version is using `Blockwise.io_deps` to effectively ""fuse"" simple input tasks that have no other dependencies.

Note that I also fixed some of the existing tests that were inadvertently testing `optimize_blockwise` rather than `fuse_roots`.
",,https://api.github.com/repos/dask/dask/issues/9273/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9273/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9273,https://github.com/dask/dask/pull/9273,https://github.com/dask/dask/pull/9273.diff,https://github.com/dask/dask/pull/9273.patch,,,,,,,,,,,,,,,,,,,
635,https://api.github.com/repos/dask/dask/issues/9277,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9277/labels{/name},https://api.github.com/repos/dask/dask/issues/9277/comments,https://api.github.com/repos/dask/dask/issues/9277/events,https://github.com/dask/dask/issues/9277,1306124707,I_kwDOAbcwm85N2eGj,9277,How to fuse / scatter / whatever dask.array objects,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2022-07-15T14:45:34Z,2022-08-22T02:13:38Z,,NONE,,"@jsignell @jacobtomlinson and I discussed this at the dask users BoF at SciPy yesterday.

Basically when trying to do the work in https://github.com/dask/distributed/issues/6360 and https://github.com/dask/distributed/issues/6571 I wanted to manipulate my dask graph in various ways (e.g. fuse specific tasks, scatter data in the graph), but for my geospatial `dask.array` computation.

On the quadrant system of documentation this means that whilst you guys have some great ""explanation"" docs (which is why I understand that fuse / scatter could have helped me), then because you don't have a ""how-to"" on how to apply these concepts to a `dask.array` object, I basically got stuck. I think this is a general issue with the docs: **how do I do low-level graph manipulations on my high-level graphs.**

(Also it would be nice if you guys had an issue template for docs requests)",,https://api.github.com/repos/dask/dask/issues/9277/timeline,,,TomNicholas,35968931,MDQ6VXNlcjM1OTY4OTMx,https://avatars.githubusercontent.com/u/35968931?v=4,,https://api.github.com/users/TomNicholas,https://github.com/TomNicholas,https://api.github.com/users/TomNicholas/followers,https://api.github.com/users/TomNicholas/following{/other_user},https://api.github.com/users/TomNicholas/gists{/gist_id},https://api.github.com/users/TomNicholas/starred{/owner}{/repo},https://api.github.com/users/TomNicholas/subscriptions,https://api.github.com/users/TomNicholas/orgs,https://api.github.com/users/TomNicholas/repos,https://api.github.com/users/TomNicholas/events{/privacy},https://api.github.com/users/TomNicholas/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9277/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
636,https://api.github.com/repos/dask/dask/issues/9280,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9280/labels{/name},https://api.github.com/repos/dask/dask/issues/9280/comments,https://api.github.com/repos/dask/dask/issues/9280/events,https://github.com/dask/dask/issues/9280,1306230984,I_kwDOAbcwm85N24DI,9280,better search in docs,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,5,2022-07-15T16:30:52Z,2022-08-22T02:13:37Z,,CONTRIBUTOR,,"My anecdotal experience is that the search bar in dask docs rarely gives me the page I actually want. It doesn't appear to do a good job on search term proximity or non-exact matches and maybe indexes too much on the API sections.

For example, if I search distributed docs for ""worker plugin""

https://distributed.dask.org/en/stable/search.html?q=worker+plugin

it's quite challenging to see the result that I actually want.

Anyone know anything about improving / changing the search engine used for this functionality?",,https://api.github.com/repos/dask/dask/issues/9280/timeline,,,ntabris,46289310,MDQ6VXNlcjQ2Mjg5MzEw,https://avatars.githubusercontent.com/u/46289310?v=4,,https://api.github.com/users/ntabris,https://github.com/ntabris,https://api.github.com/users/ntabris/followers,https://api.github.com/users/ntabris/following{/other_user},https://api.github.com/users/ntabris/gists{/gist_id},https://api.github.com/users/ntabris/starred{/owner}{/repo},https://api.github.com/users/ntabris/subscriptions,https://api.github.com/users/ntabris/orgs,https://api.github.com/users/ntabris/repos,https://api.github.com/users/ntabris/events{/privacy},https://api.github.com/users/ntabris/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9280/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
637,https://api.github.com/repos/dask/dask/issues/9292,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9292/labels{/name},https://api.github.com/repos/dask/dask/issues/9292/comments,https://api.github.com/repos/dask/dask/issues/9292/events,https://github.com/dask/dask/issues/9292,1309938141,I_kwDOAbcwm85OFBHd,9292,groupby performance degrades rapidly as column cardinality increases,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2022-07-19T19:13:09Z,2022-09-07T16:00:42Z,,CONTRIBUTOR,,"Dask can perform groupby operations relatively well for columns with low cardinality, but performance seems to degrade significantly for columns with more distinct values.

Let's look at the h2o groupby benchmarks for some examples on the 1e9 dataset (contains one billion rows and is 50 GB on disk when stored as an uncompressed CSV file).

Let's query this dataset with a 16 node i3.large cluster (244 GB of cluster RAM total).  Here's a query that returns 10,000 distinct row groups (i.e. the result has 10,000 rows) and takes 37 seconds to execute.  Here's [the notebook](https://github.com/coiled/coiled-resources/blob/main/benchmarks/h2o-groupby-query2.ipynb) with complete details on how to build the software environment, the cluster info, all the code, etc.

```python
ddf = dd.read_parquet(
    ""s3://coiled-datasets/h2o-benchmark/N_1e9_K_1e2_parquet"",
    storage_options={""anon"": True, ""use_ssl"": True},
    columns=[""id1"", ""id2"", ""v1""],
    engine=""pyarrow"",
)

ddf.groupby([""id1"", ""id2""], dropna=False, observed=True).agg({""v1"": ""sum""}).compute()
```

Here's a different groupby query on the same dataset that returns a million row groups.  I ran this query for a half hour or so and then it errored out with a KilledWorker exception.  Here's [the notebook](https://github.com/coiled/coiled-resources/blob/main/benchmarks/h2o-groupby-query3.ipynb).

```python
ddf = dd.read_parquet(
    ""s3://coiled-datasets/h2o-benchmark/N_1e9_K_1e2_parquet"",
    storage_options={""anon"": True, ""use_ssl"": True},
    columns=[""id3"", ""v1"", ""v3""],
    engine=""pyarrow"",
)

ddf.groupby(""id3"", dropna=False, observed=True).agg(
    {""v1"": ""sum"", ""v3"": ""mean""}
).compute()
```

Let's try to get this running by using the `pyarrow[string]` data type and by repartitioning first.  The `pyarrow[string]` dtype massively shrinks the memory footprint of the DataFrame from 224GB to 37GB.  This query still errors out with a KilledWorker exception.

```python
ddf[""id3""] = ddf[""id3""].astype(""string[pyarrow]"")

ddf.repartition(200).groupby(""id3"", dropna=False, observed=True).agg(
    {""v1"": ""sum"", ""v3"": ""mean""}
).compute()
```

It's the same dataset and the same cluster, so it seems like the issue is caused by the cardinality of the groupby column.  I'm interested in hearing what other folks think is the root cause.  Let me know if there is any additional info I can provide to give you with more context.  I'm happy to take pictures of dashboards, look at logs, etc.",,https://api.github.com/repos/dask/dask/issues/9292/timeline,,,MrPowers,2722395,MDQ6VXNlcjI3MjIzOTU=,https://avatars.githubusercontent.com/u/2722395?v=4,,https://api.github.com/users/MrPowers,https://github.com/MrPowers,https://api.github.com/users/MrPowers/followers,https://api.github.com/users/MrPowers/following{/other_user},https://api.github.com/users/MrPowers/gists{/gist_id},https://api.github.com/users/MrPowers/starred{/owner}{/repo},https://api.github.com/users/MrPowers/subscriptions,https://api.github.com/users/MrPowers/orgs,https://api.github.com/users/MrPowers/repos,https://api.github.com/users/MrPowers/events{/privacy},https://api.github.com/users/MrPowers/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9292/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
638,https://api.github.com/repos/dask/dask/issues/9293,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9293/labels{/name},https://api.github.com/repos/dask/dask/issues/9293/comments,https://api.github.com/repos/dask/dask/issues/9293/events,https://github.com/dask/dask/issues/9293,1310836213,I_kwDOAbcwm85OIcX1,9293,Dask arrays are replaced with different objects in a forked process worker,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}]",open,False,,[],,7,2022-07-20T10:44:36Z,2022-07-29T15:19:53Z,,NONE,,"
**What happened**:
I create a dask (lazy) array, then schedule an operation in a dask worker, which refers it as a free or global variable (i.e. not as an argument).
Within the worker code execution, the resulting (lazy) array object does not match the original in the parent code  :
  1. A lazy masked array, accessed by a free variable within a process worker, has the meta type of a ""normal"" numpy array instead of a masked one.
  2. additional custom instance properties on  lazy array do not exist in the worker
  3. the ""id"" of the array object is changed (which does not happen for ""ordinary"" Python objects).

**What you expected to happen**:
The array object should appear the same in the worker as in the parent code,
 \-- as it does, when using a ""threads"" or ""synchronous"" scheduler.

It's possible that this behaviour is essential, 
e.g. because a memory-copied object contains O.S. resources (like file handles) which cannot function in a forked process.
If so, however, that is really not obvious, and should probably be ***documented somewhere***.

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.array as da
import dask.bag
import dask.config
import numpy as np

test_maskedarray = np.ma.masked_array(da.arange(3), [0, 0, 1])
global_lazy_array = da.from_array(test_maskedarray)
global_lazy_array.custom_property = 'exists'

def array_details(array):
    result_string = (
        f'  {array}'
        f'\n  id(x) = {id(array)}'
        f'\n  type(x._meta) = {type(array._meta)}'
        f'\n  .custom_property = {getattr(array, ""custom_property"", ""<NONE>"")}'
    )
    return result_string

@dask.delayed
def trial_worker(*args):
    result = array_details(global_lazy_array)
    return result

def run_case(**compute_kwargs):
    test_delayed_op = trial_worker(0)
    with dask.config.set(**compute_kwargs):
        result = test_delayed_op.compute()
    return result


print(f'array properties IN PARENT:')
print(array_details(global_lazy_array))

print('')
print(f'array properties WITHIN WORKER (threads) :')
print(run_case(scheduler='threads'))


print('')
print(f'array properties WITHIN WORKER (processes) :')
print(run_case(**{""scheduler"":'processes', 'multiprocessing.context':""fork""}))
```

Sample result:
```
array properties IN PARENT:
  dask.array<array, shape=(3,), dtype=int64, chunksize=(3,), chunktype=numpy.MaskedArray>
  id(x) = 139657291024560
  type(x._meta) = <class 'numpy.ma.core.MaskedArray'>
  .custom_property = exists

array properties WITHIN WORKER (threads) :
  dask.array<array, shape=(3,), dtype=int64, chunksize=(3,), chunktype=numpy.MaskedArray>
  id(x) = 139657291024560
  type(x._meta) = <class 'numpy.ma.core.MaskedArray'>
  .custom_property = exists

array properties WITHIN WORKER (processes) :
  dask.array<array, shape=(3,), dtype=int64, chunksize=(3,), chunktype=numpy.ndarray>
  id(x) = 139657290681696
  type(x._meta) = <class 'numpy.ndarray'>
  .custom_property = <NONE>
```

**Anything else we need to know?**:
  * The same thing happens whether the operation is actioned via a dask Bag or a Delayed computation.
  * The problem is specific to a dask ""processes"" scheduler
     -- results are as expected for a ""synchronous"" or ""threads"" schedulers.
  * replacing dask Bag/Delayed parallelism with a `concurrent.futures.ProcessPoolExecutor` does not show the same behaviour


**Environment**:

- Dask version: 2.9.2 or 2022.05.2
- Python version: 3.8
- Operating System: linux
- Install method : conda


</details>",,https://api.github.com/repos/dask/dask/issues/9293/timeline,,,pp-mo,2089069,MDQ6VXNlcjIwODkwNjk=,https://avatars.githubusercontent.com/u/2089069?v=4,,https://api.github.com/users/pp-mo,https://github.com/pp-mo,https://api.github.com/users/pp-mo/followers,https://api.github.com/users/pp-mo/following{/other_user},https://api.github.com/users/pp-mo/gists{/gist_id},https://api.github.com/users/pp-mo/starred{/owner}{/repo},https://api.github.com/users/pp-mo/subscriptions,https://api.github.com/users/pp-mo/orgs,https://api.github.com/users/pp-mo/repos,https://api.github.com/users/pp-mo/events{/privacy},https://api.github.com/users/pp-mo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9293/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
639,https://api.github.com/repos/dask/dask/issues/9294,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9294/labels{/name},https://api.github.com/repos/dask/dask/issues/9294/comments,https://api.github.com/repos/dask/dask/issues/9294/events,https://github.com/dask/dask/issues/9294,1310858995,I_kwDOAbcwm85OIh7z,9294,Exception after merging two dataframes on index,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,4,2022-07-20T11:02:31Z,2022-08-30T10:04:01Z,,NONE,,"**What happened**:

After I merge two data frames on their index, then `reset_index` and try to access the column that was the index, I get an exception.

**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import dask
import dask.dataframe as dd

A_df = dd.from_pandas(
    pd.DataFrame(
        [('aaa', 10), ('bbb', 20)],
        columns=['string_key_A', 'value1']
    ),
    npartitions=1
).set_index('string_key_A')

B_df = dd.from_pandas(
    pd.DataFrame(
        [('aaa', 100)],
        columns=['string_key_B', 'value2']
    ),
    npartitions=1
).set_index('string_key_B')

print(A_df.compute())
print()

print(B_df.compute())
print()

merged_df = dd.merge(A_df, B_df, left_index=True, right_index=True).reset_index()

print(merged_df)
print()

print(merged_df.dtypes)
print()

print(merged_df.compute())
print()

print(merged_df['string_key_A'])
print()

print(merged_df['string_key_A'].compute())
```

Here's the output I get, including the traceback:

```              value1
string_key_A
aaa               10
bbb               20

              value2
string_key_B
aaa              100

Dask DataFrame Structure:
              string_key_A value1 value2
npartitions=1
                    object  int64  int64
                       ...    ...    ...
Dask Name: reset_index, 13 tasks

string_key_A    object
value1           int64
value2           int64
dtype: object

  index  value1  value2
0   aaa      10     100

Dask Series Structure:
npartitions=1
    object
       ...
Name: string_key_A, dtype: object
Dask Name: getitem, 14 tasks

Traceback (most recent call last):
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/pandas/core/indexes/base.py"", line 3621, in get_loc
    return self._engine.get_loc(casted_key)
  File ""pandas/_libs/index.pyx"", line 136, in pandas._libs.index.IndexEngine.get_loc
  File ""pandas/_libs/index.pyx"", line 163, in pandas._libs.index.IndexEngine.get_loc
  File ""pandas/_libs/hashtable_class_helper.pxi"", line 5198, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File ""pandas/_libs/hashtable_class_helper.pxi"", line 5206, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'string_key_A'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/home/ubuntu/bug/bug.py"", line 42, in <module>
    print(merged_df['string_key_A'].compute())
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/dask/base.py"", line 315, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/dask/base.py"", line 603, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/dask/threaded.py"", line 89, in get
    results = get_async(
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/dask/local.py"", line 511, in get_async
    raise_exception(exc, tb)
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/dask/local.py"", line 319, in reraise
    raise exc
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/dask/local.py"", line 224, in execute_task
    result = _execute_task(task, data)
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/dask/optimization.py"", line 990, in __call__
    return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/dask/core.py"", line 149, in get
    result = _execute_task(task, cache)
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/pandas/core/frame.py"", line 3505, in __getitem__
    indexer = self.columns.get_loc(key)
  File ""/home/ubuntu/.cache/pypoetry/virtualenvs/bug-TT33av2A-py3.9/lib/python3.9/site-packages/pandas/core/indexes/base.py"", line 3623, in get_loc
    raise KeyError(key) from err
KeyError: 'string_key_A'
```

**Anything else we need to know?**:

It looks like the problem is that after the `merge`, the metadata thinks that the index (now turned into a regular column by `reset_index`) is called `string_key_A` but when you actually compute to a pandas dataframe, it's called `index`. This causes things to crash later.

Interestingly if you call the column the same thing e.g. just `string_key` in both dataframes before you `merge` them, the same problem doesn't arise.


**Environment**:

Dask version: 2022.7.0
Python version: 3.9.7
Operating System: Ubuntu 20.04.3 LTS
Install method: poetry

",,https://api.github.com/repos/dask/dask/issues/9294/timeline,,,billiejoe-bw,36629568,MDQ6VXNlcjM2NjI5NTY4,https://avatars.githubusercontent.com/u/36629568?v=4,,https://api.github.com/users/billiejoe-bw,https://github.com/billiejoe-bw,https://api.github.com/users/billiejoe-bw/followers,https://api.github.com/users/billiejoe-bw/following{/other_user},https://api.github.com/users/billiejoe-bw/gists{/gist_id},https://api.github.com/users/billiejoe-bw/starred{/owner}{/repo},https://api.github.com/users/billiejoe-bw/subscriptions,https://api.github.com/users/billiejoe-bw/orgs,https://api.github.com/users/billiejoe-bw/repos,https://api.github.com/users/billiejoe-bw/events{/privacy},https://api.github.com/users/billiejoe-bw/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9294/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
640,https://api.github.com/repos/dask/dask/issues/9298,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9298/labels{/name},https://api.github.com/repos/dask/dask/issues/9298/comments,https://api.github.com/repos/dask/dask/issues/9298/events,https://github.com/dask/dask/issues/9298,1315087897,I_kwDOAbcwm85OYqYZ,9298,"How to pass compression level to_parquet, to_zarr [docs]","[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,6,2022-07-22T14:35:49Z,2023-03-01T21:12:12Z,,MEMBER,,"@pavithraes and I were answering [this](https://dask.discourse.group/t/compression-levels-with-dask-dataframe-dask-array/910/2) question on discourse and we thought that this could be a nice How to page. 

Thoughts?
",,https://api.github.com/repos/dask/dask/issues/9298/timeline,,,ncclementi,7526622,MDQ6VXNlcjc1MjY2MjI=,https://avatars.githubusercontent.com/u/7526622?v=4,,https://api.github.com/users/ncclementi,https://github.com/ncclementi,https://api.github.com/users/ncclementi/followers,https://api.github.com/users/ncclementi/following{/other_user},https://api.github.com/users/ncclementi/gists{/gist_id},https://api.github.com/users/ncclementi/starred{/owner}{/repo},https://api.github.com/users/ncclementi/subscriptions,https://api.github.com/users/ncclementi/orgs,https://api.github.com/users/ncclementi/repos,https://api.github.com/users/ncclementi/events{/privacy},https://api.github.com/users/ncclementi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9298/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
641,https://api.github.com/repos/dask/dask/issues/9303,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9303/labels{/name},https://api.github.com/repos/dask/dask/issues/9303/comments,https://api.github.com/repos/dask/dask/issues/9303/events,https://github.com/dask/dask/pull/9303,1317158405,PR_kwDOAbcwm848DpVH,9303,"WIP/RFC: In the insert_to_ooc function, only fuse the slices if there are non-empty regions","[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2022-07-25T17:40:17Z,2022-08-24T21:32:29Z,,FIRST_TIME_CONTRIBUTOR,,"This improves performance when writing out arrays with a very large number of chunks.

I made this change based on profiling and debugging. I found that in my case, where `regions = (<empty slice>, <empty slice>, <empty slice>)`, `[fuse_slice(region, slc) for slc in slices]` appears to be an identity (`slices == [fuse_slice(region, slc) for slc in slices]`). However, it takes a very long time to run.

That said, **I don't have a good grasp on either `fuse_slice`, or `insert_to_ooc`, so I'm not sure if this is correct in the first place, and if so, if this is the right place to put this logic.** So I created this PR mainly to solicit feedback from someone who understands this in better detail. Thank you!

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9303/timeline,,,WToma,2308949,MDQ6VXNlcjIzMDg5NDk=,https://avatars.githubusercontent.com/u/2308949?v=4,,https://api.github.com/users/WToma,https://github.com/WToma,https://api.github.com/users/WToma/followers,https://api.github.com/users/WToma/following{/other_user},https://api.github.com/users/WToma/gists{/gist_id},https://api.github.com/users/WToma/starred{/owner}{/repo},https://api.github.com/users/WToma/subscriptions,https://api.github.com/users/WToma/orgs,https://api.github.com/users/WToma/repos,https://api.github.com/users/WToma/events{/privacy},https://api.github.com/users/WToma/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9303/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9303,https://github.com/dask/dask/pull/9303,https://github.com/dask/dask/pull/9303.diff,https://github.com/dask/dask/pull/9303.patch,,,,,,,,,,,,,,,,,,,
642,https://api.github.com/repos/dask/dask/issues/9305,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9305/labels{/name},https://api.github.com/repos/dask/dask/issues/9305/comments,https://api.github.com/repos/dask/dask/issues/9305/events,https://github.com/dask/dask/issues/9305,1317395340,I_kwDOAbcwm85OhduM,9305,Rolling operations fail with unknown divisions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-07-25T21:26:52Z,2022-08-29T02:15:28Z,,MEMBER,,"**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd

df = dd.demo.make_timeseries()

# Works with divisions
df.x.rolling(""50D"").mean().compute()
# timestamp
# 2000-01-31 00:00:00    0.637020
# 2000-01-31 00:00:10   -0.179649
# 2000-01-31 00:00:20   -0.343737
# 2000-01-31 00:00:30   -0.206287
# 2000-01-31 00:00:40   -0.206965
#                          ...   
# 2000-12-30 23:59:10    0.000851
# 2000-12-30 23:59:20    0.000850
# 2000-12-30 23:59:30    0.000849
# 2000-12-30 23:59:40    0.000848
# 2000-12-30 23:59:50    0.000846
# Freq: 10S, Name: x, Length: 2894400, dtype: float64

# Fails without divisions
dfc = df.clear_divisions()
dfc.x.rolling(""50D"").mean().compute()

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [5], in <cell line: 1>()
----> 1 dfc.x.rolling(""50D"").mean().compute()

File ~/dev/dask/dask/dataframe/rolling.py:534, in Rolling.mean(self)
    532 @derived_from(pd_Rolling)
    533 def mean(self):
--> 534     return self._call_method(""mean"")

File ~/dev/dask/dask/dataframe/rolling.py:507, in Rolling._call_method(self, method_name, *args, **kwargs)
    505     before = self.window - 1
    506     after = 0
--> 507 return map_overlap(
    508     self.pandas_rolling_method,
    509     self.obj,
    510     before,
    511     after,
    512     rolling_kwargs,
    513     method_name,
    514     *args,
    515     token=method_name,
    516     meta=meta,
    517     **kwargs,
    518 )

File ~/dev/dask/dask/dataframe/rolling.py:229, in map_overlap(func, df, before, after, meta, enforce_metadata, transform_divisions, align_dataframes, *args, **kwargs)
    227 for arg in args:
    228     if isinstance(arg, _Frame):
--> 229         arg = _handle_frame_argument(arg)
    230         args2.append(arg)
    231         dependencies.append(arg)

File ~/dev/dask/dask/dataframe/rolling.py:211, in map_overlap.<locals>._handle_frame_argument(arg)
    208 def _handle_frame_argument(arg):
    209     dsk = {}
--> 211     prevs_parts_dsk, prevs = _get_previous_partitions(arg, before)
    212     dsk.update(prevs_parts_dsk)
    214     nexts_parts_dsk, nexts = _get_nexts_partitions(arg, after)

File ~/dev/dask/dask/dataframe/rolling.py:349, in _get_previous_partitions(df, before)
    346 elif isinstance(before, datetime.timedelta):
    347     # Assumes monotonic (increasing?) index
    348     divs = pd.Series(df.divisions)
--> 349     deltas = divs.diff().iloc[1:-1]
    351     # In the first case window-size is larger than at least one partition, thus it is
    352     # necessary to calculate how many partitions must be used for each rolling task.
    353     # Otherwise, these calculations can be skipped (faster)
    355     if (before > deltas).any():

File ~/dev/dask-playground/env/lib/python3.9/site-packages/pandas/core/series.py:2697, in Series.diff(self, periods)
   2612 @doc(
   2613     klass=""Series"",
   2614     extra_params="""",
   (...)
   2660 )
   2661 def diff(self, periods: int = 1) -> Series:
   2662     """"""
   2663     First discrete difference of element.
   2664 
   (...)
   2695     {examples}
   2696     """"""
-> 2697     result = algorithms.diff(self._values, periods)
   2698     return self._constructor(result, index=self.index).__finalize__(
   2699         self, method=""diff""
   2700     )

File ~/dev/dask-playground/env/lib/python3.9/site-packages/pandas/core/algorithms.py:1647, in diff(arr, n, axis)
   1644     _lag_indexer[axis] = slice(None, -n) if n > 0 else slice(-n, None)
   1645     lag_indexer = tuple(_lag_indexer)
-> 1647     out_arr[res_indexer] = op(arr[res_indexer], arr[lag_indexer])
   1649 if is_timedelta:
   1650     out_arr = out_arr.view(""timedelta64[ns]"")

TypeError: unsupported operand type(s) for -: 'NoneType' and 'NoneType'
```

The problem is that this `_get_previous_partitions` helper assumes the dataframe has known divisions:
https://github.com/dask/dask/blob/b7846b986632d0b20668ff632d839bcfb0d5469f/dask/dataframe/rolling.py#L346-L349

I don't know anything about rolling operationswithout known divisions, is it even possible to do them? I'm not sure here if the solution is a different algorithm, or just an informative error message.

**Environment**:

- Dask version: 2022.7.1
- Python version: 3.9
- Operating System: macOS
- Install method (conda, pip, source): source

cc @jsignell",,https://api.github.com/repos/dask/dask/issues/9305/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9305/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
643,https://api.github.com/repos/dask/dask/issues/9311,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9311/labels{/name},https://api.github.com/repos/dask/dask/issues/9311/comments,https://api.github.com/repos/dask/dask/issues/9311/events,https://github.com/dask/dask/issues/9311,1318400838,I_kwDOAbcwm85OlTNG,9311,2022.7.1: documentation build fails wth sphinx 5.x,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,13,2022-07-26T15:22:44Z,2023-05-09T22:37:56Z,,NONE,,"**What happened**:
Sphinx 5.x fails on generate documentaion because problematic `sphinx_design` extension

**What you expected to happen**:
It shoud be possible to generate documentation with latest sphinx.

**Minimal Complete Verifiable Example**:
Just run in projest root `sphinx-build -n -T -b man docs/source build/sphinx/man`

**Environment**:
- Dask version: 2022.7.1
- Python version: 3.8.13
- Operating System: Linux x86/64
- Install method (conda, pip, source): N/A",,https://api.github.com/repos/dask/dask/issues/9311/timeline,,,kloczek,31284574,MDQ6VXNlcjMxMjg0NTc0,https://avatars.githubusercontent.com/u/31284574?v=4,,https://api.github.com/users/kloczek,https://github.com/kloczek,https://api.github.com/users/kloczek/followers,https://api.github.com/users/kloczek/following{/other_user},https://api.github.com/users/kloczek/gists{/gist_id},https://api.github.com/users/kloczek/starred{/owner}{/repo},https://api.github.com/users/kloczek/subscriptions,https://api.github.com/users/kloczek/orgs,https://api.github.com/users/kloczek/repos,https://api.github.com/users/kloczek/events{/privacy},https://api.github.com/users/kloczek/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9311/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
644,https://api.github.com/repos/dask/dask/issues/9331,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9331/labels{/name},https://api.github.com/repos/dask/dask/issues/9331/comments,https://api.github.com/repos/dask/dask/issues/9331/events,https://github.com/dask/dask/issues/9331,1322651353,I_kwDOAbcwm85O1g7Z,9331,Dask DataFrame set_index does not work when column name matches index name,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,9,2022-07-29T20:28:16Z,2022-08-24T10:47:12Z,,NONE,,"**What happened:**

Calling set_index providing a column name that matches the name of the index does not perform the set_index.

**What you expected to happen:**

The provided column becomes the index, as was the case prior to Dask==2022.05.1

**Minimal Complete Verifiable Example:**

```python
import dask.dataframe as dd
import pandas as pd

df = dd.from_pandas(pd.DataFrame([
    {'a': 1, 'b': 2},
    {'a': 2, 'b': 1}]
), npartitions=1)
df = df.set_index('a')
df = df.rename(columns={'b': 'a'})
df.set_index('a').head()
```

**Anything else we need to know?:**

This is the [branch](https://github.com/dask/dask/blob/0b637ab775fa177d0af737e4648a89484aee5c74/dask/dataframe/core.py#L4816) responsible for the behavior, it was introduced in a commit that seems [unrelated](https://github.com/dask/dask/commit/d458533b5f04494c8eb070adaff6470cea2cf6b0). Dask versions prior to 2022.05.1 are unaffected.

**Environment**

Dask version: 2022.5.1
Python version: 3.10.5
Operating System: Ubuntu 20.04
Install method (conda, pip, source): pip",,https://api.github.com/repos/dask/dask/issues/9331/timeline,,reopened,georgek-auro,32307982,MDQ6VXNlcjMyMzA3OTgy,https://avatars.githubusercontent.com/u/32307982?v=4,,https://api.github.com/users/georgek-auro,https://github.com/georgek-auro,https://api.github.com/users/georgek-auro/followers,https://api.github.com/users/georgek-auro/following{/other_user},https://api.github.com/users/georgek-auro/gists{/gist_id},https://api.github.com/users/georgek-auro/starred{/owner}{/repo},https://api.github.com/users/georgek-auro/subscriptions,https://api.github.com/users/georgek-auro/orgs,https://api.github.com/users/georgek-auro/repos,https://api.github.com/users/georgek-auro/events{/privacy},https://api.github.com/users/georgek-auro/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9331/reactions,0,0,0,0,0,0,0,0,0,pavithraes,33131404.0,MDQ6VXNlcjMzMTMxNDA0,https://avatars.githubusercontent.com/u/33131404?v=4,,https://api.github.com/users/pavithraes,https://github.com/pavithraes,https://api.github.com/users/pavithraes/followers,https://api.github.com/users/pavithraes/following{/other_user},https://api.github.com/users/pavithraes/gists{/gist_id},https://api.github.com/users/pavithraes/starred{/owner}{/repo},https://api.github.com/users/pavithraes/subscriptions,https://api.github.com/users/pavithraes/orgs,https://api.github.com/users/pavithraes/repos,https://api.github.com/users/pavithraes/events{/privacy},https://api.github.com/users/pavithraes/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
645,https://api.github.com/repos/dask/dask/issues/9351,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9351/labels{/name},https://api.github.com/repos/dask/dask/issues/9351/comments,https://api.github.com/repos/dask/dask/issues/9351/events,https://github.com/dask/dask/pull/9351,1328592172,PR_kwDOAbcwm848pekq,9351,Allow some boolean indexing operations to return the correct shape,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,9,2022-08-04T13:06:07Z,2022-08-17T14:20:35Z,,CONTRIBUTOR,,"- [x] Solves #8638 
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9351/timeline,,,geraninam,108741360,U_kgDOBntC8A,https://avatars.githubusercontent.com/u/108741360?v=4,,https://api.github.com/users/geraninam,https://github.com/geraninam,https://api.github.com/users/geraninam/followers,https://api.github.com/users/geraninam/following{/other_user},https://api.github.com/users/geraninam/gists{/gist_id},https://api.github.com/users/geraninam/starred{/owner}{/repo},https://api.github.com/users/geraninam/subscriptions,https://api.github.com/users/geraninam/orgs,https://api.github.com/users/geraninam/repos,https://api.github.com/users/geraninam/events{/privacy},https://api.github.com/users/geraninam/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9351/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9351,https://github.com/dask/dask/pull/9351,https://github.com/dask/dask/pull/9351.diff,https://github.com/dask/dask/pull/9351.patch,,,,,,,,,,,,,,,,,,,
646,https://api.github.com/repos/dask/dask/issues/9355,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9355/labels{/name},https://api.github.com/repos/dask/dask/issues/9355/comments,https://api.github.com/repos/dask/dask/issues/9355/events,https://github.com/dask/dask/issues/9355,1329890279,I_kwDOAbcwm85PRIPn,9355,Add support for 'sym' and 'her' matrix structures in `da.linalg.solve`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,2,2022-08-05T12:43:35Z,2022-08-08T15:45:25Z,,MEMBER,,"In #9350, we added the `assume_a` kwarg to `da.linalg.solve` for consistency with [`scipy.linalg.solve`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html). Dask currently only supports `assume_a` = 'gen' and 'pos', it'll be nice to look into supporting 'her' and 'sym' structures as well.",,https://api.github.com/repos/dask/dask/issues/9355/timeline,,,pavithraes,33131404,MDQ6VXNlcjMzMTMxNDA0,https://avatars.githubusercontent.com/u/33131404?v=4,,https://api.github.com/users/pavithraes,https://github.com/pavithraes,https://api.github.com/users/pavithraes/followers,https://api.github.com/users/pavithraes/following{/other_user},https://api.github.com/users/pavithraes/gists{/gist_id},https://api.github.com/users/pavithraes/starred{/owner}{/repo},https://api.github.com/users/pavithraes/subscriptions,https://api.github.com/users/pavithraes/orgs,https://api.github.com/users/pavithraes/repos,https://api.github.com/users/pavithraes/events{/privacy},https://api.github.com/users/pavithraes/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9355/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
647,https://api.github.com/repos/dask/dask/issues/9356,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9356/labels{/name},https://api.github.com/repos/dask/dask/issues/9356/comments,https://api.github.com/repos/dask/dask/issues/9356/events,https://github.com/dask/dask/issues/9356,1329896535,I_kwDOAbcwm85PRJxX,9356,Remove `sym_pos` kwarg from `da.linalg.solve`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450419, 'node_id': 'LA_kwDOAbcwm87iZ8Dz', 'url': 'https://api.github.com/repos/dask/dask/labels/deprecation', 'name': 'deprecation', 'color': 'f4e49a', 'default': False, 'description': 'Something is being removed'}]",open,False,,[],,0,2022-08-05T12:48:30Z,2022-09-05T02:14:24Z,,MEMBER,,"In #9350, we deprecated the `sym_pos` kwarg in favour of `assume_a`, [similar to scipy](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html). 

This issue is to ensure we remove `sym_pos` in a future release.",,https://api.github.com/repos/dask/dask/issues/9356/timeline,,,pavithraes,33131404,MDQ6VXNlcjMzMTMxNDA0,https://avatars.githubusercontent.com/u/33131404?v=4,,https://api.github.com/users/pavithraes,https://github.com/pavithraes,https://api.github.com/users/pavithraes/followers,https://api.github.com/users/pavithraes/following{/other_user},https://api.github.com/users/pavithraes/gists{/gist_id},https://api.github.com/users/pavithraes/starred{/owner}{/repo},https://api.github.com/users/pavithraes/subscriptions,https://api.github.com/users/pavithraes/orgs,https://api.github.com/users/pavithraes/repos,https://api.github.com/users/pavithraes/events{/privacy},https://api.github.com/users/pavithraes/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9356/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
648,https://api.github.com/repos/dask/dask/issues/9358,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9358/labels{/name},https://api.github.com/repos/dask/dask/issues/9358/comments,https://api.github.com/repos/dask/dask/issues/9358/events,https://github.com/dask/dask/pull/9358,1330851840,PR_kwDOAbcwm848wx-C,9358,Passing Ignore_index kwarg to .concat,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3028194444, 'node_id': 'MDU6TGFiZWwzMDI4MTk0NDQ0', 'url': 'https://api.github.com/repos/dask/dask/labels/dispatch', 'name': 'dispatch', 'color': 'fc03db', 'default': False, 'description': 'Related to `Dispatch` extension objects'}]",open,False,,[],,2,2022-08-06T21:25:51Z,2022-08-17T20:45:49Z,,FIRST_TIME_CONTRIBUTOR,,"- [X] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9358/timeline,,,ahmedibrhm,81244897,MDQ6VXNlcjgxMjQ0ODk3,https://avatars.githubusercontent.com/u/81244897?v=4,,https://api.github.com/users/ahmedibrhm,https://github.com/ahmedibrhm,https://api.github.com/users/ahmedibrhm/followers,https://api.github.com/users/ahmedibrhm/following{/other_user},https://api.github.com/users/ahmedibrhm/gists{/gist_id},https://api.github.com/users/ahmedibrhm/starred{/owner}{/repo},https://api.github.com/users/ahmedibrhm/subscriptions,https://api.github.com/users/ahmedibrhm/orgs,https://api.github.com/users/ahmedibrhm/repos,https://api.github.com/users/ahmedibrhm/events{/privacy},https://api.github.com/users/ahmedibrhm/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9358/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9358,https://github.com/dask/dask/pull/9358,https://github.com/dask/dask/pull/9358.diff,https://github.com/dask/dask/pull/9358.patch,,,,,,,,,,,,,,,,,,,
649,https://api.github.com/repos/dask/dask/issues/9363,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9363/labels{/name},https://api.github.com/repos/dask/dask/issues/9363/comments,https://api.github.com/repos/dask/dask/issues/9363/events,https://github.com/dask/dask/issues/9363,1331673654,I_kwDOAbcwm85PX7o2,9363,Deprecate unpacking `dataclass` in favor of `namedtuple`,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450419, 'node_id': 'LA_kwDOAbcwm87iZ8Dz', 'url': 'https://api.github.com/repos/dask/dask/labels/deprecation', 'name': 'deprecation', 'color': 'f4e49a', 'default': False, 'description': 'Something is being removed'}]",open,False,,[],,3,2022-08-08T10:38:44Z,2022-09-19T02:15:09Z,,MEMBER,,"As mentioned in https://github.com/dask/dask/pull/9345#issuecomment-1207863896, we currently unpack `dataclass`es to discover embedded Dask collections. However, the support for `dataclass`es is limited: 

>[W]e basically want to be able to unpack those `dataclass`es that do not have any custom `__init__`, `__post_init__`, feature fields with `init=False`, or use `InitVars`. Those `dataclass`es should ideally not be mutated, at the very least not here and mutation would likely create a host of problems down the line. 

In #9361, we add support for unpacking `namedtuple`, which seem to be a perfect match to the limited scope of functionality we want to support in unpacking `dataclass`es. They are immutable and have a trivial, unchangeable constructor that consists of all their fields with optional defaults.

Deprecating the unpacking of `dataclass`es in favor of `namedtuple` would give us a smooth way to remove traversal of `dataclass`es as mentioned in https://github.com/dask/dask/issues/6574#issuecomment-943411814 and help us get rid of a few issues: 
* Unclear boundary of support for unpacking `dataclass`es (e.g., unset `init=False` fields are fine, set `init=False` fields are not)
* Flawed detection of un-supported `dataclass`es (i.e., detecting a custom `__init__` will likely remain imperfect)
* #5533
* Conceptually, this entire feature feels odd given the mutable nature of `dataclass`es

To deprecate unpacking of `dataclass`es, we can use the existing logic for unpacking to issue the `DeprecationWarning` whenever an embedded collection is detected.",,https://api.github.com/repos/dask/dask/issues/9363/timeline,,,hendrikmakait,2699097,MDQ6VXNlcjI2OTkwOTc=,https://avatars.githubusercontent.com/u/2699097?v=4,,https://api.github.com/users/hendrikmakait,https://github.com/hendrikmakait,https://api.github.com/users/hendrikmakait/followers,https://api.github.com/users/hendrikmakait/following{/other_user},https://api.github.com/users/hendrikmakait/gists{/gist_id},https://api.github.com/users/hendrikmakait/starred{/owner}{/repo},https://api.github.com/users/hendrikmakait/subscriptions,https://api.github.com/users/hendrikmakait/orgs,https://api.github.com/users/hendrikmakait/repos,https://api.github.com/users/hendrikmakait/events{/privacy},https://api.github.com/users/hendrikmakait/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9363/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
650,https://api.github.com/repos/dask/dask/issues/9368,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9368/labels{/name},https://api.github.com/repos/dask/dask/issues/9368/comments,https://api.github.com/repos/dask/dask/issues/9368/events,https://github.com/dask/dask/issues/9368,1333716656,I_kwDOAbcwm85Pfuaw,9368,Enable installing nightly packages in gpuCI ,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 4410724893, 'node_id': 'LA_kwDOAbcwm88AAAABBuZSHQ', 'url': 'https://api.github.com/repos/dask/dask/labels/gpu', 'name': 'gpu', 'color': '3D0CD2', 'default': False, 'description': ''}]",open,False,,[],,2,2022-08-09T19:52:14Z,2022-09-19T02:15:08Z,,MEMBER,,"@ncclementi and I are working on https://github.com/dask/dask/pull/9366 and were wanting to run tests on gpuCI with the nightly version of `pandas`. In other CI jobs we use [this script](https://github.com/dask/dask/blob/e2548c53db70929e42aa8cdac18bee552a291adb/continuous_integration/scripts/install.sh) to install the development version of a few upstream dependencies (including `pandas`). However, I don't think the same thing is done in our gpuCI builds today. 

cc @charlesbluca",,https://api.github.com/repos/dask/dask/issues/9368/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9368/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
651,https://api.github.com/repos/dask/dask/issues/9370,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9370/labels{/name},https://api.github.com/repos/dask/dask/issues/9370/comments,https://api.github.com/repos/dask/dask/issues/9370/events,https://github.com/dask/dask/issues/9370,1334473797,I_kwDOAbcwm85PinRF,9370,`dask.compute` can't handle some `dataclass`es as input,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2022-08-10T11:21:44Z,2022-09-12T02:15:18Z,,MEMBER,,"As mentioned in https://github.com/dask/dask/pull/9345#discussion_r940533164, `dask.compute` can't handle some `dataclass`es as inputs due to a limitation in `dask.base.unpack_collections`. In #9345, we added support or error handling for these types of `dataclass`es, but the implementation of `dask.base.unpack_collections` makes it non-trivial to apply those changes. Specifically, we experience issues as soon as we encounter a custom `__init__`, `__post_init__`, fields with `init=False` or `InitVar`s in the `dataclass`. #9363 would provide an alternative route to solving this issue. 

```python3
import dask
from dataclasses import dataclass

@dataclass
class MyDataClass:
    arg1: int
    def __init__(self, arg):
        self.arg1 = arg
        
dask.compute([dask.delayed(1), MyDataClass(1)])
```",,https://api.github.com/repos/dask/dask/issues/9370/timeline,,,hendrikmakait,2699097,MDQ6VXNlcjI2OTkwOTc=,https://avatars.githubusercontent.com/u/2699097?v=4,,https://api.github.com/users/hendrikmakait,https://github.com/hendrikmakait,https://api.github.com/users/hendrikmakait/followers,https://api.github.com/users/hendrikmakait/following{/other_user},https://api.github.com/users/hendrikmakait/gists{/gist_id},https://api.github.com/users/hendrikmakait/starred{/owner}{/repo},https://api.github.com/users/hendrikmakait/subscriptions,https://api.github.com/users/hendrikmakait/orgs,https://api.github.com/users/hendrikmakait/repos,https://api.github.com/users/hendrikmakait/events{/privacy},https://api.github.com/users/hendrikmakait/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9370/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
652,https://api.github.com/repos/dask/dask/issues/9373,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9373/labels{/name},https://api.github.com/repos/dask/dask/issues/9373/comments,https://api.github.com/repos/dask/dask/issues/9373/events,https://github.com/dask/dask/issues/9373,1335417784,I_kwDOAbcwm85PmNu4,9373,Hypothesis strategy for chunking arrays in different patterns,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,4,2022-08-11T03:14:12Z,2022-09-12T02:15:17Z,,NONE,,"I often want to test some parallel dask code for input with a range of different chunking structures. This seems like a possible candidate for a general chunks strategy using the hypothesis library, that could live in `dask.array`.

We actually made a simple strategy to test various chunking structures in both [xhistogram here](https://github.com/xgcm/xhistogram/blob/0d3bf5ad9c118dccb211d30fc889963087c28dd4/xhistogram/test/test_chunking_hypotheses.py#L13) and in [rechunker here](https://github.com/pangeo-data/rechunker/blob/9d129321499a7b0be422fd159dff35e28db4cfac/tests/test_algorithm.py#L204), but now I'm wondering if there is a general solution I could implement. 

It could be useful for users testing code that works with dask arrays, or perhaps it might even be useful for testing `dask.array` internally. It would also be really useful to use in xarray's tests.

---

Dask's [rules for how they defines chunk shapes](https://docs.dask.org/en/stable/array-chunks.html#specifying-chunk-shapes) are:

> We always specify a chunks argument to tell dask.array how to break up the underlying array into chunks. We can specify chunks in a variety of ways:
>
> 1. A uniform dimension size like `1000`, meaning chunks of size 1000 in each dimension
> 
> 2. A uniform chunk shape like `(1000, 2000, 3000)`, meaning chunks of size 1000 in the first axis, 2000 in the second axis, and 3000 in the third
>
> 3. Fully explicit sizes of all blocks along all dimensions, like `((1000, 1000, 500), (400, 400), (5, 5, 5, 5, 5))`
> 
> 4. A dictionary specifying chunk size per dimension like `{0: 1000, 1: 2000, 2: 3000}`. This is just another way of writing the forms 2 and 3 above

5. Xarray adds [another way to specify chunks](https://docs.xarray.dev/en/stable/generated/xarray.DataArray.chunksizes.html), which is the same as (4) but with string dimension names instead of integer axis names. We distinguish that representation by referring to it as `.chunksizes` instead of just `.chunks`.

I think the most generally useful form of chunk strategy should produce (3), which can then be wrapped up by the user to make (4) or (5) if desired.

I'm imagining exposing this publicly under a name like `dask.array.strategies.chunks`.

(Originally raised on the hypothesis repo, but it should probably live in dask instead. xref https://github.com/HypothesisWorks/hypothesis/issues/3433)",,https://api.github.com/repos/dask/dask/issues/9373/timeline,,,TomNicholas,35968931,MDQ6VXNlcjM1OTY4OTMx,https://avatars.githubusercontent.com/u/35968931?v=4,,https://api.github.com/users/TomNicholas,https://github.com/TomNicholas,https://api.github.com/users/TomNicholas/followers,https://api.github.com/users/TomNicholas/following{/other_user},https://api.github.com/users/TomNicholas/gists{/gist_id},https://api.github.com/users/TomNicholas/starred{/owner}{/repo},https://api.github.com/users/TomNicholas/subscriptions,https://api.github.com/users/TomNicholas/orgs,https://api.github.com/users/TomNicholas/repos,https://api.github.com/users/TomNicholas/events{/privacy},https://api.github.com/users/TomNicholas/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9373/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
653,https://api.github.com/repos/dask/dask/issues/9374,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9374/labels{/name},https://api.github.com/repos/dask/dask/issues/9374/comments,https://api.github.com/repos/dask/dask/issues/9374/events,https://github.com/dask/dask/pull/9374,1335448965,PR_kwDOAbcwm849ACBJ,9374,Hypothesis strategy for chunking arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,10,2022-08-11T04:14:43Z,2023-11-13T01:12:17Z,,FIRST_TIME_CONTRIBUTOR,,"Example of using this PR to create examples of arrays with a specific shape but arbitrary chunk structure:

```python
In [9]: arr
Out[9]: 
array([[1, 2, 3],
       [4, 5, 6]])

In [10]: from dask.array.strategies import chunks

In [11]: dask.array.from_array(arr, chunks=chunks(arr.shape).example())
Out[11]: dask.array<array, shape=(2, 3), dtype=int64, chunksize=(1, 3), chunktype=numpy.ndarray>

In [12]: dask.array.from_array(arr, chunks=chunks(arr.shape).example())
Out[12]: dask.array<array, shape=(2, 3), dtype=int64, chunksize=(2, 2), chunktype=numpy.ndarray>
```

- [x] Closes #9373
- [x] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9374/timeline,,,TomNicholas,35968931,MDQ6VXNlcjM1OTY4OTMx,https://avatars.githubusercontent.com/u/35968931?v=4,,https://api.github.com/users/TomNicholas,https://github.com/TomNicholas,https://api.github.com/users/TomNicholas/followers,https://api.github.com/users/TomNicholas/following{/other_user},https://api.github.com/users/TomNicholas/gists{/gist_id},https://api.github.com/users/TomNicholas/starred{/owner}{/repo},https://api.github.com/users/TomNicholas/subscriptions,https://api.github.com/users/TomNicholas/orgs,https://api.github.com/users/TomNicholas/repos,https://api.github.com/users/TomNicholas/events{/privacy},https://api.github.com/users/TomNicholas/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9374/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9374,https://github.com/dask/dask/pull/9374,https://github.com/dask/dask/pull/9374.diff,https://github.com/dask/dask/pull/9374.patch,,,,,,,,,,,,,,,,,,,
654,https://api.github.com/repos/dask/dask/issues/9379,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9379/labels{/name},https://api.github.com/repos/dask/dask/issues/9379/comments,https://api.github.com/repos/dask/dask/issues/9379/events,https://github.com/dask/dask/issues/9379,1337445462,I_kwDOAbcwm85Pt8xW,9379,KilledWorker error when running Groupby on 5GB dataset,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}]",open,False,,[],,2,2022-08-12T16:46:27Z,2022-08-22T20:19:41Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
When running Dask's GroupBy Query for a 5GB dataset, a KilledWorker error occurred, stopping the query from completing.

**What you expected to happen**:
The query is supposed to complete and display Dask's runtime for a groupby query.

**Minimal Complete Verifiable Example**:
Source repository required for running benchmark:  https://github.com/h2oai/db-benchmark
Run db-benchmark for Dask using ./_launcher/solution.R --solution=dask --task=groupby --nrow=1e8 

**Anything else we need to know?**:
Steps to generate 5GB dataset using linked repository (cloning the entire repository is required to generate the necessary dataset for running the query):
1. Run Rscript _data/groupby-datagen.R 1e8 1e2 0 0 in db-benchmark to create a 5GB dataset
2. Create a new directory in db-benchmark called data. Store the generated dataset in this directory.


**Environment**:

- Dask version: 2022.5.0
- Python version: 3.9.6
- Operating System: Ubuntu 20.04.3 LTS (Focal Fossa)
- Install method (conda, pip, source): Conda

<!-- If you are reporting an issue such as scale stability, cluster deadlock.
Please provide a cluster dump state with this issue, by running client.dump_cluster_state()

https://distributed.dask.org/en/stable/api.html?highlight=dump_cluster_state#distributed.Client.dump_cluster_state

-->

<details>
<summary>Cluster Dump State:</summary>

</details>
",,https://api.github.com/repos/dask/dask/issues/9379/timeline,,,RitikParmar,107498590,U_kgDOBmhMXg,https://avatars.githubusercontent.com/u/107498590?v=4,,https://api.github.com/users/RitikParmar,https://github.com/RitikParmar,https://api.github.com/users/RitikParmar/followers,https://api.github.com/users/RitikParmar/following{/other_user},https://api.github.com/users/RitikParmar/gists{/gist_id},https://api.github.com/users/RitikParmar/starred{/owner}{/repo},https://api.github.com/users/RitikParmar/subscriptions,https://api.github.com/users/RitikParmar/orgs,https://api.github.com/users/RitikParmar/repos,https://api.github.com/users/RitikParmar/events{/privacy},https://api.github.com/users/RitikParmar/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9379/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
655,https://api.github.com/repos/dask/dask/issues/9380,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9380/labels{/name},https://api.github.com/repos/dask/dask/issues/9380/comments,https://api.github.com/repos/dask/dask/issues/9380/events,https://github.com/dask/dask/issues/9380,1337480200,I_kwDOAbcwm85PuFQI,9380,ValueError when trying to reassign an index column,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,10,2022-08-12T17:06:38Z,2022-08-24T11:30:32Z,,CONTRIBUTOR,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:

The following error:
```
ValueError: The columns in the computed data do not match the columns in the provided metadata
  Extra:   [0]
  Missing: ['index']
```

**What you expected to happen**:
No error in this situation, it should compute as expected.

**Minimal Complete Verifiable Example**:
This is highly contrived, because I spent a long time reducing this error to a minimal state from my real world workflow. The `shuffle` method call here is used to represent any more complex operation like a hash join, which is more common in real usage.
```python
import pandas as pd
import dask.dataframe as dd

df = pd.DataFrame({
    ""uniprot"": [""P42684"", ""P42684"", ""P42684""]
}, index=pd.Series([""1:179108338:G>C"", ""1:179109432:C>T"", ""1:179126409:G>C""], name=""index""))
ddf = dd.from_pandas(df, npartitions=2)

uniprots = ddf.uniprot.unique()
x = uniprots.to_frame().assign(index = uniprots).set_index(""index"")
x.shuffle(x.index).compute()
```

**Anything else we need to know?**:
All parts of this weird example seem to be required. The `.unique()` call, and the fact that I start with a named index, and then I create a column with the same name as that index.

**Environment**:

- Dask version: `2022.8.0`
- Python version: `3.9.5`
- Operating System: Ubuntu 21.10
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/9380/timeline,,,multimeric,5019367,MDQ6VXNlcjUwMTkzNjc=,https://avatars.githubusercontent.com/u/5019367?v=4,,https://api.github.com/users/multimeric,https://github.com/multimeric,https://api.github.com/users/multimeric/followers,https://api.github.com/users/multimeric/following{/other_user},https://api.github.com/users/multimeric/gists{/gist_id},https://api.github.com/users/multimeric/starred{/owner}{/repo},https://api.github.com/users/multimeric/subscriptions,https://api.github.com/users/multimeric/orgs,https://api.github.com/users/multimeric/repos,https://api.github.com/users/multimeric/events{/privacy},https://api.github.com/users/multimeric/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9380/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
656,https://api.github.com/repos/dask/dask/issues/9381,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9381/labels{/name},https://api.github.com/repos/dask/dask/issues/9381/comments,https://api.github.com/repos/dask/dask/issues/9381/events,https://github.com/dask/dask/issues/9381,1337553111,I_kwDOAbcwm85PuXDX,9381,Use Blockwise in `da.store`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,1,2022-08-12T18:09:02Z,2022-09-12T02:15:15Z,,MEMBER,,"`da.store` is basically the main method for writing arrays out of dask; things like `to_zarr` use `da.store` internally, and downstream projects like xarray use it extensively. Currently, it produces low-level graphs. These graphs would be very simple to convert to Blockwise: https://github.com/dask/dask/blob/8b95f983c232c1bd628e9cba0695d3ef229d290b/dask/array/core.py#L4430-L4433

We're just mapping a function over every block, which is the simplest case for Blockwise.

This would make graph generation (if not submission, everything gets materialized right now anyway) a lot faster for large array-writing operations, and allow blockwise fusion onto input tasks.

cc @rjzamora @ian-r-rose",,https://api.github.com/repos/dask/dask/issues/9381/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9381/reactions,5,5,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
657,https://api.github.com/repos/dask/dask/issues/9382,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9382/labels{/name},https://api.github.com/repos/dask/dask/issues/9382/comments,https://api.github.com/repos/dask/dask/issues/9382/events,https://github.com/dask/dask/pull/9382,1337694654,PR_kwDOAbcwm849HfUy,9382,Blockwise `da.store`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2022-08-12T20:47:58Z,2022-08-12T20:55:37Z,,MEMBER,,"- [x] Closes #9381
- [ ] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9382/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9382/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9382,https://github.com/dask/dask/pull/9382,https://github.com/dask/dask/pull/9382.diff,https://github.com/dask/dask/pull/9382.patch,,,,,,,,,,,,,,,,,,,
658,https://api.github.com/repos/dask/dask/issues/9383,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9383/labels{/name},https://api.github.com/repos/dask/dask/issues/9383/comments,https://api.github.com/repos/dask/dask/issues/9383/events,https://github.com/dask/dask/issues/9383,1337965221,I_kwDOAbcwm85Pv7ql,9383,dataframe.read_sql_query does not work with datetime index,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,2,2022-08-13T13:27:32Z,2022-09-02T15:48:20Z,,NONE,,"**What happened**:

Dask failed to read_sql_query for a datetime index.

See SO question [here](https://stackoverflow.com/questions/73340732/loading-dask-dataframe-with-sqlalchemy-fails/73344622#73344622) (not mine, only reporting from it), and MCVE below.

**What you expected to happen**:

Dask reads the database and returns a df.

**Minimal Complete Verifiable Example**:

```py
from datetime import datetime

import dask.dataframe as dd
import pandas as pd
from sqlalchemy import Column, DateTime, Integer, create_engine, select
from sqlalchemy.orm import Session, declarative_base

Base = declarative_base()


class Loan(Base):
    __tablename__ = ""test_loans""
    id = Column(Integer, primary_key=True)
    date = Column(DateTime)
    balance = Column(Integer)


engine = create_engine(""sqlite:////tmp/so.db"", future=True, echo=True)

Base.metadata.create_all(engine)

with Session(engine) as session:
    session.add_all(
        [
            Loan(date=datetime.min, balance=10),
            Loan(date=datetime.min, balance=11),
            Loan(date=datetime.min, balance=12),
            Loan(date=datetime.min, balance=13),
        ]
    )
    session.commit()

dd.read_sql_query(
    select([Loan.date, Loan.balance]),
    con=""sqlite:////tmp/so.db"",
    index_col=""date"",
    npartitions=3,
    engine_kwargs={""echo"": True},
)
```

**Anything else we need to know?**:

The issue appears to come from this block which calculates the limits before dividing them into partitions:

https://github.com/dask/dask/blob/8b95f983c232c1bd628e9cba0695d3ef229d290b/dask/dataframe/io/sql.py#L130-L137

Which essentially runs the following:

```py
pd.read_sql(select([func.min(Loan.date), func.max(Loan.date)]), con=engine.connect())
```

Whose output is 

```none
                 min_1                max_1
0  0001-01-01 00:00:00  0001-01-01 00:00:00
```

and dtypes are objects since by default the `parse_dates` kwarg is None and datetimes don't get parsed 

```none
min_1    object
max_1    object
dtype: object
```

With dtype being `object` then dask falls to 

https://github.com/dask/dask/blob/8b95f983c232c1bd628e9cba0695d3ef229d290b/dask/dataframe/io/sql.py#L160-L164

and raises the exception.

**Environment**:

- Dask version: dask-2022.8.0
- Python version: 3.10.5
- Operating System: N/A
- Install method (conda, pip, source): pip",,https://api.github.com/repos/dask/dask/issues/9383/timeline,,,ljmc-github,26164870,MDQ6VXNlcjI2MTY0ODcw,https://avatars.githubusercontent.com/u/26164870?v=4,,https://api.github.com/users/ljmc-github,https://github.com/ljmc-github,https://api.github.com/users/ljmc-github/followers,https://api.github.com/users/ljmc-github/following{/other_user},https://api.github.com/users/ljmc-github/gists{/gist_id},https://api.github.com/users/ljmc-github/starred{/owner}{/repo},https://api.github.com/users/ljmc-github/subscriptions,https://api.github.com/users/ljmc-github/orgs,https://api.github.com/users/ljmc-github/repos,https://api.github.com/users/ljmc-github/events{/privacy},https://api.github.com/users/ljmc-github/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9383/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
659,https://api.github.com/repos/dask/dask/issues/9384,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9384/labels{/name},https://api.github.com/repos/dask/dask/issues/9384/comments,https://api.github.com/repos/dask/dask/issues/9384/events,https://github.com/dask/dask/issues/9384,1337995023,I_kwDOAbcwm85PwC8P,9384,Provide `DataFrame.to_pickle`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,7,2022-08-13T15:52:26Z,2022-09-19T02:15:04Z,,CONTRIBUTOR,,"Currently the best supported way to store the distributed dataframe to disk is using `to_parquet`. This is great, but there are some use cases where pickle would work better, for example when the dataframe contains native Python types that aren't easily represented in parquet. Also, the type inference for parquet isn't perfect, so often an `object` dtype that is e.g. clearly a `list[str]` gets inferred as a string and serialization fails. Pickle serialization ideally would Just Work in a way that parquet doesn't necessarily.

The implementation I imagine would be fairly easy. Each partition is a dataframe, and so we can just `df.to_pickle` each of these into a separate pickle file. In fact, it seems like other output formats that pandas already supports could be supported in dask in the same way. Is there some difficult part of this that I'm missing? I would be happy to work on this feature if it's feasible for someone like me who isn't intimately familiar with the library internals.",,https://api.github.com/repos/dask/dask/issues/9384/timeline,,,multimeric,5019367,MDQ6VXNlcjUwMTkzNjc=,https://avatars.githubusercontent.com/u/5019367?v=4,,https://api.github.com/users/multimeric,https://github.com/multimeric,https://api.github.com/users/multimeric/followers,https://api.github.com/users/multimeric/following{/other_user},https://api.github.com/users/multimeric/gists{/gist_id},https://api.github.com/users/multimeric/starred{/owner}{/repo},https://api.github.com/users/multimeric/subscriptions,https://api.github.com/users/multimeric/orgs,https://api.github.com/users/multimeric/repos,https://api.github.com/users/multimeric/events{/privacy},https://api.github.com/users/multimeric/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9384/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
660,https://api.github.com/repos/dask/dask/issues/9387,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9387/labels{/name},https://api.github.com/repos/dask/dask/issues/9387/comments,https://api.github.com/repos/dask/dask/issues/9387/events,https://github.com/dask/dask/pull/9387,1340751260,PR_kwDOAbcwm849RYla,9387,[DNM] Avoid implicit compute in `Array.__bool__`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,15,2022-08-16T18:54:23Z,2022-08-22T21:06:05Z,,MEMBER,,"When looking through https://github.com/dask/dask/pull/9351 I noticed that we're currently triggering implicit `compute`s in `Array.__bool__` for Dask arrays with size 1. This is particularly confusing as it can be easy to trigger these (potentially large) computations when using in an `if`-statement. 

I'm curious to see how much of our test suite fails when we don't allow this type of implicit compute. 

Also cc @jakirkham who has previously commented on this behavior https://github.com/dask/dask/pull/2958#issuecomment-349061303 and may have thoughts on this topic 

",,https://api.github.com/repos/dask/dask/issues/9387/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9387/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9387,https://github.com/dask/dask/pull/9387,https://github.com/dask/dask/pull/9387.diff,https://github.com/dask/dask/pull/9387.patch,,,,,,,,,,,,,,,,,,,
661,https://api.github.com/repos/dask/dask/issues/9392,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9392/labels{/name},https://api.github.com/repos/dask/dask/issues/9392/comments,https://api.github.com/repos/dask/dask/issues/9392/events,https://github.com/dask/dask/issues/9392,1341988538,I_kwDOAbcwm85P_R66,9392,Warn if the number of categories in a categorical column is large,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,0,2022-08-17T16:04:12Z,2022-08-22T11:28:21Z,,MEMBER,,"While testing #9302 I ran into some undesirable behavior around categoricals, which I have seen in the wild:

If a user converts a column with high-cardinality (`n_groups ~ len`) into a categorical dtype, then *each partition* carries around the whole list of different categories, which is many. So in the degenerate case where `n_groups == len`, each partition basically has a whole copy of a categorical column. Not only is that memory-inefficient, but it also incurs a heavy performance hit from copying and moving all of the duplicated data.

```python
import time

import dask.dataframe as dd
import pandas as pd

df = pandas.DataFrame({""a"": range(1_000_000), ""b"": range(1_000_000)}).astype({""a"": str})

ddf = dd.from_pandas(df, npartitions=10)
ddf2 = ddf.categorize(columns=[""a""])

print(ddf.memory_usage().compute().sum() / 1024**2)  # 15 MB
print(ddf2.memory_usage().compute().sum() / 1024**2)  # 410 MB

start = time.time()
ddf.groupby(""a"").mean().compute()
end = time.time()
print(end-start)  # 2 seconds

start = time.time()
ddf2.groupby(""a"").mean().compute()
end = time.time()
print(end-start)  # 23 seconds
```

I think the correct thing to do here is show a huge blinking warning to the user when the number of categories is large compared to partition sizes.",,https://api.github.com/repos/dask/dask/issues/9392/timeline,,,ian-r-rose,5728311,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9392/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
662,https://api.github.com/repos/dask/dask/issues/9393,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9393/labels{/name},https://api.github.com/repos/dask/dask/issues/9393/comments,https://api.github.com/repos/dask/dask/issues/9393/events,https://github.com/dask/dask/issues/9393,1342083979,I_kwDOAbcwm85P_pOL,9393,Is there a good way to issue a warning from a task?,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,8,2022-08-17T17:41:03Z,2023-03-31T09:27:06Z,,MEMBER,,"We have a number of places where we issue user warnings during graph construction time that a user may not be doing what they want to be doing (e.g., [here](https://github.com/dask/dask/blob/785c8456ea2f62e41b0110b07e883eea42f969d2/dask/array/reshape.py#L261-L272)). But in some cases, we may not have all the information we need to issue a warning until a task is actually executed (e.g., it may be based on a dataframe partition length which is unknown at construction time).

If I'm running a single-machine scheduler, I can just use `warnings.warn`, and I get what I want:
```python
import warnings
import dask


@dask.delayed
def do_expensive_thing():
    warnings.warn(""Are you sure you want to do this?"")
    return 10

dask.compute(do_expensive_thing(), scheduler=""processes"")
```

But if I'm running with a `distributed` scheduler, that warning gets swallowed, or at least is not easy to recover. I can see the warning again if I swap `distributed.warn` for `warning.warn`:

```python
import distributed
import dask

client = distributed.Client()

@dask.delayed
def do_expensive_thing():
    distributed.warn(""Are you sure you want to do this?"")
    return 10

client.compute(do_expensive_thing())
```

However, if I'm working in the `dask/dask` collections APIs, I want to remain scheduler-agnostic, and avoid importing `distributed` all over the place. I don't think I have a good way to do that today. One possible way forward could be to create a `dask.warn` utility, along the lines of:

```python
def warn(...):
    try:
        import distributed
        distributed.warn(...)
    except ImportError:
        import warnings
        warnings.warn(...)
```

but there may be better ways.",,https://api.github.com/repos/dask/dask/issues/9393/timeline,,,ian-r-rose,5728311,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9393/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
663,https://api.github.com/repos/dask/dask/issues/9400,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9400/labels{/name},https://api.github.com/repos/dask/dask/issues/9400/comments,https://api.github.com/repos/dask/dask/issues/9400/events,https://github.com/dask/dask/issues/9400,1342683819,I_kwDOAbcwm85QB7qr,9400,Filter parquet file without statistics,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,2,2022-08-18T07:38:42Z,2022-09-15T14:04:30Z,,NONE,,"**What happened**: If there's no statistics in parquet file I get unclear error message when trying to apply filter

`TypeError: '<=' not supported between instances of 'NoneType' and 'int'`

**What you expected to happen**: no errors or more clear error message

**Minimal Complete Verifiable Example**:

```python
from pathlib import Path
import dask.dataframe as dd
import pyarrow as pa
import pandas as pd

tmp_path = Path('test_pq.parquet')
df = pd.DataFrame({
    ""A"": [1, 2, 3, 4, 5],
    ""B"": [10, 20, 30, 40, 50]
})
t = pa.Table.from_pandas(df)
pa.parquet.write_table(t, tmp_path, write_statistics=False)
ddf = dd.read_parquet(tmp_path, filters=[('A', 'in', [2, 3])])
tmp_path.unlink()
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2022.7.0
- Arrow version: 8.0.0
- Python version: 3.9.12
- Operating System: Windows 10
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/9400/timeline,,,Winand,53390,MDQ6VXNlcjUzMzkw,https://avatars.githubusercontent.com/u/53390?v=4,,https://api.github.com/users/Winand,https://github.com/Winand,https://api.github.com/users/Winand/followers,https://api.github.com/users/Winand/following{/other_user},https://api.github.com/users/Winand/gists{/gist_id},https://api.github.com/users/Winand/starred{/owner}{/repo},https://api.github.com/users/Winand/subscriptions,https://api.github.com/users/Winand/orgs,https://api.github.com/users/Winand/repos,https://api.github.com/users/Winand/events{/privacy},https://api.github.com/users/Winand/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9400/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
664,https://api.github.com/repos/dask/dask/issues/9401,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9401/labels{/name},https://api.github.com/repos/dask/dask/issues/9401/comments,https://api.github.com/repos/dask/dask/issues/9401/events,https://github.com/dask/dask/issues/9401,1342822793,I_kwDOAbcwm85QCdmJ,9401,Dask Dataframe does not support Pandas dtype 'Float32',"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2022-08-18T09:24:15Z,2024-06-03T01:49:03Z,,NONE,,"```py
pd_df = pd.DataFrame({
		'float32': pd.Series([None, 1, 4294967295], dtype=""Float32""),
		'float64': pd.Series([None, 1, 18446744073709551615], dtype=""Float64"")}
)

dd_df = dd.from_pandas(pd_df, npartitions=10)
print(dd_df['float32'].values)
# This last line caused the crash
```

**What happened**:
```
Traceback (most recent call last):
  File ""dask_test.py"", line 17, in <module>
    print(dd_df['float32'].values)
  File ""/opt/homebrew/lib/python3.9/site-packages/dask/dataframe/core.py"", line 3324, in values
    return self.map_partitions(methods.values)
  File ""/opt/homebrew/lib/python3.9/site-packages/dask/dataframe/core.py"", line 867, in map_partitions
    return map_partitions(func, self, *args, **kwargs)
  File ""/opt/homebrew/lib/python3.9/site-packages/dask/dataframe/core.py"", line 6578, in map_partitions
    return new_dd_object(graph, name, meta, divisions)
  File ""/opt/homebrew/lib/python3.9/site-packages/dask/dataframe/core.py"", line 7706, in new_dd_object
    return da.Array(dsk, name=name, chunks=chunks, dtype=meta.dtype)
  File ""/opt/homebrew/lib/python3.9/site-packages/dask/array/core.py"", line 1329, in __new__
    meta = meta_from_array(meta, dtype=dtype)
  File ""/opt/homebrew/lib/python3.9/site-packages/dask/array/utils.py"", line 57, in meta_from_array
    x = x(shape=(0,) * (ndim or 0), dtype=dtype)
TypeError: Cannot interpret 'Float32Dtype()' as a data type
```

**What you expected to happen**:
I would expect the either `from_pandas` to fail instantly, or for it to be able to work with the dtype

**Anything else we need to know?**:

**Environment**:

- Dask version: installed through `python3 -m pip install dask`
```py
>>> dask._version.version_json
'\n{\n ""dirty"": false,\n ""error"": null,\n ""full-revisionid"": ""a77ce9513745d64cb47033d5f8026b3acc5424bf"",\n ""version"": ""2022.8.0""\n}\n'
```
- Python version: 3.9.13
- Operating System: MacOS
- Install method (conda, pip, source): pip",,https://api.github.com/repos/dask/dask/issues/9401/timeline,,,Tishj,17162323,MDQ6VXNlcjE3MTYyMzIz,https://avatars.githubusercontent.com/u/17162323?v=4,,https://api.github.com/users/Tishj,https://github.com/Tishj,https://api.github.com/users/Tishj/followers,https://api.github.com/users/Tishj/following{/other_user},https://api.github.com/users/Tishj/gists{/gist_id},https://api.github.com/users/Tishj/starred{/owner}{/repo},https://api.github.com/users/Tishj/subscriptions,https://api.github.com/users/Tishj/orgs,https://api.github.com/users/Tishj/repos,https://api.github.com/users/Tishj/events{/privacy},https://api.github.com/users/Tishj/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9401/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
665,https://api.github.com/repos/dask/dask/issues/9407,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9407/labels{/name},https://api.github.com/repos/dask/dask/issues/9407/comments,https://api.github.com/repos/dask/dask/issues/9407/events,https://github.com/dask/dask/issues/9407,1344802021,I_kwDOAbcwm85QKAzl,9407,Ignore column order when reading multiple jsons to a dataframe,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,1,2022-08-19T18:59:48Z,2024-06-03T01:49:02Z,,NONE,,"I am trying reading multiple jsons to a dataframe, but got an error about mismatched columns. Here is a simple example with two json files:
`test/1.json`
```
{""a"": 0, ""b"": 1}
{""b"": 0, ""a"": 0}
``` 
And `test/2.json`
```
{""b"": 0, ""a"": 0}
{""b"": 0, ""a"": 1}
```
If I call `dd.read_json(""test/*.json"").compute()`, I will get error:
```
ValueError: The columns in the computed data do not match the columns in the provided metadata
Order of columns does not match
```
Can we ignore column order when reading multiple jsons (e.g. by sorting columns), since column order does not matter much in json?
",,https://api.github.com/repos/dask/dask/issues/9407/timeline,,,qibin-integral,55417392,MDQ6VXNlcjU1NDE3Mzky,https://avatars.githubusercontent.com/u/55417392?v=4,,https://api.github.com/users/qibin-integral,https://github.com/qibin-integral,https://api.github.com/users/qibin-integral/followers,https://api.github.com/users/qibin-integral/following{/other_user},https://api.github.com/users/qibin-integral/gists{/gist_id},https://api.github.com/users/qibin-integral/starred{/owner}{/repo},https://api.github.com/users/qibin-integral/subscriptions,https://api.github.com/users/qibin-integral/orgs,https://api.github.com/users/qibin-integral/repos,https://api.github.com/users/qibin-integral/events{/privacy},https://api.github.com/users/qibin-integral/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9407/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
666,https://api.github.com/repos/dask/dask/issues/9412,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9412/labels{/name},https://api.github.com/repos/dask/dask/issues/9412/comments,https://api.github.com/repos/dask/dask/issues/9412/events,https://github.com/dask/dask/issues/9412,1346697015,I_kwDOAbcwm85QRPc3,9412,Support ndarrays of Delayed objects in `da.from_delayed`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1968982461, 'node_id': 'MDU6TGFiZWwxOTY4OTgyNDYx', 'url': 'https://api.github.com/repos/dask/dask/labels/delayed', 'name': 'delayed', 'color': '4f6edd', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2022-08-22T16:37:18Z,2024-06-03T01:49:01Z,,MEMBER,,"Currently, `da.from_delayed` is not an inverse function of `da.to_delayed`.

`da.to_delayed` returns a NumPy array, with object dtype, where each element is a Delayed object referring to that chunk of the array.

But `da.from_delayed` only accepts a single Delayed object, representing a single chunk of the array. You'd have to map this over every Delayed object, then use `da.stack` to combine them all together. Not only is this inconvenient, it's also much less performant: the `stack` operation will add unnecessary complexity to the graph, plus will be quite slow to run for large numbers of chunks: https://github.com/dask/dask/issues/5913#issuecomment-587360588.

It would make sense for `from_delayed` to have a fastpath if the input is a NumPy array of `Delayed`s, which would add minimal (or, when possible, zero) complexity to the graph, and at most 1 extra HLG layer.

cc @ian-r-rose @jsignell ",,https://api.github.com/repos/dask/dask/issues/9412/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9412/reactions,3,3,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
667,https://api.github.com/repos/dask/dask/issues/9415,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9415/labels{/name},https://api.github.com/repos/dask/dask/issues/9415/comments,https://api.github.com/repos/dask/dask/issues/9415/events,https://github.com/dask/dask/issues/9415,1346913587,I_kwDOAbcwm85QSEUz,9415,Array `__setitem__` with increment produces invalid HighLevelGraph,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2022-08-22T20:00:48Z,2024-06-03T01:49:00Z,,MEMBER,,"```python
def test_setitem_graph():
    x = da.zeros((5, 6), chunks=2)
    x[:2, :2] += 1
    print(x.compute())
    x.dask.validate()
```
```
__________________________________________________________________________ test_setitem_graph ___________________________________________________________________________

    def test_setitem_graph():
        x = da.zeros((5, 6), chunks=2)
        x[:2, :2] += 1
        print(x.compute())
>       x.dask.validate()

dask/array/tests/test_array_core.py:3930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = HighLevelGraph with 2 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x7fb84868f760>
 0. zeros_like-d8b18cf0588d45640dcafeece0670151
 1. setitem-fb20006370f594832623bd9f95c02dbb


    def validate(self):
        # Check dependencies
        for layer_name, deps in self.dependencies.items():
            if layer_name not in self.layers:
                raise ValueError(
                    f""dependencies[{repr(layer_name)}] not found in layers""
                )
            for dep in deps:
                if dep not in self.dependencies:
                    raise ValueError(f""{repr(dep)} not found in dependencies"")
    
        for layer in self.layers.values():
            assert hasattr(layer, ""annotations"")
    
        # Re-calculate all layer dependencies
        dependencies = compute_layer_dependencies(self.layers)
    
        # Check keys
        dep_key1 = self.dependencies.keys()
        dep_key2 = dependencies.keys()
        if dep_key1 != dep_key2:
            raise ValueError(
                f""incorrect dependencies keys {set(dep_key1)!r} ""
                f""expected {set(dep_key2)!r}""
            )
    
        # Check values
        for k in dep_key1:
            if self.dependencies[k] != dependencies[k]:
>               raise ValueError(
                    f""incorrect dependencies[{repr(k)}]: {repr(self.dependencies[k])} ""
                    f""expected {repr(dependencies[k])}""
                )
E               ValueError: incorrect dependencies['setitem-fb20006370f594832623bd9f95c02dbb']: {'zeros_like-d8b18cf0588d45640dcafeece0670151'} expected set()

dask/highlevelgraph.py:1032: ValueError
------------------------------------------------------------------------- Captured stdout call --------------------------------------------------------------------------
[[1. 1. 0. 0. 0. 0.]
 [1. 1. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0.]]
```
As you can see, it does compute correctly in this case, but the HLG validation fails.

cc @ian-r-rose @rjzamora @davidhassell",,https://api.github.com/repos/dask/dask/issues/9415/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9415/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
668,https://api.github.com/repos/dask/dask/issues/9416,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9416/labels{/name},https://api.github.com/repos/dask/dask/issues/9416/comments,https://api.github.com/repos/dask/dask/issues/9416/events,https://github.com/dask/dask/pull/9416,1347050362,PR_kwDOAbcwm849mHnv,9416,Add `numblocks=` argument to `normalize_chunks`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2022-08-22T22:11:37Z,2022-09-26T02:14:36Z,,MEMBER,,"Precursor to https://github.com/dask/dask/issues/9412. This seemed more useful than inlining all the necessary logic into `from_delayed`.

cc @ian-r-rose @jrbourbeau @jsignell

- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9416/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9416/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9416,https://github.com/dask/dask/pull/9416,https://github.com/dask/dask/pull/9416.diff,https://github.com/dask/dask/pull/9416.patch,,,,,,,,,,,,,,,,,,,
669,https://api.github.com/repos/dask/dask/issues/9417,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9417/labels{/name},https://api.github.com/repos/dask/dask/issues/9417/comments,https://api.github.com/repos/dask/dask/issues/9417/events,https://github.com/dask/dask/pull/9417,1347141895,PR_kwDOAbcwm849mbOE,9417,Support arrays of delayed objects in `da.from_delayed`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,"[{'login': 'gjoseph92', 'id': 3309802, 'node_id': 'MDQ6VXNlcjMzMDk4MDI=', 'avatar_url': 'https://avatars.githubusercontent.com/u/3309802?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/gjoseph92', 'html_url': 'https://github.com/gjoseph92', 'followers_url': 'https://api.github.com/users/gjoseph92/followers', 'following_url': 'https://api.github.com/users/gjoseph92/following{/other_user}', 'gists_url': 'https://api.github.com/users/gjoseph92/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/gjoseph92/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/gjoseph92/subscriptions', 'organizations_url': 'https://api.github.com/users/gjoseph92/orgs', 'repos_url': 'https://api.github.com/users/gjoseph92/repos', 'events_url': 'https://api.github.com/users/gjoseph92/events{/privacy}', 'received_events_url': 'https://api.github.com/users/gjoseph92/received_events', 'type': 'User', 'site_admin': False}]",,1,2022-08-23T00:03:48Z,2022-09-26T02:14:35Z,,MEMBER,,"Requires https://github.com/dask/dask/pull/9416; I'll rebase when that's merged for an easier diff

cc @ian-r-rose @jsignell

- [x] Closes #9412
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9417/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9417/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9417,https://github.com/dask/dask/pull/9417,https://github.com/dask/dask/pull/9417.diff,https://github.com/dask/dask/pull/9417.patch,,gjoseph92,3309802.0,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False
670,https://api.github.com/repos/dask/dask/issues/9420,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9420/labels{/name},https://api.github.com/repos/dask/dask/issues/9420/comments,https://api.github.com/repos/dask/dask/issues/9420/events,https://github.com/dask/dask/issues/9420,1348089656,I_kwDOAbcwm85QWjc4,9420,Policy for handling backwards incompatible API changes in upstream libraries,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-08-23T14:53:39Z,2022-09-26T02:14:34Z,,MEMBER,,"Originally noted by @ian-r-rose and @jsignell in https://github.com/dask/dask/pull/9366#pullrequestreview-1065912197:

>  I think we should reconsider some of the policies around all of these backwards incompatibility checks, and probably phase some of them out.

> It would be good to create a policy for how Dask should handle this kind of API change.",,https://api.github.com/repos/dask/dask/issues/9420/timeline,,,pavithraes,33131404,MDQ6VXNlcjMzMTMxNDA0,https://avatars.githubusercontent.com/u/33131404?v=4,,https://api.github.com/users/pavithraes,https://github.com/pavithraes,https://api.github.com/users/pavithraes/followers,https://api.github.com/users/pavithraes/following{/other_user},https://api.github.com/users/pavithraes/gists{/gist_id},https://api.github.com/users/pavithraes/starred{/owner}{/repo},https://api.github.com/users/pavithraes/subscriptions,https://api.github.com/users/pavithraes/orgs,https://api.github.com/users/pavithraes/repos,https://api.github.com/users/pavithraes/events{/privacy},https://api.github.com/users/pavithraes/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9420/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
671,https://api.github.com/repos/dask/dask/issues/9422,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9422/labels{/name},https://api.github.com/repos/dask/dask/issues/9422/comments,https://api.github.com/repos/dask/dask/issues/9422/events,https://github.com/dask/dask/pull/9422,1349236420,PR_kwDOAbcwm849tWBv,9422,Forbid columns with duplicate names,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,19,2022-08-24T10:44:42Z,2024-06-03T01:48:58Z,,CONTRIBUTOR,,"- [x] Closes #9331 and #9122
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

This PR prevents building frames with duplicate column names, raising a `ValueError` and informing about the duplicities. 

To do so, it relies on a new internal method `DataFrame._prevent_dupl_col_names()` which is invoked by the `__init__` method. This internal method has an `allow_index_name_in_cols` flag that controls whether the index is indeed allowed to have the same name as a column, or whether this is also forbidden. 

By default it IS allowed, because some join methods in `dataframe.multi` rely on this. However, when called by `from_pandas`, it is called with `False`, because it is assumed that if your Pandas dataframe index has a name, that's because it was originally a column; eventually you could reset that index to be again a column, and things should keep on working (see this [related discussion ](https://github.com/dask/dask/issues/9380)).

NOTE 1: because this is called during construction, it also works when trying to rename columns, either via `ddf.rename(columns=new_columns)` or BY setting columns directly via `ddf.columns = new_columns`. Explicit tests were added to check the `ValueError` is raised when duplicities occur as a result of renaming.

NOTE 2: there were some tests that explicitly tested what happens with column name duplicity. I followed this approach:
* If the test was exclusively intended to check behavior with duplicate columns, that test now `XFAILs` with the explicit message `dataframe does no longer support duplicate column names`.
* If the test only checked duplicate columns as a marginal case, either I deleted that particular check, or I eliminated duplicities by using unique column names, so the test keeps on working.

NOTE 3: I also added some missing annotations that don't cause any conflicts with `mypy` and for which I was fairly sure what type hints to use.",,https://api.github.com/repos/dask/dask/issues/9422/timeline,,,jorloplaz,12827365,MDQ6VXNlcjEyODI3MzY1,https://avatars.githubusercontent.com/u/12827365?v=4,,https://api.github.com/users/jorloplaz,https://github.com/jorloplaz,https://api.github.com/users/jorloplaz/followers,https://api.github.com/users/jorloplaz/following{/other_user},https://api.github.com/users/jorloplaz/gists{/gist_id},https://api.github.com/users/jorloplaz/starred{/owner}{/repo},https://api.github.com/users/jorloplaz/subscriptions,https://api.github.com/users/jorloplaz/orgs,https://api.github.com/users/jorloplaz/repos,https://api.github.com/users/jorloplaz/events{/privacy},https://api.github.com/users/jorloplaz/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9422/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9422,https://github.com/dask/dask/pull/9422,https://github.com/dask/dask/pull/9422.diff,https://github.com/dask/dask/pull/9422.patch,,,,,,,,,,,,,,,,,,,
672,https://api.github.com/repos/dask/dask/issues/9425,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9425/labels{/name},https://api.github.com/repos/dask/dask/issues/9425/comments,https://api.github.com/repos/dask/dask/issues/9425/events,https://github.com/dask/dask/issues/9425,1349872144,I_kwDOAbcwm85QdWoQ,9425,"Track whether DataFrame partitions are sorted, even if divisions are unknown?","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,8,2022-08-24T18:41:12Z,2024-06-03T01:48:57Z,,MEMBER,,"I imagine that operations like these are somewhat common:
```python
merged = dd.merge(ddf1, ddf2, on=[""a"", ""b""])
result = merged.groupby([""a"", ""b""]).apply(custom_func)
```

```python
ab = dd.merge(ddf1, ddf2, on=[""a"", ""b""])
cd = dd.merge(ddf3, ddf4, on=[""a"", ""b""])
final = dd.merge(ab, cd)
```
In these cases, there's a much faster path we could take in `groupby` and `merge` if we knew that the input was already sorted by `[""a"", ""b""]`even if we didn't know its divisions.

We just need to know that the partitions are already sorted along the index/columns in questionthat is, any given value of the group will only be found in exactly one partition. Groupby could become just a `map_partitions` in that case https://github.com/dask/dask/issues/8361, and [`merge` already is internally](https://github.com/dask/dask/blob/57ff5c2e9c550e3c76592b0affa0d45e88375e12/dask/dataframe/multi.py#L381-L390).

What if we had another parameter like `divisions`, which tracked which column(s)/index a DataFrame was sorted by, if any?
* If `df.known_divisions`, then `df.partitioned_by` would always be known
* If `df.partitioned_by`, `df.divisions` might still be unknown. This would be the case after any shuffle-based operation, namely a merge.

Then methods like `groupby` and `merge` could take advantage of this information to offer embarrassingly-parallel paths in these cases.

I know that maintaining divisions for multiple columns has been discussed before, but this seems like a much easier change to make initially, since we wouldn't be changing the meaning of current `divisions`. We could add the field, then add support for it in other methods gradually.

cc @ian-r-rose @jsignell @rjzamora @jrbourbeau

Very related to:
* https://github.com/dask/dask/issues/6246 (somewhat the same as this)
* https://github.com/dask/dask/issues/1493",,https://api.github.com/repos/dask/dask/issues/9425/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9425/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
673,https://api.github.com/repos/dask/dask/issues/9427,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9427/labels{/name},https://api.github.com/repos/dask/dask/issues/9427/comments,https://api.github.com/repos/dask/dask/issues/9427/events,https://github.com/dask/dask/pull/9427,1350020868,PR_kwDOAbcwm849v--h,9427,Avoid checking the returned sqlite dtype on all 32 bit platforms.,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2022-08-24T21:06:21Z,2022-09-26T02:14:32Z,,MEMBER,,"There's still some 32-bit linux targets in addition to win32.

- [X] Closes? #8620 It's really more of a work around, the problem of sqlite's data types not being consistent between 64 and 32 bit architectures is not fixed. This patch ignores that difference because it's pretty likely to not be that important.
- [n/a] Tests added / passed
  (test_query_with_meta was made slightly weaker on 32-bit architectures by not requiring the same dtype)
- [?] Passes `pre-commit run --all-files`

I made the patch pushed it to my own branch on github and waited for the tests to run. There's (now) one test failure that looks unrelated to this change. I think that's equivalent to the pre-commit run --all-files

(On my first try I typoed the name of int_info and there were two test failures, so I'm pretty sure the test is actually running.)
",,https://api.github.com/repos/dask/dask/issues/9427/timeline,,,detrout,975038,MDQ6VXNlcjk3NTAzOA==,https://avatars.githubusercontent.com/u/975038?v=4,,https://api.github.com/users/detrout,https://github.com/detrout,https://api.github.com/users/detrout/followers,https://api.github.com/users/detrout/following{/other_user},https://api.github.com/users/detrout/gists{/gist_id},https://api.github.com/users/detrout/starred{/owner}{/repo},https://api.github.com/users/detrout/subscriptions,https://api.github.com/users/detrout/orgs,https://api.github.com/users/detrout/repos,https://api.github.com/users/detrout/events{/privacy},https://api.github.com/users/detrout/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9427/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9427,https://github.com/dask/dask/pull/9427,https://github.com/dask/dask/pull/9427.diff,https://github.com/dask/dask/pull/9427.patch,,,,,,,,,,,,,,,,,,,
674,https://api.github.com/repos/dask/dask/issues/9434,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9434/labels{/name},https://api.github.com/repos/dask/dask/issues/9434/comments,https://api.github.com/repos/dask/dask/issues/9434/events,https://github.com/dask/dask/issues/9434,1351494590,I_kwDOAbcwm85Qjiu-,9434,Specifying `resources` kwarg in client.submit() prevents the job from completing,"[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,7,2022-08-25T22:04:43Z,2024-05-27T01:47:42Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
- The future is put into the ""pending"" state and remains that way indefinitely.
- Consequently, the call to `gather()` never returns.
- No mentions of the job's existence appear in the web UI.
- This behavior seems consistent regardless of how the ""MEMORY"" resource is configured on client workers (>20, <20, or not at all)

**What you expected to happen**:
If ""MEMORY"" is a configured resource >=20 on at least one worker:
- The job is assigned to that worker(s)
- The future is put into a completed state shortly thereafter
- The future's result is 42

Otherwise:
- The future is cancelled as the current state of the cluster will never be able to process the task given the resources available

**Minimal Complete Verifiable Example**:

```python
from dask.distributed import Client

def some_task():
    return 42

dask_client = Client()
job = dask_client.submit(some_task, resources={'MEMORY': 20})
dask_client.gather(job)
print(job.result())
```

**Anything else we need to know?**:
- Tried as well using dask annotations with same result
- The issue persists even when requesting `resources={'MEMORY': 0}`
- If you remove the ""resources"" kwarg entirely, this works as expected

**Attempts**

Tried running against the local client as shown above, with no ""MEMORY"" resource configured:
- The most recent log was:
> distributed.scheduler - INFO - Receive client connection: Client-320f56ab-24b9-11ed-aaed-0233a8571446
  - The cluster dump reports receipt of the task:
```
<TaskState 'some_task-b97c61448795b10cddb590d67d5cf67b' no-worker>
```

Tried running against a cluster, whose workers were launched with the environment variable `DASK_DISTRIBUTED__WORKER__RESOURCES__MEMORY=32` per [the documentation](https://distributed.dask.org/en/stable/resources.html):
- Identical symptoms

**Environment**:

- First try on Dask version: 2022.6.0, Python version: 3.9.7
- Second try on Dask version: 2022.7.0, Python version: 3.10.4 (default install to new conda env on this distro as of writing)
- Operating System: Ubuntu 20.04.4 LTS on AWS (GNU/Linux 5.13.0-1021-aws x86_64)
- Install method (conda, pip, source): conda

<!-- If you are reporting an issue such as scale stability, cluster deadlock.
Please provide a cluster dump state with this issue, by running client.dump_cluster_state()

https://distributed.dask.org/en/stable/api.html?highlight=dump_cluster_state#distributed.Client.dump_cluster_state

-->

<details>
<summary>Cluster Dump State:</summary>

</details>",,https://api.github.com/repos/dask/dask/issues/9434/timeline,,,rweisman-efp,103955597,U_kgDOBjI8jQ,https://avatars.githubusercontent.com/u/103955597?v=4,,https://api.github.com/users/rweisman-efp,https://github.com/rweisman-efp,https://api.github.com/users/rweisman-efp/followers,https://api.github.com/users/rweisman-efp/following{/other_user},https://api.github.com/users/rweisman-efp/gists{/gist_id},https://api.github.com/users/rweisman-efp/starred{/owner}{/repo},https://api.github.com/users/rweisman-efp/subscriptions,https://api.github.com/users/rweisman-efp/orgs,https://api.github.com/users/rweisman-efp/repos,https://api.github.com/users/rweisman-efp/events{/privacy},https://api.github.com/users/rweisman-efp/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9434/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
675,https://api.github.com/repos/dask/dask/issues/9440,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9440/labels{/name},https://api.github.com/repos/dask/dask/issues/9440/comments,https://api.github.com/repos/dask/dask/issues/9440/events,https://github.com/dask/dask/pull/9440,1354542225,PR_kwDOAbcwm849-8l7,9440,Type hints for read_bytes,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2022-08-29T16:08:16Z,2024-05-27T01:47:41Z,,MEMBER,,"- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9440/timeline,,,douglasdavis,3202090,MDQ6VXNlcjMyMDIwOTA=,https://avatars.githubusercontent.com/u/3202090?v=4,,https://api.github.com/users/douglasdavis,https://github.com/douglasdavis,https://api.github.com/users/douglasdavis/followers,https://api.github.com/users/douglasdavis/following{/other_user},https://api.github.com/users/douglasdavis/gists{/gist_id},https://api.github.com/users/douglasdavis/starred{/owner}{/repo},https://api.github.com/users/douglasdavis/subscriptions,https://api.github.com/users/douglasdavis/orgs,https://api.github.com/users/douglasdavis/repos,https://api.github.com/users/douglasdavis/events{/privacy},https://api.github.com/users/douglasdavis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9440/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9440,https://github.com/dask/dask/pull/9440,https://github.com/dask/dask/pull/9440.diff,https://github.com/dask/dask/pull/9440.patch,,,,,,,,,,,,,,,,,,,
676,https://api.github.com/repos/dask/dask/issues/9444,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9444/labels{/name},https://api.github.com/repos/dask/dask/issues/9444/comments,https://api.github.com/repos/dask/dask/issues/9444/events,https://github.com/dask/dask/pull/9444,1356332039,PR_kwDOAbcwm84-E91x,9444,Ignore zero sized chunks in auto_chunks,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2022-08-30T21:27:03Z,2024-05-27T01:47:40Z,,FIRST_TIME_CONTRIBUTOR,,"- [ ] Closes #xxxx
- [ ] Tests added / passed
- [x] Passes `pre-commit run --all-files`

When an array is interspersed with empty chunks, the zero-valued chunks skew the median; this accounts for that while maintaining original behavior if the array only contains empty chunks.

Test cases are yet to be added.",,https://api.github.com/repos/dask/dask/issues/9444/timeline,,,jasonkena,35003073,MDQ6VXNlcjM1MDAzMDcz,https://avatars.githubusercontent.com/u/35003073?v=4,,https://api.github.com/users/jasonkena,https://github.com/jasonkena,https://api.github.com/users/jasonkena/followers,https://api.github.com/users/jasonkena/following{/other_user},https://api.github.com/users/jasonkena/gists{/gist_id},https://api.github.com/users/jasonkena/starred{/owner}{/repo},https://api.github.com/users/jasonkena/subscriptions,https://api.github.com/users/jasonkena/orgs,https://api.github.com/users/jasonkena/repos,https://api.github.com/users/jasonkena/events{/privacy},https://api.github.com/users/jasonkena/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9444/reactions,0,0,0,0,0,0,0,0,0,jasonkena,35003073.0,MDQ6VXNlcjM1MDAzMDcz,https://avatars.githubusercontent.com/u/35003073?v=4,,https://api.github.com/users/jasonkena,https://github.com/jasonkena,https://api.github.com/users/jasonkena/followers,https://api.github.com/users/jasonkena/following{/other_user},https://api.github.com/users/jasonkena/gists{/gist_id},https://api.github.com/users/jasonkena/starred{/owner}{/repo},https://api.github.com/users/jasonkena/subscriptions,https://api.github.com/users/jasonkena/orgs,https://api.github.com/users/jasonkena/repos,https://api.github.com/users/jasonkena/events{/privacy},https://api.github.com/users/jasonkena/received_events,User,False,False,https://api.github.com/repos/dask/dask/pulls/9444,https://github.com/dask/dask/pull/9444,https://github.com/dask/dask/pull/9444.diff,https://github.com/dask/dask/pull/9444.patch,,,,,,,,,,,,,,,,,,,
677,https://api.github.com/repos/dask/dask/issues/9450,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9450/labels{/name},https://api.github.com/repos/dask/dask/issues/9450/comments,https://api.github.com/repos/dask/dask/issues/9450/events,https://github.com/dask/dask/issues/9450,1358184175,I_kwDOAbcwm85Q9D7v,9450,Change `split_every=False` default for DataFrame reductions like `mean`?,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,4,2022-09-01T03:10:35Z,2022-10-03T02:13:33Z,,MEMBER,,"Most DataFrame reductions like `mean`, `count`, etc. use a hardcoded `split_every=False` default. This means that we'll apply the reduction to every partiton, then in a single task, combine all those results into one.

This makes sense because it keeps the graph smaller. And the intermediate results should be tiny (a single row), so transferring them is relatively cheap. It's ideal for a local scheduler.

### `split_every=False` (current)
![mydask](https://user-images.githubusercontent.com/3309802/187822585-d540d515-d849-40ea-b437-503c708f55d6.png)
### `split_every=None`
![mydask](https://user-images.githubusercontent.com/3309802/187822522-df288e83-65d1-4a2c-a858-099588aa93a0.png)

The problem is that this doesn't overlap communication and computation well when you have large numbers of partitions in a distributed cluster.
1. The final task can't be scheduled until every input is done. **This means none of the transfers can start until every input is already done.**
2. The final task has to transfer lots of individual keys from many different workers. Workers have limits on how many other workers they're allowed to talk to at once (and how much data they're allowed to gather at once). Trying to fetch 1k or 10k dependencies as input to a single task could be quite slow, even if each input is very small, especially when there are many workers.

Whereas with a tree reduction, you can start reducing before all the inputs are done (overlapping communication and computation), and avoid the massive all-to-one transfers.

So I'm wondering if we should change the `split_every=False` default for reductions like `sum`, `mean`, etc. Perhaps `None` (to use the default), or perhaps something higher (16? 32?) to recognize that the pieces of data being transferred are small, so we can combine more of them at once and have a smaller graph.

cc @jrbourbeau @ian-r-rose @jsignell @rjzamora",,https://api.github.com/repos/dask/dask/issues/9450/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9450/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
678,https://api.github.com/repos/dask/dask/issues/9454,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9454/labels{/name},https://api.github.com/repos/dask/dask/issues/9454/comments,https://api.github.com/repos/dask/dask/issues/9454/events,https://github.com/dask/dask/issues/9454,1360418223,I_kwDOAbcwm85RFlWv,9454,bilinear interpolation in dask,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,8,2022-09-02T16:48:23Z,2022-10-10T02:14:19Z,,NONE,,"anyone have ever programmed a bilinear interpolation using dask? I have this function where im is 2D dask array (an image)  and uv is a tuple of 2 1D dask arrays, say (u,v) which are in an irregular space:
```python
import dask.array as da
import numpy as np


def bilinear_interpolate(im: da.Array, uv: tuple) -> da.Array:

    u0 = da.floor(uv[0]).astype(np.int32)
    u1 = u0 + 1
    v0 = da.floor(uv[1]).astype(np.int32)
    v1 = v0 + 1

    u0 = da.clip(u0, 0, im.shape[1] - 1)
    u1 = da.clip(u1, 0, im.shape[1] - 1)
    v0 = da.clip(v0, 0, im.shape[0] - 1)
    v1 = da.clip(v1, 0, im.shape[0] - 1)

    Ia = im[v0, u0]
    Ib = im[v1, u0]
    Ic = im[v0, u1]
    Id = im[v1, u1]

    wa = (u1 - uv[0]) * (v1 - uv[1])
    wb = (u1 - uv[0]) * (uv[1] - v0)
    wc = (uv[0] - u0) * (v1 - uv[1])
    wd = (uv[0] - u0) * (uv[1] - v0)

    return wa * Ia + wb * Ib + wc * Ic + wd * Id
```
The output of this function must have the same shape of one of the 1D arrays.

The problem is that this part of the code has a problem since these lines
```python
Ia = im[v0, u0]
Ib = im[v1, u0]
Ic = im[v0, u1]
Id = im[v1, u1]
```
are throwing the dask does not support fancy indexing. Has anyone ever been able to make a bilinear interpolation with dask bypassing the fancy indexing error? Cheers",,https://api.github.com/repos/dask/dask/issues/9454/timeline,,,miguelcarcamov,5432126,MDQ6VXNlcjU0MzIxMjY=,https://avatars.githubusercontent.com/u/5432126?v=4,,https://api.github.com/users/miguelcarcamov,https://github.com/miguelcarcamov,https://api.github.com/users/miguelcarcamov/followers,https://api.github.com/users/miguelcarcamov/following{/other_user},https://api.github.com/users/miguelcarcamov/gists{/gist_id},https://api.github.com/users/miguelcarcamov/starred{/owner}{/repo},https://api.github.com/users/miguelcarcamov/subscriptions,https://api.github.com/users/miguelcarcamov/orgs,https://api.github.com/users/miguelcarcamov/repos,https://api.github.com/users/miguelcarcamov/events{/privacy},https://api.github.com/users/miguelcarcamov/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9454/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
679,https://api.github.com/repos/dask/dask/issues/9463,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9463/labels{/name},https://api.github.com/repos/dask/dask/issues/9463/comments,https://api.github.com/repos/dask/dask/issues/9463/events,https://github.com/dask/dask/issues/9463,1361124959,I_kwDOAbcwm85RIR5f,9463,`dask/tests/test_distributed.py::test_to_hdf_scheduler_distributed` flaky,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2022-09-04T11:49:54Z,2022-10-10T02:14:18Z,,CONTRIBUTOR,,"**What happened**:
The tests within `dask/tests/test_distributed.py::test_to_hdf_scheduler_distributed` sometimes fail in GitHub Actions, for example [here](https://github.com/dask/dask/runs/8170654687?check_suite_focus=true) and [here](https://github.com/dask/dask/runs/8172357478?check_suite_focus=true).

**What you expected to happen**:
The tests to pass every time. They pass locally and in most CI runs.

**Environment**:

- Dask version: `2022.9.0`
- Python version: `3.9`
- Operating System: `macOS`
- Install method (conda, pip, source): `conda`",,https://api.github.com/repos/dask/dask/issues/9463/timeline,,,lukeconibear,19871268,MDQ6VXNlcjE5ODcxMjY4,https://avatars.githubusercontent.com/u/19871268?v=4,,https://api.github.com/users/lukeconibear,https://github.com/lukeconibear,https://api.github.com/users/lukeconibear/followers,https://api.github.com/users/lukeconibear/following{/other_user},https://api.github.com/users/lukeconibear/gists{/gist_id},https://api.github.com/users/lukeconibear/starred{/owner}{/repo},https://api.github.com/users/lukeconibear/subscriptions,https://api.github.com/users/lukeconibear/orgs,https://api.github.com/users/lukeconibear/repos,https://api.github.com/users/lukeconibear/events{/privacy},https://api.github.com/users/lukeconibear/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9463/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
680,https://api.github.com/repos/dask/dask/issues/9467,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9467/labels{/name},https://api.github.com/repos/dask/dask/issues/9467/comments,https://api.github.com/repos/dask/dask/issues/9467/events,https://github.com/dask/dask/issues/9467,1363646158,I_kwDOAbcwm85RR5bO,9467,`to_parquet` fails to persist ordering information,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-09-06T18:11:22Z,2022-10-10T02:14:17Z,,NONE,,"**What happened**: Dask fails to persist ordering information on categorical column when using `to_parquet`

**What you expected to happen**: Ordering information should be retained.

**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import numpy as np
import dask.dataframe as dd

# Here is a dataframe with a simple categorical type.
df = pd.DataFrame({
    'category': pd.Series(['a', 'b'] * 50).astype(pd.CategoricalDtype(categories=['a','b'], ordered=True)),
    'data': np.arange(0, 100)
})

# Pandas is able to persist this data type properly retaining both the categories and the ordering info
orig_dtype = df['category'].dtype # => CategoricalDtype(categories=['a', 'b'], ordered=True)
df.to_parquet('test1.parquet')
df = pd.read_parquet('test1.parquet')
assert df['category'].dtype == orig_dtype

# Let's load this data with dask
ddf = dd.read_parquet('test1.parquet')

# If would be nice if this gave a correct dtype... but thats a different issue
ddf['category'].dtype # => CategoricalDtype(categories=['__UNKNOWN_CATEGORIES__'], ordered=False)
# Now lets save this to a new parquet file
ddf.to_parquet('test2.parquet', overwrite=True)

# Let's load the new parquet file in pandas
df = pd.read_parquet('test2.parquet')
# Hmm... the dtype isn't ordered.
df['category'].dtype # => CategoricalDtype(categories=['a', 'b'], ordered=False)
assert df['category'].dtype == orig_dtype # => Assertion Error
```

**Environment**:

- Dask version: 2022.08
- Python version: 3.9
- Operating System: Mac
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/9467/timeline,,,fny,346068,MDQ6VXNlcjM0NjA2OA==,https://avatars.githubusercontent.com/u/346068?v=4,,https://api.github.com/users/fny,https://github.com/fny,https://api.github.com/users/fny/followers,https://api.github.com/users/fny/following{/other_user},https://api.github.com/users/fny/gists{/gist_id},https://api.github.com/users/fny/starred{/owner}{/repo},https://api.github.com/users/fny/subscriptions,https://api.github.com/users/fny/orgs,https://api.github.com/users/fny/repos,https://api.github.com/users/fny/events{/privacy},https://api.github.com/users/fny/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9467/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
681,https://api.github.com/repos/dask/dask/issues/9468,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9468/labels{/name},https://api.github.com/repos/dask/dask/issues/9468/comments,https://api.github.com/repos/dask/dask/issues/9468/events,https://github.com/dask/dask/pull/9468,1363772893,PR_kwDOAbcwm84-dwu5,9468,Add compat code for unsupported groupby `dropna` cases,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2022-09-06T20:21:26Z,2024-05-27T01:47:39Z,,MEMBER,,"Adds warnings when we attempt to use `dropna=False` for groupby cases where it would fail as outlined in #8817 - this should be fixed as of pandas 1.5.0.

- [x] Closes #8817
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9468/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9468/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9468,https://github.com/dask/dask/pull/9468,https://github.com/dask/dask/pull/9468.diff,https://github.com/dask/dask/pull/9468.patch,,,,,,,,,,,,,,,,,,,
682,https://api.github.com/repos/dask/dask/issues/9470,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9470/labels{/name},https://api.github.com/repos/dask/dask/issues/9470/comments,https://api.github.com/repos/dask/dask/issues/9470/events,https://github.com/dask/dask/pull/9470,1364135643,PR_kwDOAbcwm84-e8d_,9470,bug of svd_compressed needs to fix,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-09-07T06:04:10Z,2022-10-17T02:15:38Z,,FIRST_TIMER,,"here is the bug: svd_compressed() fails for complex input #7639

and I have figured out where are the bugs and explaned how to fix this bug (maybe not the best way): https://github.com/dask/dask/issues/7639#issuecomment-1236279296",,https://api.github.com/repos/dask/dask/issues/9470/timeline,,,LUOXIAO92,89069722,MDQ6VXNlcjg5MDY5NzIy,https://avatars.githubusercontent.com/u/89069722?v=4,,https://api.github.com/users/LUOXIAO92,https://github.com/LUOXIAO92,https://api.github.com/users/LUOXIAO92/followers,https://api.github.com/users/LUOXIAO92/following{/other_user},https://api.github.com/users/LUOXIAO92/gists{/gist_id},https://api.github.com/users/LUOXIAO92/starred{/owner}{/repo},https://api.github.com/users/LUOXIAO92/subscriptions,https://api.github.com/users/LUOXIAO92/orgs,https://api.github.com/users/LUOXIAO92/repos,https://api.github.com/users/LUOXIAO92/events{/privacy},https://api.github.com/users/LUOXIAO92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9470/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9470,https://github.com/dask/dask/pull/9470,https://github.com/dask/dask/pull/9470.diff,https://github.com/dask/dask/pull/9470.patch,,,,,,,,,,,,,,,,,,,
683,https://api.github.com/repos/dask/dask/issues/9471,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9471/labels{/name},https://api.github.com/repos/dask/dask/issues/9471/comments,https://api.github.com/repos/dask/dask/issues/9471/events,https://github.com/dask/dask/issues/9471,1365061810,I_kwDOAbcwm85RXTCy,9471,`numeric_only` compatibility with `pandas=1.5`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}]",open,False,,"[{'login': 'jrbourbeau', 'id': 11656932, 'node_id': 'MDQ6VXNlcjExNjU2OTMy', 'avatar_url': 'https://avatars.githubusercontent.com/u/11656932?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/jrbourbeau', 'html_url': 'https://github.com/jrbourbeau', 'followers_url': 'https://api.github.com/users/jrbourbeau/followers', 'following_url': 'https://api.github.com/users/jrbourbeau/following{/other_user}', 'gists_url': 'https://api.github.com/users/jrbourbeau/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/jrbourbeau/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/jrbourbeau/subscriptions', 'organizations_url': 'https://api.github.com/users/jrbourbeau/orgs', 'repos_url': 'https://api.github.com/users/jrbourbeau/repos', 'events_url': 'https://api.github.com/users/jrbourbeau/events{/privacy}', 'received_events_url': 'https://api.github.com/users/jrbourbeau/received_events', 'type': 'User', 'site_admin': False}]",,7,2022-09-07T18:50:05Z,2024-05-27T01:47:38Z,,MEMBER,,"The upcoming `panads=1.5` release contains several deprecations around `pandas` use of `numeric_only` (xref https://github.com/pandas-dev/pandas/issues/46560). All of these changes are backwards compatible, so user code shouldn't break, but users will start getting lots of deprecation warnings from `dask`s internal use of `pandas` (which is scattered throughout `dask.dataframe`). Ideally, `dask` would emit the same deprecation `pandas` does and users wouldn't see any deprecations due to `dask`s internal use of `pandas`. 

There have been a few attempts at adding `numeric_only` compatibility to `dask` with `pandas=1.5` (https://github.com/dask/dask/pull/9269, https://github.com/dask/dask/pull/9271, https://github.com/dask/dask/pull/9241) but, as @rhshadrach highlights in https://github.com/pandas-dev/pandas/issues/46560#issuecomment-1180871534, exactly what the current default value is for `numeric_only` and when a deprecation warning isn't super straightforward. 

Opening a dedicated issue so we don't loose track of this issue. 

cc @rhshadrach as he appears to be leading the `numeric_only` changes upstream in `pandas`
cc @mroeschke @jorisvandenbossche in case you have thoughts ",,https://api.github.com/repos/dask/dask/issues/9471/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9471/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,jrbourbeau,11656932.0,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False
684,https://api.github.com/repos/dask/dask/issues/9473,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9473/labels{/name},https://api.github.com/repos/dask/dask/issues/9473/comments,https://api.github.com/repos/dask/dask/issues/9473/events,https://github.com/dask/dask/pull/9473,1365430288,PR_kwDOAbcwm84-jQbS,9473,[POC] Introduce partition_metadata attribute to DataFrame,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3028194444, 'node_id': 'MDU6TGFiZWwzMDI4MTk0NDQ0', 'url': 'https://api.github.com/repos/dask/dask/labels/dispatch', 'name': 'dispatch', 'color': 'fc03db', 'default': False, 'description': 'Related to `Dispatch` extension objects'}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,0,2022-09-08T02:28:58Z,2022-10-27T15:54:03Z,,MEMBER,,"This is a rough POC intended to illustrate how a new `PartitionMetadata` ~and `PartitionStatistics` classes~ class can be used to accomplish a few impactful goals in Dask-DataFrame **The Goals**:

1. Isolate DataFrame-collection metadata (`meta` and `divisions`) in one place (simplifying future expansion and possible movement into HLG/Layer)
2. Add a mechanism to track column partitioning **beyond** the conventional `divisions`. **Motivation**: #9425
3. Add a mechanism to track partition-wise statistics (e.g. partition lengths and min/max statistics for each column). **Motivation**: #5633, #6387, #7912 

If we ultimately decide that a change like this make sense, I suggest that we break the work into three distinct stages:

1. Move `meta` and `divisions` management into a new/distinct ""partition_metadata"" attribute using a new `PartitionMetadata` class (specific attribute and class names are up for debate)
2. Add `partitioned_by` functionality to `PartitionMetadata` (and therefore `DataFrame`/`Series`)
3. Add mechanism to track partition statistics to `PartitionMetadata`


**TODO**: Add a clearer breakdown of the proposed design changes, and include some explicit user-code examples.",,https://api.github.com/repos/dask/dask/issues/9473/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9473/reactions,2,0,0,0,0,0,2,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9473,https://github.com/dask/dask/pull/9473,https://github.com/dask/dask/pull/9473.diff,https://github.com/dask/dask/pull/9473.patch,,,,,,,,,,,,,,,,,,,
685,https://api.github.com/repos/dask/dask/issues/9476,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9476/labels{/name},https://api.github.com/repos/dask/dask/issues/9476/comments,https://api.github.com/repos/dask/dask/issues/9476/events,https://github.com/dask/dask/issues/9476,1366903902,I_kwDOAbcwm85ReUxe,9476,Add `dtypes=` option to `read_parquet`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,4,2022-09-08T19:44:14Z,2024-05-27T01:47:37Z,,MEMBER,,"Similar to `dd.read_csv`, we should consider making it easy for users to optionally specify `dtype`s when using `dd.read_parquet`. 

@rjzamora and I were running computations on parquet datasets that have some columns stored as `category` dtypes. However, it's known that `category` dtypes can be inefficient in some cases (for example https://github.com/dask/dask/issues/9392) so we wanted to, in this particular case, use `pyarrow[string]` `dtype` instead. This is possible today using `DataFrame.astype(...)`, which is what we used, but we thought it would be more straightforward for users to pass in `dtypes={""col-name"": ""string[pyarrow]""}` instead. This would also have the added benefit of being able to pass the desired `dtype` directly to the parquet read calls. 

We currently read in a parquet schema already and then pass that down to the I/O call. To support a `dtype=` keyword, one approach would be to take the user-provided `dtype=` specification, convert it to a `pyarrow.Schema` object, and then merge that with the `Schema` object we get from looking at the parquet metadata on disk. That merged schema object is the one we would then use when performing parquet read calls.  ",,https://api.github.com/repos/dask/dask/issues/9476/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9476/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
686,https://api.github.com/repos/dask/dask/issues/9499,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9499/labels{/name},https://api.github.com/repos/dask/dask/issues/9499/comments,https://api.github.com/repos/dask/dask/issues/9499/events,https://github.com/dask/dask/issues/9499,1374830115,I_kwDOAbcwm85R8j4j,9499,[UPSTREAM] `test_stats.py::test_two[ttest_1samp-kwargs2]` failing,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2022-09-15T17:00:18Z,2022-10-17T02:15:31Z,,MEMBER,,"Looks like Scipy modify what is accepted as `popmean` in `scipy.stats.ttest_1samp`

[`scipy=1.9.1`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ttest_1samp.html)

>popmean:float or array_like
> Expected value in null hypothesis. If array_like, then it must have the same shape as a excluding the axis dimension.


[`dev`](https://scipy.github.io/devdocs/reference/generated/scipy.stats.ttest_1samp.html)

> popmean:float or array_like
>Expected value in null hypothesis. If array_like, then its length along axis must equal 1, and it must otherwise be broadcastable with a.

To enforce that, they are doing a `np.squeeze(popmean, axis=axis) and we are getting a [raise](https://github.com/dask/dask/actions/runs/3056175429/jobs/4930062292#step:5:11384) 

```
E           ValueError: `popmean.shape[axis]` must equal 1.
```

In our test https://github.com/dask/dask/blob/982376efeb47b7a6371271728d3e05ee12d4c02a/dask/array/tests/test_stats.py#L65-L98 

```
  a = np.random.random(size=30)
  b = a[::-1] # this is popmean
```
and  we can't do `np.squeeze(b, 0)` because it raises:
```
ValueError: cannot select an axis to squeeze out which has size not equal to one
```

We need to update this code to be consistent with SciPy
https://github.com/dask/dask/blob/982376efeb47b7a6371271728d3e05ee12d4c02a/dask/array/stats.py#L105-L121
",,https://api.github.com/repos/dask/dask/issues/9499/timeline,,,ncclementi,7526622,MDQ6VXNlcjc1MjY2MjI=,https://avatars.githubusercontent.com/u/7526622?v=4,,https://api.github.com/users/ncclementi,https://github.com/ncclementi,https://api.github.com/users/ncclementi/followers,https://api.github.com/users/ncclementi/following{/other_user},https://api.github.com/users/ncclementi/gists{/gist_id},https://api.github.com/users/ncclementi/starred{/owner}{/repo},https://api.github.com/users/ncclementi/subscriptions,https://api.github.com/users/ncclementi/orgs,https://api.github.com/users/ncclementi/repos,https://api.github.com/users/ncclementi/events{/privacy},https://api.github.com/users/ncclementi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9499/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
687,https://api.github.com/repos/dask/dask/issues/9501,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9501/labels{/name},https://api.github.com/repos/dask/dask/issues/9501/comments,https://api.github.com/repos/dask/dask/issues/9501/events,https://github.com/dask/dask/issues/9501,1376396948,I_kwDOAbcwm85SCiaU,9501,Update documentation on shuffling to include p2p ,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2022-09-16T19:40:55Z,2022-10-17T02:15:29Z,,MEMBER,,"This documentation page talks about shuffling options. With ""p2p"" merged we should update it. 
https://docs.dask.org/en/stable/dataframe-groupby.html
",,https://api.github.com/repos/dask/dask/issues/9501/timeline,,,ncclementi,7526622,MDQ6VXNlcjc1MjY2MjI=,https://avatars.githubusercontent.com/u/7526622?v=4,,https://api.github.com/users/ncclementi,https://github.com/ncclementi,https://api.github.com/users/ncclementi/followers,https://api.github.com/users/ncclementi/following{/other_user},https://api.github.com/users/ncclementi/gists{/gist_id},https://api.github.com/users/ncclementi/starred{/owner}{/repo},https://api.github.com/users/ncclementi/subscriptions,https://api.github.com/users/ncclementi/orgs,https://api.github.com/users/ncclementi/repos,https://api.github.com/users/ncclementi/events{/privacy},https://api.github.com/users/ncclementi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9501/reactions,3,2,1,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
688,https://api.github.com/repos/dask/dask/issues/9502,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9502/labels{/name},https://api.github.com/repos/dask/dask/issues/9502/comments,https://api.github.com/repos/dask/dask/issues/9502/events,https://github.com/dask/dask/issues/9502,1376803191,I_kwDOAbcwm85SEFl3,9502,"The workers keep ""Waiting to connect to Scheduler"" while computing large matrix or tensor","[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2022-09-17T15:34:41Z,2022-10-24T02:14:53Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**What happened**:
The workers keep ""Waiting to connect to Scheduler"" while computing a large matrix or tensor. I'm not sure, but it seems that the scheduler can not afford to deal a huge number of task graphs. 

**What you expected to happen**:
Any scale of matrix or tensor can be computed with enough memory.

**Minimal Complete Verifiable Example**:

```python
    rs = da.random.RandomState(seed=1234,RandomState=np.random.RandomState)
    Dcut = 16
    b = 8
    T1 = rs.random(size=(Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut), chunks=(b,b,b,b,b,b,b,b))\
        + 1j*rs.random(size=(Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut), chunks=(b,b,b,b,b,b,b,b))
    T2 = rs.random(size=(Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut), chunks=(b,b,b,b,b,b,b,b))\
        + 1j*rs.random(size=(Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut), chunks=(b,b,b,b,b,b,b,b))
    T = da.einsum(""abcdijkl,efghjilk->aebfcgdh"",T1,T2)
    trace = da.einsum(""aabbccdd"",T)
    trace = trace.compute()
```
This can be computed when Dcut less equal than 12.

<details>
<summary>Full code:</summary>

```python
import sys
import datetime

from dask_mpi import initialize
from dask.utils import parse_bytes
from dask.distributed import Client
import dask.array as da
import numpy as np
import dask

if __name__ == ""__main__"":
    initialize(interface=""tofu0"",
                local_directory=""./tmp"",
                protocol=""tcp"",
                nthreads=1,
                dashboard=False,
                memory_limit=parse_bytes('621 MB')
                )
    client = Client()
    print(""client:"",client)
    
    now=datetime.datetime.now()
    with open(""result.out"",""a"") as f:
        f.write(""{:}\n"".format(now))
        
    rs = da.random.RandomState(seed=1234,RandomState=np.random.RandomState)
    Dcut = 16
    b = 8
    T1 = rs.random(size=(Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut), chunks=(b,b,b,b,b,b,b,b))\
        + 1j*rs.random(size=(Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut), chunks=(b,b,b,b,b,b,b,b))
    T2 = rs.random(size=(Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut), chunks=(b,b,b,b,b,b,b,b))\
        + 1j*rs.random(size=(Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut,Dcut), chunks=(b,b,b,b,b,b,b,b))

    T1mem=T1.nbytes/(1024**3)

    from time import time
    with open(""result.out"",""a"") as f:
        f.write(""{:}\n"".format(client))
        t0=time()
        T = da.einsum(""abcdijkl,efghjilk->aebfcgdh"",T1,T2)
        trace  = da.einsum(""aabbccdd"",T)
        print(T)
        f.write(""{:}\n"".format(T))
        trace = trace.compute()
        t1=time()
        client.close()
        print(""time:"",t1-t0,""s"")
        print(""trace:"",trace)
        f.write(""T1 mem: {:.2e} Gbytes, Dcut: {:}, trace: {:.6e} , time: {:.2e} s\n\n"".format(T1mem, Dcut, trace, t1-t0))
```
</details>

**Anything else we need to know?**:
I'm using dask_mpi.
The architecture of cpu is ARMv8-A

**Environment**:
- Dask version: 2022.9.0
- Python version: 3.9
- Operating System: Red Hat Enterprise Linux 8
- Install method (conda, pip, source): conda

<!-- If you are reporting an issue such as scale stability, cluster deadlock.
Please provide a cluster dump state with this issue, by running client.dump_cluster_state()

https://distributed.dask.org/en/stable/api.html?highlight=dump_cluster_state#distributed.Client.dump_cluster_state

-->

**Out put log:**
Since the log is too large, i have picked some important message.
<details>
<summary>Log:</summary>

```
2022-09-17 23:04:42,758 - distributed.scheduler - INFO - State start
2022-09-17 23:04:42,806 - distributed.scheduler - INFO -   Scheduler at: tcp://10.10.112.183:36955
2022-09-17 23:04:42,807 - distributed.scheduler - INFO -   dashboard at:        10.10.112.183:8787
2022-09-17 23:04:43,752 - distributed.diskutils - INFO - Found stale lock file and directory '/work/03/wo22i012/w17001/test/dask/tmp/dask-worker-space/worker-3k4_s7ea', purging
2022-09-17 23:04:43,768 - distributed.diskutils - INFO - Found stale lock file and directory '/work/03/wo22i012/w17001/test/dask/tmp/dask-worker-space/worker-kfu_yv74', purging
2022-09-17 23:04:43,790 - distributed.diskutils - INFO - Found stale lock file and directory '/work/03/wo22i012/w17001/test/dask/tmp/dask-worker-space/worker-tr24dqnr', purging
2022-09-17 23:04:43,799 - distributed.diskutils - INFO - Found stale lock file and directory '/work/03/wo22i012/w17001/test/dask/tmp/dask-worker-space/worker-hb95os2q', purging
2022-09-17 23:04:43,816 - distributed.diskutils - INFO - Found stale lock file and directory '/work/03/wo22i012/w17001/test/dask/tmp/dask-worker-space/worker-0b_iz67d', purging
2022-09-17 23:04:43,839 - distributed.worker - INFO -       Start worker at:  tcp://10.10.120.191:45861
2022-09-17 23:04:43,839 - distributed.worker - INFO -       Start worker at:  tcp://10.10.120.191:38835
2022-09-17 23:04:43,840 - distributed.worker - INFO -          Listening to:  tcp://10.10.120.191:45861
2022-09-17 23:04:43,840 - distributed.worker - INFO -          Listening to:  tcp://10.10.120.191:38835
2022-09-17 23:04:43,840 - distributed.worker - INFO -           Worker name:                        435
2022-09-17 23:04:43,840 - distributed.worker - INFO -           Worker name:                        459
2022-09-17 23:04:43,840 - distributed.worker - INFO -          dashboard at:        10.10.120.191:42959
2022-09-17 23:04:43,840 - distributed.worker - INFO -          dashboard at:        10.10.120.191:32953
2022-09-17 23:04:43,840 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:04:43,840 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:04:43,840 - distributed.worker - INFO - -------------------------------------------------
2022-09-17 23:04:43,840 - distributed.worker - INFO - -------------------------------------------------
2022-09-17 23:04:43,841 - distributed.worker - INFO -               Threads:                          1
2022-09-17 23:04:43,841 - distributed.worker - INFO -               Threads:                          1
2022-09-17 23:04:43,841 - distributed.worker - INFO -                Memory:                 592.23 MiB
2022-09-17 23:04:43,841 - distributed.worker - INFO -                Memory:                 592.23 MiB
2022-09-17 23:04:43,841 - distributed.worker - INFO -       Local Directory: /work/03/wo22i012/w17001/test/dask/tmp/dask-worker-space/worker-j01iemwx
2022-09-17 23:04:43,841 - distributed.worker - INFO -       Local Directory: /work/03/wo22i012/w17001/test/dask/tmp/dask-worker-space/worker-ty809bue
2022-09-17 23:04:43,841 - distributed.worker - INFO - -------------------------------------------------
2022-09-17 23:04:43,841 - distributed.worker - INFO - -------------------------------------------------
/work/wo22i012/w17001/.conda/envs/py3.9-dask/lib/python3.9/contextlib.py:126: UserWarning: Creating scratch directories is taking a surprisingly long time. (1.00s) This is often due to running workers on a network file system. Consider specifying a local-directory to point workers to write scratch data to a local disk.
  next(self.gen)
2022-09-17 23:04:43,839 - distributed.worker - INFO -       Start worker at:  tcp://10.10.120.143:33273
2022-09-17 23:04:43,840 - distributed.worker - INFO -          Listening to:  tcp://10.10.120.143:33273
2022-09-17 23:04:43,840 - distributed.worker - INFO -           Worker name:                        357
2022-09-17 23:04:43,840 - distributed.worker - INFO -          dashboard at:        10.10.120.143:36149
2022-09-17 23:04:43,840 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:04:43,840 - distributed.worker - INFO - -------------------------------------------------
2022-09-17 23:04:43,841 - distributed.worker - INFO -               Threads:                          1
2022-09-17 23:04:43,841 - distributed.worker - INFO -                Memory:                 592.23 MiB
2022-09-17 23:04:43,841 - distributed.worker - INFO -       Local Directory: /work/03/wo22i012/w17001/test/dask/tmp/dask-worker-space/worker-xsmvfoac
2022-09-17 23:04:43,841 - distributed.worker - INFO - -------------------------------------------------
/work/wo22i012/w17001/.conda/envs/py3.9-dask/lib/python3.9/contextlib.py:126: UserWarning: Creating scratch directories is taking a surprisingly long time. (1.01s) This is often due to running workers on a network file system. Consider specifying a local-directory to point workers to write scratch data to a local disk.
  next(self.gen)
/work/wo22i012/w17001/.conda/envs/py3.9-dask/lib/python3.9/contextlib.py:126: UserWarning: Creating scratch directories is taking a surprisingly long time. (1.01s) This is often due to running workers on a network file system. Consider specifying a local-directory to point workers to write scratch data to a local disk.
  next(self.gen)
/work/wo22i012/w17001/.conda/envs/py3.9-dask/lib/python3.9/contextlib.py:126: UserWarning: Creating scratch directories is taking a surprisingly long time. (1.01s) This is often due to running workers on a network file system. Consider specifying a local-directory to point workers to write scratch data to a local disk.
  next(self.gen)
...
2022-09-17 23:04:53,078 - distributed.scheduler - INFO - Register worker <WorkerState 'tcp://10.10.112.183:39139', name: 36, status: init, memory: 0, processing: 0>
2022-09-17 23:04:53,079 - distributed.core - INFO - Starting established connection
2022-09-17 23:04:53,080 - distributed.scheduler - INFO - Starting worker compute stream, tcp://10.10.112.183:39139
2022-09-17 23:04:53,080 - distributed.core - INFO - Starting established connection
2022-09-17 23:04:53,081 - distributed.worker - INFO -         Registered to:  tcp://10.10.112.183:36955
2022-09-17 23:04:53,081 - distributed.worker - INFO - -------------------------------------------------
2022-09-17 23:04:53,082 - distributed.scheduler - INFO - Register worker <WorkerState 'tcp://10.10.112.183:33745', name: 20, status: init, memory: 0, processing: 0>
2022-09-17 23:04:53,083 - distributed.core - INFO - Starting established connection
2022-09-17 23:04:53,084 - distributed.scheduler - INFO - Starting worker compute stream, tcp://10.10.112.183:33745
2022-09-17 23:04:53,084 - distributed.core - INFO - Starting established connection
2022-09-17 23:04:53,085 - distributed.worker - INFO -         Registered to:  tcp://10.10.112.183:36955
2022-09-17 23:04:53,085 - distributed.worker - INFO - -------------------------------------------------
2022-09-17 23:04:53,086 - distributed.scheduler - INFO - Register worker <WorkerState 'tcp://10.10.112.183:34031', name: 14, status: init, memory: 0, processing: 0>
2022-09-17 23:04:53,087 - distributed.core - INFO - Starting established connection
2022-09-17 23:04:53,088 - distributed.scheduler - INFO - Starting worker compute stream, tcp://10.10.112.183:34031
2022-09-17 23:04:53,088 - distributed.core - INFO - Starting established connection
2022-09-17 23:04:53,089 - distributed.worker - INFO -         Registered to:  tcp://10.10.112.183:36955
2022-09-17 23:04:53,089 - distributed.worker - INFO - -------------------------------------------------
2022-09-17 23:04:53,091 - distributed.core - INFO - Starting established connection
/work/wo22i012/w17001/.conda/envs/py3.9-dask/lib/python3.9/site-packages/dask/array/routines.py:328: PerformanceWarning: Increasing number of chunks by factor of 16
  intermediate = blockwise(
2022-09-17 23:04:56,126 - distributed.worker_memory - WARNING - Worker is at 84% memory usage. Pausing worker.  Process memory: 499.69 MiB -- Worker memory limit: 592.23 MiB
2022-09-17 23:04:56,145 - distributed.worker_memory - WARNING - Worker is at 83% memory usage. Pausing worker.  Process memory: 491.75 MiB -- Worker memory limit: 592.23 MiB
2022-09-17 23:04:56,218 - distributed.worker_memory - WARNING - Worker is at 87% memory usage. Pausing worker.  Process memory: 515.62 MiB -- Worker memory limit: 592.23 MiB
2022-09-17 23:04:56,624 - distributed.worker_memory - WARNING - Worker is at 84% memory usage. Pausing worker.  Process memory: 501.81 MiB -- Worker memory limit: 592.23 MiB
2022-09-17 23:05:13,865 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:13,865 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:13,866 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:13,866 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
...
2022-09-17 23:05:15,285 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:15,287 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:15,291 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:19,431 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:29,734 - distributed.worker_memory - WARNING - Unmanaged memory use is high. This may indicate a memory leak or the memory may not be released to the OS; see https://distributed.dask.org/en/latest/worker-memory.html#memory-not-released-back-to-the-os for more information. -- Unmanaged memory: 436.50 MiB -- Worker memory limit: 592.23 MiB
2022-09-17 23:05:29,735 - distributed.core - INFO - Event loop was unresponsive in Worker for 33.72s.  This is often caused by long-running GIL-holding functions or moving large chunks of data. This can cause timeouts and instability.
2022-09-17 23:05:43,991 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:43,991 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:43,991 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:43,991 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
...
2022-09-17 23:05:44,148 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:44,152 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:29,759 - distributed.worker_memory - WARNING - Unmanaged memory use is high. This may indicate a memory leak or the memory may not be released to the OS; see https://distributed.dask.org/en/latest/worker-memory.html#memory-not-released-back-to-the-os for more information. -- Unmanaged memory: 444.69 MiB -- Worker memory limit: 592.23 MiB
2022-09-17 23:05:44,024 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:05:44,026 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
...
2022-09-17 23:07:15,781 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:07:19,920 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:07:30,690 - distributed.worker_memory - WARNING - Worker is at 85% memory usage. Pausing worker.  Process memory: 504.31 MiB -- Worker memory limit: 592.23 MiB
2022-09-17 23:07:30,691 - distributed.worker_memory - WARNING - Unmanaged memory use is high. This may indicate a memory leak or the memory may not be released to the OS; see https://distributed.dask.org/en/latest/worker-memory.html#memory-not-released-back-to-the-os for more information. -- Unmanaged memory: 504.31 MiB -- Worker memory limit: 592.23 MiB
2022-09-17 23:07:30,692 - distributed.core - INFO - Event loop was unresponsive in Worker for 154.76s.  This is often caused by long-running GIL-holding functions or moving large chunks of data. This can cause timeouts and instability.
2022-09-17 23:07:44,465 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:07:44,465 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
...
2022-09-17 23:07:44,610 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:07:30,716 - distributed.worker_memory - WARNING - Unmanaged memory use is high. This may indicate a memory leak or the memory may not be released to the OS; see https://distributed.dask.org/en/latest/worker-memory.html#memory-not-released-back-to-the-os for more information. -- Unmanaged memory: 504.31 MiB -- Worker memory limit: 592.23 MiB
2022-09-17 23:07:44,479 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
...
2022-09-17 23:08:16,005 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:08:16,008 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:08:31,198 - distributed.worker_memory - WARNING - Unmanaged memory use is high. This may indicate a memory leak or the memory may not be released to the OS; see https://distributed.dask.org/en/latest/worker-memory.html#memory-not-released-back-to-the-os for more information. -- Unmanaged memory: 371.56 MiB -- Worker memory limit: 592.23 MiB
2022-09-17 23:08:31,200 - distributed.core - INFO - Event loop was unresponsive in Worker for 215.32s.  This is often caused by long-running GIL-holding functions or moving large chunks of data. This can cause timeouts and instability.
2022-09-17 23:08:44,680 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
...
2022-09-17 23:14:17,292 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:14:17,368 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:14:17,368 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
2022-09-17 23:14:17,368 - distributed.worker - INFO - Waiting to connect to:  tcp://10.10.112.183:36955
[WARN] PLE 0610 plexec The process terminated with the signal.(rank=8)(nid=0x02b20008)(sig=24)
```
</details>",,https://api.github.com/repos/dask/dask/issues/9502/timeline,,,LUOXIAO92,89069722,MDQ6VXNlcjg5MDY5NzIy,https://avatars.githubusercontent.com/u/89069722?v=4,,https://api.github.com/users/LUOXIAO92,https://github.com/LUOXIAO92,https://api.github.com/users/LUOXIAO92/followers,https://api.github.com/users/LUOXIAO92/following{/other_user},https://api.github.com/users/LUOXIAO92/gists{/gist_id},https://api.github.com/users/LUOXIAO92/starred{/owner}{/repo},https://api.github.com/users/LUOXIAO92/subscriptions,https://api.github.com/users/LUOXIAO92/orgs,https://api.github.com/users/LUOXIAO92/repos,https://api.github.com/users/LUOXIAO92/events{/privacy},https://api.github.com/users/LUOXIAO92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9502/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
689,https://api.github.com/repos/dask/dask/issues/9506,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9506/labels{/name},https://api.github.com/repos/dask/dask/issues/9506/comments,https://api.github.com/repos/dask/dask/issues/9506/events,https://github.com/dask/dask/pull/9506,1379199025,PR_kwDOAbcwm84_Q5kL,9506,Add test for issue 4845,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450421, 'node_id': 'LA_kwDOAbcwm87iZ8D1', 'url': 'https://api.github.com/repos/dask/dask/labels/hygiene', 'name': 'hygiene', 'color': 'b5ccfa', 'default': False, 'description': 'Improve code quality and reduce maintenance overhead'}]",open,False,,[],,8,2022-09-20T10:40:58Z,2024-05-20T01:46:51Z,,FIRST_TIME_CONTRIBUTOR,,"- Tests added for issue 4845

First time adding a test. I could run pytest, but it did not find this new test. Check
carefully.",,https://api.github.com/repos/dask/dask/issues/9506/timeline,,,marberi,2119690,MDQ6VXNlcjIxMTk2OTA=,https://avatars.githubusercontent.com/u/2119690?v=4,,https://api.github.com/users/marberi,https://github.com/marberi,https://api.github.com/users/marberi/followers,https://api.github.com/users/marberi/following{/other_user},https://api.github.com/users/marberi/gists{/gist_id},https://api.github.com/users/marberi/starred{/owner}{/repo},https://api.github.com/users/marberi/subscriptions,https://api.github.com/users/marberi/orgs,https://api.github.com/users/marberi/repos,https://api.github.com/users/marberi/events{/privacy},https://api.github.com/users/marberi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9506/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9506,https://github.com/dask/dask/pull/9506,https://github.com/dask/dask/pull/9506.diff,https://github.com/dask/dask/pull/9506.patch,,,,,,,,,,,,,,,,,,,
690,https://api.github.com/repos/dask/dask/issues/9508,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9508/labels{/name},https://api.github.com/repos/dask/dask/issues/9508/comments,https://api.github.com/repos/dask/dask/issues/9508/events,https://github.com/dask/dask/issues/9508,1379704885,I_kwDOAbcwm85SPKA1,9508,Experimental feature warning?,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,5,2022-09-20T16:41:47Z,2022-10-24T02:14:52Z,,MEMBER,,"When developing new functionality/algorithms it's very useful to release an initial implementation quickly in order to get early feedback from users. That helps address questions like: Does this actually solve user's problems? Does the API feel intuitive? and so on. After getting initial feedback, we then go back and improve the implementation -- fixing reported bugs, make things more robust to edge cases, etc.

However, today we're not differentiating between of these quick, initial implementations that are under development, and other stable, rock solid parts of the codebase. This means users can come across something that's still under development (e.g. our `p2p` shuffling algorithm), have a bad experience, and think to themselves ""Dask is fragile and doesn't work"".

It'd be useful if we could signal to users when they're using something that's still under development. One way to accomplish this would be to add a custom `ExperimentalFeature` warning that we emit accordingly. I'm curious what others think about this. 

cc @gjoseph92 @ian-r-rose @rjzamora @jsignell @crusaderky @fjetter in case any of you have thoughts on this topic",,https://api.github.com/repos/dask/dask/issues/9508/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9508/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
691,https://api.github.com/repos/dask/dask/issues/9509,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9509/labels{/name},https://api.github.com/repos/dask/dask/issues/9509/comments,https://api.github.com/repos/dask/dask/issues/9509/events,https://github.com/dask/dask/issues/9509,1379801108,I_kwDOAbcwm85SPhgU,9509,`DataFrame.groupby().cov()` fails with `split_out>1`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-09-20T18:05:09Z,2022-10-31T02:14:33Z,,MEMBER,,"The following fails for both `cov` and `corr` when `split_out>1`:

```python
import pandas as pd
import dask.dataframe as dd

pdf = pd.DataFrame(
  {
      ""a"": [1, 2, 6, 4, 4, 6, 4, 3, 7] * 10,
      ""b"": [4, 2, 7, 3, 3, 1, 1, 1, 2] * 10,
      ""d"": [0, 1, 2, 3, 4, 5, 6, 7, 8] * 10,
      ""c"": [0, 1, 2, 3, 4, 5, 6, 7, 8] * 10,
  },
  columns=[""c"", ""b"", ""a"", ""d""],
)

ddf = dd.from_pandas(pdf, 2)

ddf.groupby(""a"").cov(split_out=1).compute()  # Succeeds
ddf.groupby(""a"").cov(split_out=2).compute()  # Fails
```

<details>

```python-traceback
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [21], in <cell line: 17>()
     14 ddf = dd.from_pandas(pdf, 2)
     16 ddf.groupby(""a"").cov(split_out=1).compute()  # Succeeds
---> 17 ddf.groupby(""a"").cov(split_out=2).compute()

File ~/dask/dask/dask/base.py:315, in DaskMethodsMixin.compute(self, **kwargs)
    291 def compute(self, **kwargs):
    292     """"""Compute this dask collection
    293 
    294     This turns a lazy Dask collection into its in-memory equivalent.
   (...)
    313     dask.base.compute
    314     """"""
--> 315     (result,) = compute(self, traverse=False, **kwargs)
    316     return result

File ~/dask/dask/dask/base.py:600, in compute(traverse, optimize_graph, scheduler, get, *args, **kwargs)
    597     keys.append(x.__dask_keys__())
    598     postcomputes.append(x.__dask_postcompute__())
--> 600 results = schedule(dsk, keys, **kwargs)
    601 return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])

File ~/dask/dask/dask/threaded.py:89, in get(dsk, keys, cache, num_workers, pool, **kwargs)
     86     elif isinstance(pool, multiprocessing.pool.Pool):
     87         pool = MultiprocessingPoolExecutor(pool)
---> 89 results = get_async(
     90     pool.submit,
     91     pool._max_workers,
     92     dsk,
     93     keys,
     94     cache=cache,
     95     get_id=_thread_get_id,
     96     pack_exception=pack_exception,
     97     **kwargs,
     98 )
    100 # Cleanup pools associated to dead threads
    101 with pools_lock:

File ~/dask/dask/dask/local.py:511, in get_async(submit, num_workers, dsk, result, cache, get_id, rerun_exceptions_locally, pack_exception, raise_exception, callbacks, dumps, loads, chunksize, **kwargs)
    509         _execute_task(task, data)  # Re-execute locally
    510     else:
--> 511         raise_exception(exc, tb)
    512 res, worker_id = loads(res_info)
    513 state[""cache""][key] = res

File ~/dask/dask/dask/local.py:319, in reraise(exc, tb)
    317 if exc.__traceback__ is not tb:
    318     raise exc.with_traceback(tb)
--> 319 raise exc

File ~/dask/dask/dask/local.py:224, in execute_task(key, task_info, dumps, loads, get_id, pack_exception)
    222 try:
    223     task, data = loads(task_info)
--> 224     result = _execute_task(task, data)
    225     id = get_id()
    226     result = dumps((result, id))

File ~/dask/dask/dask/core.py:119, in _execute_task(arg, cache, dsk)
    115     func, args = arg[0], arg[1:]
    116     # Note: Don't assign the subtask results to a variable. numpy detects
    117     # temporaries by their reference count and can execute certain
    118     # operations in-place.
--> 119     return func(*(_execute_task(a, cache) for a in args))
    120 elif not ishashable(arg):
    121     return arg

File ~/dask/dask/dask/optimization.py:990, in SubgraphCallable.__call__(self, *args)
    988 if not len(args) == len(self.inkeys):
    989     raise ValueError(""Expected %d args, got %d"" % (len(self.inkeys), len(args)))
--> 990 return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))

File ~/dask/dask/dask/core.py:149, in get(dsk, out, cache)
    147 for key in toposort(dsk):
    148     task = dsk[key]
--> 149     result = _execute_task(task, cache)
    150     cache[key] = result
    151 result = _execute_task(out, cache)

File ~/dask/dask/dask/core.py:119, in _execute_task(arg, cache, dsk)
    115     func, args = arg[0], arg[1:]
    116     # Note: Don't assign the subtask results to a variable. numpy detects
    117     # temporaries by their reference count and can execute certain
    118     # operations in-place.
--> 119     return func(*(_execute_task(a, cache) for a in args))
    120 elif not ishashable(arg):
    121     return arg

File ~/dask/dask/dask/dataframe/core.py:6335, in hash_shard(df, nparts, split_out_setup, split_out_setup_kwargs, ignore_index)
   6332 else:
   6333     h = df
-> 6335 h = hash_object_dispatch(h, index=False)
   6336 return group_split_dispatch(df, h % nparts, nparts, ignore_index=ignore_index)

File ~/dask/dask/dask/utils.py:638, in Dispatch.__call__(self, arg, *args, **kwargs)
    634 def __call__(self, arg, *args, **kwargs):
    635     """"""
    636     Call the corresponding method based on type of argument.
    637     """"""
--> 638     meth = self.dispatch(type(arg))
    639     return meth(arg, *args, **kwargs)

File ~/dask/dask/dask/utils.py:632, in Dispatch.dispatch(self, cls)
    630         register()
    631         return self.dispatch(cls)  # recurse
--> 632 raise TypeError(f""No dispatch for {cls}"")

TypeError: No dispatch for <class 'builtin_function_or_method'>
```

</details>",,https://api.github.com/repos/dask/dask/issues/9509/timeline,,,ian-r-rose,5728311,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9509/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
692,https://api.github.com/repos/dask/dask/issues/9510,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9510/labels{/name},https://api.github.com/repos/dask/dask/issues/9510/comments,https://api.github.com/repos/dask/dask/issues/9510/events,https://github.com/dask/dask/issues/9510,1382772633,I_kwDOAbcwm85Sa2-Z,9510,Support multiple output arrays in dask.array.blockwise(),"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,1,2022-09-22T17:18:03Z,2024-05-20T01:46:50Z,,MEMBER,,"If `blockwise` supported multiple output arrays directly, we could use it to implement `xarray.map_blocks`, instead of needing to write our own custom Dask graph manipulation:
https://github.com/pydata/xarray/blob/e6791852aa7ec0b126048b0986e205e158ab9601/xarray/core/parallel.py#L164-L589

This also feels like the right basic ""primitive"" operation for implementing most distributed array operations.

`blockwise` is the low-level routine used for implementing `apply_gufunc` and `map_blocks`, so this would presumably be a broadly useful building block and would subsume https://github.com/dask/dask/issues/72",,https://api.github.com/repos/dask/dask/issues/9510/timeline,,,shoyer,1217238,MDQ6VXNlcjEyMTcyMzg=,https://avatars.githubusercontent.com/u/1217238?v=4,,https://api.github.com/users/shoyer,https://github.com/shoyer,https://api.github.com/users/shoyer/followers,https://api.github.com/users/shoyer/following{/other_user},https://api.github.com/users/shoyer/gists{/gist_id},https://api.github.com/users/shoyer/starred{/owner}{/repo},https://api.github.com/users/shoyer/subscriptions,https://api.github.com/users/shoyer/orgs,https://api.github.com/users/shoyer/repos,https://api.github.com/users/shoyer/events{/privacy},https://api.github.com/users/shoyer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9510/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
693,https://api.github.com/repos/dask/dask/issues/9512,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9512/labels{/name},https://api.github.com/repos/dask/dask/issues/9512/comments,https://api.github.com/repos/dask/dask/issues/9512/events,https://github.com/dask/dask/issues/9512,1383257629,I_kwDOAbcwm85SctYd,9512,Cumulative aggregation on SeriesGroupBy produces TypeError: assign() keywords must be strings,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-09-23T03:46:17Z,2022-10-24T02:14:51Z,,NONE,,"**What happened**:
Received the following stack trace when trying to do a cumulative aggregation on a `SeriesGroupBy` (e.g., `cumsum`, `cumprod`) in Dask. The same code runs in pandas without error. Other aggregations (e.g., `sum`, `prod`, `max`) seem to work without error in Dask.
```
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""/Users/kevfly/.pyenv/versions/3.8.9/lib/python3.8/site-packages/dask/dataframe/groupby.py"", line 1461, in cumsum
    return self._cum_agg(""cumsum"", chunk=M.cumsum, aggregate=M.add, initial=0)
  File ""/Users/kevfly/.pyenv/versions/3.8.9/lib/python3.8/site-packages/dask/dataframe/groupby.py"", line 1337, in _cum_agg
    cumpart_ext = cumpart_raw_frame.assign(
TypeError: assign() keywords must be strings
```

**What you expected to happen**:
Return a `Series` with the cumulative aggregation.

**Minimal Complete Verifiable Example**:

```
import pandas as pd
pdf = pd.DataFrame({'index': ['A', 'A', 'B'], 'start': [0,0,0], 'end': [10,10,10]})
pds = (
    pdf['start'] > pdf.groupby('index', sort=False)['end'].shift().cummax()
).groupby(pdf['index'], sort=False).cumsum()

import dask.dataframe as dd
ddf = dd.from_pandas(pdf, npartitions=1)
ddf = ddf.reset_index()
dds = (
    ddf['start'] > ddf.groupby('index', sort=False)['end'].shift(meta=('end', 'int64')).cummax()
).groupby(ddf['index'], sort=False).cumsum()
```

**Anything else we need to know?**:
This may be related to this [issue](https://github.com/dask/dask/issues/4922), but I don't know the equivalent workaround if there is one.

**Environment**:

- Dask version: 2022.9.1
- Python version: 3.8.9
- Operating System: MacOS
- Install method: pip
",,https://api.github.com/repos/dask/dask/issues/9512/timeline,,,kevfly16,5757987,MDQ6VXNlcjU3NTc5ODc=,https://avatars.githubusercontent.com/u/5757987?v=4,,https://api.github.com/users/kevfly16,https://github.com/kevfly16,https://api.github.com/users/kevfly16/followers,https://api.github.com/users/kevfly16/following{/other_user},https://api.github.com/users/kevfly16/gists{/gist_id},https://api.github.com/users/kevfly16/starred{/owner}{/repo},https://api.github.com/users/kevfly16/subscriptions,https://api.github.com/users/kevfly16/orgs,https://api.github.com/users/kevfly16/repos,https://api.github.com/users/kevfly16/events{/privacy},https://api.github.com/users/kevfly16/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9512/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
694,https://api.github.com/repos/dask/dask/issues/9515,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9515/labels{/name},https://api.github.com/repos/dask/dask/issues/9515/comments,https://api.github.com/repos/dask/dask/issues/9515/events,https://github.com/dask/dask/issues/9515,1384193669,I_kwDOAbcwm85SgR6F,9515,Groupby result disagrees with Pandas for categorical keys,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,"[{'login': 'ian-r-rose', 'id': 5728311, 'node_id': 'MDQ6VXNlcjU3MjgzMTE=', 'avatar_url': 'https://avatars.githubusercontent.com/u/5728311?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/ian-r-rose', 'html_url': 'https://github.com/ian-r-rose', 'followers_url': 'https://api.github.com/users/ian-r-rose/followers', 'following_url': 'https://api.github.com/users/ian-r-rose/following{/other_user}', 'gists_url': 'https://api.github.com/users/ian-r-rose/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/ian-r-rose/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/ian-r-rose/subscriptions', 'organizations_url': 'https://api.github.com/users/ian-r-rose/orgs', 'repos_url': 'https://api.github.com/users/ian-r-rose/repos', 'events_url': 'https://api.github.com/users/ian-r-rose/events{/privacy}', 'received_events_url': 'https://api.github.com/users/ian-r-rose/received_events', 'type': 'User', 'site_admin': False}]",,2,2022-09-23T19:00:04Z,2022-10-24T02:14:50Z,,MEMBER,,"**What happened**:

Performing a groupby aggregation on a categorical column returns a different result than Pandas.

**What you expected to happen**:

I expect the result of `dask.dataframe` to aggree with that of Pandas.

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.dataframe as dd

ddf = dask.datasets.timeseries(
    end='2000-01-02',
    freq='3600s',
    partition_freq='1d',
    seed=1,
)

# Account for https://github.com/dask/dask/issues/9514
# (a separate problem)
ddf = ddf[[""name"", ""x"", ""y""]]

# Convert name to category (problematic line)
ddf[""name""] = ddf[""name""].astype(""category"")

# Check that dask and pandas give same result
got = ddf.groupby(""name"", sort=True).agg(
    {""x"": [""mean"", ""max""], ""y"": [""mean"", ""count""]}
)
expect = ddf.compute().groupby(""name"", sort=True).agg(
    {""x"": [""mean"", ""max""], ""y"": [""mean"", ""count""]}
)
dd.assert_eq(expect, got)
```",,https://api.github.com/repos/dask/dask/issues/9515/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9515/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,ian-r-rose,5728311.0,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False
695,https://api.github.com/repos/dask/dask/issues/9517,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9517/labels{/name},https://api.github.com/repos/dask/dask/issues/9517/comments,https://api.github.com/repos/dask/dask/issues/9517/events,https://github.com/dask/dask/issues/9517,1384429089,I_kwDOAbcwm85ShLYh,9517,"Avoid expanding ""broadcast-trick"" NumPy arrays when possible","[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,0,2022-09-23T23:12:29Z,2022-10-24T02:14:49Z,,MEMBER,,"A common request for advanced dask array users is wanting some way to represent sparsely-chunked arrays (where many/most chunks contain all empty data).

As a stopgap for implementing a data structure like this, what if we made it easy to use something with a tiny memory representation for the empty chunks, and operations on or between empty chunks would preserve their tininess?

The graph wouldn't be smaller, but at least you'd spend much, much less CPU, memory, and network processing the empty parts. Plus, this could be used when loading large datasets, when you don't know in advance which chunks are going to be empty. In `from_zarr`, for example, if a chunk ends up being all 0 when read from cloud storage, it could return a ""tiny thing"" instead of a full array of 0s.

Well, turns out there already is a thing with a tiny memory representation for NumPy arrays: a ""broadcast-trick"" NumPy array. 

```python
import numpy as np
from dask.sizeof import sizeof

a = np.broadcast_to(1, (10, 10))
a.shape  # (10, 10)
sizeof(a)  # 8
sizeof(a + 1)  # 800
```

And, Dask already uses this broadcast trick internally for things like `ones`, `zeros`, `full`, etc:
https://github.com/dask/dask/blob/72832d4bd685a25000ee646966a1aa5d0d8a1793/dask/array/wrap.py#L140-L158

The problem is that right now, NumPy doesn't preserve the tininess of these things. Any operation on a broadcast-trick array materializes it into a full-size array.

But it would be pretty feasible to make basic dask operators aware of these. We'd need a small wrapper function for arithmetic operations (`__add__`, etc.), and trivial implementations for basic reductions (`sum`, `prod`, etc.).

Then, I think libraries or users could produce broadcast-trick input chunks, and everything downstream would just work. And it wouldn't break any existing code, since they're still valid NumPy arraysworst case, they just get materialized like they used to be.

Offhand, it seems that broadcast-trick-aware operations would be 5-10x fasterand, of course, use effectively no memory:

```python
In [5]: arr = np.ones(100_000)

In [6]: %timeit arr.sum()
30.1 s  1.05 s per loop (mean  std. dev. of 7 runs, 10,000 loops each)

In [7]: ae = np.broadcast_to(1, arr.shape)

In [8]: %timeit ae.sum()
30 s  206 ns per loop (mean  std. dev. of 7 runs, 10,000 loops each)

In [9]: %timeit ae.base * ae.size
651 ns  10.6 ns per loop (mean  std. dev. of 7 runs, 1,000,000 loops each)
```

```python
In [13]: %timeit arr + arr
27.2 s  496 ns per loop (mean  std. dev. of 7 runs, 10,000 loops each)

In [14]: %timeit ae + ae
46 s  310 ns per loop (mean  std. dev. of 7 runs, 10,000 loops each)

In [15]: %timeit np.broadcast_to(ae.base + ae.base, ae.shape)
4.69 s  96 ns per loop (mean  std. dev. of 7 runs, 100,000 loops each)
```

cc @ian-r-rose @jrbourbeau ",,https://api.github.com/repos/dask/dask/issues/9517/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9517/reactions,2,1,0,0,0,0,0,0,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
696,https://api.github.com/repos/dask/dask/issues/9521,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9521/labels{/name},https://api.github.com/repos/dask/dask/issues/9521/comments,https://api.github.com/repos/dask/dask/issues/9521/events,https://github.com/dask/dask/pull/9521,1389239150,PR_kwDOAbcwm84_xbcI,9521,[FEA]: external shuffle registration,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,8,2022-09-28T12:04:13Z,2022-09-28T15:37:08Z,,MEMBER,,"It is currently difficult to try out new shuffle plugins outside of
dask because one cannot easily monkey-patch into all the places that
the top-level shuffle.shuffle method is imported within dask itself.

To enable external shuffle engines, introduce a registry of known
shuffle methods that are tried in priority order. To register a new
method, one must provide a function with the same signature as
shuffle.shuffle, a priority (different from all existing registered
priorities) and a function which decides (given the requested shuffle
name, column(s) to shuffle on, and names of the dataframe columns)
whether or not a method is suitable.

- [ ] Closes #xxxx
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9521/timeline,,,wence-,1126981,MDQ6VXNlcjExMjY5ODE=,https://avatars.githubusercontent.com/u/1126981?v=4,,https://api.github.com/users/wence-,https://github.com/wence-,https://api.github.com/users/wence-/followers,https://api.github.com/users/wence-/following{/other_user},https://api.github.com/users/wence-/gists{/gist_id},https://api.github.com/users/wence-/starred{/owner}{/repo},https://api.github.com/users/wence-/subscriptions,https://api.github.com/users/wence-/orgs,https://api.github.com/users/wence-/repos,https://api.github.com/users/wence-/events{/privacy},https://api.github.com/users/wence-/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9521/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9521,https://github.com/dask/dask/pull/9521,https://github.com/dask/dask/pull/9521.diff,https://github.com/dask/dask/pull/9521.patch,,,,,,,,,,,,,,,,,,,
697,https://api.github.com/repos/dask/dask/issues/9522,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9522/labels{/name},https://api.github.com/repos/dask/dask/issues/9522/comments,https://api.github.com/repos/dask/dask/issues/9522/events,https://github.com/dask/dask/issues/9522,1389735782,I_kwDOAbcwm85S1a9m,9522,[Discussion] Cluster-aware graph logic,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2022-09-28T17:47:36Z,2022-10-31T02:14:31Z,,MEMBER,,"Historically, Dask has been execution-model agnostic when constructing graphs. This has had some notable advantages, since it means that dask task graphs/collections can be executed using any of a number of different schedulers. So the same graph can be computed using local schedulers, the distributed scheduler, and even third-party schedulers like Ray. It also enforces a certain amount of separation-of-concerns so that `dask/dask` and `dask/distributed` can be developed in a semi-independent fashion.

There is, however, some downside to this cluster-agnostic approach. Often there are specific tuning parameters and configuration options that significantly affect the performance of computations. Choosing good values for these parameters typically requires fairly advanced knowledge of Dask, its optimizations, and distributed systems in general. As developers, we would like to remove the onus from users to possess this information, but often *cannot do that without knowledge of the cluster that they will be running it on.*

One example of this that I ran into recently was with groupby/aggregations and the `split_every` parameter. It defaults to 8, but there are some easy-to-hit cases where that winds up being a [very bad choice](https://github.com/dask/dask/pull/9453#discussion_r961801460). And making a better choice requires knowing, at a minimum, the number of workers you will likely be using. This doesn't seem like an unreasonable ask for the task graph, but it's not easily available today.

Some tuning parameters which might benefit from having more context about the cluster:

* `chunks` (array creation and rechunking)
* `split_every` (array reductions)
* `merge_chunks` (array reshaping)
* `split_every`, `split_out` (dataframe reductions)
* `npartitions`, `broadcast` (dataframe merges)
* `divisions`, `npartitions`, `partition_size` (dataframe creation and repartitioning)
* `split_every` (bag reductions)
* `dataframe.parquet.metadata-task-size-remote` (parquet metadata processing)

There are some caveats to the above assertion that dask task graphs are cluster-unaware:
1. The default cluster implementation depends on whether there is an active `distributed.Client`. This usually does the right thing, but can cause problems if the graph is constructed before the client starts.
2. p2p shuffling does some out-of-task-graph work on the workers.

These are both interesting antecedents for reasoning about the execution environment, but it's not clear to me how reproducible they are in other contexts. From my perspective, I'd like to have something like the following:

1. A repeatable pattern for learning about a cluster during graph construction. Today, the default shuffle implementation goes through the dask config system, but I might want something a bit more formalized and thread-safe. It should also be able to be run on the scheduler: if we are delaying graph construction until an expression reaches the scheduler, we should be able to take advantage of more detailed information.
2. Possibly have an abstract HLG/HLE for repartitioning and rechunking. In particular, knowing some things about the number of workers and how much memory they have would help to avoid having too much or too little work-per-worker.

Some questions I don't have good answers to:

1. Even if we do have cluster information available during graph construction, can we write down good defaults for some of the tuning parameters? In some cases, maybe yes, in other cases, maybe no.
2. Is it possible all of the above is wildly overthinking things? Could a half-dozen blocks like the following do everything I want?
    ```python
    try:
        import distributed
        info = distributed.get_default_client().scheduler_info()
        # Set some defaults based on the info.
    except ImportError, ValueError:
        # Set some default defaults.
    ```
3. Is any of the above doable in the absence of HLG refactoring (cf discussion in #9159 and linked issues)? If the answer is no, I still think this is a valuable thing to think about when designing and implementing their replacement.",,https://api.github.com/repos/dask/dask/issues/9522/timeline,,,ian-r-rose,5728311,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9522/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
698,https://api.github.com/repos/dask/dask/issues/9523,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9523/labels{/name},https://api.github.com/repos/dask/dask/issues/9523/comments,https://api.github.com/repos/dask/dask/issues/9523/events,https://github.com/dask/dask/pull/9523,1389842935,PR_kwDOAbcwm84_zdPD,9523,[DNM] Flush out extension dtype issues,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,0,2022-09-28T19:24:22Z,2022-10-20T15:11:10Z,,MEMBER,,"Mutate pandas dataframes in `dd.from_pandas()` to nullable dtypes to see what in the dask test suite fails.

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9523/timeline,,,ian-r-rose,5728311,MDQ6VXNlcjU3MjgzMTE=,https://avatars.githubusercontent.com/u/5728311?v=4,,https://api.github.com/users/ian-r-rose,https://github.com/ian-r-rose,https://api.github.com/users/ian-r-rose/followers,https://api.github.com/users/ian-r-rose/following{/other_user},https://api.github.com/users/ian-r-rose/gists{/gist_id},https://api.github.com/users/ian-r-rose/starred{/owner}{/repo},https://api.github.com/users/ian-r-rose/subscriptions,https://api.github.com/users/ian-r-rose/orgs,https://api.github.com/users/ian-r-rose/repos,https://api.github.com/users/ian-r-rose/events{/privacy},https://api.github.com/users/ian-r-rose/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9523/reactions,2,1,0,0,0,0,0,0,1,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9523,https://github.com/dask/dask/pull/9523,https://github.com/dask/dask/pull/9523.diff,https://github.com/dask/dask/pull/9523.patch,,,,,,,,,,,,,,,,,,,
699,https://api.github.com/repos/dask/dask/issues/9525,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9525/labels{/name},https://api.github.com/repos/dask/dask/issues/9525/comments,https://api.github.com/repos/dask/dask/issues/9525/events,https://github.com/dask/dask/issues/9525,1390894695,I_kwDOAbcwm85S515n,9525,Dask unable to handle pytorch tensors,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-09-29T13:39:32Z,2022-11-07T02:12:48Z,,CONTRIBUTOR,,"**Problem description**

I am trying to use dask for parallelizing the training of a machine learning model. For this, I make use of pytorch tensors for the model parameters (with [`requires_grad=True`](https://pytorch.org/docs/stable/generated/torch.Tensor.requires_grad.html)). This works fine with the `single-threaded` scheduler. However, when using the `distributed` scheduler, I get:

```
torch/_tensor.py:1083: UserWarning: The .grad attribute of a Tensor that is not a leaf Tensor is being accessed. Its .grad attribute won't be populated during autograd.backward(). If you indeed want the .grad field to be populated for a non-leaf Tensor, use .retain_grad() on the non-leaf Tensor. If you access the non-leaf Tensor by mistake, make sure you access the leaf Tensor instead. See github.com/pytorch/pytorch/pull/30531 for more informations. (Triggered internally at  aten/src/ATen/core/TensorBody.h:482.)
  return self._grad
```
What I notice is that the model never learns.

**Example**

This reproduces the warning:

```python
import dask
import torch
from dask.distributed import Client


def func(x):
    return x + 2


def run(single_threaded: bool = True):
    # Set up dask scheduler
    _ = Client()
    if single_threaded:
        dask.config.set(scheduler=""single-threaded"")

    # Define tensor
    x = torch.linspace(0, 5, 10, dtype=torch.double, requires_grad=True)

    # Run function with dask
    result = []
    for xx in x:
        result.append(dask.delayed(func)(xx))
    _ = dask.compute(*result)


if __name__ == ""__main__"":
    run(single_threaded=True) 
    print(""===================="")
    run(single_threaded=False)  # this throws the warning
```

**Environment**

- Dask version: dask==2022.9.1; distributed==2022.9.1; torch==1.12.1
- Python version: 3.8.10
- Operating System: Ubuntu 20.04.3 LTS
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/9525/timeline,,,estebanag,27647769,MDQ6VXNlcjI3NjQ3NzY5,https://avatars.githubusercontent.com/u/27647769?v=4,,https://api.github.com/users/estebanag,https://github.com/estebanag,https://api.github.com/users/estebanag/followers,https://api.github.com/users/estebanag/following{/other_user},https://api.github.com/users/estebanag/gists{/gist_id},https://api.github.com/users/estebanag/starred{/owner}{/repo},https://api.github.com/users/estebanag/subscriptions,https://api.github.com/users/estebanag/orgs,https://api.github.com/users/estebanag/repos,https://api.github.com/users/estebanag/events{/privacy},https://api.github.com/users/estebanag/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9525/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
700,https://api.github.com/repos/dask/dask/issues/9529,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9529/labels{/name},https://api.github.com/repos/dask/dask/issues/9529/comments,https://api.github.com/repos/dask/dask/issues/9529/events,https://github.com/dask/dask/issues/9529,1391689770,I_kwDOAbcwm85S84Aq,9529,dask read_csv ignore broken files ,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,4,2022-09-30T01:28:59Z,2022-11-07T02:12:47Z,,NONE,,"I try to read the CSV files with,
```python
import dask.dataframe as dd
data = dd.read_csv(""*.csv.gz"",sep='\t',dtype='unicode', low_memory='true',compression='gzip',blocksize=None)
```
I have some CSV files which are broken files. I want to ignore that. It will be great if we have some function like below,

```python
import dask.dataframe as dd
data = dd.read_csv(""*.csv.gz"",sep='\t',dtype='unicode', low_memory='true',compression='gzip',blocksize=None,ignore_broken_files = True)
```
Which will skip the files that can't be read.




",,https://api.github.com/repos/dask/dask/issues/9529/timeline,,,wybert,5254627,MDQ6VXNlcjUyNTQ2Mjc=,https://avatars.githubusercontent.com/u/5254627?v=4,,https://api.github.com/users/wybert,https://github.com/wybert,https://api.github.com/users/wybert/followers,https://api.github.com/users/wybert/following{/other_user},https://api.github.com/users/wybert/gists{/gist_id},https://api.github.com/users/wybert/starred{/owner}{/repo},https://api.github.com/users/wybert/subscriptions,https://api.github.com/users/wybert/orgs,https://api.github.com/users/wybert/repos,https://api.github.com/users/wybert/events{/privacy},https://api.github.com/users/wybert/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9529/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
701,https://api.github.com/repos/dask/dask/issues/9539,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9539/labels{/name},https://api.github.com/repos/dask/dask/issues/9539/comments,https://api.github.com/repos/dask/dask/issues/9539/events,https://github.com/dask/dask/issues/9539,1395437125,I_kwDOAbcwm85TLK5F,9539,Support concat_func arg in apply_concat_apply,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,1,2022-10-03T23:01:38Z,2022-11-07T02:12:46Z,,MEMBER,,"The [apply_concat_apply](https://github.com/dask/dask/blob/bdb21aedecb36e755d49eadc5e3873192c975411/dask/dataframe/core.py#L6357) function constructs a `DataFrameTreeReductions` layer with [a wrapped version of _concat](https://github.com/dask/dask/blob/bdb21aedecb36e755d49eadc5e3873192c975411/dask/dataframe/core.py#L6524) for the `concat_func` argument. Although this is *usually* fine, the ""chunk"" and ""combine"" functions are not **required** to return `DataFrame`-like objects, and so some custom aggregations may benefit from a ""custom"" concatenation function.

Example use case: NVTabular (optionally) reduces peak GPU-memory usage by converting cudf DataFrames into pyarrow Tables between tree-reduction nodes. In this case, the ""custom"" `concat_func` will concatenate a list of pyarrow Tables and then convert the result to a single cudf DataFrame.
",,https://api.github.com/repos/dask/dask/issues/9539/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9539/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
702,https://api.github.com/repos/dask/dask/issues/9541,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9541/labels{/name},https://api.github.com/repos/dask/dask/issues/9541/comments,https://api.github.com/repos/dask/dask/issues/9541/events,https://github.com/dask/dask/issues/9541,1395493223,I_kwDOAbcwm85TLYln,9541,Multiple annotations not working as expected,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,2,2022-09-28T14:25:33Z,2024-05-20T01:46:49Z,,NONE,,"Hi, I am doing some inference on large arrays. I have some workers for GPU tasks and others for the generic ones, mainly reshaping and I/O. I notice some GPU-related code is executed on workers without the GPU, resulting in an exception.



```python

import dask
import dask.array as da
import numpy as np
from dask.distributed import Client, LocalCluster


def test_gpu(array):
    print(""test_gpu"")
    return array


def main():
    cluster = LocalCluster(
        resources={""CPU"": 1},
    )
    client = Client(cluster)

    zeros = da.zeros(10)
    with dask.annotate(resources={""GPU"": 1}):
        res = zeros.map_blocks(test_gpu, meta=np.array(()))
    with dask.annotate(resources={""CPU"": 1}):
        zarr_array = da.to_zarr(
            res,
            ""/tmp/test.zarr"",
            overwrite=True,
            return_stored=True,
        )
    zarr_array.compute(optimize_graph=False)


if __name__ == ""__main__"":
    main()

```
This is just an example that shows the issue. In this case I expect the job to be hunging, waiting for a GPU worker. Anyway the job is completed and the *print* appears on the screen.
If I change the second ```dask.annotate``` to GPU, the job waits forever.
Did I misunderstand how annotations work or is it bug?

**Environment**:

- Dask version: 2022.9.1
- Python version: 3.8.13
- Operating System: Ubuntu 20.0.4
- Install method (conda, pip, source):  conda
",,https://api.github.com/repos/dask/dask/issues/9541/timeline,,,mdrio,5130716,MDQ6VXNlcjUxMzA3MTY=,https://avatars.githubusercontent.com/u/5130716?v=4,,https://api.github.com/users/mdrio,https://github.com/mdrio,https://api.github.com/users/mdrio/followers,https://api.github.com/users/mdrio/following{/other_user},https://api.github.com/users/mdrio/gists{/gist_id},https://api.github.com/users/mdrio/starred{/owner}{/repo},https://api.github.com/users/mdrio/subscriptions,https://api.github.com/users/mdrio/orgs,https://api.github.com/users/mdrio/repos,https://api.github.com/users/mdrio/events{/privacy},https://api.github.com/users/mdrio/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9541/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
703,https://api.github.com/repos/dask/dask/issues/9546,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9546/labels{/name},https://api.github.com/repos/dask/dask/issues/9546/comments,https://api.github.com/repos/dask/dask/issues/9546/events,https://github.com/dask/dask/issues/9546,1398154880,I_kwDOAbcwm85TViaA,9546,ttest_ind with nan dimensions,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,3,2022-10-05T17:53:03Z,2022-11-07T02:12:45Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
Running ttest_ind with dask arrays that have nan dimensions produces  t-test results that are nan. 
Computing selections before taking the t-test is a workaround that produces a result that I would expect to be equivalent to the first approach.


**Minimal Complete Verifiable Example**:

```python
import dask.array as da
from dask.array.stats import ttest_ind


inputs = da.random.random(1000)
outputs = da.random.random(1000)

fromLow = outputs[ inputs < 0.5 ]
fromHigh = outputs[ inputs >= 0.5]


print( ttest_ind(fromLow, fromHigh).compute() )
###  produces ->>   Ttest_indResult(statistic=nan, pvalue=nan)

print( ttest_ind(fromLow.compute(), fromHigh.compute()).compute() )
###  produces ->>   Ttest_indResult(statistic=1.2748224533024408, pvalue=0.2026688066494705)

```

**Environment**:

- Dask version: 2022.9.1
- Python version: 3.9.13
- Operating System: macOS 11.6
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/9546/timeline,,,lrast,1191040,MDQ6VXNlcjExOTEwNDA=,https://avatars.githubusercontent.com/u/1191040?v=4,,https://api.github.com/users/lrast,https://github.com/lrast,https://api.github.com/users/lrast/followers,https://api.github.com/users/lrast/following{/other_user},https://api.github.com/users/lrast/gists{/gist_id},https://api.github.com/users/lrast/starred{/owner}{/repo},https://api.github.com/users/lrast/subscriptions,https://api.github.com/users/lrast/orgs,https://api.github.com/users/lrast/repos,https://api.github.com/users/lrast/events{/privacy},https://api.github.com/users/lrast/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9546/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
704,https://api.github.com/repos/dask/dask/issues/9548,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9548/labels{/name},https://api.github.com/repos/dask/dask/issues/9548/comments,https://api.github.com/repos/dask/dask/issues/9548/events,https://github.com/dask/dask/issues/9548,1399590846,I_kwDOAbcwm85TbA--,9548,DataFrame reppartition with timedelta division for convenience,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,3,2022-10-06T13:08:04Z,2022-11-14T02:12:10Z,,CONTRIBUTOR,,"The same way _divisions_ can be parsed as memory bytes for convenience,
I thing it could be interesting to support timedelta divisions.

Of course the _freq_ parameter is already supporting timedeltas and string version of it.

My goal would be to allow:
```
dd.repartition(divisions='10D')
# or
dd.repartition(divisions=pd.Timedelta(hours=12))
```

I am not sure if the string representation of memory bytes (10MB, etc) can conflict with the string representation of timedelta (10D, 5min, etc)",,https://api.github.com/repos/dask/dask/issues/9548/timeline,,,epizut,1694892,MDQ6VXNlcjE2OTQ4OTI=,https://avatars.githubusercontent.com/u/1694892?v=4,,https://api.github.com/users/epizut,https://github.com/epizut,https://api.github.com/users/epizut/followers,https://api.github.com/users/epizut/following{/other_user},https://api.github.com/users/epizut/gists{/gist_id},https://api.github.com/users/epizut/starred{/owner}{/repo},https://api.github.com/users/epizut/subscriptions,https://api.github.com/users/epizut/orgs,https://api.github.com/users/epizut/repos,https://api.github.com/users/epizut/events{/privacy},https://api.github.com/users/epizut/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9548/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
705,https://api.github.com/repos/dask/dask/issues/9556,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9556/labels{/name},https://api.github.com/repos/dask/dask/issues/9556/comments,https://api.github.com/repos/dask/dask/issues/9556/events,https://github.com/dask/dask/issues/9556,1400318185,I_kwDOAbcwm85Tdyjp,9556,dask.array.store() not working properly in multiprocessing mode,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,6,2022-10-06T21:24:51Z,2022-11-14T02:12:09Z,,CONTRIBUTOR,,"**Describe the issue**:

When using ``dask.array.store()`` with ``scheduler='processes'``, the output array is not modified

**Minimal Complete Verifiable Example**:

```python
import numpy as np
import dask.array as da
from multiprocessing import freeze_support
from dask.utils import SerializableLock

if __name__ == ""__main__"":

    freeze_support()

    r = da.random.random((321, 323)).rechunk((100, 100))
    o = np.zeros((321, 323))

    lock = SerializableLock()

    da.store(r, o, scheduler='processes', lock=lock)

    print(r.mean().compute())
    print(o.mean())
```

The output is:

```
0.4998744172250268
0.0
```

The ``o`` array is all zeros, as it was before calling ``da.store``. Note that this works fine if changing ``scheduler`` to ``'synchronous'``:

```
0.49971368122818133
0.49971368122818133
```

and ``'threads'`` works too.

**Environment**:

- Dask version: latest developer version (6858dc645aa23c6134cb58b364854423b506ae28)
- Python version: 3.10
- Operating System: MacOS X and Linux
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/9556/timeline,,,astrofrog,314716,MDQ6VXNlcjMxNDcxNg==,https://avatars.githubusercontent.com/u/314716?v=4,,https://api.github.com/users/astrofrog,https://github.com/astrofrog,https://api.github.com/users/astrofrog/followers,https://api.github.com/users/astrofrog/following{/other_user},https://api.github.com/users/astrofrog/gists{/gist_id},https://api.github.com/users/astrofrog/starred{/owner}{/repo},https://api.github.com/users/astrofrog/subscriptions,https://api.github.com/users/astrofrog/orgs,https://api.github.com/users/astrofrog/repos,https://api.github.com/users/astrofrog/events{/privacy},https://api.github.com/users/astrofrog/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9556/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
706,https://api.github.com/repos/dask/dask/issues/9557,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9557/labels{/name},https://api.github.com/repos/dask/dask/issues/9557/comments,https://api.github.com/repos/dask/dask/issues/9557/events,https://github.com/dask/dask/pull/9557,1400406832,PR_kwDOAbcwm85AWs2g,9557,Lazy computation of array shape for statistical tests,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-10-06T23:10:39Z,2022-11-07T02:12:43Z,,FIRST_TIME_CONTRIBUTOR,,"Updates the computation of the number of data points in statistical tests to be lazy, allowing them to handle nan dimensional inputs

- [x] Closes #9546
- [x] Tests added / passed: 3728 passed, 230 skipped, 8 xfailed, 40 xpassed, 1 warning
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9557/timeline,,,lrast,1191040,MDQ6VXNlcjExOTEwNDA=,https://avatars.githubusercontent.com/u/1191040?v=4,,https://api.github.com/users/lrast,https://github.com/lrast,https://api.github.com/users/lrast/followers,https://api.github.com/users/lrast/following{/other_user},https://api.github.com/users/lrast/gists{/gist_id},https://api.github.com/users/lrast/starred{/owner}{/repo},https://api.github.com/users/lrast/subscriptions,https://api.github.com/users/lrast/orgs,https://api.github.com/users/lrast/repos,https://api.github.com/users/lrast/events{/privacy},https://api.github.com/users/lrast/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9557/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9557,https://github.com/dask/dask/pull/9557,https://github.com/dask/dask/pull/9557.diff,https://github.com/dask/dask/pull/9557.patch,,,,,,,,,,,,,,,,,,,
707,https://api.github.com/repos/dask/dask/issues/9558,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9558/labels{/name},https://api.github.com/repos/dask/dask/issues/9558/comments,https://api.github.com/repos/dask/dask/issues/9558/events,https://github.com/dask/dask/pull/9558,1401918897,PR_kwDOAbcwm85AbqzX,9558,Enable slice by 0-dimensional `np.array`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2022-10-08T11:38:03Z,2024-05-13T01:47:04Z,,CONTRIBUTOR,,"- [x] Closes #3406
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9558/timeline,,,fandreuz,8464342,MDQ6VXNlcjg0NjQzNDI=,https://avatars.githubusercontent.com/u/8464342?v=4,,https://api.github.com/users/fandreuz,https://github.com/fandreuz,https://api.github.com/users/fandreuz/followers,https://api.github.com/users/fandreuz/following{/other_user},https://api.github.com/users/fandreuz/gists{/gist_id},https://api.github.com/users/fandreuz/starred{/owner}{/repo},https://api.github.com/users/fandreuz/subscriptions,https://api.github.com/users/fandreuz/orgs,https://api.github.com/users/fandreuz/repos,https://api.github.com/users/fandreuz/events{/privacy},https://api.github.com/users/fandreuz/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9558/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9558,https://github.com/dask/dask/pull/9558,https://github.com/dask/dask/pull/9558.diff,https://github.com/dask/dask/pull/9558.patch,,,,,,,,,,,,,,,,,,,
708,https://api.github.com/repos/dask/dask/issues/9560,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9560/labels{/name},https://api.github.com/repos/dask/dask/issues/9560/comments,https://api.github.com/repos/dask/dask/issues/9560/events,https://github.com/dask/dask/pull/9560,1403188329,PR_kwDOAbcwm85Afst5,9560,DataFrame reppartition with timedelta divisions for convenience,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450414, 'node_id': 'LA_kwDOAbcwm87iZ8Du', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20review', 'name': 'needs review', 'color': '8c918c', 'default': False, 'description': 'Needs review from a contributor.'}]",open,False,,[],,2,2022-10-10T13:33:32Z,2024-05-13T01:47:03Z,,CONTRIBUTOR,,"Here's a first try,

I am not a fan of the nested try block so any comments would be greatly appreciated.

- [x ] Closes #9548
- [x ] Tests added / passed
- [x ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9560/timeline,,,epizut,1694892,MDQ6VXNlcjE2OTQ4OTI=,https://avatars.githubusercontent.com/u/1694892?v=4,,https://api.github.com/users/epizut,https://github.com/epizut,https://api.github.com/users/epizut/followers,https://api.github.com/users/epizut/following{/other_user},https://api.github.com/users/epizut/gists{/gist_id},https://api.github.com/users/epizut/starred{/owner}{/repo},https://api.github.com/users/epizut/subscriptions,https://api.github.com/users/epizut/orgs,https://api.github.com/users/epizut/repos,https://api.github.com/users/epizut/events{/privacy},https://api.github.com/users/epizut/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9560/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9560,https://github.com/dask/dask/pull/9560,https://github.com/dask/dask/pull/9560.diff,https://github.com/dask/dask/pull/9560.patch,,,,,,,,,,,,,,,,,,,
709,https://api.github.com/repos/dask/dask/issues/9565,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9565/labels{/name},https://api.github.com/repos/dask/dask/issues/9565/comments,https://api.github.com/repos/dask/dask/issues/9565/events,https://github.com/dask/dask/issues/9565,1404766153,I_kwDOAbcwm85TuwfJ,9565,`black`en docs ,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,3,2022-10-11T14:40:09Z,2022-11-14T02:12:06Z,,MEMBER,,"We, along with many other projects, use `black` for code formatting in `dask`. However, we don't apply similar formatting to code examples in documentation. There's a [`blackdoc`](https://github.com/keewis/blackdoc) tool we could use for this. I think this would be nice because it would provide a consistent code style across our docs. ",,https://api.github.com/repos/dask/dask/issues/9565/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9565/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
710,https://api.github.com/repos/dask/dask/issues/9574,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9574/labels{/name},https://api.github.com/repos/dask/dask/issues/9574/comments,https://api.github.com/repos/dask/dask/issues/9574/events,https://github.com/dask/dask/pull/9574,1411874144,PR_kwDOAbcwm85A8h8_,9574,Support split_out>1 for groupby().cov(),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2022-10-17T16:29:31Z,2022-11-21T02:11:21Z,,MEMBER,,"Possible solution for the current lack of support for `groupby(...).cov(split_out>1)`.

The current problem is that the apply-concat-apply (`aca`) code path assumes that the output of `chunk` is ""frame-like"" (i.e. a pandas/cudf Series or DataFrame object) when `split_out>1`. This PR proposes that we allow the `chunk` function to handle hash-based sharding by skipping the `hash_shard` call in `aca` when the output of `chunk` is already a `dict` with the expected keys (e.g. `[0, split_out)`).

- [x] Closes #9509
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9574/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9574/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9574,https://github.com/dask/dask/pull/9574,https://github.com/dask/dask/pull/9574.diff,https://github.com/dask/dask/pull/9574.patch,,,,,,,,,,,,,,,,,,,
711,https://api.github.com/repos/dask/dask/issues/9576,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9576/labels{/name},https://api.github.com/repos/dask/dask/issues/9576/comments,https://api.github.com/repos/dask/dask/issues/9576/events,https://github.com/dask/dask/issues/9576,1413002551,I_kwDOAbcwm85UOLU3,9576,Documentation bug in dask.array.rot90,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-10-18T10:52:06Z,2022-11-21T02:11:20Z,,NONE,,"As per https://docs.dask.org/en/stable/generated/dask.array.rot90.html, it states that ```dask.array.rot90``` returns ""a rotated view of _m_"".

Looking at the source code, it is implemented as: 
```python
@derived_from(np)
def rot90(m, k=1, axes=(0, 1)):
    axes = tuple(axes)
    if len(axes) != 2:
        raise ValueError(""len(axes) must be 2."")

    m = asanyarray(m)

    if axes[0] == axes[1] or np.absolute(axes[0] - axes[1]) == m.ndim:
        raise ValueError(""Axes must be different."")

    if axes[0] >= m.ndim or axes[0] < -m.ndim or axes[1] >= m.ndim or axes[1] < -m.ndim:
        raise ValueError(f""Axes={axes} out of range for array of ndim={m.ndim}."")

    k %= 4

    if k == 0:
        return m[:]
    if k == 2:
        return flip(flip(m, axes[0]), axes[1])

    axes_list = list(range(0, m.ndim))
    (axes_list[axes[0]], axes_list[axes[1]]) = (axes_list[axes[1]], axes_list[axes[0]])

    if k == 1:
        return transpose(flip(m, axes[1]), axes_list)
    else:
        # k == 3
        return flip(transpose(m, axes_list), axes[1])
```
When looking at the return type of ```dask.array.flip``` it returns ""The flipped array."" I believe this is an error, because if ```flip``` returns the flipped version, then how does ```rot90``` always return a view? I realize that if the if-clause triggers at $k == 1$, then ```transpose``` is called, which ""returns a view of _m_ with the entries of axis permuted. A view is returned whenever possible"".   

I believe the error stems from the fact that ```np.flip``` returns ""A view of m with the entries of axis reversed. Since a view is returned, this operation is done in constant time."" (https://numpy.org/doc/stable/reference/generated/numpy.flip.html)


So what does dask.rot90 return? If flip returns the flipped array, how is a view returned? Is this an error in the flip documentation?",,https://api.github.com/repos/dask/dask/issues/9576/timeline,,,Joachimoe,39569971,MDQ6VXNlcjM5NTY5OTcx,https://avatars.githubusercontent.com/u/39569971?v=4,,https://api.github.com/users/Joachimoe,https://github.com/Joachimoe,https://api.github.com/users/Joachimoe/followers,https://api.github.com/users/Joachimoe/following{/other_user},https://api.github.com/users/Joachimoe/gists{/gist_id},https://api.github.com/users/Joachimoe/starred{/owner}{/repo},https://api.github.com/users/Joachimoe/subscriptions,https://api.github.com/users/Joachimoe/orgs,https://api.github.com/users/Joachimoe/repos,https://api.github.com/users/Joachimoe/events{/privacy},https://api.github.com/users/Joachimoe/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9576/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
712,https://api.github.com/repos/dask/dask/issues/9581,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9581/labels{/name},https://api.github.com/repos/dask/dask/issues/9581/comments,https://api.github.com/repos/dask/dask/issues/9581/events,https://github.com/dask/dask/issues/9581,1415217053,I_kwDOAbcwm85UWn-d,9581,PipInstall vs UploadDirectory vs CustomWorkerPlugin ,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2022-10-19T14:37:28Z,2022-11-21T02:11:19Z,,MEMBER,,"As a user I want to know when I need to use PipInstall, UploadDirectory or CustomWorkerPlugin so I can install my custom internal code in dask-gateway cluster.

Create documentation providing concrete examples on how to install custom code that is in a private artifactory, simple script, github repository modules, etc.

Note: `CustomWorkerPlugin` is a user-defined plugin. Usually used when code is in github and not in artifactory. But the code is pip installable, so this could be a combination of UplaodDirectory and PipInstall, which the user will have to create it.

@phobson you mentioned you have some other user requests, let's start a conversation about what do we need and what's the best way to present it. ",,https://api.github.com/repos/dask/dask/issues/9581/timeline,,,ncclementi,7526622,MDQ6VXNlcjc1MjY2MjI=,https://avatars.githubusercontent.com/u/7526622?v=4,,https://api.github.com/users/ncclementi,https://github.com/ncclementi,https://api.github.com/users/ncclementi/followers,https://api.github.com/users/ncclementi/following{/other_user},https://api.github.com/users/ncclementi/gists{/gist_id},https://api.github.com/users/ncclementi/starred{/owner}{/repo},https://api.github.com/users/ncclementi/subscriptions,https://api.github.com/users/ncclementi/orgs,https://api.github.com/users/ncclementi/repos,https://api.github.com/users/ncclementi/events{/privacy},https://api.github.com/users/ncclementi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9581/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
713,https://api.github.com/repos/dask/dask/issues/9586,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9586/labels{/name},https://api.github.com/repos/dask/dask/issues/9586/comments,https://api.github.com/repos/dask/dask/issues/9586/events,https://github.com/dask/dask/issues/9586,1417708510,I_kwDOAbcwm85UgIPe,9586,Reading parquet hangs when used parquet folder as input but works when I give list of files,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,6,2022-10-21T04:24:41Z,2024-05-06T01:46:31Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
I have 20000 parquet files partitioned by name. `read_parquet` hangs when I give parquet folder as input. I tried glob pattern and that is also same. However, when I tried passing the list of parquet files, it takes fraction of a second.

**Minimal Complete Verifiable Example**:

```python
paths = [f'az://parquet/phone/name={name}/{name}.parquet' for name in names]
path = 'az://parquet/phone'
gpath = 'az://parquet/phone/**/*.parquet'

def read_parquet(p):
    df = dd.read_parquet(p, engine=""pyarrow"", columns=col_list, index=ind_list, storage_options=storage_options,dataset ={""schema"":SCHEMA,""format"":""parquet""})
    return df

df = read_parquet(paths) # Fraction of a second 
df = read_parquet(path) # Hangs and there is no task in the dashboard
df = read_parquet(gpath) # Hangs and there is no task in the dashboard
```

**Anything else we need to know?**:
In case of folder path, when I interrupt, same set of lines are always highlighted by Jupyter notebook,

![image](https://user-images.githubusercontent.com/16543422/197110974-34389c6f-a2a4-46e5-813b-3a29adb61ec8.png)

Note:
- All my parquet files has same schema
- There could be couple of corrupted files (say <10)
- I am not able share the data here, sorry.

**Environment**:

- Dask version: 2022.10.0
- Python version: 3.8.13
- Operating System: Windows
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/9586/timeline,,,selvavm,16543422,MDQ6VXNlcjE2NTQzNDIy,https://avatars.githubusercontent.com/u/16543422?v=4,,https://api.github.com/users/selvavm,https://github.com/selvavm,https://api.github.com/users/selvavm/followers,https://api.github.com/users/selvavm/following{/other_user},https://api.github.com/users/selvavm/gists{/gist_id},https://api.github.com/users/selvavm/starred{/owner}{/repo},https://api.github.com/users/selvavm/subscriptions,https://api.github.com/users/selvavm/orgs,https://api.github.com/users/selvavm/repos,https://api.github.com/users/selvavm/events{/privacy},https://api.github.com/users/selvavm/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9586/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
714,https://api.github.com/repos/dask/dask/issues/9588,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9588/labels{/name},https://api.github.com/repos/dask/dask/issues/9588/comments,https://api.github.com/repos/dask/dask/issues/9588/events,https://github.com/dask/dask/issues/9588,1418396648,I_kwDOAbcwm85UiwPo,9588,BUG/DOC: threads_per_worker does not limit all thread types,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,9,2022-10-21T14:05:28Z,2022-11-28T02:04:41Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

Dask `Client` with `threads_per_worker=1` does not limit all thread types, so it can be violated for example by sklearn FastICA via OpenMP.

**Minimal Complete Verifiable Example**:

<details>

```python
import os

from dask.distributed import Client
import joblib
import numpy as np
from sklearn.decomposition import FastICA
import threadpoolctl

n_workers = 3


def fit_ica(seed):
    #threadpoolctl.threadpool_limits(limits=1, user_api='openmp')
    data = np.random.RandomState(seed).randn(10000, 10)
    ica = FastICA(
        n_components=10, random_state=seed, whiten='unit-variance',
        max_iter=1000)
    ica.fit(data)


if __name__ == '__main__':
    client = Client(n_workers=n_workers, threads_per_worker=1, name='test')
    with joblib.parallel_backend('dask'):
        parallel = joblib.Parallel(n_jobs=n_workers)
        parallel(joblib.delayed(fit_ica)(seed) for seed in range(n_workers))
```

</details>

On my macOS M1 machine (with 10 CPUs) I get:
```
$ time python -u rep_dask.py 
...
real	0m20.006s
user	1m53.512s
sys	0m15.559s
```
Which is driven by oversubscription of CPUs -- 30 threads get spawned because `n_workers=3` and no limit is set on the OpenMP number of threads.

However, uncommenting the `threadpoolctl.threadpool_limits(limits=1, user_api='openmp')` line above within the `fit_ica` function, I get much better timings:
```
$ time python -u rep_dask.py 
...
real	0m4.766s
user	0m6.675s
sys	0m1.612s
```

**Anything else we need to know?**:

I understand that a solution to `threads_per_worker) might be (endlessly) complicated -- although maybe some iteration over `threadpoolctl`-discovered interfaces could be used? -- so in lieu of that, maybe docs could be updated to give people hints. I'm thinking specifically:

1. Document what `threads_per_worker` actually controls/sets and how, e.g. in [LocalCluster](https://distributed.dask.org/en/stable/api.html#cluster).
2. Add a link from the `threads_per_worker` docstring to some separate doc/[FAQ](https://distributed.dask.org/en/stable/faq.html) that talk about OMP_NUM_THREADS, MKL_NUM_THREADS, threadpoolctl, etc. methods of controlling execution.

Apologies if these are already documented somewhere and I missed it!

**Environment**:

- Dask version: '2022.05.0'
- Python version: 3.10
- Operating System: macOS M1
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/9588/timeline,,,larsoner,2365790,MDQ6VXNlcjIzNjU3OTA=,https://avatars.githubusercontent.com/u/2365790?v=4,,https://api.github.com/users/larsoner,https://github.com/larsoner,https://api.github.com/users/larsoner/followers,https://api.github.com/users/larsoner/following{/other_user},https://api.github.com/users/larsoner/gists{/gist_id},https://api.github.com/users/larsoner/starred{/owner}{/repo},https://api.github.com/users/larsoner/subscriptions,https://api.github.com/users/larsoner/orgs,https://api.github.com/users/larsoner/repos,https://api.github.com/users/larsoner/events{/privacy},https://api.github.com/users/larsoner/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9588/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
715,https://api.github.com/repos/dask/dask/issues/9590,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9590/labels{/name},https://api.github.com/repos/dask/dask/issues/9590/comments,https://api.github.com/repos/dask/dask/issues/9590/events,https://github.com/dask/dask/pull/9590,1421313311,PR_kwDOAbcwm85BcJ-f,9590,Spark compatibility with pandas extension dtypes,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-10-24T19:23:24Z,2024-05-06T01:46:29Z,,MEMBER,,"This test demonstrates that, when Parquet datasets with extension dtypes are written with Spark, Dask isn't currently able to read in extension dtypes as expected. Instead, things get dtypes get downcasted (e.g. a column that starts out as `Float64` is read in by Dask as `float`) ",,https://api.github.com/repos/dask/dask/issues/9590/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9590/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9590,https://github.com/dask/dask/pull/9590,https://github.com/dask/dask/pull/9590.diff,https://github.com/dask/dask/pull/9590.patch,,,,,,,,,,,,,,,,,,,
716,https://api.github.com/repos/dask/dask/issues/9593,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9593/labels{/name},https://api.github.com/repos/dask/dask/issues/9593/comments,https://api.github.com/repos/dask/dask/issues/9593/events,https://github.com/dask/dask/issues/9593,1422909615,I_kwDOAbcwm85Uz-Cv,9593,Dataframe .loc slicing can ignore partitions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2022-10-25T18:38:55Z,2024-05-06T01:46:28Z,,NONE,,"**Behaviour**:
In some cases slicing a dataframe with .loc over the boundary between partitions results in only the last partition being considered.

One such case is the example below, in which the .loc slicing and .compute do not commute (since one .loc is dask's and one is panda's).
The source of the problem seems to be the `map_partitions` over the index, and removing the two lines converting between datetime and seconds-timestamp (marked with ""###"" at their end) makes the assertion pass (though the point is that it fails in this case).

**Minimal Complete Verifiable Example**:

TL;DR: a dataframe is saved in two halves with an integer timestamp (of seconds) as index; the slicing issue described above occurs after reading the halves as partitions of one df and converting the index to a datetime.

```python
import numpy as np
import pandas as pd
import dask.dataframe as dd

## Preparing the data

# Timestamps (in seconds) of minutes between two (arbitrary) timezone-aware dates
minutes = pd.date_range('2021-02-02', '2022-02-02', freq = '1min', tz = 'US/Eastern')
minutes = np.int64(minutes) // 10 ** 9 ### convert datetime to seconds ###

# Dataframe with minutes as index and dummy columns
df = pd.DataFrame(dict(zs = np.zeros(len(minutes)), os = np.ones(len(minutes))), index = minutes)

# Save in two halves
half = int(np.floor(len(df)/2)) # Around 2021-08-03
df.iloc[:half].to_parquet('./FIRST_HALF.parquet')
df.iloc[half:].to_parquet('./SECOND_HALF.parquet')


## Using the data

# Read in two partitions and convert the index back to timezone-aware datetime
ddf = dd.read_parquet(['./FIRST_HALF.parquet', './SECOND_HALF.parquet'])
ddf.index = ddf.index.map_partitions(lambda index: pd.to_datetime(index, unit = 's', utc = True).tz_convert('US/Eastern')) ### convert seconds to datetime ###
ddf.set_index(ddf.index, sorted = True) # This line seems to need to be queued separately from the one above

# One date within the first partition and one within the second
from_date, to_date = [pd.to_datetime(date, format = '%Y-%m-%d').tz_localize('US/Eastern') for date in ('2021-06-02', '2022-01-02')]

# Slicing before and after .compute
ddf.loc[from_date:to_date].visualize() # See the attached picture
dask_loc   = ddf.loc[from_date:to_date].compute() # 2021-08-03 (half) to 2022-01-02
pandas_loc = ddf.compute().loc[from_date:to_date] # 2021-06-02 to 2022-01-02

assert dask_loc.index.equals(pandas_loc.index), 'dask_loc ignored the first partition'
```

The issue is also visible from the result of the .visualize():
![mydask](https://user-images.githubusercontent.com/6699494/197851877-cb00820a-7805-46ee-bfc4-04a682f6bc1c.png)

**Possibly related issues**
- https://github.com/dask/dask/issues/3411
- ""Issue 2"" from https://github.com/dask/dask/issues/862, though they find a work-around the specific case

**Environment**:

- Dask version: 2022.5.0
- Python version: 3.10.4
- Operating System: Windows 10 Pro - 21H2
- Install method: conda
",,https://api.github.com/repos/dask/dask/issues/9593/timeline,,,T-Flet,6699494,MDQ6VXNlcjY2OTk0OTQ=,https://avatars.githubusercontent.com/u/6699494?v=4,,https://api.github.com/users/T-Flet,https://github.com/T-Flet,https://api.github.com/users/T-Flet/followers,https://api.github.com/users/T-Flet/following{/other_user},https://api.github.com/users/T-Flet/gists{/gist_id},https://api.github.com/users/T-Flet/starred{/owner}{/repo},https://api.github.com/users/T-Flet/subscriptions,https://api.github.com/users/T-Flet/orgs,https://api.github.com/users/T-Flet/repos,https://api.github.com/users/T-Flet/events{/privacy},https://api.github.com/users/T-Flet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9593/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
717,https://api.github.com/repos/dask/dask/issues/9594,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9594/labels{/name},https://api.github.com/repos/dask/dask/issues/9594/comments,https://api.github.com/repos/dask/dask/issues/9594/events,https://github.com/dask/dask/issues/9594,1422948708,I_kwDOAbcwm85U0Hlk,9594,Automatic retries beyond `read_parquet` / `to_parquet`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,5,2022-10-25T19:15:16Z,2024-05-06T01:46:28Z,,MEMBER,,In https://github.com/dask/dask/pull/9175 we added automatic retries when using remote filesystems with `dd.read_parquet` / `dd.to_parquet`. It'd be nice for other I/O functions (e.g. `dd.read_csv` / `dd.to_csv`) to have similar robustness. ,,https://api.github.com/repos/dask/dask/issues/9594/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9594/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
718,https://api.github.com/repos/dask/dask/issues/9601,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9601/labels{/name},https://api.github.com/repos/dask/dask/issues/9601/comments,https://api.github.com/repos/dask/dask/issues/9601/events,https://github.com/dask/dask/pull/9601,1425820094,PR_kwDOAbcwm85BrQ8w,9601,Retries on read/to csv,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,6,2022-10-27T15:18:01Z,2024-05-06T01:46:27Z,,MEMBER,,"- [x] Closes #9594
- [ ] Tests added / passed
- [x] Passes `pre-commit run --all-files`

This is a draft PR, I'm having some issues but I though I'll push it to get more eyes on it.

- I had to pass storage options to `text_blocks_to_pandas` to be able to check the filesystem. but I'm not sure this is the correct thing to do.


cc: @jrbourbeau ",,https://api.github.com/repos/dask/dask/issues/9601/timeline,,,ncclementi,7526622,MDQ6VXNlcjc1MjY2MjI=,https://avatars.githubusercontent.com/u/7526622?v=4,,https://api.github.com/users/ncclementi,https://github.com/ncclementi,https://api.github.com/users/ncclementi/followers,https://api.github.com/users/ncclementi/following{/other_user},https://api.github.com/users/ncclementi/gists{/gist_id},https://api.github.com/users/ncclementi/starred{/owner}{/repo},https://api.github.com/users/ncclementi/subscriptions,https://api.github.com/users/ncclementi/orgs,https://api.github.com/users/ncclementi/repos,https://api.github.com/users/ncclementi/events{/privacy},https://api.github.com/users/ncclementi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9601/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9601,https://github.com/dask/dask/pull/9601,https://github.com/dask/dask/pull/9601.diff,https://github.com/dask/dask/pull/9601.patch,,,,,,,,,,,,,,,,,,,
719,https://api.github.com/repos/dask/dask/issues/9608,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9608/labels{/name},https://api.github.com/repos/dask/dask/issues/9608/comments,https://api.github.com/repos/dask/dask/issues/9608/events,https://github.com/dask/dask/issues/9608,1428661905,I_kwDOAbcwm85VJ6aR,9608,Dataframe returning NaN for Rolling Window when window-range > window frame,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-10-30T08:01:04Z,2022-12-05T01:59:38Z,,NONE,,"**Describe the issue**:

Dataframe returning NaN for Rolling Window when window-range > window frame

**Minimal Complete Verifiable Example**:

```python
import time
import numpy as np
import pandas as pd

from distributed import Client
from dask import dataframe as dd
client = Client(...)

def geometric_mean(x):
    a = np.log(x)
    return np.exp(a.mean())

df = pd.DataFrame(np.random.random([200000, 4]), columns=['A', 'B', 'C', 'D'])
dff = dd.from_pandas(df, npartitions=100)
futures = []
for inc in [30, 300, 3000, 30000, 30000]:
    futures.append(client.compute(dff['B'].rolling(inc).apply(geometric_mean, raw=True)))
    
while all([f.done() for f in futures]) is False:
    time.sleep(.1)
    
print('Done', [f.status for f in futures])
print(futures[-1].result())
```

**Anything else we need to know?**:
Related Tickets
* https://github.com/dask/dask/issues/4248
* https://github.com/jmcarpenter2/swifter/issues/180

**Environment**:

- Dask version: Latest
- Python version: Latest
- Operating System: ...
",,https://api.github.com/repos/dask/dask/issues/9608/timeline,,,jbcurtin,45219,MDQ6VXNlcjQ1MjE5,https://avatars.githubusercontent.com/u/45219?v=4,,https://api.github.com/users/jbcurtin,https://github.com/jbcurtin,https://api.github.com/users/jbcurtin/followers,https://api.github.com/users/jbcurtin/following{/other_user},https://api.github.com/users/jbcurtin/gists{/gist_id},https://api.github.com/users/jbcurtin/starred{/owner}{/repo},https://api.github.com/users/jbcurtin/subscriptions,https://api.github.com/users/jbcurtin/orgs,https://api.github.com/users/jbcurtin/repos,https://api.github.com/users/jbcurtin/events{/privacy},https://api.github.com/users/jbcurtin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9608/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
720,https://api.github.com/repos/dask/dask/issues/9611,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9611/labels{/name},https://api.github.com/repos/dask/dask/issues/9611/comments,https://api.github.com/repos/dask/dask/issues/9611/events,https://github.com/dask/dask/issues/9611,1430023391,I_kwDOAbcwm85VPGzf,9611,GroupBy.cov() when dask SeriesGroupBy object returns unexpected response,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-10-31T15:18:17Z,2022-12-05T01:59:37Z,,MEMBER,,"**Describe the issue**:

When performing a groupby covariance on a Pandas DataFrame, where the groupby operation returns a `pd.SeriesGroupBy` object, Pandas returns a `TypeError`, which makes sense since there is not a second column.  However, the same operation on a dask dataframe returns a Dask Series

**Minimal Complete Verifiable Example**:

```python

import dask.dataframe as dd
import pandas as pd
from dask.dataframe.utils import assert_eq

pdf = pd.DataFrame(
{""a"": [1, 2, 6, 4, 4, 6, 4, 3, 7], ""b"": [4, 2, 7, 3, 3, 1, 1, 1, 2]},
index=[0, 1, 3, 5, 6, 8, 9, 9, 9],
)
ddf = dd.from_pandas(pdf, npartitions=3)
assert_eq(pdf.groupby(""b"").a.cov(), ddf.groupby(""b"").a.cov())
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In [1], line 10
      5 pdf = pd.DataFrame(
      6 {""a"": [1, 2, 6, 4, 4, 6, 4, 3, 7], ""b"": [4, 2, 7, 3, 3, 1, 1, 1, 2]},
      7 index=[0, 1, 3, 5, 6, 8, 9, 9, 9],
      8 )
      9 ddf = dd.from_pandas(pdf, npartitions=3)
---> 10 assert_eq(pdf.groupby(""b"").a.cov(), ddf.groupby(""b"").a.cov())

File ~/mambaforge/envs/dask/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:950, in GroupBy._make_wrapper.<locals>.wrapper(*args, **kwargs)
    947 if name in base.plotting_methods:
    948     return self.apply(curried)
--> 950 return self._python_apply_general(curried, self._obj_with_exclusions)

File ~/mambaforge/envs/dask/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1464, in GroupBy._python_apply_general(self, f, data, not_indexed_same)
   1438 @final
   1439 def _python_apply_general(
   1440     self,
   (...)
   1443     not_indexed_same: bool | None = None,
   1444 ) -> DataFrame | Series:
   1445     """"""
   1446     Apply function f in python space
   1447 
   (...)
   1462         data after applying f
   1463     """"""
-> 1464     values, mutated = self.grouper.apply(f, data, self.axis)
   1466     if not_indexed_same is None:
   1467         not_indexed_same = mutated or self.mutated

File ~/mambaforge/envs/dask/lib/python3.9/site-packages/pandas/core/groupby/ops.py:761, in BaseGrouper.apply(self, f, data, axis)
    759 # group might be modified
    760 group_axes = group.axes
--> 761 res = f(group)
    762 if not mutated and not _is_indexed_like(res, group_axes, axis):
    763     mutated = True

File ~/mambaforge/envs/dask/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:939, in GroupBy._make_wrapper.<locals>.wrapper.<locals>.curried(x)
    938 def curried(x):
--> 939     return f(x, *args, **kwargs)

TypeError: cov() missing 1 required positional argument: 'other'
```
See:
```
ddf.groupby(""b"").a.cov().compute()
b   
1  a     2.333333
2  a    12.500000
3  a     0.000000
4  a          NaN
7  a          NaN
Name: a, dtype: float64
```
```
pdf.groupby(""b"").a.cov().compute()

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In [4], line 1
----> 1 pdf.groupby(""b"").a.cov()

File ~/mambaforge/envs/dask/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:950, in GroupBy._make_wrapper.<locals>.wrapper(*args, **kwargs)
    947 if name in base.plotting_methods:
    948     return self.apply(curried)
--> 950 return self._python_apply_general(curried, self._obj_with_exclusions)

File ~/mambaforge/envs/dask/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1464, in GroupBy._python_apply_general(self, f, data, not_indexed_same)
   1438 @final
   1439 def _python_apply_general(
   1440     self,
   (...)
   1443     not_indexed_same: bool | None = None,
   1444 ) -> DataFrame | Series:
   1445     """"""
   1446     Apply function f in python space
   1447 
   (...)
   1462         data after applying f
   1463     """"""
-> 1464     values, mutated = self.grouper.apply(f, data, self.axis)
   1466     if not_indexed_same is None:
   1467         not_indexed_same = mutated or self.mutated

File ~/mambaforge/envs/dask/lib/python3.9/site-packages/pandas/core/groupby/ops.py:761, in BaseGrouper.apply(self, f, data, axis)
    759 # group might be modified
    760 group_axes = group.axes
--> 761 res = f(group)
    762 if not mutated and not _is_indexed_like(res, group_axes, axis):
    763     mutated = True

File ~/mambaforge/envs/dask/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:939, in GroupBy._make_wrapper.<locals>.wrapper.<locals>.curried(x)
    938 def curried(x):
--> 939     return f(x, *args, **kwargs)

TypeError: cov() missing 1 required positional argument: 'other'
```

**Environment**:

- Dask version:  2022.10.1
- Python version: 3.9
- Operating System: MacOs
",,https://api.github.com/repos/dask/dask/issues/9611/timeline,,,hayesgb,12595382,MDQ6VXNlcjEyNTk1Mzgy,https://avatars.githubusercontent.com/u/12595382?v=4,,https://api.github.com/users/hayesgb,https://github.com/hayesgb,https://api.github.com/users/hayesgb/followers,https://api.github.com/users/hayesgb/following{/other_user},https://api.github.com/users/hayesgb/gists{/gist_id},https://api.github.com/users/hayesgb/starred{/owner}{/repo},https://api.github.com/users/hayesgb/subscriptions,https://api.github.com/users/hayesgb/orgs,https://api.github.com/users/hayesgb/repos,https://api.github.com/users/hayesgb/events{/privacy},https://api.github.com/users/hayesgb/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9611/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
721,https://api.github.com/repos/dask/dask/issues/9612,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9612/labels{/name},https://api.github.com/repos/dask/dask/issues/9612/comments,https://api.github.com/repos/dask/dask/issues/9612/events,https://github.com/dask/dask/pull/9612,1430227554,PR_kwDOAbcwm85B53Kc,9612,Raise NotImplementedError on seriesgroupby.cov(),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2022-10-31T17:37:13Z,2024-05-06T01:46:25Z,,MEMBER,,"- [ ] Closes #9611 
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9612/timeline,,,hayesgb,12595382,MDQ6VXNlcjEyNTk1Mzgy,https://avatars.githubusercontent.com/u/12595382?v=4,,https://api.github.com/users/hayesgb,https://github.com/hayesgb,https://api.github.com/users/hayesgb/followers,https://api.github.com/users/hayesgb/following{/other_user},https://api.github.com/users/hayesgb/gists{/gist_id},https://api.github.com/users/hayesgb/starred{/owner}{/repo},https://api.github.com/users/hayesgb/subscriptions,https://api.github.com/users/hayesgb/orgs,https://api.github.com/users/hayesgb/repos,https://api.github.com/users/hayesgb/events{/privacy},https://api.github.com/users/hayesgb/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9612/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9612,https://github.com/dask/dask/pull/9612,https://github.com/dask/dask/pull/9612.diff,https://github.com/dask/dask/pull/9612.patch,,,,,,,,,,,,,,,,,,,
722,https://api.github.com/repos/dask/dask/issues/9619,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9619/labels{/name},https://api.github.com/repos/dask/dask/issues/9619/comments,https://api.github.com/repos/dask/dask/issues/9619/events,https://github.com/dask/dask/issues/9619,1434649108,I_kwDOAbcwm85VgwIU,9619,Read_parquet is slower than expected with S3,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,51,2022-11-03T13:17:46Z,2024-04-29T01:46:23Z,,MEMBER,,"I was looking at a read_parquet profile with @th3ed @ncclementi and @gjoseph92 

Looking at this performance report: https://raw.githubusercontent.com/coiled/h2o-benchmarks/main/performance-reports-pyarr_str-50GB/q1_50GB_pyarr.html
I see the following analysis (two minute video): https://www.loom.com/share/4c8ad1c5251a4e658c1c47ee2113f34a

We're spending only about 20-25% of our time reading from S3, and about 5% of our time converting data to Pandas.  We're spending a lot of our time doing *something else*.

@gjoseph92 took a look at this with pyspy and generated reports like the following: [tls-10_0_0_177-42425.json](https://speedscope.app/#profileURL=https%3a%2f%2fgistcdn.githack.com%2fgjoseph92%2ff71d825abb5a5d7e44f1cdeb041d8bff%2fraw%2ffbcd35977906999c5df4d88ca9d847a6b7ccf0aa%2ftls-10_0_0_177-42425.json)

I'm copying a note from him below:

> What you'll see from this is that pyarrow isn't doing the actual reads. Because dask uses s3fs, the C++ arrow code has to call back into Python for each read. Ultimately, the reads are actually happening on the fsspec event loop (see the `fsspecIO` thread in profiles). If we look there, about 40% of CPU time is spent waiting for something (aka data from S3, good), but 60% is spent doing stuff in Python (which I'd consider overhead, to some degree).

> We can also see that 30% of the total time is spent blocking on Python's GIL (all the `pthread_cond_timedwait`s) (look at the functions calling into this and the corresponding lines in the Python source if you don't believe me; they're all `Py_END_ALLOW_THREADS`). This is an issue known as the convoy effect: https://bugs.python.org/issue7946, https://github.com/dask/distributed/issues/6325.

> My takeaway is that using fsspec means dask is using Python for reads, which might be adding significant overhead / reducing parallelism due to the GIL.

> I'd be interested in doing a comparison by hacking together a version that bypasses fsspec, and uses pyarrow's native [S3FileSystem](https://arrow.apache.org/docs/python/generated/pyarrow.fs.S3FileSystem.html#pyarrow.fs.S3FileSystem) directly. Before that though, it might be good to get some baseline numbers on how fast we can pull the raw data from S3 (just as bytes), to understand what performance we can expect.

> FYI I also tried https://developer.nvidia.com/blog/optimizing-access-to-parquet-data-with-fsspec/, but it was ~2x slower. Haven't tried repeating that though, so not sure if it's a real result.

> One other thing I find surprising is that polars appears to be using fsspec for reads as well, rather than the native S3FileSystem or GCSFileSystem:
> https://github.com/pola-rs/polars/blob/445c550e8f965d9e8f2da1cb2d01b6c15874f6c8/py-polars/polars/io.py#L949-L956
> https://github.com/pola-rs/polars/blob/445c550e8f965d9e8f2da1cb2d01b6c15874f6c8/py-polars/polars/internals/io.py#L114-L121

> I would have expected polars and dask read performance to be closer in this case. We should probably confirm for ourselves that they're not.

It looks like we could make things a lot faster.  I'm curious about the right steps to isolate the problem further.

cc'ing @martindurant @rjzamora @ritchie46 @fjetter ",,https://api.github.com/repos/dask/dask/issues/9619/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9619/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
723,https://api.github.com/repos/dask/dask/issues/9620,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9620/labels{/name},https://api.github.com/repos/dask/dask/issues/9620/comments,https://api.github.com/repos/dask/dask/issues/9620/events,https://github.com/dask/dask/issues/9620,1434908669,I_kwDOAbcwm85Vhvf9,9620,[ENH] Add support for cumulative aggregations in `GroupBy.agg`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,1,2022-11-03T16:01:57Z,2024-04-29T01:46:22Z,,MEMBER,,"<!-- Please do a quick search of existing issues to make sure that this has not been asked before. -->

Currently, cumulative grouped aggregations can be called using their named methods, but passing them into `.agg()` raises an error:

```python
from dask.datasets import timeseries

ddf = timeseries()

ddf,groupby(""name"").cumsum()  # works
ddf.groupby(""name"").agg(""cumsum"")
```

```python-traceback
ValueError                                Traceback (most recent call last)
Cell In [3], line 3
      1 from dask.datasets import timeseries
----> 3 timeseries().groupby(""name"").agg(""cumsum"")

File ~/dev/dask/main/dask/dataframe/groupby.py:2557, in DataFrameGroupBy.agg(self, arg, split_every, split_out, shuffle, **kwargs)
   2555 @_aggregate_docstring(based_on=""pd.core.groupby.DataFrameGroupBy.agg"")
   2556 def agg(self, arg=None, split_every=None, split_out=1, shuffle=None, **kwargs):
-> 2557     return self.aggregate(
   2558         arg=arg,
   2559         split_every=split_every,
   2560         split_out=split_out,
   2561         shuffle=shuffle,
   2562         **kwargs,
   2563     )

File ~/dev/dask/main/dask/dataframe/groupby.py:2547, in DataFrameGroupBy.aggregate(self, arg, split_every, split_out, shuffle, **kwargs)
   2544 if arg == ""size"":
   2545     return self.size()
-> 2547 return super().aggregate(
   2548     arg=arg,
   2549     split_every=split_every,
   2550     split_out=split_out,
   2551     shuffle=shuffle,
   2552     **kwargs,
   2553 )

File ~/dev/dask/main/dask/dataframe/groupby.py:1976, in _GroupBy.aggregate(self, arg, split_every, split_out, shuffle, **kwargs)
   1973 else:
   1974     raise ValueError(f""aggregate on unknown object {self.obj}"")
-> 1976 chunk_funcs, aggregate_funcs, finalizers = _build_agg_args(spec)
   1978 if isinstance(self.by, (tuple, list)) and len(self.by) > 1:
   1979     levels = list(range(len(self.by)))

File ~/dev/dask/main/dask/dataframe/groupby.py:833, in _build_agg_args(spec)
    830 if not isinstance(func, Aggregation):
    831     func = funcname(known_np_funcs.get(func, func))
--> 833 impls = _build_agg_args_single(result_column, func, input_column)
    835 # overwrite existing result-columns, generate intermediates only once
    836 for spec in impls[""chunk_funcs""]:

File ~/dev/dask/main/dask/dataframe/groupby.py:886, in _build_agg_args_single(result_column, func, input_column)
    883     return _build_agg_args_custom(result_column, func, input_column)
    885 else:
--> 886     raise ValueError(f""unknown aggregate {func}"")

ValueError: unknown aggregate cumsum
```

It looks like the underlying issue here is that we don't have a `_build_agg_args_*` function for any of the cumulative aggregations; not sure if that's all that needs to be done here to unblock this functionality.",,https://api.github.com/repos/dask/dask/issues/9620/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9620/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
724,https://api.github.com/repos/dask/dask/issues/9623,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9623/labels{/name},https://api.github.com/repos/dask/dask/issues/9623/comments,https://api.github.com/repos/dask/dask/issues/9623/events,https://github.com/dask/dask/issues/9623,1435105342,I_kwDOAbcwm85Vifg-,9623,Drop `pytest-runner`,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450421, 'node_id': 'LA_kwDOAbcwm87iZ8D1', 'url': 'https://api.github.com/repos/dask/dask/labels/hygiene', 'name': 'hygiene', 'color': 'b5ccfa', 'default': False, 'description': 'Improve code quality and reduce maintenance overhead'}]",open,False,,[],,3,2022-11-03T18:35:55Z,2024-04-29T01:46:21Z,,MEMBER,,"As `pytest-runner` [is deprecated]( https://pytest-runner.readthedocs.io/en/latest/index.html#deprecation-notice ), we should drop it.",,https://api.github.com/repos/dask/dask/issues/9623/timeline,,,jakirkham,3019665,MDQ6VXNlcjMwMTk2NjU=,https://avatars.githubusercontent.com/u/3019665?v=4,,https://api.github.com/users/jakirkham,https://github.com/jakirkham,https://api.github.com/users/jakirkham/followers,https://api.github.com/users/jakirkham/following{/other_user},https://api.github.com/users/jakirkham/gists{/gist_id},https://api.github.com/users/jakirkham/starred{/owner}{/repo},https://api.github.com/users/jakirkham/subscriptions,https://api.github.com/users/jakirkham/orgs,https://api.github.com/users/jakirkham/repos,https://api.github.com/users/jakirkham/events{/privacy},https://api.github.com/users/jakirkham/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9623/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
725,https://api.github.com/repos/dask/dask/issues/9656,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9656/labels{/name},https://api.github.com/repos/dask/dask/issues/9656/comments,https://api.github.com/repos/dask/dask/issues/9656/events,https://github.com/dask/dask/issues/9656,1448630783,I_kwDOAbcwm85WWFn_,9656,`da.full` docstring has `np.full_like` content,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-11-14T19:37:40Z,2022-12-19T01:54:52Z,,MEMBER,,"I noticed in our API docs, it appears `da.full` is wrapping `np.full_like`s docstring, when it should be wrapping `np.full`. Maybe this was introduced with the recent backend dispatching changes? cc @rjzamora 

This might (haven't confirmed yet) be causing the doctest failures we're seeing in https://github.com/dask/dask/pull/9655.


EDIT: Here's a relevant screenshot 

![Screen Shot 2022-11-14 at 1 34 46 PM](https://user-images.githubusercontent.com/11656932/201753826-4912f3ae-f20e-4b83-9b39-08395a7ff68d.png)
 ",,https://api.github.com/repos/dask/dask/issues/9656/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9656/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
726,https://api.github.com/repos/dask/dask/issues/9663,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9663/labels{/name},https://api.github.com/repos/dask/dask/issues/9663/comments,https://api.github.com/repos/dask/dask/issues/9663/events,https://github.com/dask/dask/issues/9663,1450166974,I_kwDOAbcwm85Wb8q-,9663,Recursion error when submitting recursive object,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-11-15T17:56:17Z,2022-12-19T01:54:51Z,,CONTRIBUTOR,,"**Describe the issue**:

When I submit an object that recurses in a specific way, it causes Dask to infinitely recurse.

```python
import dask.distributed
from dataclasses import dataclass
from typing import Any

@dataclasses
class Node:
    next: Any = None
    prev: Any = None

a = Node()
b = Node()
c = Node()
a.next = b
b.next = c
c.prev = b
b.prev = a

with dask.distributed.LocalCluster() as cluster, dask.distributed.Client(cluster) as client:
    client.submit(print, a)
```

**Error summary:** The program says `Exception ignored ... RecursionError`. It presumably retries, because it prints that same error every few seconds until I hit ctrl+c, at which point I get a KeyboardInterrupt traceback.

1. `test.py:19`, which reads `client.submit(print, a)`
2. `distributed/client.py:1836:submit`
3. `dask/base.py:931:tokenize`
4. `dask/utils.py:640:__call__` (recursion returns to this frame)
4. `dask/base.py:1020:normalize_object`
5. `dask/base.py:1094:normalize_dataclass`
6. `dask/base.py:978:_normalize_seq_func`
7. `dask/utils.py:640:__call__`
8. `dask/base.py:992:normalize_seq`
9. `dask/base.py:978:_normalize_seq_func`
10. back to 4

Full error log: [here](https://hastebin.com/cejeyotolo.kotlin)

**Anything else we need to know?**:

I've tried whittling this down further, but it appears it requires all three nodes, all four links, and it must be a `@dataclass`. This at least means that the client is robust to _some kinds of_ recursion, just not this specific configuration.

All of this, just to name the future (distributed/client.py:1836). It seems like if Dask could get past naming it, the rest would work fine. The object is perfectly `cloudpickle`-able.

**Environment**:

- Dask version: 2022.10.2
- Python version: 3.10.6
- Operating System: Ubuntu 22.04.1 LTS
- Install method (conda, pip, source): pip/poetry",,https://api.github.com/repos/dask/dask/issues/9663/timeline,,,charmoniumQ,928570,MDQ6VXNlcjkyODU3MA==,https://avatars.githubusercontent.com/u/928570?v=4,,https://api.github.com/users/charmoniumQ,https://github.com/charmoniumQ,https://api.github.com/users/charmoniumQ/followers,https://api.github.com/users/charmoniumQ/following{/other_user},https://api.github.com/users/charmoniumQ/gists{/gist_id},https://api.github.com/users/charmoniumQ/starred{/owner}{/repo},https://api.github.com/users/charmoniumQ/subscriptions,https://api.github.com/users/charmoniumQ/orgs,https://api.github.com/users/charmoniumQ/repos,https://api.github.com/users/charmoniumQ/events{/privacy},https://api.github.com/users/charmoniumQ/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9663/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
727,https://api.github.com/repos/dask/dask/issues/9666,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9666/labels{/name},https://api.github.com/repos/dask/dask/issues/9666/comments,https://api.github.com/repos/dask/dask/issues/9666/events,https://github.com/dask/dask/pull/9666,1451886706,PR_kwDOAbcwm85DCi5u,9666,Use repeat to build nearest boundary,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,5,2022-11-16T16:16:43Z,2024-04-29T01:46:19Z,,FIRST_TIME_CONTRIBUTOR,,"The current implementation of `map_overlap` with `boundary='nearest'` uses dark.array.overlap.nearest, which copies the first and last elements of the array, concatenate them, and then finally concatenate the array and the repeated first and last elements.

This works well, but produces unreadable visualizations. As an example, here's what one obtain for the following simple example.

```python
import dask.array as da

x = da.arange(50)
y = x.map_overlap(lambda x: x + 1, depth=20, boundary='nearest')

y.visualize(optimize_graph=False)
```

![69a8dde3-8f08-401a-a0d7-824f931bd62d](https://user-images.githubusercontent.com/3016805/202234553-906aa395-0ec5-4a29-b63b-0bc757d2cf85.png)

In this pull request, I replace the element copy/concatenate steps by a call to `da.repeat`. It's probably very similar in terms of performance (though I haven't tested that), but produces much cleaner graphs. Here it is for the previous example.

![9f55d512-0e9f-4fae-b273-eacbd399af17](https://user-images.githubusercontent.com/3016805/202234628-ec50226b-da50-4975-a38d-7b5aa55634cc.png)

- [X] Tests passed
- [X] Passes `pre-commit run --all-files`

",,https://api.github.com/repos/dask/dask/issues/9666/timeline,,,j2bbayle,3016805,MDQ6VXNlcjMwMTY4MDU=,https://avatars.githubusercontent.com/u/3016805?v=4,,https://api.github.com/users/j2bbayle,https://github.com/j2bbayle,https://api.github.com/users/j2bbayle/followers,https://api.github.com/users/j2bbayle/following{/other_user},https://api.github.com/users/j2bbayle/gists{/gist_id},https://api.github.com/users/j2bbayle/starred{/owner}{/repo},https://api.github.com/users/j2bbayle/subscriptions,https://api.github.com/users/j2bbayle/orgs,https://api.github.com/users/j2bbayle/repos,https://api.github.com/users/j2bbayle/events{/privacy},https://api.github.com/users/j2bbayle/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9666/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9666,https://github.com/dask/dask/pull/9666,https://github.com/dask/dask/pull/9666.diff,https://github.com/dask/dask/pull/9666.patch,,,,,,,,,,,,,,,,,,,
728,https://api.github.com/repos/dask/dask/issues/9674,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9674/labels{/name},https://api.github.com/repos/dask/dask/issues/9674/comments,https://api.github.com/repos/dask/dask/issues/9674/events,https://github.com/dask/dask/issues/9674,1454516303,I_kwDOAbcwm85WsihP,9674,Dask Groupby result multiple partitions with sorted=True.,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-11-18T06:01:34Z,2022-12-26T01:57:34Z,,NONE,,"I have a time-series data in dask dataframe. I am reading from huge parquet file (around 8 GB) which has 12 row-groups which translated to 12 partitions in dask after read_parquet.

[![enter image description here][1]][1]

After reading data there was multiple entries for a single timestamp. I performed groupby-sum aggregation over it to get rid of multiple entries.

[![enter image description here][2]][2]

This happened successfully but it changed number of partitions to 1 which is [expected](https://examples.dask.org/dataframes/02-groupby.html#Many-groups). Further, I have to run some downstream operations on it, such as handling null values, resampling, scaling and transforming it to sequences. 

1. I was following [this](https://stackoverflow.com/questions/51772090/dask-groupby-turns-multiple-partitions-into-one) question and was wondering would I lose parallelism because number of partition is 1 now? Does dask repartition it implicitly by default while performing operations on data frame?

2. I was checking [split_out](https://docs.dask.org/en/stable/generated/dask.dataframe.groupby.DataFrameGroupBy.aggregate.html) parameter to control number of partitions, but it gave me warning 

> Cannot guarantee sorted keys for `split_out>1`. Try using split_out=1,
> or grouping with sort=False.

but I need data sorted on timestamps. How can I ensure that while having npartitions > 1.

3. There are some downstream operations which can again run across partition and give result in single partition. Do I need to monitor partitions every time and [repartition](https://docs.dask.org/en/stable/generated/dask.dataframe.DataFrame.repartition.html) it explicitly to exploit parallelism?


  [1]: https://i.stack.imgur.com/DshdD.png
  [2]: https://i.stack.imgur.com/Otp70.png
",,https://api.github.com/repos/dask/dask/issues/9674/timeline,,,Arunes007,15686836,MDQ6VXNlcjE1Njg2ODM2,https://avatars.githubusercontent.com/u/15686836?v=4,,https://api.github.com/users/Arunes007,https://github.com/Arunes007,https://api.github.com/users/Arunes007/followers,https://api.github.com/users/Arunes007/following{/other_user},https://api.github.com/users/Arunes007/gists{/gist_id},https://api.github.com/users/Arunes007/starred{/owner}{/repo},https://api.github.com/users/Arunes007/subscriptions,https://api.github.com/users/Arunes007/orgs,https://api.github.com/users/Arunes007/repos,https://api.github.com/users/Arunes007/events{/privacy},https://api.github.com/users/Arunes007/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9674/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
729,https://api.github.com/repos/dask/dask/issues/9694,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9694/labels{/name},https://api.github.com/repos/dask/dask/issues/9694/comments,https://api.github.com/repos/dask/dask/issues/9694/events,https://github.com/dask/dask/pull/9694,1464074168,PR_kwDOAbcwm85Drywo,9694,Update flake8-bugbear with 'upadup',"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2022-11-25T06:03:34Z,2024-04-29T01:46:17Z,,FIRST_TIME_CONTRIBUTOR,," Hi there!

I've recently been tinkering on [a tool to complement `pre-commit autoupdate` and take care of `flake8-bugbear`](https://pypi.org/project/upadup/) and related `additional_dependencies` problems.

`pipx run upadup` is sufficient to see how it behaves on the `dask` config.

The tool is brand new, so it might have some rough edges, but I figured it would be nice to introduce it by means of PRs on projects to show that it works on their config. If you like it, it could go into the `flake8-bugbear` comment!",,https://api.github.com/repos/dask/dask/issues/9694/timeline,,,sirosen,1300022,MDQ6VXNlcjEzMDAwMjI=,https://avatars.githubusercontent.com/u/1300022?v=4,,https://api.github.com/users/sirosen,https://github.com/sirosen,https://api.github.com/users/sirosen/followers,https://api.github.com/users/sirosen/following{/other_user},https://api.github.com/users/sirosen/gists{/gist_id},https://api.github.com/users/sirosen/starred{/owner}{/repo},https://api.github.com/users/sirosen/subscriptions,https://api.github.com/users/sirosen/orgs,https://api.github.com/users/sirosen/repos,https://api.github.com/users/sirosen/events{/privacy},https://api.github.com/users/sirosen/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9694/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9694,https://github.com/dask/dask/pull/9694,https://github.com/dask/dask/pull/9694.diff,https://github.com/dask/dask/pull/9694.patch,,,,,,,,,,,,,,,,,,,
730,https://api.github.com/repos/dask/dask/issues/9698,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9698/labels{/name},https://api.github.com/repos/dask/dask/issues/9698/comments,https://api.github.com/repos/dask/dask/issues/9698/events,https://github.com/dask/dask/issues/9698,1465853782,I_kwDOAbcwm85XXydW,9698,TypeError: to_csv() missing 1 required positional argument: 'filename',"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-11-28T05:50:58Z,2023-01-02T01:57:09Z,,NONE,,"I am getting below warning while reading a dask dataframe, my xls file is of 1GB large and I need to wrangle that sheet, I am just writing some data to another csv file though to_csv but I am getting the error: 
TypeError: to_csv() missing 1 required positional argument: 'filename'

Skipping line 2: ',' expected after '""'
Skipping line 3: ',' expected after '""' 
......

from dask import dataframe as df1
df = df1.read_csv(""C:\\Work1\\Tool\\Work.xls"", engine=""python"", sep=',', quotechar='""', error_bad_lines=False, encoding = 'cp437')
df1.to_csv(""C:\\Work1\\WO.csv"", encoding = 'cp437',single_file=True, error_bad_lines = False)


if I am using pandas I am getting below error: 

Skipping line 904: '	' expected after '""'
Skipping line 19978: '	' expected after '""'
Skipping line 28555: '	' expected after '""'
Skipping line 29099: '	' expected after '""'

AttributeError: 'str' object has no attribute 'to_delayed'



Please some one help",,https://api.github.com/repos/dask/dask/issues/9698/timeline,,,prashant2601,46065119,MDQ6VXNlcjQ2MDY1MTE5,https://avatars.githubusercontent.com/u/46065119?v=4,,https://api.github.com/users/prashant2601,https://github.com/prashant2601,https://api.github.com/users/prashant2601/followers,https://api.github.com/users/prashant2601/following{/other_user},https://api.github.com/users/prashant2601/gists{/gist_id},https://api.github.com/users/prashant2601/starred{/owner}{/repo},https://api.github.com/users/prashant2601/subscriptions,https://api.github.com/users/prashant2601/orgs,https://api.github.com/users/prashant2601/repos,https://api.github.com/users/prashant2601/events{/privacy},https://api.github.com/users/prashant2601/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9698/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
731,https://api.github.com/repos/dask/dask/issues/9700,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9700/labels{/name},https://api.github.com/repos/dask/dask/issues/9700/comments,https://api.github.com/repos/dask/dask/issues/9700/events,https://github.com/dask/dask/issues/9700,1467881044,I_kwDOAbcwm85XfhZU,9700,"dask dataframe advertises `dot` applies to `DataFrame`, but is only implemented for `Series`","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2022-11-29T11:13:03Z,2023-01-02T01:57:08Z,,MEMBER,,"**Describe the issue**:

The `dot` method on dask dataframe objects is defined on `_Frame`, however, the implementation only works when the left operands is a `Series`. Calling `left_df.dot(right_df)` with appropriately aligned shapes therefore fails deep in pandas with a ""dataframes are not aligned"" error.

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import pandas as pd
import numpy as np

A = pd.DataFrame(np.arange(12).reshape(3, 4))
B = pd.DataFrame(np.arange(4).reshape(4, 1))

dA = dd.from_pandas(A, npartitions=1)
dB = dd.from_pandas(B, npartitions=1)

dC = dA.dot(dB, meta=pd.DataFrame(columns=dB.columns)).persist()
```

Backtrace

```
Traceback (most recent call last):
  File "".../src/doodles/cudf-12240/bug.py"", line 11, in <module>
    dC = dA.dot(dB, meta=pd.DataFrame(columns=dB.columns)).persist()
  File "".../src/dask/dask/base.py"", line 288, in persist
    (result,) = persist(self, traverse=False, **kwargs)
  File "".../src/dask/dask/base.py"", line 901, in persist
    results = schedule(dsk, keys, **kwargs)
  File "".../src/dask/dask/threaded.py"", line 89, in get
    results = get_async(
  File "".../src/dask/dask/local.py"", line 511, in get_async
    raise_exception(exc, tb)
  File "".../src/dask/dask/local.py"", line 319, in reraise
    raise exc
  File "".../src/dask/dask/local.py"", line 224, in execute_task
    result = _execute_task(task, data)
  File "".../src/dask/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File "".../src/dask/dask/optimization.py"", line 990, in __call__
    return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
  File "".../src/dask/dask/core.py"", line 149, in get
    result = _execute_task(task, cache)
  File "".../src/dask/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File "".../src/dask/dask/utils.py"", line 71, in apply
    return func(*args, **kwargs)
  File "".../src/dask/dask/dataframe/core.py"", line 6773, in apply_and_enforce
    df = func(*args, **kwargs)
  File "".../src/dask/dask/utils.py"", line 1103, in __call__
    return getattr(__obj, self.method)(*args, **kwargs)
  File "".../site-packages/pandas/core/frame.py"", line 1590, in dot
    raise ValueError(""matrices are not aligned"")
ValueError: matrices are not aligned
```

**Anything else we need to know?**:

Dask array, I think, implements `tensordot` (using a communication pattern I cannot deduce), so it might be possible to implement things by piggybacking on that implementation. An interim would be to move the implementation onto `Series` so that the API doesn't advertise something unsupported.",,https://api.github.com/repos/dask/dask/issues/9700/timeline,,,wence-,1126981,MDQ6VXNlcjExMjY5ODE=,https://avatars.githubusercontent.com/u/1126981?v=4,,https://api.github.com/users/wence-,https://github.com/wence-,https://api.github.com/users/wence-/followers,https://api.github.com/users/wence-/following{/other_user},https://api.github.com/users/wence-/gists{/gist_id},https://api.github.com/users/wence-/starred{/owner}{/repo},https://api.github.com/users/wence-/subscriptions,https://api.github.com/users/wence-/orgs,https://api.github.com/users/wence-/repos,https://api.github.com/users/wence-/events{/privacy},https://api.github.com/users/wence-/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9700/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
732,https://api.github.com/repos/dask/dask/issues/9702,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9702/labels{/name},https://api.github.com/repos/dask/dask/issues/9702/comments,https://api.github.com/repos/dask/dask/issues/9702/events,https://github.com/dask/dask/issues/9702,1468807871,I_kwDOAbcwm85XjDq_,9702,Support per-project YAML config files (search current directory),"[{'id': 1012929478, 'node_id': 'MDU6TGFiZWwxMDEyOTI5NDc4', 'url': 'https://api.github.com/repos/dask/dask/labels/config', 'name': 'config', 'color': '1586c0', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,7,2022-11-29T22:58:25Z,2024-04-29T01:46:15Z,,MEMBER,,"Dask currently supports YAML config files at a number of _global_ paths: https://docs.dask.org/en/stable/configuration.html#yaml-files. However, it can be useful to set configuration per-project.

You can currently do this by creating a YAML file in your repo (say `dask.yaml`) and setting `DASK_CONFIG=dask.yaml`. But then you need to remember to set the environment variable all the time, or use dotenv or something.

It would be nice if Dask would also also search for a `dask.yaml` file (name up for debate) in the current directory, and have it take precedence over the other layers of config. Possibly it could also traverse up from the current directory until it found a `dask.yaml` file.",,https://api.github.com/repos/dask/dask/issues/9702/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9702/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
733,https://api.github.com/repos/dask/dask/issues/9705,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9705/labels{/name},https://api.github.com/repos/dask/dask/issues/9705/comments,https://api.github.com/repos/dask/dask/issues/9705/events,https://github.com/dask/dask/pull/9705,1469411681,PR_kwDOAbcwm85D9W8T,9705,DataFrame.dot is not implemented,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,0,2022-11-30T10:36:59Z,2024-04-22T01:46:24Z,,MEMBER,,"Raise a useful error message in this case.

- [x] Closes #9700
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9705/timeline,,,wence-,1126981,MDQ6VXNlcjExMjY5ODE=,https://avatars.githubusercontent.com/u/1126981?v=4,,https://api.github.com/users/wence-,https://github.com/wence-,https://api.github.com/users/wence-/followers,https://api.github.com/users/wence-/following{/other_user},https://api.github.com/users/wence-/gists{/gist_id},https://api.github.com/users/wence-/starred{/owner}{/repo},https://api.github.com/users/wence-/subscriptions,https://api.github.com/users/wence-/orgs,https://api.github.com/users/wence-/repos,https://api.github.com/users/wence-/events{/privacy},https://api.github.com/users/wence-/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9705/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9705,https://github.com/dask/dask/pull/9705,https://github.com/dask/dask/pull/9705.diff,https://github.com/dask/dask/pull/9705.patch,,,,,,,,,,,,,,,,,,,
734,https://api.github.com/repos/dask/dask/issues/9706,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9706/labels{/name},https://api.github.com/repos/dask/dask/issues/9706/comments,https://api.github.com/repos/dask/dask/issues/9706/events,https://github.com/dask/dask/pull/9706,1470744483,PR_kwDOAbcwm85EB5HX,9706,[WIP] Add parquet-statistics utility and optimize __len__,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,0,2022-12-01T06:12:52Z,2022-12-08T14:17:52Z,,MEMBER,,"Adds a new (experimental) `layer_statistics` utility to the `dask.dataframe.io.parquet` module.  When passed a high-level-graph `Layer`, this utility extracts the partition-wise path/row-group mapping, and then generates a list of statistics for each partition.

This PR also shows how the new utility can be used to optimize `DataFrame.__len__` without explicitly tracking partition lens in the `DataFrame` class itself.

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
- [ ] Support fastparquet engine
- [ ] Cleanup
",,https://api.github.com/repos/dask/dask/issues/9706/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9706/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9706,https://github.com/dask/dask/pull/9706,https://github.com/dask/dask/pull/9706.diff,https://github.com/dask/dask/pull/9706.patch,,,,,,,,,,,,,,,,,,,
735,https://api.github.com/repos/dask/dask/issues/9709,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9709/labels{/name},https://api.github.com/repos/dask/dask/issues/9709/comments,https://api.github.com/repos/dask/dask/issues/9709/events,https://github.com/dask/dask/issues/9709,1471737800,I_kwDOAbcwm85XuO_I,9709,Adding partition end into partition_info,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2022-12-01T18:09:31Z,2024-04-22T01:46:23Z,,CONTRIBUTOR,,"When using _map_partitions()_, some computation needs the theoretical partition end in order to avoid overlapping with the next partition.
We could either add the **next** and **last** divisions or the entire **divisions** tuple.
```python
partition_info = {
   'division': ...
   'next_division': ...
   'last_division' or 'is_last': ...
}
# Or
partition_info = {
   'division': ...  # current div
   'divisions': ... # every divisions (memory / IO consuming?)
}
```

The PR looks easy, I can do it if we agree on.
",,https://api.github.com/repos/dask/dask/issues/9709/timeline,,,epizut,1694892,MDQ6VXNlcjE2OTQ4OTI=,https://avatars.githubusercontent.com/u/1694892?v=4,,https://api.github.com/users/epizut,https://github.com/epizut,https://api.github.com/users/epizut/followers,https://api.github.com/users/epizut/following{/other_user},https://api.github.com/users/epizut/gists{/gist_id},https://api.github.com/users/epizut/starred{/owner}{/repo},https://api.github.com/users/epizut/subscriptions,https://api.github.com/users/epizut/orgs,https://api.github.com/users/epizut/repos,https://api.github.com/users/epizut/events{/privacy},https://api.github.com/users/epizut/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9709/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
736,https://api.github.com/repos/dask/dask/issues/9710,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9710/labels{/name},https://api.github.com/repos/dask/dask/issues/9710/comments,https://api.github.com/repos/dask/dask/issues/9710/events,https://github.com/dask/dask/issues/9710,1471910379,I_kwDOAbcwm85Xu5Hr,9710,Reexports not explicitly specified for typecheckers,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,3,2022-12-01T20:20:41Z,2024-04-22T01:46:22Z,,NONE,,"**Describe the issue**:
Running pyright or `mypy --strict` on a file using `dask.dataframe.from_pandas()` will error with:
```
# pyright
error: ""from_pandas"" is not exported from module ""dask.dataframe"" (reportPrivateImportUsage)

# mypy --strict
error: ""Module dask.dataframe"" does not explicitly export attribute ""from_pandas""  [attr-defined]
```

**Minimal Complete Verifiable Example**:

```python
import pandas
import dask.dataframe as dd

df = pandas.DataFrame()
dd.from_pandas(df)
```

**Anything else we need to know?**:
It seems like all that's needed is adding appropriate `__all__` identifiers

More details: https://github.com/microsoft/pyright/issues/3409

**Environment**:

- Dask version:
- Python version:
- Operating System:
- Install method (conda, pip, source):
",,https://api.github.com/repos/dask/dask/issues/9710/timeline,,,brandon-leapyear,27799541,MDQ6VXNlcjI3Nzk5NTQx,https://avatars.githubusercontent.com/u/27799541?v=4,,https://api.github.com/users/brandon-leapyear,https://github.com/brandon-leapyear,https://api.github.com/users/brandon-leapyear/followers,https://api.github.com/users/brandon-leapyear/following{/other_user},https://api.github.com/users/brandon-leapyear/gists{/gist_id},https://api.github.com/users/brandon-leapyear/starred{/owner}{/repo},https://api.github.com/users/brandon-leapyear/subscriptions,https://api.github.com/users/brandon-leapyear/orgs,https://api.github.com/users/brandon-leapyear/repos,https://api.github.com/users/brandon-leapyear/events{/privacy},https://api.github.com/users/brandon-leapyear/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9710/reactions,9,9,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
737,https://api.github.com/repos/dask/dask/issues/9711,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9711/labels{/name},https://api.github.com/repos/dask/dask/issues/9711/comments,https://api.github.com/repos/dask/dask/issues/9711/events,https://github.com/dask/dask/pull/9711,1472234191,PR_kwDOAbcwm85EG9PF,9711,[WIP] Support `pandas` `mode.string_storage` option in `read_parquet`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,"[{'login': 'jrbourbeau', 'id': 11656932, 'node_id': 'MDQ6VXNlcjExNjU2OTMy', 'avatar_url': 'https://avatars.githubusercontent.com/u/11656932?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/jrbourbeau', 'html_url': 'https://github.com/jrbourbeau', 'followers_url': 'https://api.github.com/users/jrbourbeau/followers', 'following_url': 'https://api.github.com/users/jrbourbeau/following{/other_user}', 'gists_url': 'https://api.github.com/users/jrbourbeau/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/jrbourbeau/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/jrbourbeau/subscriptions', 'organizations_url': 'https://api.github.com/users/jrbourbeau/orgs', 'repos_url': 'https://api.github.com/users/jrbourbeau/repos', 'events_url': 'https://api.github.com/users/jrbourbeau/events{/privacy}', 'received_events_url': 'https://api.github.com/users/jrbourbeau/received_events', 'type': 'User', 'site_admin': False}]",,0,2022-12-02T02:53:44Z,2024-04-22T01:46:21Z,,MEMBER,,"Pushing up a quick diff to help aid the conversation happening here https://github.com/dask/dask/issues/9631#issuecomment-1334433767. The `test_pandas_string_storage_option` test added here demonstrates the behavior we ultimately want, but the actual changes to `read_parquet` are still preliminary (I suspect we'll need more changes). ",,https://api.github.com/repos/dask/dask/issues/9711/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9711/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9711,https://github.com/dask/dask/pull/9711,https://github.com/dask/dask/pull/9711.diff,https://github.com/dask/dask/pull/9711.patch,,jrbourbeau,11656932.0,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False
738,https://api.github.com/repos/dask/dask/issues/9712,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9712/labels{/name},https://api.github.com/repos/dask/dask/issues/9712/comments,https://api.github.com/repos/dask/dask/issues/9712/events,https://github.com/dask/dask/issues/9712,1473401217,I_kwDOAbcwm85X0lGB,9712,[DISCUSSION] Rethinking default read_parquet partitioning,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,5,2022-12-02T20:20:13Z,2024-04-22T01:46:21Z,,MEMBER,,"This is mostly a brain dump, so I realize this may be difficult to process. With that said, I welcome any thoughts and feedback (both positive and negative)

I spent some time yesterday working through the following exercise: **If I were defining and writing the `dask.dataframe.read_parquet` API from scratch, what would it look like?**

I experimented for a few hours before arriving at an API that was not all that different from what we have today. The key difference was that my ""ideal"" API was prioritizing **efficient*** partition sizes, while `dd.read_parquet` is only prioritizing metadata-processing latency.  That is, `dd.read_parquet` is doing its very best to avoid processing Parquet metadata, just in case the data is in remote storage.  Although this decision makes sense in context, I believe we are much better off prioritizing efficient partition sizes, and warning (and instructing) the user (ahead of time) when we expect the defaults to case pain.

To better-prioritize efficient partitioning, I suspect we could make the following changes:

- Remove `split_row_groups` completely
  - This is the most-significant **breaking** change considered here. However, it is probably possible to translate most `split_row_groups` uses into *other* options (clearing a manageable path for deprecation)
- Remove `aggregate_files` completely
  - This option is already ""pre-deprecated,"" so this should be manageable
- I'd deprecate the current meaning of `chunksize`
  - It should mean ""the maximum-desired **row-count** in a partition"" to be more consistent with similarly-named arguments in pandas/pyarrow
  - The default for `chunksize` (or maybe `chunk_size`) should be `None`
  - The existing `chunksize` option is already ""pre-deprecated,"" so this may be manageable
- I'd add a new `blocksize` argument
  - **Meaning**: ""the maximum desired (uncompressed) storage size to map to each partition""
  - The default for `blocksize` would be set by the engine (so it could be larger in dask_cudf)
  - `chunksize` would take precedence over `blocksize` (since row-count is a more-specific criteria)
- I'd add a `granularity` argument
  - **Options**: `""row-group""`, `""file""`, `(""row-group"", <int>)`, or `(""file"", <int>)`
    - **Note**: I'm not crazy about the `(""row-group"", <int>)` or `(""file"", <int>)` options, but this would allow us to avoid breaking existing code that uses `split_row_groups=<int>`
  - **Meaning**: What kind of ""metadata fragments"" should we work with when processing metadata and generating a ""partitioning plan""
  - The default would be `""file""` when both `blocksize` and `chunksize` are set to `None`, and `""row-group""` otherwise
- I'd add a `file_groups` argument
  - **Meaning**: Whether any directory-partitioned columns should be used to prevent two row-groups or files from being mapped to the same output DataFrame partition. For example, the user might specify something like groups=[""year"", ""month""] (leaving out ""day"") to indicate that they want every row in a given partition to correspond to the same year and month.
  - Default would be `None`
  - `True` could be taken to mean that an output partition can only map to a single file (i.e. ""all files are a distinct group"")
- I'd use `dask.delayed` to eagerly collect ""metadata-fragment"" records from the dataset in parallel
  - `granularity` would determine if each metadata-fragment record corresponds to a file, row-group, or integer-stride of files/row-groups
  - These records would be used (on the client) to construct a partitioning plan that satisfies `chunksize`, `blocksize` and `file_groups`
  - For large datasets (where we known that there are **many** records to collect) on remote storage, I would raise a `UserWarning` to suggest that the user set `blocksize=None` or use `granularity=""file""` if latency is too high and/or files are sufficiently small (this warning would be silenced if any of the partitioning arguments were explicitly set)
    - This would allow us to prioritize good default partition sizes, and leave it up to the user to opt into a simple per-file mapping if they must avoid parsing metadata at all costs",,https://api.github.com/repos/dask/dask/issues/9712/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9712/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
739,https://api.github.com/repos/dask/dask/issues/9713,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9713/labels{/name},https://api.github.com/repos/dask/dask/issues/9713/comments,https://api.github.com/repos/dask/dask/issues/9713/events,https://github.com/dask/dask/issues/9713,1473595460,I_kwDOAbcwm85X1UhE,9713,dask.dataframe.from_pandas  weird docs display.,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2022-12-02T23:51:54Z,2024-04-22T01:46:20Z,,MEMBER,,"When you go to the docs for [`dask.dataframe.from_pandas`](https://docs.dask.org/en/stable/generated/dask.dataframe.from_pandas.html)

The blue section appears twice, once for dataframe and once series, is this expected, or is this a bug?

![Screen Shot 2022-12-02 at 6 49 19 PM](https://user-images.githubusercontent.com/7526622/205410248-ee6ea1c3-76a7-43f4-9950-5fb9f23a8793.png)

cc: @jacobtomlinson ",,https://api.github.com/repos/dask/dask/issues/9713/timeline,,,ncclementi,7526622,MDQ6VXNlcjc1MjY2MjI=,https://avatars.githubusercontent.com/u/7526622?v=4,,https://api.github.com/users/ncclementi,https://github.com/ncclementi,https://api.github.com/users/ncclementi/followers,https://api.github.com/users/ncclementi/following{/other_user},https://api.github.com/users/ncclementi/gists{/gist_id},https://api.github.com/users/ncclementi/starred{/owner}{/repo},https://api.github.com/users/ncclementi/subscriptions,https://api.github.com/users/ncclementi/orgs,https://api.github.com/users/ncclementi/repos,https://api.github.com/users/ncclementi/events{/privacy},https://api.github.com/users/ncclementi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9713/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
740,https://api.github.com/repos/dask/dask/issues/9714,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9714/labels{/name},https://api.github.com/repos/dask/dask/issues/9714/comments,https://api.github.com/repos/dask/dask/issues/9714/events,https://github.com/dask/dask/issues/9714,1475500051,I_kwDOAbcwm85X8lgT,9714,Generalized ufuncs don't always work for cupy chunked dask arrays,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}, {'id': 4410724893, 'node_id': 'LA_kwDOAbcwm88AAAABBuZSHQ', 'url': 'https://api.github.com/repos/dask/dask/labels/gpu', 'name': 'gpu', 'color': '3D0CD2', 'default': False, 'description': ''}]",open,False,,[],,9,2022-12-05T02:54:05Z,2024-04-22T01:46:19Z,,MEMBER,,"# Issue summary
Dask generalized ufuncs do not work correctly when given Dask arrays containing cupy chunks.

This issue was first reported by @lrlunin in https://github.com/dask/dask-image/issues/275 (I'd prefer to transfer that issue here to avoid losing the discussion, but it appears that requires ""write"" instead of ""triage"" level access to both repos). I've copy-pasted the contents of [my comment](https://github.com/dask/dask-image/issues/275#issuecomment-1333148164) here.

## Minimal reproducible example
You can run this quick test on [Google Colab](https://colab.research.google.com/), if you don't have a GPU on your local machine.
1. From the Google Colab ""Runtime"" menu, click ""Change Runtime Type"" and check the runtime type is set to ""GPU"".
2. Install cupy into the notebook environment. Copy-paste `!pip install cupy-cuda11x` into a notebook cell and execute it.

I used [this docstring example](https://github.com/dask/dask/blob/main/dask/array/gufunc.py#L277-L283) to make a minimal, reproducible test.

It works as expected with a numpy backed dask array:
```python
import dask.array as da
import numpy as np

def outer_product(x, y):
    return np.einsum(""i,j->ij"", x, y)

a = da.random.normal(size=(20,30), chunks=(10, 30))
b = da.random.normal(size=(10, 1,40), chunks=(5, 1, 40))
c = da.apply_gufunc(outer_product, ""(i),(j)->(i,j)"", a, b, vectorize=True)
c.compute().shape
# Expected output: (10, 20, 30, 40)
# Works as expected
```

Fails with a cupy backed dask array:
```python
import dask.array as da
import cupy as cp

def outer_product(x, y):
    return cp.einsum(""i,j->ij"", x, y)

data_a = cp.random.normal(size=(20,30))
a = da.from_array(data_a, chunks=(10, 30))
data_b = cp.random.normal(size=(10, 1,40))
b = da.from_array(data_b, chunks=(5, 1, 40))
c = da.apply_gufunc(outer_product, ""(i),(j)->(i,j)"", a, b, vectorize=True)
c.compute().shape
# Expected output: (10, 20, 30, 40)
# TypeError: Implicit conversion to a NumPy array is not allowed. Please use `.get()` to construct a NumPy array explicitly.
```

Notably, [this other docstring example](https://github.com/dask/dask/blob/main/dask/array/gufunc.py#L267-L274) *does* work with a dask array containing cupy chunks. This example does not use the `vectorize` keyword argument, which is probably why we don't see the problem here.

## Hypothesis
There are several lines in [dask/array/gufunc.py](https://github.com/dask/dask/blob/main/dask/array/gufunc.py) that have numpy specific functions
(`np.vectorize` and `np.newaxis`, see [here](https://github.com/dask/dask/blob/b1e468e8645baee30992fbfa84250d816ac1098a/dask/array/gufunc.py#L312), [here](https://github.com/dask/dask/blob/b1e468e8645baee30992fbfa84250d816ac1098a/dask/array/gufunc.py#L362), and [here](https://github.com/dask/dask/blob/b1e468e8645baee30992fbfa84250d816ac1098a/dask/array/gufunc.py#L508)). These lines might be causing this problem for dask arrays containing cupy chunks.

## What we've tried so far
To test this idea, I tried switching out the `np.vectorize` functions for the [`cupy.vectorize` function](https://docs.cupy.dev/en/stable/reference/generated/cupy.vectorize.html). 

Unfortunately, cupy gives me this error: 
```
NotImplementedError: cupy.vectorize does not support `signature` option currently.
```
See [here](https://github.com/cupy/cupy/blob/v11.3.0/cupy/_functional/vectorize.py#L52-L55) in the cupy source code.

## What to do next?
We could make a feature request issue in the [cupy repository](https://github.com/cupy/cupy/issues), for supporting the `signature` keyword argument in `cupy.vectorize`. I don't know where that request would fit in to their other priorities.

If that was implemented, Dask could then consider replacing the three numpy-specific lines in [dask/array/gufunc.py](https://github.com/dask/dask/blob/main/dask/array/gufunc.py) with some sort of dispatching solution, so that `np.vectorize` is used by numpy backed dask arrays, and `cupy.vectorize` is used by cupy backed dask arrays.

**Environment**:

- Dask version: 2022.2.0
- Python version: 3.8.15
- Operating System: [Google Colab](https://colab.research.google.com/) is running Linux version #1 SMP Fri Aug 26 08:44:51 UTC 2022
- Install method (conda, pip, source):
  - dask 2022.2.0 came pre-installed on Google Colab (presumably installed with pip)
  - `pip install cupy-cuda11x` (installs version cupy-cuda11x-11.3.0)
- CUDA information: `nvcc --version`
```
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2021 NVIDIA Corporation
Built on Sun_Feb_14_21:12:58_PST_2021
Cuda compilation tools, release 11.2, V11.2.152
Build cuda_11.2.r11.2/compiler.29618528_0
```",,https://api.github.com/repos/dask/dask/issues/9714/timeline,,,GenevieveBuckley,30920819,MDQ6VXNlcjMwOTIwODE5,https://avatars.githubusercontent.com/u/30920819?v=4,,https://api.github.com/users/GenevieveBuckley,https://github.com/GenevieveBuckley,https://api.github.com/users/GenevieveBuckley/followers,https://api.github.com/users/GenevieveBuckley/following{/other_user},https://api.github.com/users/GenevieveBuckley/gists{/gist_id},https://api.github.com/users/GenevieveBuckley/starred{/owner}{/repo},https://api.github.com/users/GenevieveBuckley/subscriptions,https://api.github.com/users/GenevieveBuckley/orgs,https://api.github.com/users/GenevieveBuckley/repos,https://api.github.com/users/GenevieveBuckley/events{/privacy},https://api.github.com/users/GenevieveBuckley/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9714/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
741,https://api.github.com/repos/dask/dask/issues/9718,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9718/labels{/name},https://api.github.com/repos/dask/dask/issues/9718/comments,https://api.github.com/repos/dask/dask/issues/9718/events,https://github.com/dask/dask/issues/9718,1477110894,I_kwDOAbcwm85YCuxu,9718,"DOC: add example showing dask.delayed on a range, with usage of `nout`","[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,4,2022-12-05T18:02:16Z,2024-04-22T01:46:18Z,,NONE,,"Hi devs and thank you for `dask`. I very much appreciate how easy it makes parallelizing things.

That said, I'd like to suggest adding an example to the docs that I think is a simple yet common use case that took me a while to figure out, something like the following:
```
results = []
for _ in range(n_times):
   results = do_task(**task_kwargs)
```

This would be common to e.g. run $n$ repeats of a simulation where results across runs are not dependent. 

Originally I thought I should do this somehow with a `dask.bag`.  
As I understand it now, the right way to do this is with `dask.delayed`.
The current docs and examples for `dask.delayed` focus on how it is collection agnostic (not an array, bag, or dataframe), but AFAICT it does not address this case that seems like it would be the first thing many people might think of.

The closest is I can find is this snippet, that doesn't show making a graph + calling compute on it:
https://docs.dask.org/en/stable/delayed-best-practices.html?highlight=range#avoid-too-many-tasks

Here's is an SO post suggesting I might not be the only one confused by this, with the answer that made me realize I should be using `dask.delayed`, and not trying to somehow combine the delayed wrapper with a bag.
https://stackoverflow.com/questions/61215533/how-to-parallelize-a-loop-with-dask

I fought with this though, and especially kept running into the error:
> Delayed objects of unspecified length are not iterable

Finally I found this explanation in an issue:
https://github.com/dask/dask/issues/6060#issuecomment-611539087

Putting it all together, the example I am suggesting adding would be like the following (maybe on 'https://docs.dask.org/en/stable/delayed.html' since 'examples.dask' seems to be very focused on distributed?):

```python
import dask

def my_expensive_function(**kwargs):
   ... 
   return result, stats, history

expensive_function_delayed = dask.delayed(my_expensive_function, nout=3)

def run_repeats_of_expensive_function(func_kwargs, n_repeats=100):
    delayed = []
    for _ in range(n_repeats):
        delayed.append(my_expensive_function_delayed(**func_kwargs))
    graph = dask.delayed()(delayed)
    return graph.compute()
```
with a brief `admonition` in the text letting someone know `nout` exists, in case they are so unsure of how to solve the problem correctly that they don't stop to carefully read all the docstrings",,https://api.github.com/repos/dask/dask/issues/9718/timeline,,,NickleDave,11934090,MDQ6VXNlcjExOTM0MDkw,https://avatars.githubusercontent.com/u/11934090?v=4,,https://api.github.com/users/NickleDave,https://github.com/NickleDave,https://api.github.com/users/NickleDave/followers,https://api.github.com/users/NickleDave/following{/other_user},https://api.github.com/users/NickleDave/gists{/gist_id},https://api.github.com/users/NickleDave/starred{/owner}{/repo},https://api.github.com/users/NickleDave/subscriptions,https://api.github.com/users/NickleDave/orgs,https://api.github.com/users/NickleDave/repos,https://api.github.com/users/NickleDave/events{/privacy},https://api.github.com/users/NickleDave/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9718/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
742,https://api.github.com/repos/dask/dask/issues/9725,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9725/labels{/name},https://api.github.com/repos/dask/dask/issues/9725/comments,https://api.github.com/repos/dask/dask/issues/9725/events,https://github.com/dask/dask/pull/9725,1481664588,PR_kwDOAbcwm85En-t5,9725,Upgrade `tiledb-py` to `>=0.18.3` in CI,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2022-12-07T11:16:43Z,2024-04-22T01:46:17Z,,MEMBER,,"tiledb-py 0.18 is needed for python 3.11 support, so this pin would prevent the upgrade
see also https://github.com/dask/dask/pull/9569

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9725/timeline,,,graingert,413772,MDQ6VXNlcjQxMzc3Mg==,https://avatars.githubusercontent.com/u/413772?v=4,,https://api.github.com/users/graingert,https://github.com/graingert,https://api.github.com/users/graingert/followers,https://api.github.com/users/graingert/following{/other_user},https://api.github.com/users/graingert/gists{/gist_id},https://api.github.com/users/graingert/starred{/owner}{/repo},https://api.github.com/users/graingert/subscriptions,https://api.github.com/users/graingert/orgs,https://api.github.com/users/graingert/repos,https://api.github.com/users/graingert/events{/privacy},https://api.github.com/users/graingert/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9725/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9725,https://github.com/dask/dask/pull/9725,https://github.com/dask/dask/pull/9725.diff,https://github.com/dask/dask/pull/9725.patch,,,,,,,,,,,,,,,,,,,
743,https://api.github.com/repos/dask/dask/issues/9729,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9729/labels{/name},https://api.github.com/repos/dask/dask/issues/9729/comments,https://api.github.com/repos/dask/dask/issues/9729/events,https://github.com/dask/dask/issues/9729,1483273854,I_kwDOAbcwm85YaPZ-,9729,`visualize` is misleading when multiple operations have the same name,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2022-12-08T01:11:12Z,2024-04-15T02:49:04Z,,MEMBER,,"If multiple, distinct tasks in the graph have the same prefix, they are inaccurately collapsed into a single node in `visualize`. This can be very misleading when trying to understand what's happening in a graph.

```python
import dask.array as da

a = da.ones((30,), chunks=(10,))
b = da.ones((30,), chunks=(10,))
(a + b).visualize('test.png', optimize_graph=False)
```

![test](https://user-images.githubusercontent.com/3309802/206330995-ec8dc75d-4a02-4a97-b475-279c702ec5be.png)

By just changing the names, the tree structure you'd expect suddenly appears:

```python
import dask.array as da

a = da.ones((30,), chunks=(10,))
b = da.ones((30,), chunks=(10,), name=""foo"")
(a + b).visualize('test.png', optimize_graph=False)
```
![test](https://user-images.githubusercontent.com/3309802/206331508-891d7961-7b8a-4456-a1aa-a012f2533d8f.png)",,https://api.github.com/repos/dask/dask/issues/9729/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9729/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
744,https://api.github.com/repos/dask/dask/issues/9730,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9730/labels{/name},https://api.github.com/repos/dask/dask/issues/9730/comments,https://api.github.com/repos/dask/dask/issues/9730/events,https://github.com/dask/dask/pull/9730,1484841474,PR_kwDOAbcwm85EzRpP,9730,Introduce support for directory-specific Dask config,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2022-12-08T15:08:40Z,2023-01-09T01:59:06Z,,MEMBER,,"Adds directory-specific `.dask` config files (name chosen arbitrarily) to the top of Dask's config precedence, with those closest to the current working directory prioritized, making it so users can configure Dask on a per-[sub]directory level.

- [ ] Closes #9702 
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9730/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9730/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9730,https://github.com/dask/dask/pull/9730,https://github.com/dask/dask/pull/9730.diff,https://github.com/dask/dask/pull/9730.patch,,,,,,,,,,,,,,,,,,,
745,https://api.github.com/repos/dask/dask/issues/9732,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9732/labels{/name},https://api.github.com/repos/dask/dask/issues/9732/comments,https://api.github.com/repos/dask/dask/issues/9732/events,https://github.com/dask/dask/pull/9732,1485330544,PR_kwDOAbcwm85E0-zD,9732,Remove source and target optimization in array.store,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,6,2022-12-08T20:10:42Z,2024-04-15T02:49:02Z,,CONTRIBUTOR,,"As discussed in #8380, there are cases where a user may want to store multiple sources or store to multiple targets that share tasks somewhere in their history. In current `main` calling `da.store` with `compute=False` results in the individual dask graphs being optimized (fused tasks, renamed tasks, etc) which means future computations won't be able to combine/share tasks any more. In simplified code this looks like:

```python
src1 = ...
src2 = ...  # <- shares tasks with src1
store1 = da.store(src1, target1, compute=False)
store2 = da.store(src2, target2, compute=False)
da.compute(store1, store2)  # <- this will compute shared tasks twice
```

As I was working on a fix for this, I realized that I don't think there is any need for `da.store` to optimize anything before final computation. I *think* all computation will optimize the graphs anyway so the only benefit to early optimization is to reduce the graphs/dictionaries that are passed around internally in `da.store` (a small benefit if I'm not mistaken).

Lastly a question on dask PR best practice: What are the feelings about including refactorings in a PR alongside bug fixes? For example, the `da.store` function could be split into a lot of sub-functions that would reduce cyclomatic complexity of the function and make it easier to read. But for overall appearance of the PR it could make it harder to review.

- [x] Closes #8380
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9732/timeline,,,djhoese,1828519,MDQ6VXNlcjE4Mjg1MTk=,https://avatars.githubusercontent.com/u/1828519?v=4,,https://api.github.com/users/djhoese,https://github.com/djhoese,https://api.github.com/users/djhoese/followers,https://api.github.com/users/djhoese/following{/other_user},https://api.github.com/users/djhoese/gists{/gist_id},https://api.github.com/users/djhoese/starred{/owner}{/repo},https://api.github.com/users/djhoese/subscriptions,https://api.github.com/users/djhoese/orgs,https://api.github.com/users/djhoese/repos,https://api.github.com/users/djhoese/events{/privacy},https://api.github.com/users/djhoese/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9732/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9732,https://github.com/dask/dask/pull/9732,https://github.com/dask/dask/pull/9732.diff,https://github.com/dask/dask/pull/9732.patch,,,,,,,,,,,,,,,,,,,
746,https://api.github.com/repos/dask/dask/issues/9735,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9735/labels{/name},https://api.github.com/repos/dask/dask/issues/9735/comments,https://api.github.com/repos/dask/dask/issues/9735/events,https://github.com/dask/dask/issues/9735,1485857096,I_kwDOAbcwm85YkGFI,9735,Make `test_upstream_packages_installed` more robust,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2022-12-09T02:56:36Z,2023-01-09T01:59:03Z,,MEMBER,,"In https://github.com/dask/dask/pull/9731, we added a test that checks that certain packages installed are a nightly/dev/release candidate/etc. version (only runs in our `upstream` build)

https://github.com/dask/dask/blob/e6511215a025bf8ac967bab6955cecadd83322c1/dask/tests/test_ci.py#L12-L38

This works great for packages that have a dedicated nightly conda channel or PyPI index. However, the logic in this test can fail for packages that use `git` tags to determine versions (e.g. versionseer) when installed directly from GitHub as the latest `main` branch can sometimes point to a released version of the project.

For now we've temporarily commented out these impacted projects, but it'd be great if we could update things to work for those cases. 
",,https://api.github.com/repos/dask/dask/issues/9735/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9735/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
747,https://api.github.com/repos/dask/dask/issues/9763,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9763/labels{/name},https://api.github.com/repos/dask/dask/issues/9763/comments,https://api.github.com/repos/dask/dask/issues/9763/events,https://github.com/dask/dask/issues/9763,1497629148,I_kwDOAbcwm85ZRAHc,9763,It raises Error to Index dask.dataframe's index by applied series.,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2022-12-15T01:03:03Z,2024-04-15T02:49:01Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

**Minimal Complete Verifiable Example**:
```
toy_df = pd.DataFrame(
                    np.random.randn(10,3),
                    columns = list(""ABC""),
                    index = list(range(10)),
)

toy_ddf1 = dd.from_pandas(toy_df, npartitions=2)

s1 = toy_ddf1['A'].apply(lambda x: abs(x) < 0.5 , meta = ('A', 'bool'))

toy_ddf1.index[s1]
```

raises an Error
```
Traceback (most recent call last):
  File ""/software/anaconda3/envs/TOSC_ML/lib/python3.10/site-packages/IPython/core/interactiveshell.py"", line 3398, in run_code
    exec(code_obj, self.user_global_ns, self.user_ns)
  File ""/tmp/ipykernel_2591361/913354499.py"", line 1, in <cell line: 1>
    toy_ddf1.index[s1]
  File ""/software/anaconda3/envs/TOSC_ML/lib/python3.10/site-packages/dask/dataframe/core.py"", line 3486, in __getitem__
    return Series(graph, name, self._meta, self.divisions)
  File ""/software/anaconda3/envs/TOSC_ML/lib/python3.10/site-packages/dask/dataframe/core.py"", line 321, in __init__
    raise TypeError(
TypeError: Expected meta to specify type Series, got type pandas.core.indexes.numeric.Int64Index
```


```python
# Put your MCVE code here
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2022.2.1
- Python version: 3.10
- Operating System: CentOS Linux release 8.4.2105
- Install method (conda, pip, source): conda





",,https://api.github.com/repos/dask/dask/issues/9763/timeline,,reopened,Crispy13,47196430,MDQ6VXNlcjQ3MTk2NDMw,https://avatars.githubusercontent.com/u/47196430?v=4,,https://api.github.com/users/Crispy13,https://github.com/Crispy13,https://api.github.com/users/Crispy13/followers,https://api.github.com/users/Crispy13/following{/other_user},https://api.github.com/users/Crispy13/gists{/gist_id},https://api.github.com/users/Crispy13/starred{/owner}{/repo},https://api.github.com/users/Crispy13/subscriptions,https://api.github.com/users/Crispy13/orgs,https://api.github.com/users/Crispy13/repos,https://api.github.com/users/Crispy13/events{/privacy},https://api.github.com/users/Crispy13/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9763/reactions,0,0,0,0,0,0,0,0,0,quasiben,1403768.0,MDQ6VXNlcjE0MDM3Njg=,https://avatars.githubusercontent.com/u/1403768?v=4,,https://api.github.com/users/quasiben,https://github.com/quasiben,https://api.github.com/users/quasiben/followers,https://api.github.com/users/quasiben/following{/other_user},https://api.github.com/users/quasiben/gists{/gist_id},https://api.github.com/users/quasiben/starred{/owner}{/repo},https://api.github.com/users/quasiben/subscriptions,https://api.github.com/users/quasiben/orgs,https://api.github.com/users/quasiben/repos,https://api.github.com/users/quasiben/events{/privacy},https://api.github.com/users/quasiben/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
748,https://api.github.com/repos/dask/dask/issues/9765,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9765/labels{/name},https://api.github.com/repos/dask/dask/issues/9765/comments,https://api.github.com/repos/dask/dask/issues/9765/events,https://github.com/dask/dask/issues/9765,1498809134,I_kwDOAbcwm85ZVgMu,9765,`sort_values` fails to sort by nullable numeric columns when a partition is entirely null,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,6,2022-12-15T17:16:59Z,2024-04-15T02:49:00Z,,MEMBER,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
When attempting to sort a dataframe by a nullable numeric column (e.g. `Int64`) that has a partition made up entirely of `pd.NA`, we fail at the computation of divisions with `TypeError: boolean value of NA is ambiguous`.

It looks like the underlying issue here is that the various algorithms behind `_repartition_quantiles` (specifically `merge_and_compress_summaries` and `process_val_weights`) have support for `np.nan` but not `pd.NA`.

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import pandas as pd

df = pd.DataFrame({""a"": [2, 3, 1, 2, None, None]})
df[""a""] = df[""a""].astype(""Int64"")

ddf = dd.from_pandas(df, npartitions=3)
ddf.sort_values(""a"")
```
**Environment**:

- Dask version: latest
- Python version: 3.10
- Operating System: ubuntu20.04
- Install method (conda, pip, source): source
",,https://api.github.com/repos/dask/dask/issues/9765/timeline,,reopened,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9765/reactions,0,0,0,0,0,0,0,0,0,jrbourbeau,11656932.0,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
749,https://api.github.com/repos/dask/dask/issues/9766,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9766/labels{/name},https://api.github.com/repos/dask/dask/issues/9766/comments,https://api.github.com/repos/dask/dask/issues/9766/events,https://github.com/dask/dask/issues/9766,1498895830,I_kwDOAbcwm85ZV1XW,9766,Mimic dataset,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,2,2022-12-15T18:25:27Z,2023-01-23T01:58:52Z,,MEMBER,,"Sometimes we talk to people and they say ""I'm running into a problem, but I can't share my data""

Maybe we could make a simple function that looked at their data and created a similar dataset.  It might mimic things like 
the following (in increasing order of difficulty):

1.  Data types
2. Number of rows (per partition?)
3. Cardinality (per partition?)
4. Sortedness
5. Distribution of values beyond cardinality
6. ...

We would do a single full pass of the data to create a recipe and then people could share that recipe 

Some of these might still be sensitive (cardinality might leak number of users for example).  In general though this might be helpful?  No pressure, just a thought.",,https://api.github.com/repos/dask/dask/issues/9766/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9766/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
750,https://api.github.com/repos/dask/dask/issues/9769,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9769/labels{/name},https://api.github.com/repos/dask/dask/issues/9769/comments,https://api.github.com/repos/dask/dask/issues/9769/events,https://github.com/dask/dask/pull/9769,1500532029,PR_kwDOAbcwm85FqHJK,9769,Cast nullable columns to non-nullable dtypes in `partition_quantiles`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2022-12-16T16:40:33Z,2024-04-15T02:48:59Z,,MEMBER,,"It looks like the `sort_values` codepath doesn't have support for quantile divisions containing `pd.NA`, which occurs when we attempt to sort by a nullable column with an entirely null partition.

This PR attempts to cast nullable columns to their non-nullable equivalent as part of `partition_quantiles`, which should unblock this edge case.

- [x] Closes #9765
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9769/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9769/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9769,https://github.com/dask/dask/pull/9769,https://github.com/dask/dask/pull/9769.diff,https://github.com/dask/dask/pull/9769.patch,,,,,,,,,,,,,,,,,,,
751,https://api.github.com/repos/dask/dask/issues/9773,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9773/labels{/name},https://api.github.com/repos/dask/dask/issues/9773/comments,https://api.github.com/repos/dask/dask/issues/9773/events,https://github.com/dask/dask/issues/9773,1501674210,I_kwDOAbcwm85Zgbri,9773,parquet removes custom index when saving with schema,"[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,9,2022-12-18T00:40:16Z,2024-04-15T02:48:58Z,,NONE,,"to_parquet seems to set preserve_index=False when using a schema. This removes the index when saving. When saving without the schema attached, the index is kept - which is the expected/correct behaviour.

**Minimal Complete Verifiable Example**:

```python
df3 = pd.DataFrame.from_dict({11: {'a': 'a11'}, 22: {'a': 'a22'}}, orient='index')
#>>> df3
#      a
#11  a11
#22  a22

df4 = dd.from_pandas(df3, chunksize=1, sort=True)
#>>> df4.compute()
#      a
#11  a11
#22  a22

# Saving without schema (works as expected)
df4.to_parquet('test', compression=""brotli"", write_metadata_file=True)

# reading it back - works
df5 = dd.read_parquet('test', compression=""brotli"")
#>>> df5.compute()
#      a
#11  a11
#22  a22

# Saving with schema (deletes the index)
import pyarrow as pa
schema = pa.schema([pa.field('a', pa.string())])
df4.to_parquet('test', compression=""brotli"", schema=schema, write_metadata_file=True)

# reading it back - has lost index
df5 = dd.read_parquet('test', compression=""brotli"")
#>>> df5.compute()
#     a
#0  a11
#0  a22
```


**Anything else we need to know?**:

when including the index in the schema, the following trace from the exception is shown, locating the problem:

```
Traceback (most recent call last):
  File ""/Users/tom/Dev/test/dask/testCompression.py"", line 79, in <module>
    df.to_parquet('users', schema=schema, compression=""brotli"", write_metadata_file=True, preserve_index=True)
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/dataframe/core.py"", line 5272, in to_parquet
    return to_parquet(self, path, *args, **kwargs)
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/dataframe/io/parquet/core.py"", line 1037, in to_parquet
    out = out.compute(**compute_kwargs)
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/base.py"", line 315, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/base.py"", line 600, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/threaded.py"", line 89, in get
    results = get_async(
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/local.py"", line 511, in get_async
    raise_exception(exc, tb)
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/local.py"", line 319, in reraise
    raise exc
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/local.py"", line 224, in execute_task
    result = _execute_task(task, data)
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/optimization.py"", line 990, in __call__
    return core.get(self.dsk, self.outkey, dict(zip(self.inkeys, args)))
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/core.py"", line 149, in get
    result = _execute_task(task, cache)
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/dataframe/io/parquet/core.py"", line 172, in __call__
    return self.engine.write_partition(
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/dataframe/io/parquet/arrow.py"", line 771, in write_partition
    t = cls._pandas_to_arrow_table(df, preserve_index=preserve_index, schema=schema)
  File ""/opt/homebrew/lib/python3.10/site-packages/dask/dataframe/io/parquet/arrow.py"", line 719, in _pandas_to_arrow_table
    return pa.Table.from_pandas(
  File ""pyarrow/table.pxi"", line 3475, in pyarrow.lib.Table.from_pandas
  File ""/opt/homebrew/lib/python3.10/site-packages/pyarrow/pandas_compat.py"", line 570, in dataframe_to_arrays
    convert_fields) = _get_columns_to_convert(df, schema, preserve_index,
  File ""/opt/homebrew/lib/python3.10/site-packages/pyarrow/pandas_compat.py"", line 357, in _get_columns_to_convert
    return _get_columns_to_convert_given_schema(df, schema, preserve_index)
  File ""/opt/homebrew/lib/python3.10/site-packages/pyarrow/pandas_compat.py"", line 439, in _get_columns_to_convert_given_schema
    raise ValueError(
ValueError: name '__index_level_0__' present in the specified schema corresponds to the index, but 'preserve_index=False' was specified
```


**Environment**:

- Dask version: 2022.12.1
- Python version: python3.10
- Operating System: macos 12.6
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/9773/timeline,,,thomasf1,937467,MDQ6VXNlcjkzNzQ2Nw==,https://avatars.githubusercontent.com/u/937467?v=4,,https://api.github.com/users/thomasf1,https://github.com/thomasf1,https://api.github.com/users/thomasf1/followers,https://api.github.com/users/thomasf1/following{/other_user},https://api.github.com/users/thomasf1/gists{/gist_id},https://api.github.com/users/thomasf1/starred{/owner}{/repo},https://api.github.com/users/thomasf1/subscriptions,https://api.github.com/users/thomasf1/orgs,https://api.github.com/users/thomasf1/repos,https://api.github.com/users/thomasf1/events{/privacy},https://api.github.com/users/thomasf1/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9773/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
752,https://api.github.com/repos/dask/dask/issues/9778,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9778/labels{/name},https://api.github.com/repos/dask/dask/issues/9778/comments,https://api.github.com/repos/dask/dask/issues/9778/events,https://github.com/dask/dask/issues/9778,1505401508,I_kwDOAbcwm85Zupqk,9778,Groupby mean inconsistent depending on where `inf` is inserted in data,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2022-12-20T22:39:39Z,2023-01-23T01:58:49Z,,MEMBER,,"In pandas when we do a groupby and a mean agg on a column that has `inf`. The result varies depending on where the `inf` was introduced. 

Upstream pandas issue see : https://github.com/pandas-dev/pandas/issues/50367 read comment for updated reproducer, as it turns out the issue is where the `inf` are in the dataframe, https://github.com/pandas-dev/pandas/issues/50367#issuecomment-1361474533

We are not being consistent with the pandas behavior 

MRE

```python
#When `inf` is at the end of of the column
import numpy as np
import pandas as pd
from dask.distributed import Client
import dask.dataframe as dd

client = Client()
client

d ={""x"": [1, 2, 3, 4, 5, np.inf], # inf at the end
    ""y"": [1, 1 ,1, 1, 1, 1],
    ""z"": [""alice"", ""bob"", ""alice"", ""bob"", 
          ""alice"", ""bob"",]}

pdf = pd.DataFrame(d).astype({""x"": ""float32"", ""y"": ""float32"",""z"": ""string""})

pdf.groupby(""z"").x.mean()

#this returns in pandas
""""""
z
alice    3.0
bob      inf
Name: x, dtype: float32
"""""" 

type(pdf.x[0])
#numpy.float32


## dask behavior consistent

ddf= dd.from_pandas(pdf, npartitions=2)
ddf.groupby(""z"").x.mean().compute()
# this returns
""""""
z
alice    3.0
bob      inf
Name: x, dtype: float64
""""""


### when the inf is at the begining
d = {""x"": [np.inf, 1, 2, 3, 4, 5] ,
     ""y"": [1, 1 ,1, 1, 1, 1],
     ""z"": [""alice"", ""bob"", ""alice"", 
           ""bob"", ""alice"", ""bob"",]}

pdf2 =pd.DataFrame(d2).astype({""x"": ""float32"", ""y"": ""float32"", ""z"": ""string""})

pdf2.groupby(""z"").x.mean()
#this returns
""""""
z
alice         NaN
bob           3.0
Name: yox, dtype: float32
""""""

## dask behavior inconsistent 

ddf2= dd.from_pandas(pdf2, npartitions=2)
ddf2.groupby(""z"").yox.mean().compute()
# this returns
""""""
z
alice    1.333333
bob      3.000000
Name: x, dtype: float64
""""""
```
cc: @jrbourbeau 

versions:
dask=2022.12.0
pandas=1.5.2
numpy=1.23.5 / tried also 1.24.0",,https://api.github.com/repos/dask/dask/issues/9778/timeline,,,ncclementi,7526622,MDQ6VXNlcjc1MjY2MjI=,https://avatars.githubusercontent.com/u/7526622?v=4,,https://api.github.com/users/ncclementi,https://github.com/ncclementi,https://api.github.com/users/ncclementi/followers,https://api.github.com/users/ncclementi/following{/other_user},https://api.github.com/users/ncclementi/gists{/gist_id},https://api.github.com/users/ncclementi/starred{/owner}{/repo},https://api.github.com/users/ncclementi/subscriptions,https://api.github.com/users/ncclementi/orgs,https://api.github.com/users/ncclementi/repos,https://api.github.com/users/ncclementi/events{/privacy},https://api.github.com/users/ncclementi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9778/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
753,https://api.github.com/repos/dask/dask/issues/9780,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9780/labels{/name},https://api.github.com/repos/dask/dask/issues/9780/comments,https://api.github.com/repos/dask/dask/issues/9780/events,https://github.com/dask/dask/pull/9780,1505540533,PR_kwDOAbcwm85F6vFk,9780,Fix read_parquet index preservation when pyarrow-schema is specified,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2022-12-21T00:50:52Z,2024-04-08T01:45:40Z,,MEMBER,,"- [x] Closes #9773
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9780/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9780/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9780,https://github.com/dask/dask/pull/9780,https://github.com/dask/dask/pull/9780.diff,https://github.com/dask/dask/pull/9780.patch,,,,,,,,,,,,,,,,,,,
754,https://api.github.com/repos/dask/dask/issues/9782,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9782/labels{/name},https://api.github.com/repos/dask/dask/issues/9782/comments,https://api.github.com/repos/dask/dask/issues/9782/events,https://github.com/dask/dask/issues/9782,1506634803,I_kwDOAbcwm85ZzWwz,9782,Add docs on `dask spec`,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2022-12-21T17:04:42Z,2023-01-23T01:58:47Z,,MEMBER,,In https://github.com/dask/distributed/pull/7427 we added a new `dask spec` subcommand to our CLI. It'd be good to mention that as an option for deploying Dask in https://docs.dask.org/en/stable/deploying-cli.html ,,https://api.github.com/repos/dask/dask/issues/9782/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9782/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
755,https://api.github.com/repos/dask/dask/issues/9791,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9791/labels{/name},https://api.github.com/repos/dask/dask/issues/9791/comments,https://api.github.com/repos/dask/dask/issues/9791/events,https://github.com/dask/dask/issues/9791,1512922875,I_kwDOAbcwm85aLV77,9791,Consider adding support for https://github.com/eto-ai/lance,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2022-12-28T15:50:09Z,2024-04-08T01:45:39Z,,CONTRIBUTOR,,"To quote the GitHub description:

> Alternative to Parquet. 100x faster for random access, automatic versioning, optimized for ML data. Apache Arrow and DuckDB compatible. 

https://github.com/eto-ai/lance",,https://api.github.com/repos/dask/dask/issues/9791/timeline,,,asmith26,6988036,MDQ6VXNlcjY5ODgwMzY=,https://avatars.githubusercontent.com/u/6988036?v=4,,https://api.github.com/users/asmith26,https://github.com/asmith26,https://api.github.com/users/asmith26/followers,https://api.github.com/users/asmith26/following{/other_user},https://api.github.com/users/asmith26/gists{/gist_id},https://api.github.com/users/asmith26/starred{/owner}{/repo},https://api.github.com/users/asmith26/subscriptions,https://api.github.com/users/asmith26/orgs,https://api.github.com/users/asmith26/repos,https://api.github.com/users/asmith26/events{/privacy},https://api.github.com/users/asmith26/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9791/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
756,https://api.github.com/repos/dask/dask/issues/9795,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9795/labels{/name},https://api.github.com/repos/dask/dask/issues/9795/comments,https://api.github.com/repos/dask/dask/issues/9795/events,https://github.com/dask/dask/issues/9795,1516875429,I_kwDOAbcwm85aaa6l,9795,Optimization is slow,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,29,2023-01-03T02:57:50Z,2024-04-08T01:45:39Z,,MEMBER,,"Ref: https://github.com/dask-contrib/dask-awkward/issues/138

The referenced issue provides a way to make a dask HLG having 746 layers. This size, and much bigger, look like they might be common with dask-awkward and high-energy physics workloads - but are far from typical in normal array and dataframe usage.

When wishing to compute the result, optimizaion happens, including `dask.blockwise.optimize_blockwise` to merge layers where possible. This takes 2.1s for this simple example, by far dominating the compute time. Looking at the profile, all the time is in `rewrite_blockwise`, which calls `subs()` 7.5M times. Given that this is working on layers, not tasks, I am surprised. The code of `rewrite_blockwise` appears to be N**2, and I cannot understand yet how it works. (in the example in the linked issue, there is only one partition, so everything goes much much faster by immediately falling back to a low-level graph)


Any thoughts?

- Dask version: main
",,https://api.github.com/repos/dask/dask/issues/9795/timeline,,,martindurant,6042212,MDQ6VXNlcjYwNDIyMTI=,https://avatars.githubusercontent.com/u/6042212?v=4,,https://api.github.com/users/martindurant,https://github.com/martindurant,https://api.github.com/users/martindurant/followers,https://api.github.com/users/martindurant/following{/other_user},https://api.github.com/users/martindurant/gists{/gist_id},https://api.github.com/users/martindurant/starred{/owner}{/repo},https://api.github.com/users/martindurant/subscriptions,https://api.github.com/users/martindurant/orgs,https://api.github.com/users/martindurant/repos,https://api.github.com/users/martindurant/events{/privacy},https://api.github.com/users/martindurant/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9795/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
757,https://api.github.com/repos/dask/dask/issues/9798,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9798/labels{/name},https://api.github.com/repos/dask/dask/issues/9798/comments,https://api.github.com/repos/dask/dask/issues/9798/events,https://github.com/dask/dask/issues/9798,1518822158,I_kwDOAbcwm85ah2MO,9798,Indexing a dask DataFrame with a dask boolean array,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,2,2023-01-04T11:37:54Z,2024-04-08T01:45:38Z,,NONE,,"This seems related to https://github.com/dask/dask/issues/2651

```python
import dask.dataframe as dkd
import dask.array as dka
import numpy as np
arr = np.random.rand(25,2)
ddf = dkd.from_array(arr)
darr_bool = dka.from_array([True]*25)
ddf[darr_bool]
------------------------------------------------
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""/home/ubuntu/envs/test-dask/lib/python3.10/site-packages/dask/dataframe/core.py"", line 4639, in __getitem__
    raise NotImplementedError(key)
NotImplementedError: dask.array<array, shape=(25,), dtype=bool, chunksize=(25,), chunktype=numpy.ndarray>
```

I got this error running on main (indexing a dask Series with a dask boolean array works fine).

Is there some fundamental issue with this type of feature?",,https://api.github.com/repos/dask/dask/issues/9798/timeline,,,gcaria,44147817,MDQ6VXNlcjQ0MTQ3ODE3,https://avatars.githubusercontent.com/u/44147817?v=4,,https://api.github.com/users/gcaria,https://github.com/gcaria,https://api.github.com/users/gcaria/followers,https://api.github.com/users/gcaria/following{/other_user},https://api.github.com/users/gcaria/gists{/gist_id},https://api.github.com/users/gcaria/starred{/owner}{/repo},https://api.github.com/users/gcaria/subscriptions,https://api.github.com/users/gcaria/orgs,https://api.github.com/users/gcaria/repos,https://api.github.com/users/gcaria/events{/privacy},https://api.github.com/users/gcaria/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9798/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
758,https://api.github.com/repos/dask/dask/issues/9800,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9800/labels{/name},https://api.github.com/repos/dask/dask/issues/9800/comments,https://api.github.com/repos/dask/dask/issues/9800/events,https://github.com/dask/dask/issues/9800,1519316476,I_kwDOAbcwm85aju38,9800,ValueError: divisions must be sorted when using int64 index,"[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2023-01-04T17:12:43Z,2024-04-08T01:45:37Z,,NONE,,"Running below code fails with `ValueError: divisions must be sorted`. This example works when setting the dtype of the index to 32 bit.

**Minimal example**:

```python
import dask.dataframe
import numpy as np
n = 1000
dtype = np.int64
index = np.iinfo(dtype).max*np.ones(n, dtype=dtype)
zerocol = np.zeros(n)
index[0:100] = 0
index[100:120] = 1
dfdt = np.dtype([('idx', dtype), ('zeros', np.float32)])
npdata = np.empty(n, dtype=dfdt)
npdata[""idx""] = index
npdata[""zeros""] = zerocol
df = dask.dataframe.from_array(npdata)
df = df.repartition(npartitions=3)
print(""Idx positive?"", np.all(df.index.compute()>=0))
print(""Idx sorted?"", np.all(np.diff(df.index.compute())>=0))
print(""Divisions?"", df.divisions)
df.set_index(""idx"")
```

Output prior to exception:

```
Idx positive? True
Idx sorted? True
Divisions? (0, 333, 666, 999)
```


This example works fine with dtype=np.int32, but fails with np.int64:



```python
~/anaconda3/lib/python3.9/site-packages/dask/dataframe/core.py in divisions(self, value)
    432             if not (is_categorical_dtype(index_dtype) and index_dtype.ordered):
    433                 if value != tuple(sorted(value)):
--> 434                     raise ValueError(""divisions must be sorted"")
    435 
    436         self._divisions = value

ValueError: divisions must be sorted
```

In divisions() of dask.dataframe.core, prior to the exception, we have: index_dtype == int64, value == (0, 3074457345618258432, 6148914691236516864, -9223372036854775808) and tuple(sorted(value)) == (-9223372036854775808, 0, 3074457345618258432, 6148914691236516864).

As some negative numbers pop up in the divisions, even though the ""idx"" is positive , there seems some overflow along the way.

**Environment**:

- Dask version: '2022.12.1'
- Python version: 3.9.13
- Operating System: Fedora 36
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/9800/timeline,,,cbyrohl,9221545,MDQ6VXNlcjkyMjE1NDU=,https://avatars.githubusercontent.com/u/9221545?v=4,,https://api.github.com/users/cbyrohl,https://github.com/cbyrohl,https://api.github.com/users/cbyrohl/followers,https://api.github.com/users/cbyrohl/following{/other_user},https://api.github.com/users/cbyrohl/gists{/gist_id},https://api.github.com/users/cbyrohl/starred{/owner}{/repo},https://api.github.com/users/cbyrohl/subscriptions,https://api.github.com/users/cbyrohl/orgs,https://api.github.com/users/cbyrohl/repos,https://api.github.com/users/cbyrohl/events{/privacy},https://api.github.com/users/cbyrohl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9800/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
759,https://api.github.com/repos/dask/dask/issues/9802,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9802/labels{/name},https://api.github.com/repos/dask/dask/issues/9802/comments,https://api.github.com/repos/dask/dask/issues/9802/events,https://github.com/dask/dask/pull/9802,1519352958,PR_kwDOAbcwm85GpVHq,9802,enable PEP 597 EncodingWarnings,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,1,2023-01-04T17:41:20Z,2023-03-22T16:22:01Z,,MEMBER,,"This PR enables https://peps.python.org/pep-0597/ EncodingWarnings, these warnings are issued when a call to `subprocess.Popen(text=True, ...` or `open(...` where the `encoding` kwarg is absent

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9802/timeline,,,graingert,413772,MDQ6VXNlcjQxMzc3Mg==,https://avatars.githubusercontent.com/u/413772?v=4,,https://api.github.com/users/graingert,https://github.com/graingert,https://api.github.com/users/graingert/followers,https://api.github.com/users/graingert/following{/other_user},https://api.github.com/users/graingert/gists{/gist_id},https://api.github.com/users/graingert/starred{/owner}{/repo},https://api.github.com/users/graingert/subscriptions,https://api.github.com/users/graingert/orgs,https://api.github.com/users/graingert/repos,https://api.github.com/users/graingert/events{/privacy},https://api.github.com/users/graingert/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9802/reactions,0,0,0,0,0,0,0,0,0,graingert,413772.0,MDQ6VXNlcjQxMzc3Mg==,https://avatars.githubusercontent.com/u/413772?v=4,,https://api.github.com/users/graingert,https://github.com/graingert,https://api.github.com/users/graingert/followers,https://api.github.com/users/graingert/following{/other_user},https://api.github.com/users/graingert/gists{/gist_id},https://api.github.com/users/graingert/starred{/owner}{/repo},https://api.github.com/users/graingert/subscriptions,https://api.github.com/users/graingert/orgs,https://api.github.com/users/graingert/repos,https://api.github.com/users/graingert/events{/privacy},https://api.github.com/users/graingert/received_events,User,False,True,https://api.github.com/repos/dask/dask/pulls/9802,https://github.com/dask/dask/pull/9802,https://github.com/dask/dask/pull/9802.diff,https://github.com/dask/dask/pull/9802.patch,,,,,,,,,,,,,,,,,,,
760,https://api.github.com/repos/dask/dask/issues/9803,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9803/labels{/name},https://api.github.com/repos/dask/dask/issues/9803/comments,https://api.github.com/repos/dask/dask/issues/9803/events,https://github.com/dask/dask/issues/9803,1519441176,I_kwDOAbcwm85akNUY,9803,Provide a clearer error message when using dataframe.backend if dask_cudf is not installed,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,3,2023-01-04T19:01:44Z,2024-04-08T01:45:36Z,,NONE,,"I was trying to use Dask's new configurable DataFrame backend:
```
import dask.dataframe as dd
dask.config.set({""dataframe.backend"": ""cudf""})
```
On attempting to read a Parquet file w/ dd.read_parquet, I stumbled on:
```
ValueError: No backend dispatch registered for cudf
```

It turns out this is because dask_cudf was missing from my environment. It might help users if the error message was less generic and suggested your environment might be missing or have an otherwise unusable package for the configured backend.",,https://api.github.com/repos/dask/dask/issues/9803/timeline,,,randerzander,1692914,MDQ6VXNlcjE2OTI5MTQ=,https://avatars.githubusercontent.com/u/1692914?v=4,,https://api.github.com/users/randerzander,https://github.com/randerzander,https://api.github.com/users/randerzander/followers,https://api.github.com/users/randerzander/following{/other_user},https://api.github.com/users/randerzander/gists{/gist_id},https://api.github.com/users/randerzander/starred{/owner}{/repo},https://api.github.com/users/randerzander/subscriptions,https://api.github.com/users/randerzander/orgs,https://api.github.com/users/randerzander/repos,https://api.github.com/users/randerzander/events{/privacy},https://api.github.com/users/randerzander/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9803/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
761,https://api.github.com/repos/dask/dask/issues/9804,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9804/labels{/name},https://api.github.com/repos/dask/dask/issues/9804/comments,https://api.github.com/repos/dask/dask/issues/9804/events,https://github.com/dask/dask/issues/9804,1519544438,I_kwDOAbcwm85akmh2,9804,test_tokenize_object_with_recursion_error() triggers stack overflow on Windows due to IPython imports,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-01-04T20:39:48Z,2024-04-08T01:45:35Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

Running the following test:
`py.test dask -k test_tokenize_object_with_recursion_error`

Triggers the following error:

```
ask/tests/test_base.py::test_tokenize_object_with_recursion_error Windows fatal exception: stack overflow

Thread 0x00005a34 (most recent call first):
  File ""C:\Program Files\Python310\lib\concurrent\futures\thread.py"", line 81 in _worker
  File ""C:\Program Files\Python310\lib\threading.py"", line 946 in run
  File ""C:\Program Files\Python310\lib\threading.py"", line 1009 in _bootstrap_inner
  File ""C:\Program Files\Python310\lib\threading.py"", line 966 in _bootstrap

Thread 0x00005de4 (most recent call first):
  File ""C:\Program Files\Python310\lib\socket.py"", line 293 in accept
  File ""C:\Users\pafox\Code\dask\.venv\lib\site-packages\pytest_rerunfailures.py"", line 457 in run_server
  File ""C:\Program Files\Python310\lib\threading.py"", line 946 in run
  File ""C:\Program Files\Python310\lib\threading.py"", line 1009 in _bootstrap_inner
  File ""C:\Program Files\Python310\lib\threading.py"", line 966 in _bootstrap

Current thread 0x00000b14 (most recent call first):
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 639 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 961 in normalize_dict
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 978 in _normalize_seq_func
  File ""C:\Users\pafox\Code\dask\dask\dask\base.py"", line 992 in normalize_seq
  File ""C:\Users\pafox\Code\dask\dask\dask\utils.py"", line 640 in __call__
  ...
```

This issue appears to be related to an increased recursion limit, set by an indirect import of jedi from IPython, which is imported in turn by test_typing.py:
```from IPython.display import DisplayObject```

This can be fixed by resetting the recursion limit to the default of 1000 after this import.

In theory this could also be fixed by increasing the stack size of the pytest main thread, but there doesn't seem to be any easy way to do this.

- Dask version: dask-2022.12.1+16.gf721de65f
- Python version: 3.10.4
- Operating System: Windows 11
- Install method (conda, pip, source): source
",,https://api.github.com/repos/dask/dask/issues/9804/timeline,,,pfox89,61061722,MDQ6VXNlcjYxMDYxNzIy,https://avatars.githubusercontent.com/u/61061722?v=4,,https://api.github.com/users/pfox89,https://github.com/pfox89,https://api.github.com/users/pfox89/followers,https://api.github.com/users/pfox89/following{/other_user},https://api.github.com/users/pfox89/gists{/gist_id},https://api.github.com/users/pfox89/starred{/owner}{/repo},https://api.github.com/users/pfox89/subscriptions,https://api.github.com/users/pfox89/orgs,https://api.github.com/users/pfox89/repos,https://api.github.com/users/pfox89/events{/privacy},https://api.github.com/users/pfox89/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9804/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
762,https://api.github.com/repos/dask/dask/issues/9814,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9814/labels{/name},https://api.github.com/repos/dask/dask/issues/9814/comments,https://api.github.com/repos/dask/dask/issues/9814/events,https://github.com/dask/dask/pull/9814,1526390948,PR_kwDOAbcwm85HBPdN,9814,Update `RemovedIn20Warning` filtering,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-01-09T21:59:53Z,2024-04-08T01:45:35Z,,MEMBER,,"xref https://github.com/dask/dask/pull/9809#pullrequestreview-1241243229

cc @charlesbluca @graingert ",,https://api.github.com/repos/dask/dask/issues/9814/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9814/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9814,https://github.com/dask/dask/pull/9814,https://github.com/dask/dask/pull/9814.diff,https://github.com/dask/dask/pull/9814.patch,,,,,,,,,,,,,,,,,,,
763,https://api.github.com/repos/dask/dask/issues/9819,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9819/labels{/name},https://api.github.com/repos/dask/dask/issues/9819/comments,https://api.github.com/repos/dask/dask/issues/9819/events,https://github.com/dask/dask/pull/9819,1528012741,PR_kwDOAbcwm85HGnaR,9819,Improve error message when cudf-backend dispatching fails,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,0,2023-01-10T21:10:05Z,2024-04-01T01:47:20Z,,MEMBER,,"- [x] Closes #9803
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9819/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9819/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9819,https://github.com/dask/dask/pull/9819,https://github.com/dask/dask/pull/9819.diff,https://github.com/dask/dask/pull/9819.patch,,,,,,,,,,,,,,,,,,,
764,https://api.github.com/repos/dask/dask/issues/9821,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9821/labels{/name},https://api.github.com/repos/dask/dask/issues/9821/comments,https://api.github.com/repos/dask/dask/issues/9821/events,https://github.com/dask/dask/issues/9821,1529077690,I_kwDOAbcwm85bI9-6,9821,Update deploying-kubernetes to use `dask_kubernetes.operator`.,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-01-11T13:47:26Z,2024-04-01T01:47:19Z,,MEMBER,,"Currently, `deploying-kubernetes` shows the classic deployment, instead of the newer `dask_kubernetes.operator` deployment:

```python
from dask_kubernetes import KubeCluster
cluster = KubeCluster.from_yaml('worker-template.yaml')
cluster.scale(20)  # add 20 workers
cluster.adapt()    # or create and destroy workers dynamically based on workload

from dask.distributed import Client
client = Client(cluster)
```

@jacobtomlinson is `dask_kubernetes.operator` your recommended way to deploy things?",,https://api.github.com/repos/dask/dask/issues/9821/timeline,,,TomAugspurger,1312546,MDQ6VXNlcjEzMTI1NDY=,https://avatars.githubusercontent.com/u/1312546?v=4,,https://api.github.com/users/TomAugspurger,https://github.com/TomAugspurger,https://api.github.com/users/TomAugspurger/followers,https://api.github.com/users/TomAugspurger/following{/other_user},https://api.github.com/users/TomAugspurger/gists{/gist_id},https://api.github.com/users/TomAugspurger/starred{/owner}{/repo},https://api.github.com/users/TomAugspurger/subscriptions,https://api.github.com/users/TomAugspurger/orgs,https://api.github.com/users/TomAugspurger/repos,https://api.github.com/users/TomAugspurger/events{/privacy},https://api.github.com/users/TomAugspurger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9821/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
765,https://api.github.com/repos/dask/dask/issues/9824,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9824/labels{/name},https://api.github.com/repos/dask/dask/issues/9824/comments,https://api.github.com/repos/dask/dask/issues/9824/events,https://github.com/dask/dask/issues/9824,1529592529,I_kwDOAbcwm85bK7rR,9824,Groupby Quantile,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,1,2023-01-11T19:48:07Z,2024-04-01T01:47:18Z,,NONE,,"Similar to #8658,
I'd like to be able to use `quantile` on groupby Series and DataFrame objects.
This works in Pandas but not Dask.

```
import pandas as pd
import dask.dataframe as dd

pdf = pd.DataFrame(
    {""a"": [0, 1, 0, 1, 1, 0], ""b"": range(6)}
)

ddf = dd.from_pandas(pdf, 2)

# Pandas Quantile Func
print(pdf.groupby('a').b.quantile(0.2))

# Dask Quantile Func
ddf.groupby('a').b.quantile(0.2)

a
0    0.8
1    1.8
Name: b, dtype: float64
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
[<ipython-input-27-7ab35545b918>](https://localhost:8080/#) in <module>
     13 
     14 # Dask Quantile Func
---> 15 ddf.groupby('a').b.quantile(0.2)

AttributeError: 'SeriesGroupBy' object has no attribute 'quantile'
```


```
dask                          2022.2.1
pandas                        1.3.5
```

",,https://api.github.com/repos/dask/dask/issues/9824/timeline,,,patcao,4999021,MDQ6VXNlcjQ5OTkwMjE=,https://avatars.githubusercontent.com/u/4999021?v=4,,https://api.github.com/users/patcao,https://github.com/patcao,https://api.github.com/users/patcao/followers,https://api.github.com/users/patcao/following{/other_user},https://api.github.com/users/patcao/gists{/gist_id},https://api.github.com/users/patcao/starred{/owner}{/repo},https://api.github.com/users/patcao/subscriptions,https://api.github.com/users/patcao/orgs,https://api.github.com/users/patcao/repos,https://api.github.com/users/patcao/events{/privacy},https://api.github.com/users/patcao/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9824/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
766,https://api.github.com/repos/dask/dask/issues/9825,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9825/labels{/name},https://api.github.com/repos/dask/dask/issues/9825/comments,https://api.github.com/repos/dask/dask/issues/9825/events,https://github.com/dask/dask/issues/9825,1530097961,I_kwDOAbcwm85bM3Ep,9825,Docstring of dask.array.coarsen should provide more details on valid reduction functions,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2023-01-12T04:56:32Z,2024-04-01T01:47:18Z,,CONTRIBUTOR,,"The [dask.array.coarsen](https://docs.dask.org/en/stable/generated/dask.array.coarsen.html) documentation provides little detail about the requirements of its `reduction` argument:

https://github.com/dask/dask/blob/6d639d2cfc9acc365ab90dea453c87c38e7c4edb/dask/array/chunk.py#L87-L88

Looking at the relevant part of the implementation:

https://github.com/dask/dask/blob/6d639d2cfc9acc365ab90dea453c87c38e7c4edb/dask/array/chunk.py#L133-L136

It seems to me that the requirements on the reduction function are:
- it should be able to take an array as the first argument, and
- it should be able to take in a tuple of axes as an `axis=` argument, and
- it should be able to not instantiate the input dask array (?). ie does the reduction function of np.<whatever> only work because of `__array_function__` dispatch? Or am I missing some other magic here? 

Obviously I'm not super clear on the last one, or whether I'm missing some, and would love some guidance from people more familiar with this function, after which I'd be happy to make a PR or leave this as a good-first-issue for some dask hackathons. :blush: ",,https://api.github.com/repos/dask/dask/issues/9825/timeline,,,jni,492549,MDQ6VXNlcjQ5MjU0OQ==,https://avatars.githubusercontent.com/u/492549?v=4,,https://api.github.com/users/jni,https://github.com/jni,https://api.github.com/users/jni/followers,https://api.github.com/users/jni/following{/other_user},https://api.github.com/users/jni/gists{/gist_id},https://api.github.com/users/jni/starred{/owner}{/repo},https://api.github.com/users/jni/subscriptions,https://api.github.com/users/jni/orgs,https://api.github.com/users/jni/repos,https://api.github.com/users/jni/events{/privacy},https://api.github.com/users/jni/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9825/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
767,https://api.github.com/repos/dask/dask/issues/9832,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9832/labels{/name},https://api.github.com/repos/dask/dask/issues/9832/comments,https://api.github.com/repos/dask/dask/issues/9832/events,https://github.com/dask/dask/pull/9832,1532722105,PR_kwDOAbcwm85HWjaj,9832,[TEST] Use dd.Scalar in to_hdf,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,0,2023-01-13T18:12:06Z,2023-01-13T18:12:27Z,,MEMBER,,"Another attempt to resolve the `test_blockwise_dataframe_io` failure mentioned in https://github.com/dask/dask/issues/9793.

The assumption here is that the problem *may* have something to do with `compute_as_if_collection` (which is not used by other `to_*` methods in Dask-DataFrame).

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9832/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9832/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9832,https://github.com/dask/dask/pull/9832,https://github.com/dask/dask/pull/9832.diff,https://github.com/dask/dask/pull/9832.patch,,,,,,,,,,,,,,,,,,,
768,https://api.github.com/repos/dask/dask/issues/9835,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9835/labels{/name},https://api.github.com/repos/dask/dask/issues/9835/comments,https://api.github.com/repos/dask/dask/issues/9835/events,https://github.com/dask/dask/pull/9835,1533425178,PR_kwDOAbcwm85HY3al,9835,Don't import sizeof entrypoints immediately,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,7,2023-01-14T18:46:35Z,2024-04-01T01:47:17Z,,MEMBER,,"The `dask.sizeof` entrypoints registering new sizeof implementations should only be imported when needed.

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`

cc @douglasdavis ",,https://api.github.com/repos/dask/dask/issues/9835/timeline,,,martindurant,6042212,MDQ6VXNlcjYwNDIyMTI=,https://avatars.githubusercontent.com/u/6042212?v=4,,https://api.github.com/users/martindurant,https://github.com/martindurant,https://api.github.com/users/martindurant/followers,https://api.github.com/users/martindurant/following{/other_user},https://api.github.com/users/martindurant/gists{/gist_id},https://api.github.com/users/martindurant/starred{/owner}{/repo},https://api.github.com/users/martindurant/subscriptions,https://api.github.com/users/martindurant/orgs,https://api.github.com/users/martindurant/repos,https://api.github.com/users/martindurant/events{/privacy},https://api.github.com/users/martindurant/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9835/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9835,https://github.com/dask/dask/pull/9835,https://github.com/dask/dask/pull/9835.diff,https://github.com/dask/dask/pull/9835.patch,,,,,,,,,,,,,,,,,,,
769,https://api.github.com/repos/dask/dask/issues/9837,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9837/labels{/name},https://api.github.com/repos/dask/dask/issues/9837/comments,https://api.github.com/repos/dask/dask/issues/9837/events,https://github.com/dask/dask/issues/9837,1535049513,I_kwDOAbcwm85bfv8p,9837,Documentation on how to set an s3 profile,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-01-16T14:38:13Z,2024-04-01T01:47:16Z,,MEMBER,,"From https://docs.dask.org/en/stable/how-to/connect-to-remote-data.html:

> The following parameters may be passed to s3fs using storage_options:
> [...]
> kwargs: Other parameters are passed to the [boto3 Session](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html) object, such as profile_name, to pick one of the authentication sections from the configuration files referred to above (see [here](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html#shared-credentials-file))

However, this fails:
```python
dd.read_parquet(
    ""s3://coiled-datasets/prefect-dask/nyc-uber-lyft/processed_data.parquet"",
    storage_options={""kwargs"": {""profile_name"": ""oss""}},
)

TypeError: AioSession.__init__() got an unexpected keyword argument 'kwargs'
```
This instead works:
```python
dd.read_parquet(
    ""s3://coiled-datasets/prefect-dask/nyc-uber-lyft/processed_data.parquet"",
    storage_options={""profile"": ""oss""},
)
```

However, the above is only fine as long as I run locally. If I connect to a Coiled cluster, it fails as soon as I try computing the dataframe, stating that the oss profile does not exist.
At the moment of writing, I could not find a clean solution.

**Workaround:** rename the `[oss]` profile to `[default]` in `~/.aws/credentials` and don't pass any parameters in Python.
I *think* that this causes the initial `read_parquet` call - which runs locally - to read the `role_arn` from my credentials, and then when the chunks are loaded remotely on the Coiled cluster there's *a different role_arn* that has been pre-set there?",,https://api.github.com/repos/dask/dask/issues/9837/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9837/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
770,https://api.github.com/repos/dask/dask/issues/9846,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9846/labels{/name},https://api.github.com/repos/dask/dask/issues/9846/comments,https://api.github.com/repos/dask/dask/issues/9846/events,https://github.com/dask/dask/issues/9846,1537485410,I_kwDOAbcwm85bpCpi,9846,implementation of np.fill_diagonal,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,11,2023-01-18T06:48:05Z,2024-04-01T01:47:15Z,,NONE,,"i would like to request something like np.fill_diagonal for dask

Any pointers on how I could go about implementing this on my own would be much appreciated.

The best i have come across SO is https://stackoverflow.com/questions/51713725/what-is-the-equivalent-of-np-fill-diagonal-in-dask which mentions using map_block but I am unsure of the logic to put inside the function passed to map_block

For a minimal example implemented in numpy that I wish to take over to dask:
```
def update_diagonal(matrix, num, lr, i):
    """"""
    Description:
        Updates the diagonal of the input matrix
    Inputs:
        matrix: Input diagonal matrix.
        num            : Number of rows/columns.
        lr          : Learning rate.
        i           : ith iteration
    """"""
    np.fill_diagonal(matrix, np.nan)
    matrix_std = np.nanstd(matrix, axis=0, ddof=0)
    matrix_fill = matrix_std * i * math.exp(2 * lr * step)
    np.fill_diagonal(matrix, matrix_fill)
    return matrix

```
Thanks for the great work on dask. it has really helped in my project",,https://api.github.com/repos/dask/dask/issues/9846/timeline,,,talkhanz,63508490,MDQ6VXNlcjYzNTA4NDkw,https://avatars.githubusercontent.com/u/63508490?v=4,,https://api.github.com/users/talkhanz,https://github.com/talkhanz,https://api.github.com/users/talkhanz/followers,https://api.github.com/users/talkhanz/following{/other_user},https://api.github.com/users/talkhanz/gists{/gist_id},https://api.github.com/users/talkhanz/starred{/owner}{/repo},https://api.github.com/users/talkhanz/subscriptions,https://api.github.com/users/talkhanz/orgs,https://api.github.com/users/talkhanz/repos,https://api.github.com/users/talkhanz/events{/privacy},https://api.github.com/users/talkhanz/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9846/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
771,https://api.github.com/repos/dask/dask/issues/9847,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9847/labels{/name},https://api.github.com/repos/dask/dask/issues/9847/comments,https://api.github.com/repos/dask/dask/issues/9847/events,https://github.com/dask/dask/issues/9847,1538364356,I_kwDOAbcwm85bsZPE,9847,We should rethink categorize(),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2023-01-18T17:06:42Z,2024-04-01T01:47:14Z,,MEMBER,,"As far as I understand, there are three use cases for why someone would want to convert a regular dtype into a categorical one, which need different implementations:

1. To shrink down the size of the dataframe, and/or to make string types more performant (even faster than with string[pyarrow]), and/or to make string types easy to manipulate with C/Cython/numba/CUDA/etc. - with the caveat that non-python functions are constrained to a single partition, and that it's straightforward to do domain mapping afterwards
2. To make string types easy to manipulate with C/Cython/numba/CUDA/etc., using an algorithm that spans across multiple partitions, e.g. machine learning, or in preparation of some other kind of very heavy interaction between the partitions - so that the categorical domains must be the same across all partitions.
3. To inspect the categorical domains in the GUI, or because for whatever reason they must be known ahead of the graph computation.

It's important to understand that this distinction is dask-specific. 
No such nuance is needed in pandas due to all data being eagerly stored on the user's machine at once.

As of today,
- use case (1) is implemented by `dd.Dataframe.astype(""category"")`, like in pandas.
- use cases (2) and (3) are implemented by `dd.Dataframe.categorize()`.
- there is no implementation for use case (2) without (3), where you want domains to be global but you don't care about knowing them in the metadata.

The `categorize()` method **computes the whole dask graph until that moment**, sends the global domains back to the client, and then adds a simple map step to the original dask graph. By the end of the day, the whole graph until categorize will be computed twice:

![2023-01-18 15 54 25](https://user-images.githubusercontent.com/6213168/213231548-9ad44a99-1670-4623-bcc4-10b4ecc39097.jpg)

One can avoid this by prepending persist():
```python
< df = df.categorize()
> df = df.persist().categorize()
```

![2023-01-18 15 54 59](https://user-images.githubusercontent.com/6213168/213231602-9f2d9335-8def-40c3-8f3f-4d03d23ddbfa.jpg)

...which is great, except that now the whole graph until categorize() needs to be in memory at the same time on the cluster.
A better way to to do this is to understand that local (intra-partition) categorization can shrink the size of the dataframe substantially:

```python
< df = df.persist().categorize()
> df = df.astype(""category"").persist().categorize()
```

![2023-01-18 15 55 38](https://user-images.githubusercontent.com/6213168/213231653-d5746c0a-ee2d-442f-bde0-1e46eee207de.jpg)

Regardless, the call blocks until the first computation is complete - which precludes the option to call `client.publish_dataset`, close the laptop, and go home. We don't need to block in use case (2) - we *could* add two new layers without recomputing anything:

![2023-01-18 15 56 06](https://user-images.githubusercontent.com/6213168/213231714-ba591765-e3a9-47ca-8f62-0cf2b3d148dd.jpg)

# User's perspective

I think it is unreasonable to expect a typical data scientist, proficient in pandas but not so hot in dask, to appreciate the difference between the three use cases without first either being explained at length or crashing and burning.

A lot of users will end up computing everything twice, particularly if the categorize() call is in the middle of a complex algorithm.

A lot of users will end up with local domains when they actually need to be global. In a realistic worst case situation, for the whole dev process their data will accidentally conjure local domains that are identical across partitions (because each partition has all the use cases), then move to production, and a fated Friday night have everything crash down because a single partition is missing a single value and now the domains are misaligned.

Users that figured out the `persist()` trick will end up with a lot of memory usage, which could be slimmed down considerably - except that they didn't figure out the triple-flip jump `astype(""category"").persist().categorize()`.

# Proposed design

Add parameters to categorize():
```
topology: ""global"" | ""local""
    ""global""
        Align the categorical domains across partitions. This will cost either more time or memory
        (see 'compute' below), but may be necessary for cross-partition numerical algorithms that require
        consistent domains (e.g. machine learning).
    ""local""
        Domains may differ across partitions. This is much faster and lighter and should be preferred as long
        as it's not too onerous for any inter-partition interactions down the line to perform domain mapping.

compute: ""twice"" | ""persisted"" | False, optional
    ""twice""
        Only permitted if topology=""global"". Compute the whole graph so far in real-time, as soon as you invoke
        categorize(), and populate the global domains in the metadata. The whole graph since the latest call to
        persist() will be recomputed from scratch once you eventually compute the output of categorize().
        This may be desirable e.g. if your graph so far consists in very large data which is fast to recompute.
    ""persisted""
        Only permitted if topology=""global"". Compute the whole graph so far in real-time, as soon as you invoke
        categorize(), and populate the global domains in the metadata. However, persist the graph just before that,
        so that the graph so far ends up being computed only once. This however will mean that the whole graph
        needs to be in memory at the same time.
    False (default)
        Do not compute the graph. categorize() will return almost immediately, without sending anything to the
        cluster yet. The metadata on the client will remain unknown.
        Note that, if topology=""global"", this means that the whole dataframe will need to be in memory at the
        same time at some point.

*Deprecated:* if both topology and compute are omitted, default to topology=""global"", compute=""twice"".
Note that when topology is explicit, the default for compute is False.
The topology parameter will become mandatory in the future.
```

- `.categorize(""global"", ""twice"")` is the same as the current `.categorize()`
- `.categorize(""global"", ""persisted"")` is the same as the current `.astype(""category"").persist().categorize()`
- `.categorize(""global"", False)` is use case (2) at the beginning of this post, which is currently impossible.
- `.categorize(""local"")` is the same as the current `.astype(""category"")`

Finally, `.astype(""category"")` should be deprecated in favor of an explicit decision with categorize().",,https://api.github.com/repos/dask/dask/issues/9847/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9847/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
772,https://api.github.com/repos/dask/dask/issues/9849,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9849/labels{/name},https://api.github.com/repos/dask/dask/issues/9849/comments,https://api.github.com/repos/dask/dask/issues/9849/events,https://github.com/dask/dask/issues/9849,1549080908,I_kwDOAbcwm85cVRlM,9849,Add blocksize to read_parquet and read_json (non-line json),"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,13,2023-01-19T12:43:17Z,2024-04-01T01:47:14Z,,MEMBER,,"# Business case
It is exceedingly frequent to have to load oversized partitions from disk, regardless of file format.
This typically happens due to the partitions on disk being the output of groupby or being created by some algorithm that has no regard for output size.

A few file formats (csv, line json, fwf, and more) natively support reading only part of the rows. This is reflected by either a blocksize (number of bytes) or chunksize (number of rows) parameter in the matching `dd.read_*` functions.

These two file formats however do not allow for partial reads, so there's no option but to load them all in memory at once:
- parquet
- json (not line json)

In this case, if you call `repartition()` immediately after `read_parquet` / `read_json`, you will typically end up with a much lower memory usage compared to just doing your whole computation on the original partitions.

When input partitions are not all the same size, you have no other option than to use `repartition(partition_size=...)`, which loads the whole input data in memory in order to recalculate the splits. This is wasteful. `repartition` doesn't really have an option, as it doesn't know what's in the graph below it - but `read_parquet` and `read_json` do.

# Proposed design
- Add the `blocksize` parameter to `read_parquet`. This will simply measure the size on disk of each partition, load the partition with a single task and, if it exceeds blocksize, split it into equal parts.
- Enhance the `blocksize` parameter in `read_json` to work for non-line json files, exactly like in `read_parquet` above.

# Alternative design (not recommended)
There's a long-standing discussion that the graph could be annotated with the expected output size of each task, primarily with the intent of empowering the distributed scheduler to do memory-aware choices. This metadata could be reused to run `repartition(partition_size=...)` without having to compute anything.

This approach would however be extremely high effort to implement and reach far out of the scope of this specific problem.",,https://api.github.com/repos/dask/dask/issues/9849/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9849/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
773,https://api.github.com/repos/dask/dask/issues/9850,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9850/labels{/name},https://api.github.com/repos/dask/dask/issues/9850/comments,https://api.github.com/repos/dask/dask/issues/9850/events,https://github.com/dask/dask/issues/9850,1549126170,I_kwDOAbcwm85cVcoa,9850,dask.dataframe.read_*: change default blocksize to 128 MiB,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 996497175, 'node_id': 'MDU6TGFiZWw5OTY0OTcxNzU=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20second%20issue', 'name': 'good second issue', 'color': '5319e7', 'default': False, 'description': 'Clearly described, educational, but less trivial than ""good first issue"".'}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,1,2023-01-19T13:09:45Z,2023-01-24T15:17:31Z,,MEMBER,,"- Related: https://github.com/dask/dask/issues/9849.

Oversized chunks cause the RAM-per-host requirements of a workload to shoot up.
High variance in the chunk size of a dataset confuses the duration prediction algorithm in the distributed scheduler - and probably a few other heuristics that I can't think of right now.

It is exceedingly common in real life to have to deal with loading files from disk that are far too large for comfort and/or vary wildly in size among the same dataset. I had recently to load up a dataset where the files varied between 22 MiB and 830 MiB each. Once decompressed, the 830 MiB partitions took in excees of 6 GiB RAM each to load up.

New dask users are unlikely to be immediately aware of this problem, which will cause their computatio to crash, and they may not notice that there's a simple parameter that would fix their problem.
*Experienced* dask uses are also not guaranteed to notice that there are a dozen of huge files among a dataset of 1000+ modestly sized ones.

# Proposed design
In an effort to improve user experience, I believe we should change the default `blocksize` for all `dask.dataframe.read_*` functions from False (1 file = 1 partition) to 128 MiB, coherently with the default chunk size in dask.array.
Note that 128 MiB is the size on disk, which can be substantially different from the size in memory. However I believe that ending up with somewhat too large or too small, but constrained, partitions is much preferable to having to deal with unconstrained partitions.

### Special cases

- `read_parquet` and `read_json` (for non-line json) don't support `blocksize`. It should be added (#9849).
- For the two above file formats, print a warning:
> Some partitions on disk are up to 830 MiB in size; they will be split into 128 MiB ones but only after loading them up at once. This will cause your RAM usage to spike during data load. If you produced this dataset yourself, consider saving it in smaller partitions (e.g. by calling `repartition` just before writing to disk). Explicitly set the blocksize parameter to disable this warning. 

(only print the warning if there are partitions exceeding 256 MiB).

- `read_hdf` has `chunksize` (number of rows) instead of `blocksize` (number of bytes). We should add a mutually-exclusive `blocksize` parameter, which would crudely estimate `size of 1 row in bytes = size of the file in bytes / number of rows in the file`. The default when neither is explicitly stated should change from `chunksize=1_000_000` to `blocksize=""128MiB""`.
",,https://api.github.com/repos/dask/dask/issues/9850/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9850/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
774,https://api.github.com/repos/dask/dask/issues/9856,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9856/labels{/name},https://api.github.com/repos/dask/dask/issues/9856/comments,https://api.github.com/repos/dask/dask/issues/9856/events,https://github.com/dask/dask/issues/9856,1550622156,I_kwDOAbcwm85cbJ3M,9856,Allow structs in Parquet files to be flattened on read,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,8,2023-01-20T10:29:30Z,2024-03-25T01:45:38Z,,NONE,,"It would be very useful if I could get a flat dataframe (no nested structs) when reading from a Parquet file. 

For example, if I want to read a file with the following schema:
```
{
    parent_id: struct {
        higher: integer,
        lower: integer
    },
    child_id: struct {
        higher: integer,
        lower: integer
    }
}
```

I would like to Ideally be able to read it like this:

```python
from dask import dataframe as dd

# ideally
dd.read_parquet('example.parquet',
                columns=['parent_id.higher', 'parent_id.lower', 'child_id.lower'],
                split_row_groups=True)

# Dask DataFrame Structure:
#               parent_id.higher parent_id.lower child_id.lower                                                                                                                     
#                         uint64          uint64         uint64
#                            ...             ...            ...
```

Also useful:
```python
dd.read_parquet('example.parquet',
                flatten=True,
                split_row_groups=True)

# Dask DataFrame Structure:
#               parent_id.higher parent_id.lower child_id.higher child_id.lower
#                         uint64          uint64          uint64         uint64
#                            ...             ...             ...            ...
```

For context, currently this is the result, to the best of my knowledge:

```python
dd.read_parquet('example.parquet',
                split_row_groups=True)

# Dask DataFrame Structure:
#               parent_id child_id
#                  object   object
#                     ...      ...
```

PyArrow already offers a method to do this: [pyarrow.Table.flatten](https://enpiar.com/arrow-site/docs/python/generated/pyarrow.Table.html#pyarrow.Table.flatten), not sure about fastparquet or other engines.

Thanks!",,https://api.github.com/repos/dask/dask/issues/9856/timeline,,,te-x,5640701,MDQ6VXNlcjU2NDA3MDE=,https://avatars.githubusercontent.com/u/5640701?v=4,,https://api.github.com/users/te-x,https://github.com/te-x,https://api.github.com/users/te-x/followers,https://api.github.com/users/te-x/following{/other_user},https://api.github.com/users/te-x/gists{/gist_id},https://api.github.com/users/te-x/starred{/owner}{/repo},https://api.github.com/users/te-x/subscriptions,https://api.github.com/users/te-x/orgs,https://api.github.com/users/te-x/repos,https://api.github.com/users/te-x/events{/privacy},https://api.github.com/users/te-x/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9856/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
775,https://api.github.com/repos/dask/dask/issues/9857,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9857/labels{/name},https://api.github.com/repos/dask/dask/issues/9857/comments,https://api.github.com/repos/dask/dask/issues/9857/events,https://github.com/dask/dask/issues/9857,1550779401,I_kwDOAbcwm85cbwQJ,9857,`DataFrame.__len__` / `Series.__len__` should raise a warning if it triggers a compute,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,6,2023-01-20T12:34:03Z,2024-03-25T01:45:37Z,,MEMBER,,"Calling `len(ddf)` or `len(ddf.index)` looks like something very innocent; a typical pandas user (but really, a typical *Python* user!) expects it to be a trivial O(1) operation.

However, unless the number of rows in each partition is known, it will trigger an intermediate computation of everything so far, which could take minutes or hours.

This is not a big problem when the call is performed manually from a Jupyter notebook, but it can have a devastating impact if it's hidden somewhere in the middle of complex user code.

# Proposed design
`__len__` should print a warning if the partition sizes are unknown, suggesting to use `.size()` instead and compute it at the end with a single `client.compute()` call, together with everything else, if possible.
",,https://api.github.com/repos/dask/dask/issues/9857/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9857/reactions,3,3,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
776,https://api.github.com/repos/dask/dask/issues/9859,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9859/labels{/name},https://api.github.com/repos/dask/dask/issues/9859/comments,https://api.github.com/repos/dask/dask/issues/9859/events,https://github.com/dask/dask/issues/9859,1551161706,I_kwDOAbcwm85cdNlq,9859,Utility that prints out delayed values when they're computed?,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,8,2023-01-20T16:48:43Z,2024-03-25T01:45:36Z,,MEMBER,,"It's common to see `print(dask_thing.compute())` in the middle of people's code. Print statements are helpful for debugging, and especially with dask, where everything is delayed already, it can be especially helpful to see what an object actually looks like. However, these `compute` calls can enormously slow things down and recompute data unnecessarily, and users may not understand this.

What if we had a utility for making print statements like this that basically deferred the printing/evaluation until a later call of `dask.compute`?

#### Original code:
```python
Q3 = ddf[""trip_time""].quantile(0.75)
print(f""Q3 is:  {Q3.compute()}"")  # blocks, computes whole dataframe, prints
upper_bound = Q3 + (1.5 * (Q3 - lower_bound))
print(f""Upper bound is:  {upper_bound.compute()}"")  # blocks, recomputes whole dataframe, prints

ddf = ddf.loc[(ddf[""trip_time""] >= lower_bound) & (ddf[""trip_time""] <= upper_bound)]
ddf.to_parquet(...).compute()  # blocks, does actual computation you care about
```

#### Using new utility:
```python
Q3 = ddf[""trip_time""].quantile(0.75)
dask.print(""Q3 is:  {}"", Q3)  # instant, doesn't print anything yet
upper_bound = Q3 + (1.5 * (Q3 - lower_bound))
dask.print(""Upper bound is:  {}"", upper_bound)  # instant, doesn't print anything yet

ddf = ddf.loc[(ddf[""trip_time""] >= lower_bound) & (ddf[""trip_time""] <= upper_bound)]
ddf.to_parquet(...).compute()  # blocks, does actual computation you care about.
# first prints ""Q3 is ...""
# then a little later prints ""Upper bound is ...""
# then later returns
```

Basically, `dask.print` / `dask.log` (not sure what to name it) would just push a print statement onto an internal, global queue when you call it, but not actually print anything yet.

Then each time it's called, `dask.compute` would pull everything off that queue and add it to the list of dask collections to be computed. It would take Futures to each of the print statements, and as soon as the future completed, it would print.",,https://api.github.com/repos/dask/dask/issues/9859/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9859/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
777,https://api.github.com/repos/dask/dask/issues/9861,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9861/labels{/name},https://api.github.com/repos/dask/dask/issues/9861/comments,https://api.github.com/repos/dask/dask/issues/9861/events,https://github.com/dask/dask/issues/9861,1552207204,I_kwDOAbcwm85chM1k,9861,Issue writing parquet files on s3 in append mode with pyarrow,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2023-01-22T17:19:18Z,2024-03-25T01:45:35Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
`dask.DataFrame.to_parquet` fails under the following conditions:
1. Target filesystem is `s3fs.S3FileSystem`
2. the target `path` doesn't exists on S3
3. `to_parquet` parameter `append` is `True`
4. the parquet engine is `pyarrow`

Note: if the target file system is a `LocalFileSytem` then the write succeeds, therefore I would expect the same for a `S3FileSystem`

**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import dask.dataframe as dd

df = dd.from_pandas(pd.DataFrame({""a"": [1,2,3]}), npartitions=1)
df.to_parquet(""/tmp/test.parquet"", append=True, engine=""pyarrow"")  # -> works
df.to_parquet(""s3://my-test-bucket/test.parquet"", append=False, engine=""pyarrow"")  #-> works even if ""s3://my-test-bucket/test.parquet"" doesn't exist
df.to_parquet(""s3://my-test-bucket/test.parquet"", append=True, engine=""pyarrow"")  #-> works if ""s3://my-test-bucket/test.parquet"" exists
df.to_parquet(""s3://my-test-bucket/test.parquet"", append=True, engine=""pyarrow"")  #-> fails if ""s3://my-test-bucket/test.parquet"" doesn't exist, see traceback below

```

Traceback:
```
~/.venv/lib/python3.10/site-packages/dask/dataframe/core.py in to_parquet(self, path, *args, **kwargs)
   5279         from dask.dataframe.io import to_parquet
   5280 
-> 5281         return to_parquet(self, path, *args, **kwargs)
   5282 
   5283     def to_orc(self, path, *args, **kwargs):

~/.venv/lib/python3.10/site-packages/dask/dataframe/io/parquet/core.py in to_parquet(df, path, engine, compression, write_index, append, overwrite, ignore_divisions, partition_on, storage_options, custom_metadata, write_metadata_file, compute, compute_kwargs, schema, name_function, **kwargs)
    938     # Engine-specific initialization steps to write the dataset.
    939     # Possibly create parquet metadata, and load existing stuff if appending
--> 940     i_offset, fmd, metadata_file_exists, extra_write_kwargs = engine.initialize_write(
    941         df,
    942         fs,

~/.venv/lib/python3.10/site-packages/dask/dataframe/io/parquet/arrow.py in initialize_write(cls, df, fs, path, append, partition_on, ignore_divisions, division_info, schema, index_cols, **kwargs)
    625         if append:
    626             # Extract metadata and get file offset if appending
--> 627             ds = pa_ds.dataset(path, filesystem=_wrapped_fs(fs), format=""parquet"")
    628             i_offset = len(ds.files)
    629             if i_offset > 0:

~/.venv/lib/python3.10/site-packages/pyarrow/dataset.py in dataset(source, schema, format, filesystem, partitioning, partition_base_dir, exclude_invalid_files, ignore_prefixes)
    750 
    751     if _is_path_like(source):
--> 752         return _filesystem_dataset(source, **kwargs)
    753     elif isinstance(source, (tuple, list)):
    754         if all(_is_path_like(elem) for elem in source):

~/.venv/lib/python3.10/site-packages/pyarrow/dataset.py in _filesystem_dataset(source, schema, filesystem, partitioning, format, partition_base_dir, exclude_invalid_files, selector_ignore_prefixes)
    442         fs, paths_or_selector = _ensure_multiple_sources(source, filesystem)
    443     else:
--> 444         fs, paths_or_selector = _ensure_single_source(source, filesystem)
    445 
    446     options = FileSystemFactoryOptions(

~/.venv/lib/python3.10/site-packages/pyarrow/dataset.py in _ensure_single_source(path, filesystem)
    418         paths_or_selector = [path]
    419     else:
--> 420         raise FileNotFoundError(path)
    421 
    422     return filesystem, paths_or_selector

FileNotFoundError: my-test-bucket/test.parquet

```

**Environment**:

- Dask version: 2023.1.0
- Python version: 3.10
- pyarrow version: 10.0.1
- fsspec version: 2022.11.0
- s3fs version: 2022.11.0
- Operating System: Ubuntu
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/9861/timeline,,,antoinebon,3825783,MDQ6VXNlcjM4MjU3ODM=,https://avatars.githubusercontent.com/u/3825783?v=4,,https://api.github.com/users/antoinebon,https://github.com/antoinebon,https://api.github.com/users/antoinebon/followers,https://api.github.com/users/antoinebon/following{/other_user},https://api.github.com/users/antoinebon/gists{/gist_id},https://api.github.com/users/antoinebon/starred{/owner}{/repo},https://api.github.com/users/antoinebon/subscriptions,https://api.github.com/users/antoinebon/orgs,https://api.github.com/users/antoinebon/repos,https://api.github.com/users/antoinebon/events{/privacy},https://api.github.com/users/antoinebon/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9861/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
778,https://api.github.com/repos/dask/dask/issues/9866,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9866/labels{/name},https://api.github.com/repos/dask/dask/issues/9866/comments,https://api.github.com/repos/dask/dask/issues/9866/events,https://github.com/dask/dask/pull/9866,1553638011,PR_kwDOAbcwm85IWu7O,9866,Da fill diagonal,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,5,2023-01-23T19:25:44Z,2024-03-25T01:45:34Z,,FIRST_TIME_CONTRIBUTOR,,"- [ V] Closes #9846 https://github.com/dask/dask/issues/9846
- [ V] passes dask/array/tests/test_creation.py::test_fill_diagonal 
- [ x] Passes `pre-commit run --all-files` 
",,https://api.github.com/repos/dask/dask/issues/9866/timeline,,,talkhanz,63508490,MDQ6VXNlcjYzNTA4NDkw,https://avatars.githubusercontent.com/u/63508490?v=4,,https://api.github.com/users/talkhanz,https://github.com/talkhanz,https://api.github.com/users/talkhanz/followers,https://api.github.com/users/talkhanz/following{/other_user},https://api.github.com/users/talkhanz/gists{/gist_id},https://api.github.com/users/talkhanz/starred{/owner}{/repo},https://api.github.com/users/talkhanz/subscriptions,https://api.github.com/users/talkhanz/orgs,https://api.github.com/users/talkhanz/repos,https://api.github.com/users/talkhanz/events{/privacy},https://api.github.com/users/talkhanz/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9866/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9866,https://github.com/dask/dask/pull/9866,https://github.com/dask/dask/pull/9866.diff,https://github.com/dask/dask/pull/9866.patch,,,,,,,,,,,,,,,,,,,
779,https://api.github.com/repos/dask/dask/issues/9874,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9874/labels{/name},https://api.github.com/repos/dask/dask/issues/9874/comments,https://api.github.com/repos/dask/dask/issues/9874/events,https://github.com/dask/dask/pull/9874,1557243404,PR_kwDOAbcwm85Ii2Mf,9874,Add `dataframe.nullable_dtypes` configuration option,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-01-25T20:37:25Z,2024-03-25T01:45:33Z,,MEMBER,,"This PR adds a new `dataframe.nullable_dtype` configuration option similar to what `pandas` is doing in https://github.com/pandas-dev/pandas/pull/50748. This should both make alignment between `pandas` and `dask.dataframe` better and make it easier for folks to opt into using `pyarrow`-backed dtypes.

cc @phofl for visibility ",,https://api.github.com/repos/dask/dask/issues/9874/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9874/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9874,https://github.com/dask/dask/pull/9874,https://github.com/dask/dask/pull/9874.diff,https://github.com/dask/dask/pull/9874.patch,,,,,,,,,,,,,,,,,,,
780,https://api.github.com/repos/dask/dask/issues/9879,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9879/labels{/name},https://api.github.com/repos/dask/dask/issues/9879/comments,https://api.github.com/repos/dask/dask/issues/9879/events,https://github.com/dask/dask/issues/9879,1558639932,I_kwDOAbcwm85c5vU8,9879,Apply `dataframe.dtype_backend` configuration option globally ,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2023-01-26T19:14:47Z,2024-03-25T01:45:32Z,,MEMBER,,"We recently added a `dataframe.dtype_backend` config option for specifying whether classic `numpy`-backed dtypes (e.g. `int64`, `float64`, etc.) or `pyarrow`-backed dtypes (e.g. `int64[pyarrow]`, `float64[pyarrow]`, etc.) should be used in a dask DataFrame.

However, today `dataframe.dtype_backend` is only used in `dd.read_parquet`. To extend where `pyarrow` dtypes can be used, and arguably for a more intuitive UX (xref https://github.com/dask/dask/issues/9840), I think we want `dataframe.dtype_backend` to work with all methods for creating a dask DataFrame. That is, things like the following

```python
import dask
import dask.dataframe as dd

# Tell dask to use `pyarrow`-backed dtypes
dask.config.set({""dataframe.dtypes_backend"": ""pyarrow""})

df = dd.read_csv(...)
df = dd.from_pandas(...)
df = dd.from_delayed(...)
...
```

should all return dask DataFrames backed by `pyarrow` dtypes.

Some methods, like `read_parquet`, will want to have a specialized implementation for this. However, in cases where a specialized method isn't implemented, we should still automatically cast the dask DataFrame to use `pyarrow` dtypes when `dataframe.dtype_backend = ""pyarrrow""`. For example, through an (optional) `map_partitions` call after our existing DataFrame creation logic. 

cc @rjzamora @phofl for visibility ",,https://api.github.com/repos/dask/dask/issues/9879/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9879/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
781,https://api.github.com/repos/dask/dask/issues/9882,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9882/labels{/name},https://api.github.com/repos/dask/dask/issues/9882/comments,https://api.github.com/repos/dask/dask/issues/9882/events,https://github.com/dask/dask/issues/9882,1559008120,I_kwDOAbcwm85c7JN4,9882,idxmin/idxmax on GroupBy does not returns the same result as Pandas,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,5,2023-01-27T01:03:58Z,2024-03-25T01:45:31Z,,MEMBER,,"**Describe the issue**:

When computing `idxmax` on grouped dataframe, dask returns a different result from pandas.

**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import dask.dataframe as dd

df = pd.DataFrame({
    ""a"": [1, 2, 1, 5],
    ""b"": [3, 4, 5, 3]
})
ddf = dd.from_pandas(df, npartitions=2)
res1 = df.groupby(""a"").idxmax()
res2 = ddf.groupby(""a"").idxmax().compute()
print(res1)
print(res2)
print(res1 == res2)
```

This outputs:

```
   b
a
1  2
2  1
5  3
   b
a
1  0
2  1
5  3
       b
a
1  False
2   True
5   True
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2023.1.0+20.gc6b7052ac.dirty
- Python version: 3.9.15
- Operating System: macos
- Install method (conda, pip, source): source
",,https://api.github.com/repos/dask/dask/issues/9882/timeline,,,j-bennet,637013,MDQ6VXNlcjYzNzAxMw==,https://avatars.githubusercontent.com/u/637013?v=4,,https://api.github.com/users/j-bennet,https://github.com/j-bennet,https://api.github.com/users/j-bennet/followers,https://api.github.com/users/j-bennet/following{/other_user},https://api.github.com/users/j-bennet/gists{/gist_id},https://api.github.com/users/j-bennet/starred{/owner}{/repo},https://api.github.com/users/j-bennet/subscriptions,https://api.github.com/users/j-bennet/orgs,https://api.github.com/users/j-bennet/repos,https://api.github.com/users/j-bennet/events{/privacy},https://api.github.com/users/j-bennet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9882/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
782,https://api.github.com/repos/dask/dask/issues/9883,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9883/labels{/name},https://api.github.com/repos/dask/dask/issues/9883/comments,https://api.github.com/repos/dask/dask/issues/9883/events,https://github.com/dask/dask/pull/9883,1559096133,PR_kwDOAbcwm85IpEMc,9883,[WIP] Support `dataframe.dtype_backend` globally,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-01-27T03:06:56Z,2024-03-25T01:45:29Z,,MEMBER,,Closes https://github.com/dask/dask/issues/9879,,https://api.github.com/repos/dask/dask/issues/9883/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9883/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9883,https://github.com/dask/dask/pull/9883,https://github.com/dask/dask/pull/9883.diff,https://github.com/dask/dask/pull/9883.patch,,,,,,,,,,,,,,,,,,,
783,https://api.github.com/repos/dask/dask/issues/9888,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9888/labels{/name},https://api.github.com/repos/dask/dask/issues/9888/comments,https://api.github.com/repos/dask/dask/issues/9888/events,https://github.com/dask/dask/issues/9888,1560000679,I_kwDOAbcwm85c-7in,9888,Reuse of keys in blockwise fusion can cause spurious KeyErrors on distributed cluster,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,13,2023-01-27T15:57:58Z,2024-03-18T01:45:08Z,,MEMBER,,"Subsequent Blockwise layers are currently fused into a single layer. This reduces the number of tasks, the overhead and is very generally a good thing to do. Currently, the fused output does not generate unique key names which is a problem from a UX perspective but can also cause severe failure cases when being executed on the distributed scheduler since distributed assumes that a task key is a unique identifier for the **entire task**. While it is true that the data output of the fused key and the non-fused key is identical, the runspec and the local topology is intentionally very different. Specifically, a fused task, for example, may not have any dependencies while the non-fused task does have dependencies.

An example where this matters is the following (async code is not necessary but the condition is actually a bit difficult to trigger and this helps. Paste this code in a Jupyter notebook and run it a couple of times).


```python
import asyncio
from distributed import Client, Scheduler, Worker

import dask
import time
import dask.dataframe as dd
async with (
    Scheduler() as s,
    Worker(s.address) as a,
    Worker(s.address) as b,
    Client(s.address, asynchronous=True) as c
):
    df = dask.datasets.timeseries(
        start=""2000-01-01"",
        end=""2000-01-10"",
        dtypes={""x"": float, ""y"": float},
        freq=""100 s"",
    )
    out = dd.shuffle.shuffle(df, ""x"")
    out = out.persist()

    while not a.tasks:
        await asyncio.sleep(0.05)

    del out

    out = dd.shuffle.shuffle(df, ""x"")
    x, y = c.compute([df.x.size, out.x.size])
    x = await c.gather(x, y)
```

Note how initial shuffle is persisted and a slightly different version of this graph is computed *again* below but the graph below is slightly different. From what I can gather, the initial persist is fusing the keys while the latter one does not (maybe it's the other way round, I'm not sure. Either way a different issue).

This specific reproducer actually triggers (not every time) a `KeyError` in a workers data buffer while trying to read data. 

```
023-01-27 16:28:34,648 - distributed.worker - ERROR - Exception during execution of task ('size-chunk-0482e0de93343089cd64837d139d9a80-49c0404470df4695b3f5aa383f11c345', 3).
Traceback (most recent call last):
  File ""/Users/fjetter/workspace/distributed/distributed/worker.py"", line 2366, in _prepare_args_for_execution
    data[k] = self.data[k]
  File ""/Users/fjetter/workspace/distributed/distributed/spill.py"", line 257, in __getitem__
    return super().__getitem__(key)
  File ""/Users/fjetter/mambaforge/envs/dask-distributed-310/lib/python3.10/site-packages/zict/buffer.py"", line 108, in __getitem__
    raise KeyError(key)
KeyError: ""('simple-shuffle-539a650502e21de2dabd2021c9c9e684', 3)""

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/Users/fjetter/workspace/distributed/distributed/worker.py"", line 2247, in execute
    args2, kwargs2 = self._prepare_args_for_execution(ts, args, kwargs)
  File ""/Users/fjetter/workspace/distributed/distributed/worker.py"", line 2370, in _prepare_args_for_execution
    data[k] = Actor(type(self.state.actors[k]), self.address, k, self)
KeyError: ""('simple-shuffle-539a650502e21de2dabd2021c9c9e684', 3)""
```

This is caused because the dependency relations between tasks are no longer accurate on the scheduler and it considers a task ""ready"", i.e. all dependencies in memory, too soon, causing a failure on the worker.
When `validate` is activated, the scheduler catches these cases earlier and raises appropriate AssertionErrors. This is not checked at runtime for performance reasons and is typically not necessary since we rely on the assumption that keys identify a task uniquely.

Apart from this artificial example, we do have internal reports about such a spurious KeyError in combination with an xgboost workload",,https://api.github.com/repos/dask/dask/issues/9888/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9888/reactions,2,0,0,0,0,0,0,0,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
784,https://api.github.com/repos/dask/dask/issues/9894,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9894/labels{/name},https://api.github.com/repos/dask/dask/issues/9894/comments,https://api.github.com/repos/dask/dask/issues/9894/events,https://github.com/dask/dask/issues/9894,1562649759,I_kwDOAbcwm85dJCSf,9894,Links to changelog sub-sections are not stable,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-01-30T15:21:12Z,2024-03-18T01:45:07Z,,MEMBER,,"While #8534 enabled permalinks for the changelog when linking to the individual versions (e.g., https://distributed.dask.org/en/stable/changelog.html#v2023-1-0), linking to sub-sections within a release is still transient: As of this writing, https://distributed.dask.org/en/stable/changelog.html#id3 links to **Enhancements** within **2023.1.0**, but eventually it will link to some other sub-section of a newer release. Instead, I would expect the changelog to offer durable links (something like https://distributed.dask.org/en/stable/changelog.html#v2023-1-0-enhancements) to sub-sections.

(Alternatively, it should not offer me the visual cue for ""Permalink to this headline"" on sub-sections to avoid suggesting stable links.)",,https://api.github.com/repos/dask/dask/issues/9894/timeline,,,hendrikmakait,2699097,MDQ6VXNlcjI2OTkwOTc=,https://avatars.githubusercontent.com/u/2699097?v=4,,https://api.github.com/users/hendrikmakait,https://github.com/hendrikmakait,https://api.github.com/users/hendrikmakait/followers,https://api.github.com/users/hendrikmakait/following{/other_user},https://api.github.com/users/hendrikmakait/gists{/gist_id},https://api.github.com/users/hendrikmakait/starred{/owner}{/repo},https://api.github.com/users/hendrikmakait/subscriptions,https://api.github.com/users/hendrikmakait/orgs,https://api.github.com/users/hendrikmakait/repos,https://api.github.com/users/hendrikmakait/events{/privacy},https://api.github.com/users/hendrikmakait/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9894/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
785,https://api.github.com/repos/dask/dask/issues/9902,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9902/labels{/name},https://api.github.com/repos/dask/dask/issues/9902/comments,https://api.github.com/repos/dask/dask/issues/9902/events,https://github.com/dask/dask/pull/9902,1564621246,PR_kwDOAbcwm85I7iH1,9902,Add support for grouping by tuple keys,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-01-31T16:17:13Z,2024-03-18T01:45:06Z,,MEMBER,,"It looks like we've been allowing the `by` columns of a groupby to be specified in a list or tuple, but expected pandas behavior treats a tuple as a column key; this PR attempts to align us with pandas behavior, marking this as a draft as I imagine this will break a few tests.

Also noting that the added tests seem to be failing due to numpy warnings getting emitted in pandas while trying to index an empty dataframe with a tuple column key:

```python
import pandas as pd

df = pd.DataFrame(columns=[('a', 'b'), 'a', 'b', 'c'])
df[[('a', 'b'), 'c']]
# /raid/charlesb/mambaforge/envs/groupby-tuple/lib/python3.9/site-packages/pandas/core/common.py:241: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
#   result = np.asarray(values, dtype=dtype)
```

~Will file an issue to track this if it doesn't already exist.~

EDIT:

Looks like this is resolved in `pandas>=1.5`, so opting to just ignore the warnings for our 3.8/3.9 testing

cc @quasiben 

- [x] Closes #2893
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9902/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9902/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9902,https://github.com/dask/dask/pull/9902,https://github.com/dask/dask/pull/9902.diff,https://github.com/dask/dask/pull/9902.patch,,,,,,,,,,,,,,,,,,,
786,https://api.github.com/repos/dask/dask/issues/9913,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9913/labels{/name},https://api.github.com/repos/dask/dask/issues/9913/comments,https://api.github.com/repos/dask/dask/issues/9913/events,https://github.com/dask/dask/issues/9913,1567445045,I_kwDOAbcwm85dbVA1,9913,"`numeric_only` compatibility with `pandas>=2.0`, handling datetime and timedelta","[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-02-02T06:57:10Z,2024-03-18T01:45:04Z,,MEMBER,,"In pandas 2.0, there were a lot of changes related to `numeric_only` argument in `DataFrame` and `DataFrameGroupBy` aggs. In Dask, we followed up to implement similar behavior and ensure that clients are able to use Dask with `pandas>=2.0` without things breaking. The following PRs add or change `numeric_only` behavior to align with the changes in pandas:

* https://github.com/dask/dask/pull/9787
* https://github.com/dask/dask/pull/9889
* https://github.com/dask/dask/pull/9898

The support of `numeric_only` is not quite complete without also supporting some aggs on datetime-like dtypes, like this PR implements in Pandas:

* https://github.com/pandas-dev/pandas/pull/29941

In https://github.com/dask/dask/pull/9898, with pandas 2.0, if the dataframe contains datetime-like dtype, and `numeric_only` is `False` or default, an attempt to aggregate it will raise an error. With pandas 1.5, a warning is raised, and non-numeric columns are dropped.

Also related, this PR:

https://github.com/dask/dask/pull/9868

contains a workaround to not test `mean` on datetimes, because while pandas supports finding `mean` of a datetime dtype, Dask can't handle it yet.

Opening this issue to add support for datetime-like dtypes.

cc @jrbourbeau.",,https://api.github.com/repos/dask/dask/issues/9913/timeline,,,j-bennet,637013,MDQ6VXNlcjYzNzAxMw==,https://avatars.githubusercontent.com/u/637013?v=4,,https://api.github.com/users/j-bennet,https://github.com/j-bennet,https://api.github.com/users/j-bennet/followers,https://api.github.com/users/j-bennet/following{/other_user},https://api.github.com/users/j-bennet/gists{/gist_id},https://api.github.com/users/j-bennet/starred{/owner}{/repo},https://api.github.com/users/j-bennet/subscriptions,https://api.github.com/users/j-bennet/orgs,https://api.github.com/users/j-bennet/repos,https://api.github.com/users/j-bennet/events{/privacy},https://api.github.com/users/j-bennet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9913/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
787,https://api.github.com/repos/dask/dask/issues/9914,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9914/labels{/name},https://api.github.com/repos/dask/dask/issues/9914/comments,https://api.github.com/repos/dask/dask/issues/9914/events,https://github.com/dask/dask/pull/9914,1568164274,PR_kwDOAbcwm85JHbGK,9914,From-array dispatch support,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-02-02T14:30:00Z,2024-03-18T01:45:04Z,,MEMBER,,"- [ ] Closes #xxxx
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

PR adds from_array support for dispatching and tests from_* array methods

cc @rjzamora @GenevieveBuckley 
",,https://api.github.com/repos/dask/dask/issues/9914/timeline,,,quasiben,1403768,MDQ6VXNlcjE0MDM3Njg=,https://avatars.githubusercontent.com/u/1403768?v=4,,https://api.github.com/users/quasiben,https://github.com/quasiben,https://api.github.com/users/quasiben/followers,https://api.github.com/users/quasiben/following{/other_user},https://api.github.com/users/quasiben/gists{/gist_id},https://api.github.com/users/quasiben/starred{/owner}{/repo},https://api.github.com/users/quasiben/subscriptions,https://api.github.com/users/quasiben/orgs,https://api.github.com/users/quasiben/repos,https://api.github.com/users/quasiben/events{/privacy},https://api.github.com/users/quasiben/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9914/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9914,https://github.com/dask/dask/pull/9914,https://github.com/dask/dask/pull/9914.diff,https://github.com/dask/dask/pull/9914.patch,,,,,,,,,,,,,,,,,,,
788,https://api.github.com/repos/dask/dask/issues/9915,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9915/labels{/name},https://api.github.com/repos/dask/dask/issues/9915/comments,https://api.github.com/repos/dask/dask/issues/9915/events,https://github.com/dask/dask/issues/9915,1568823162,I_kwDOAbcwm85dgld6,9915,`axis=None` behavior in `pandas` 2.0 for `skew` and `kurtosis`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-02-02T21:38:02Z,2024-03-18T01:45:03Z,,MEMBER,,"In `pandas=2.0` certain DataFrame reductions (e.g. `DataFrame.min()`, `DataFrame.max()`) will now be performed over both axes and a scalar returned when `axis=None`. https://github.com/dask/dask/pull/9867 handles this new behavior for `min`, `max`, and `mean` but not `skew` or `kurtosis`. This issue is so we don't loose track of circling back to add the corresponding updates to `skew` and `kurtosis`.  ",,https://api.github.com/repos/dask/dask/issues/9915/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9915/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
789,https://api.github.com/repos/dask/dask/issues/9917,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9917/labels{/name},https://api.github.com/repos/dask/dask/issues/9917/comments,https://api.github.com/repos/dask/dask/issues/9917/events,https://github.com/dask/dask/issues/9917,1569968895,I_kwDOAbcwm85dk9L_,9917,[DOC] Favicon not loading for generated API docs ,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,4,2023-02-03T14:55:42Z,2024-03-18T01:45:02Z,,MEMBER,,"Looks like the favicon isn't getting loaded for the generated API docs pages; for example, the [`dask.dataframe.DataFrame` API docs](https://docs.dask.org/en/latest/generated/dask.dataframe.DataFrame.html):

![image](https://user-images.githubusercontent.com/20627856/216634235-e573a9a6-2245-4fc0-a912-ef2688173f7a.png)

A little torn between tasks right now but imagine this is a simple fix and can look into this myself if no one else is able to.

",,https://api.github.com/repos/dask/dask/issues/9917/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9917/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
790,https://api.github.com/repos/dask/dask/issues/9923,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9923/labels{/name},https://api.github.com/repos/dask/dask/issues/9923/comments,https://api.github.com/repos/dask/dask/issues/9923/events,https://github.com/dask/dask/pull/9923,1572993014,PR_kwDOAbcwm85JXJsJ,9923,Fix `idxmin`/`idxmax` aggregation implementation,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2023-02-06T17:35:57Z,2023-02-08T21:21:46Z,,MEMBER,,"- [ ] Closes #9882
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9923/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9923/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9923,https://github.com/dask/dask/pull/9923,https://github.com/dask/dask/pull/9923.diff,https://github.com/dask/dask/pull/9923.patch,,,,,,,,,,,,,,,,,,,
791,https://api.github.com/repos/dask/dask/issues/9925,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9925/labels{/name},https://api.github.com/repos/dask/dask/issues/9925/comments,https://api.github.com/repos/dask/dask/issues/9925/events,https://github.com/dask/dask/pull/9925,1573986398,PR_kwDOAbcwm85Jaezc,9925,Do not ravel array when slicing with same shape,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-02-07T09:32:32Z,2024-03-18T01:45:01Z,,MEMBER,,"I'm not very familiar with the array API so I might be missing something obvious. However, I encountered a troubling complex graph when doing an operation like `array[array > 100]`

```python
import dask.array as da
arr = da.random.random((200,200,200), chunks=(20, 20, 20))
arr[arr > 1].dask
```

![image](https://user-images.githubusercontent.com/8629629/217204020-daa896a5-0005-4ee9-861d-23a52cb5b167.png)

This is under the hood raveling the arrays before indexing. Raveling is effectively a rechunking operation which is relatively expensive, specifically for an operation that should be elemwise.

I'm wondering if I'm missing anything here or why there is a reason for this complexity",,https://api.github.com/repos/dask/dask/issues/9925/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9925/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9925,https://github.com/dask/dask/pull/9925,https://github.com/dask/dask/pull/9925.diff,https://github.com/dask/dask/pull/9925.patch,,,,,,,,,,,,,,,,,,,
792,https://api.github.com/repos/dask/dask/issues/9927,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9927/labels{/name},https://api.github.com/repos/dask/dask/issues/9927/comments,https://api.github.com/repos/dask/dask/issues/9927/events,https://github.com/dask/dask/pull/9927,1574913353,PR_kwDOAbcwm85JdmgW,9927,Add `from_frame` and `from_series` functions to Dask-DataFrame,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,0,2023-02-07T19:34:11Z,2023-02-07T19:59:59Z,,MEMBER,,"This PR proposes the introduction of new `from_frame` and `from_series` functions for dd.DataFrame and dd.Series construction, respectively. The proposed functions (which are defined in `dask.dataframe.io.io` and imported within the `dask.dataframe` namespace) are intended to wrap `dd.repartition` and `dd.from_pandas`, depending on the input data. 

### Motivation

The primary motivation for this PR is to improve user experience for the ""cudf"" backend of Dask-DataFrame. For example, direct users of the `dask_cudf` library have access to `dask_cudf.from_cudf` function to create a new cudf-backed DataFrame collection from a cudf DataFrame or Series, E.g:

```python
import dask_cudf
import cudf

df = cudf.DataFrame({""a"": range(10), ""b"": [1, 2]*5})
print(dask_cudf.from_cudf(df, npartitions=2))
```
```
<dask_cudf.DataFrame | 2 tasks | 2 npartitions>
```

Those who want to use the `dask.dataframe` API with the ""cudf"" dataframe backend only have access to `dd.from_pandas`:

```python
import dask.dataframe as dd
import cudf

df = cudf.DataFrame({""a"": range(10), ""b"": [1, 2]*5})
print(dd.from_pandas(df, npartitions=2))
```
```
<dask_cudf.DataFrame | 2 tasks | 2 npartitions>
```

As you can see, `from_pandas` and `from_cudf` do (almost) the same thing. In fact, the `dask_cudf.from_cudf` implementation is just a `dd.from_pandas` wrapper. For this reason, it seems reasonable to adopt a backend-agnostic  name/API for the same functionality.  Since backend-agnostic behavior already exists for `dd.from_array`, this PR proposes that we follow that convention by supporting `from_frame` and `from_series` for frame-like and series-like data, respectively.

E.g.

```python
import dask.dataframe as dd
import cudf

ser = cudf.Series(range(10))
dd.from_series(ser, npartitions=2)  #  <dask_cudf.Series | 2 tasks | 2 npartitions>

df = cudf.DataFrame({""a"": range(10), ""b"": [1, 2]*5})
dd.from_frame(df, npartitions=2)  #  <dask_cudf.DataFrame | 2 tasks | 2 npartitions>
```

**Note: I am not proposing the deprecation of `from_pandas`.  Rather, I am proposing that we add some light-weight functions to the top-level `dask.dataframe` API (practically aliases) so that both Dask and RAPIDS examples/documentation can promote CPU/GPU compatible code.**


- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9927/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9927/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9927,https://github.com/dask/dask/pull/9927,https://github.com/dask/dask/pull/9927.diff,https://github.com/dask/dask/pull/9927.patch,,,,,,,,,,,,,,,,,,,
793,https://api.github.com/repos/dask/dask/issues/9934,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9934/labels{/name},https://api.github.com/repos/dask/dask/issues/9934/comments,https://api.github.com/repos/dask/dask/issues/9934/events,https://github.com/dask/dask/issues/9934,1578298060,I_kwDOAbcwm85eEurM,9934,`dask.array.linalg.svd` leaks memory for large dataset,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2023-02-09T17:24:40Z,2023-02-14T20:40:44Z,,NONE,,"**Describe the issue**:
I have a test dataset (~6GB) with 4 dimensions `{'time': 2000, 'field': 3, 'x': 512, 'y': 512}`. I load the dataset with `(42, 3, 512, 512)` [~126MB] chunks (i.e. I only chunk in the time direction). 

As a first step, I flatten the data along the `('field', 'x', 'y')` axes into an array with `{'time': 2000, 'dims': 786432}` with chunks `(42, 786432)` [~126MB]. 

On this array, I run `_, s, basis = dask.linalg.svd(data)` to get the singular values and right singular vectors, ie. `s.shape = (2000,)`, `basis.shape = (2000, 786432)`. Of the basis, I want the 100 first elements, ie. `basis[:100].shape = (100, 786432)`.

When I call `dask.compute()` I get the following warning:
```
distributed.worker.memory - WARNING - Unmanaged memory use is high. This may indicate a memory leak or the memory
may not be released to the OS; see 
https://distributed.dask.org/en/latest/worker-memory.html#memory-not-released-back-to-the-os for more information. 
-- Unmanaged memory: 27.61 GiB 
-- Worker memory limit: 37.66 GiB
```

It seems like this should not happen if my dataset is only 6GBs and my chunk only ~126MB.

**Minimal Complete Verifiable Example**:

Unfortunately, I cannot share my dataset, it is too large. However, you can reproduce the problem as follows:

1. imports:
```python
import numpy as np

import dask
from dask.distributed import Client
import xarray as xr
```
2. start client:
```python
client = Client()
```
4. create dataset (using `xarray`):
```python
rng = np.random.default_rng()
data = rng.normal(0, 1, (2000, 500000))
arr = xr.DataArray(
    data, 
    dims=('time', 'dims'), 
    coords={'time': np.arange(data.shape[0]), 'dims': np.arange(data.shape[1])}
)
arr.name = 'data'

arr.to_netcdf('dask_9934.h5')
```
5. load data using `xarray`. This is done lazily:
```python
fh = xr.open_dataset('dask_9934.h5', chunks={'time': 'auto', 'dims': -1})
X = fh['data']
```

6. compute svd using dask:
```python
_, s, v = dask.array.linalg.svd(X.data)
basis, singular_values = dask.compute(v[:100], s)
```
7. compute svd using xarray using dask:
```python
_, s, v = xr.apply_ufunc(
    dask.array.linalg.svd,
    X,
    input_core_dims=[('time', ""dims"")],
    output_core_dims=[('time', ""r""), (""r"",), (""r"", ""dims"")],
    dask=""allowed"",
)
basis, singular_values = dask.compute(v[:100], s)
```

Both steps 4 and 5 throw a memory warning and leak memory to disk.

**Environment**:

- Dask version: '2023.1.0'
- Python version: Python 3.10.8
- Operating System: some linux (code is run on a compute node)
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/9934/timeline,,,cgahr,26804763,MDQ6VXNlcjI2ODA0NzYz,https://avatars.githubusercontent.com/u/26804763?v=4,,https://api.github.com/users/cgahr,https://github.com/cgahr,https://api.github.com/users/cgahr/followers,https://api.github.com/users/cgahr/following{/other_user},https://api.github.com/users/cgahr/gists{/gist_id},https://api.github.com/users/cgahr/starred{/owner}{/repo},https://api.github.com/users/cgahr/subscriptions,https://api.github.com/users/cgahr/orgs,https://api.github.com/users/cgahr/repos,https://api.github.com/users/cgahr/events{/privacy},https://api.github.com/users/cgahr/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9934/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
794,https://api.github.com/repos/dask/dask/issues/9935,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9935/labels{/name},https://api.github.com/repos/dask/dask/issues/9935/comments,https://api.github.com/repos/dask/dask/issues/9935/events,https://github.com/dask/dask/pull/9935,1578665902,PR_kwDOAbcwm85JqMJE,9935,Handle inconsistent nullability during read_parquet file aggregation,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2023-02-09T21:49:41Z,2023-03-07T20:14:07Z,,MEMBER,,"cudf will typically include a ""not null"" distinction in the row-group schema for columns that do not contain any null values. `dd.read_parquet` will currently raise an error when aggregating multiple files with inconsistent nullability (even if the types are compatible). This PR adds the necessary change to handle inconsistent nullabilities.

Note that this error was illustrated in https://github.com/rapidsai/cudf/issues/12702

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9935/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9935/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/9935,https://github.com/dask/dask/pull/9935,https://github.com/dask/dask/pull/9935.diff,https://github.com/dask/dask/pull/9935.patch,,,,,,,,,,,,,,,,,,,
795,https://api.github.com/repos/dask/dask/issues/9942,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9942/labels{/name},https://api.github.com/repos/dask/dask/issues/9942/comments,https://api.github.com/repos/dask/dask/issues/9942/events,https://github.com/dask/dask/pull/9942,1580343894,PR_kwDOAbcwm85Jv2gB,9942,[DNM] Try `copy_on_write` in CI,"[{'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-02-10T21:13:35Z,2024-03-18T01:45:00Z,,MEMBER,,I was chatting with @phofl and he mentioned `pandas` 2.0 has a bunch of performance updates related to `copy_on_write`. This PR just turns `copy_on_write` on in our test suite to see if anything breaks ,,https://api.github.com/repos/dask/dask/issues/9942/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9942/reactions,0,0,0,0,0,0,0,0,0,jrbourbeau,11656932.0,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,False,https://api.github.com/repos/dask/dask/pulls/9942,https://github.com/dask/dask/pull/9942,https://github.com/dask/dask/pull/9942.diff,https://github.com/dask/dask/pull/9942.patch,,,,,,,,,,,,,,,,,,,
796,https://api.github.com/repos/dask/dask/issues/9946,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9946/labels{/name},https://api.github.com/repos/dask/dask/issues/9946/comments,https://api.github.com/repos/dask/dask/issues/9946/events,https://github.com/dask/dask/issues/9946,1582708081,I_kwDOAbcwm85eVjVx,9946,Make `pyarrow` strings easy to use,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,2,2023-02-13T16:50:44Z,2024-03-11T01:45:00Z,,MEMBER,,"This is similar to https://github.com/dask/dask/issues/9879, but smaller in scope.

## Motivation 

We've seen several cases where using `pyarrow` strings for text data have significant memory usage / computation performance improvements (xref https://github.com/dask/dask/issues/9631, https://github.com/dask/community/issues/301). We should make it easy for users to use utilize this performant data type. 

## Proposal

I'll propose we add a config option users can set to automatically convert `object` and `string[python]` data that's encountered to `string[pyarrow]`. We'll want this to work with all methods for creating dask `DataFrame`s. That is, things like the following

```python
import dask
import dask.dataframe as dd

# Tell dask to use `pyarrow`-strings for object dtypes
dask.config.set({""dataframe.object_as_pyarrow_string"": True})  # Suggestions for a better name are welcome! 

df = dd.read_parquet(...)
df = dd.read_csv(...)
df = dd.from_pandas(...)
df = dd.from_delayed(...)
...
```

should all return dask `DataFrame`s that use `string[pyarrow]` appropriately. 

For some methods, like `read_parquet`, we'll want to have a specialized implementation as they'll be able to efficiently read data directly into `string[pyarrow]`. However, in cases where a specialized method isn't implemented, we should still automatically cast the dask `DataFrame` to use `string[pyarrow]` when the config option is set. For example, through an `map_partitions` call after our existing `DataFrame` creation logic.

## Steps

Steps that I think make sense here are:

- [x] Add a config option that automatically converts to `string[pyarrow]` dtype where appropriate (see https://github.com/dask/dask/pull/9926) 
- [x] Add specialized implementation for `dd.read_parquet` (see https://github.com/dask/dask/pull/9979) 
- [x] Add a CI job with the new config option turned on (see https://github.com/dask/dask/pull/10017) 
- [ ] Fix all test failures in the new CI job
- [ ] Add documentation
- [ ] (Optional) Make it easy to always use performant `string[pyarrow]` (e.g. emit a performance warning when using text data without `string[pyarrow]`, turn the config option on by default, etc).

## Notes

See https://github.com/dask/dask/pull/9926 where I'm taking an initial pass at adding the config option. 

cc @rjzamora @quasiben @j-bennet @phofl for visibility ",,https://api.github.com/repos/dask/dask/issues/9946/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9946/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
797,https://api.github.com/repos/dask/dask/issues/9954,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9954/labels{/name},https://api.github.com/repos/dask/dask/issues/9954/comments,https://api.github.com/repos/dask/dask/issues/9954/events,https://github.com/dask/dask/issues/9954,1583355604,I_kwDOAbcwm85eYBbU,9954,Keep `freq` in `to_timestamp()` on small partitions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,0,2023-02-14T01:53:49Z,2024-03-11T01:44:59Z,,MEMBER,,"In https://github.com/dask/dask/pull/9932, @j-bennet found that we can loose `.freq` in `to_timestamp(...)` calls when a partitions are small. However, I suspect we may be able to extract `.freq` from the underlying `DataFrame._meta` and then frward it through the `to_timestamp()` calls https://github.com/dask/dask/pull/9932#pullrequestreview-1294393312. 
",,https://api.github.com/repos/dask/dask/issues/9954/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9954/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
798,https://api.github.com/repos/dask/dask/issues/9957,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9957/labels{/name},https://api.github.com/repos/dask/dask/issues/9957/comments,https://api.github.com/repos/dask/dask/issues/9957/events,https://github.com/dask/dask/issues/9957,1584747263,I_kwDOAbcwm85edVL_,9957,Properly fix index class and dtype mismatch in empty DataFrame or Series with pandas 2.0,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-02-14T20:01:06Z,2024-03-11T01:44:58Z,,MEMBER,,"In Pandas 2.0, whenever an empty DataFrame or Series is created, the empty index would be a `RangeIndex` with dtype `int64`. See https://pandas.pydata.org/docs/dev/whatsnew/v2.0.0.html#empty-dataframes-series-will-now-default-to-have-a-rangeindex.

Dask creates an `Index` instead, and in some cases, we also fail to enforce `dtype` to be `int64`. This PR:

* https://github.com/dask/dask/pull/9930

fixes the failing tests, but doesn't solve the problem.

We need to align the behavior between pandas and dask, whenever an empty `index` is created.

",,https://api.github.com/repos/dask/dask/issues/9957/timeline,,,j-bennet,637013,MDQ6VXNlcjYzNzAxMw==,https://avatars.githubusercontent.com/u/637013?v=4,,https://api.github.com/users/j-bennet,https://github.com/j-bennet,https://api.github.com/users/j-bennet/followers,https://api.github.com/users/j-bennet/following{/other_user},https://api.github.com/users/j-bennet/gists{/gist_id},https://api.github.com/users/j-bennet/starred{/owner}{/repo},https://api.github.com/users/j-bennet/subscriptions,https://api.github.com/users/j-bennet/orgs,https://api.github.com/users/j-bennet/repos,https://api.github.com/users/j-bennet/events{/privacy},https://api.github.com/users/j-bennet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9957/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
799,https://api.github.com/repos/dask/dask/issues/9958,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9958/labels{/name},https://api.github.com/repos/dask/dask/issues/9958/comments,https://api.github.com/repos/dask/dask/issues/9958/events,https://github.com/dask/dask/pull/9958,1584766987,PR_kwDOAbcwm85J-gkb,9958,POC - Add basic shim layer class for expressions,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-02-14T20:16:27Z,2024-03-11T01:44:57Z,,MEMBER,,"This is for demonstration purposes only.

This experiment introduces a non-functional expression layer in between the DataFrame/Series classes and meta/divisions/name/graph generation. This expression layer doesn't do anything, in only holds a single opaque type, but it demonstrates the ease/pain with which we could introduce a new abstraction and slowly phase out immediate metadata construction.

Most of the pain here was about being careful with attribute assignment / properties / getters and setters.  I didn't bother with all of this so about half of the test suite fails.  This is enough though, I think, to show a path.

This is part of an ongoing conversation with @jrbourbeau @fjetter @rjzamora ",,https://api.github.com/repos/dask/dask/issues/9958/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9958/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9958,https://github.com/dask/dask/pull/9958,https://github.com/dask/dask/pull/9958.diff,https://github.com/dask/dask/pull/9958.patch,,,,,,,,,,,,,,,,,,,
800,https://api.github.com/repos/dask/dask/issues/9964,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9964/labels{/name},https://api.github.com/repos/dask/dask/issues/9964/comments,https://api.github.com/repos/dask/dask/issues/9964/events,https://github.com/dask/dask/issues/9964,1585853083,I_kwDOAbcwm85ehjKb,9964,Key collision in dask graph,"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,3,2023-02-15T13:21:36Z,2024-03-11T01:44:56Z,,CONTRIBUTOR,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

When building many similar dask graphs that have the same structure, just different input data, it can happen that the default dask optimizations create keys for the dask graph dictionary that are the same for different input data. In essence, this is a hash collision, which (by default) has a relatively large probability.



```python
import dask.config
from dask import delayed
from dask.base import collections_to_dsk
from dask.bag import from_sequence


@delayed
def first_function_with_a_long_name_that_just_returns_its_argument(arg):
    return arg


@delayed
def second_function_with_a_long_name_that_just_returns_its_argument(arg):
    return arg


@delayed
def third_function_with_a_long_name_that_just_returns_its_argument(arg):
    return arg


# see comments below
# dask.config.set({""optimization.fuse.rename-keys"": False})

if __name__ == ""__main__"":

    all_dsk_keys = set()

    for i in range(1_000):
        print(i)
        d = (
            from_sequence([i])
            .map(third_function_with_a_long_name_that_just_returns_its_argument)
            .map(second_function_with_a_long_name_that_just_returns_its_argument)
            .map(first_function_with_a_long_name_that_just_returns_its_argument)
        )
        dsk = collections_to_dsk([d])
        dsk_keys = set(dsk)
        colliding_keys = all_dsk_keys & dsk_keys
        assert not colliding_keys, f""Key collision: {colliding_keys}""
        all_dsk_keys.update(dsk_keys)
```

this shows assertion errors like this:

```
...
155
156
Traceback (most recent call last):
  File ""dask-hash-collision.py"", line 42, in <module>
    assert not colliding_keys, f""Key collision: {colliding_keys}""
AssertionError: Key collision: {('second_function_with_a_long_name_that_just_returns-third_function_with_a_long_name_that_just_returns_-first_functio--208', 0)}
```

The source of the issue is the default for ""rename-keys"", which truncates the hash part to only 4 hex characters in case the fused key name becomes too long:
https://github.com/dask/dask/blob/0890b96be75e46ef2b88c11015761b9a6bd32480/dask/optimization.py#L416
Using only 4 hex characters of hash makes hash collisions pretty common; it is often enough to use a few dozen graphs.

Using the commented-out line `dask.config.set` above works around the issue. Still, I think the default behavior should be fixed, as it makes this issue too likely.

We do observe such key collisions in real-world scenarios in distributed, where we would get the wrong result on client side since the scheduler hands out old results of the key that the new computation collided with.

Side note: using `default_fused_linear_keys_renamer` as ""optimization.fuse.rename-keys"" creates other key collision issues. It seems the `default_fused_linear_keys_renamer` and the `default_fused_key_renamer` have incompatible assumptions about the order of keys in their `keys` argument.

**Environment**:

- Dask version: 2023.2.0
- Python version: 3.8
- Operating System: linux (debian)
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/9964/timeline,,,jochenott,13297654,MDQ6VXNlcjEzMjk3NjU0,https://avatars.githubusercontent.com/u/13297654?v=4,,https://api.github.com/users/jochenott,https://github.com/jochenott,https://api.github.com/users/jochenott/followers,https://api.github.com/users/jochenott/following{/other_user},https://api.github.com/users/jochenott/gists{/gist_id},https://api.github.com/users/jochenott/starred{/owner}{/repo},https://api.github.com/users/jochenott/subscriptions,https://api.github.com/users/jochenott/orgs,https://api.github.com/users/jochenott/repos,https://api.github.com/users/jochenott/events{/privacy},https://api.github.com/users/jochenott/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9964/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
801,https://api.github.com/repos/dask/dask/issues/9968,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9968/labels{/name},https://api.github.com/repos/dask/dask/issues/9968/comments,https://api.github.com/repos/dask/dask/issues/9968/events,https://github.com/dask/dask/issues/9968,1587087976,I_kwDOAbcwm85emQpo,9968,Re-integrate `pyarrow` `write_to_dataset` instead of `arrow._write_partitioned` in `dask`,"[{'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450421, 'node_id': 'LA_kwDOAbcwm87iZ8D1', 'url': 'https://api.github.com/repos/dask/dask/labels/hygiene', 'name': 'hygiene', 'color': 'b5ccfa', 'default': False, 'description': 'Improve code quality and reduce maintenance overhead'}]",open,False,,[],,3,2023-02-16T06:14:33Z,2024-03-11T01:44:55Z,,MEMBER,,"**Describe the issue**:

Because of https://github.com/apache/arrow/issues/24440 (https://issues.apache.org/jira/browse/ARROW-8244), dask is using its own code to write a table to a partitioned pyarrow dataset. The code lives here:

https://github.com/dask/dask/blob/3124376d68bd3a15d381ce803ca066c7eef4c24f/dask/dataframe/io/parquet/arrow.py#L89-L101

Since this code was [added in March 2020](https://github.com/dask/dask/pull/6023), `pyarrow` came a long way. The original issue was [fixed in pyarrow in April 2020](https://github.com/apache/arrow/commit/ac3bfe47821cb8368f657860f115e88077eaf64d). There's a TODO in Dask code to re-integrate back `write_to_dataset`, we still need to do it. The custom code already required multiple bugfixes, and we can't be sure that it's up to date with `pyarrow`.

- Dask version: 2023.2.0+11.g0890b96b

cc @rjzamora .",,https://api.github.com/repos/dask/dask/issues/9968/timeline,,,j-bennet,637013,MDQ6VXNlcjYzNzAxMw==,https://avatars.githubusercontent.com/u/637013?v=4,,https://api.github.com/users/j-bennet,https://github.com/j-bennet,https://api.github.com/users/j-bennet/followers,https://api.github.com/users/j-bennet/following{/other_user},https://api.github.com/users/j-bennet/gists{/gist_id},https://api.github.com/users/j-bennet/starred{/owner}{/repo},https://api.github.com/users/j-bennet/subscriptions,https://api.github.com/users/j-bennet/orgs,https://api.github.com/users/j-bennet/repos,https://api.github.com/users/j-bennet/events{/privacy},https://api.github.com/users/j-bennet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9968/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
802,https://api.github.com/repos/dask/dask/issues/9969,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9969/labels{/name},https://api.github.com/repos/dask/dask/issues/9969/comments,https://api.github.com/repos/dask/dask/issues/9969/events,https://github.com/dask/dask/issues/9969,1587620956,I_kwDOAbcwm85eoSxc,9969,Abandon encoded tuples as task definition in dsk graphs,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,6,2023-02-16T12:49:44Z,2024-03-11T01:44:55Z,,MEMBER,,"# TLDR

I would like to introduce a `Task` class (name TBD) instead of using tuples to define our graphs. I believe this can help us with many problem spaces like serialization, stringification, graph composition and analysis, etc.

# Motivation

Currently, all task graphs are defined as dictionaries that are mapping a hashable to a tuple of _things_

Example

```python
dsk = {
    ""key-1"": (func, ""a"", ""b""),
    ""key-2"": (func, ""key-1"", ""b""),
    ""key-3"": (func, (func2, ""c"", ""key-1""), ""key-2"")
}
```

This examples showcases three different possibilities of defining tasks

- `key-1`: is the simplest example. This is a function that is supposed to be called with a couple of arguments. This will translate to an expression like `key_1 = func(""a"", ""b"")`
- `key-2`: This is a task that defines a dependency to `key-1` by defining the literal key value as an argument. [1, 2] It will evaluate to `key_2 = func(key_1, ""b"")`.
- `key-3`: It is even possible to define tasks recursively with arbitrary nesting levels. It will evaluate to `key_3 = func(func2(""c"", key_1), key_2)`.

To handle this structure, several utility functions are typically used through the code base to convert strings, generate tokens or walk the graph recursively. Below a couple of important methods

- [`istask`](https://github.com/dask/dask/blob/3124376d68bd3a15d381ce803ca066c7eef4c24f/dask/core.py#L24-L38) inspects and object and guesses that if the structure is approximately as described above, the object is a task spec
- [`get_deps`](https://github.com/dask/dask/blob/3124376d68bd3a15d381ce803ca066c7eef4c24f/dask/core.py#L263-L276), [`get_dependencies`](https://github.com/dask/dask/blob/3124376d68bd3a15d381ce803ca066c7eef4c24f/dask/core.py#L222-L260) and [`keys_in_tasks`](https://github.com/dask/dask/blob/3124376d68bd3a15d381ce803ca066c7eef4c24f/dask/core.py#L157-L191) which is used to walk the dask graph
- [`_execute_task`](https://github.com/dask/dask/blob/3124376d68bd3a15d381ce803ca066c7eef4c24f/dask/core.py#L82-L125) which is used to execute a task and walk a recursive function like `key-3`. Note that a very similar functionality is provided by [`SubgraphCallable`](https://github.com/dask/dask/blob/3124376d68bd3a15d381ce803ca066c7eef4c24f/dask/optimization.py#L948-L996).
- [`dumps_task`](https://github.com/dask/distributed/blob/405c0e62d008e40aa873611ec932f2e81f2731dd/distributed/worker.py#L2947-L2975) to serialize such a tuple and again recursing through it. The developer has to ensure that this only happens after [``](https://github.com/dask/distributed/blob/405c0e62d008e40aa873611ec932f2e81f2731dd/distributed/utils_comm.py#L248-L276)

The important piece to take away is that we are iterating and recursing over almost every iterable we can find in the graph and replace matching keys automatically. Multiple times. This is very error prone and not particularly performance sensitive [3].

Apart from unnecessarily walking the graph, a lot of the `HighLevelGraph` and `distributed.protocol` complexity stems from the attempt to not deserialize payload data or user functions on the scheduler. The reasons for this are plentiful but also being debated recently (e.g. scheduler environments differ from clients, performance by not serializing data unnecessarily). I consider this only a minor motivator for this change but I think it's a nice to have and comes for free.

# Proposal

Most, if not all, of the above described complexity could be avoided if we chose to go for a very explicit task representation that is not based on an encoded tuple which would avoid any semantic confusion and would reduce our need to walk and recurse significantly.

```python
from distributed.utils_comm import WrappedKey
from typing import Callable, Any, NewType

Key = NewType(""Key"", str)

_RemotePlaceholder = object()


class Task:
    func: Callable
    key: Key
    dependencies: dict[int, Key | WrappedKey]
    argspec: list[Any]

    __slots__ = tuple(__annotations__)

    def __init__(self, key: Key, func, args):
        self.key = key
        self.func = func
        self.dependencies = {}
        parsed_args: list[Any] = [None] * len(args)
        for ix, arg in enumerate(args):
            if isinstance(arg, (Key, WrappedKey)):
                self.dependencies[ix] = arg
                parsed_args[ix] = _RemotePlaceholder
            else:
                parsed_args[ix] = arg
        self.argspec = parsed_args

    def pack(self):
        # Serialization could be expresse by just convering between two objects
        # ... or this logic would just be implemented in __reduce__
        return PackedTask(
            key=self.key,
            dependencies=self.dependencies,
            # This could be just a pickle.dumps
            runspec=dumps({""func"": self.func, ""argspec"": self.argspec}),
        )

    def __call__(self, *args, **kwargs):
        # resolve the input and match it to the dependencies
        argspec = self.match_args_with_dependencies(*args, **kwargs)
        return self.func(*argspec)

# Note how graph related metadata stays untouched between packing/unpacking. In
# the end, the dask scheduler only cares about the graph metadata and everything
# else is a pass through.
# More complicated versions of this could also curry arguments, e.g. user
# functions or payload data, while keeping others still free for later
# optimizations

class PackedTask:
    key: Key
    runspec: bytes
    dependencies: dict[int, Key]
    __slots__ = tuple(__annotations__)

    def __init__(self, key: Key, runspec: bytes, dependencies: dict[int, Key]):
        self.key = key
        self.runspec = runspec
        self.dependencies = dependencies

    def unpack(self):
        spec = loads(self.runspec)
        return Task(
            key=self.key,
            # We could implement a fast path that
            # is not computing dependencies again
            #
            # dependencies=self.dependencies,
            func=spec[""func""],
            args=spec[""argspec""],
        )

    @property
    def nbytes(self) -> int:
        # Some utility things could become object properties
        ...
```

I ran a couple of micro benchmarks to estimate the performance impact of using a slotted class instead of tuples and could indeed see a slowdown during graph generation (maybe a factor of 2) but this appears to be easily amortized by just not walking the graph so often and not recursing into everything and matching strings, etc. since this class exposes everything we'd be interested to know.

Cherry on top, this would allow us to have an identical definition of a tasks runspec in vanilla dask, on the client, scheduler and worker. Specifically, we could get rid of all the `dumps_function`, `loads_function`, `dumps_task`, `execute_task`, etc. in `distributed/worker.py`.

A migration path would be straight forward since we would convert at the outmost layer a legacy task graph to a new task graph such that all internal systems can use this representation instead. Nested tuples would be converted to `SubgraphCallable` (in fact, I believe in this world we should make `SubgraphCallable` a `Task` but that's a detail)

I can genuinely only see benefits. This will be a bit of tedious work but I believe it would make working on internals so much easier, particularly around serialization topics.

Thoughts? Am I missing something?


[1] The fact that we're using simple literals to identify dependencies can cause problems for developers if ""stringification"" is not properly applied since keys are not necessarily required to be strings until they reach the scheduler. However, if graph construction was not done properly, this can cause spurious errors, e.g. because the user function receives the non-stringified literal instead of the actual data.
[2] Whenever users are providing a `key` themselves, e.g. in [scatter](https://github.com/dask/distributed/issues/3965) or [compute](https://github.com/dask/distributed/issues/7551) this can cause dask to resolve dependency structures falsely and confuses literal user argumnets with keys.
[3] All of these functions are written efficiently and are operating on builtins so the performance overhead is OK but still unnecessary.


cc @rjzamora, @madsbk, @jrbourbeau, @mrocklin, @crusaderky
",,https://api.github.com/repos/dask/dask/issues/9969/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9969/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
803,https://api.github.com/repos/dask/dask/issues/9970,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9970/labels{/name},https://api.github.com/repos/dask/dask/issues/9970/comments,https://api.github.com/repos/dask/dask/issues/9970/events,https://github.com/dask/dask/issues/9970,1587830440,I_kwDOAbcwm85epF6o,9970,Expressions and Query Optimization (again),"[{'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,0,2023-02-16T14:56:50Z,2023-03-20T01:59:09Z,,MEMBER,,"We've spoken about this topic in the past.  There have been various aborted attempts.  I thought I'd give this another go.  I have some thoughts and early-stage poc work here:

-  [Design document](https://docs.google.com/document/d/1EpalwAyKa_EudEB8NuJb3XWEa1Cqc4WPDmN8kZWEfkI/edit?usp=sharing)
- [Standalone expression poc with matchpy](https://github.com/mrocklin/dask-match)
- https://github.com/dask/dask/pull/9958

I encoruage comments either here or in the google doc (google doc preferred). I've been iterating on this with @fjetter @jrbourbeau and @rjzamora so far, but figured that it'd be good to be fully transparent.",,https://api.github.com/repos/dask/dask/issues/9970/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9970/reactions,3,0,0,0,0,0,3,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
804,https://api.github.com/repos/dask/dask/issues/9974,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9974/labels{/name},https://api.github.com/repos/dask/dask/issues/9974/comments,https://api.github.com/repos/dask/dask/issues/9974/events,https://github.com/dask/dask/pull/9974,1588957477,PR_kwDOAbcwm85KMn0z,9974,Fix default fused key renamer,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-02-17T08:43:49Z,2024-03-11T01:44:53Z,,CONTRIBUTOR,,"To avoid hash collisions, keep the full 'first_key' is possible. If even 'first_key' is too long, keep a full hash of that key.

For keys shorter than `max_fused_key_length`, the renamed key does not change.

- [x] Closes #9964
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`


Update: Note that this PR assumes that the current key name choice of `fuse` with `rename_keys=False` is valid. If this is a problem it needs to be addressed separately from this PR.",,https://api.github.com/repos/dask/dask/issues/9974/timeline,,,jochenott,13297654,MDQ6VXNlcjEzMjk3NjU0,https://avatars.githubusercontent.com/u/13297654?v=4,,https://api.github.com/users/jochenott,https://github.com/jochenott,https://api.github.com/users/jochenott/followers,https://api.github.com/users/jochenott/following{/other_user},https://api.github.com/users/jochenott/gists{/gist_id},https://api.github.com/users/jochenott/starred{/owner}{/repo},https://api.github.com/users/jochenott/subscriptions,https://api.github.com/users/jochenott/orgs,https://api.github.com/users/jochenott/repos,https://api.github.com/users/jochenott/events{/privacy},https://api.github.com/users/jochenott/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9974/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9974,https://github.com/dask/dask/pull/9974,https://github.com/dask/dask/pull/9974.diff,https://github.com/dask/dask/pull/9974.patch,,,,,,,,,,,,,,,,,,,
805,https://api.github.com/repos/dask/dask/issues/9992,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9992/labels{/name},https://api.github.com/repos/dask/dask/issues/9992/comments,https://api.github.com/repos/dask/dask/issues/9992/events,https://github.com/dask/dask/issues/9992,1595340059,I_kwDOAbcwm85fFvUb,9992,ENH: Allow `__array_ufunc__` to dispatch on `where=` in NumPy?,"[{'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2023-02-22T15:43:50Z,2023-05-24T19:06:16Z,,NONE,,"NumPy may allow `where=array_like` to also dispatch when given to a NumPy ufunc.  This would mean that if `where=array_like` implements `__array_ufunc__`, NumPy would try dispatching to it in the future.  (Currently only input and output array-likes dispatch).

If you have any concerns, please just let us know.  The use-case is relatively specific:  An uncertainty array-like.  It makes sense to have `where=boolean_uncertainty` promote the result to also be an uncertainty.

The PR in NumPy is https://github.com/numpy/numpy/pull/23240

The probability of anything breaking seems very low.  You need to pass a non-compatible object into `where=` to trigger even potential issues.

In the long term, the only change would be that dask would add a check for `kwargs[""where""]` being supported.

CC @mmccarty",,https://api.github.com/repos/dask/dask/issues/9992/timeline,,,seberg,61977,MDQ6VXNlcjYxOTc3,https://avatars.githubusercontent.com/u/61977?v=4,,https://api.github.com/users/seberg,https://github.com/seberg,https://api.github.com/users/seberg/followers,https://api.github.com/users/seberg/following{/other_user},https://api.github.com/users/seberg/gists{/gist_id},https://api.github.com/users/seberg/starred{/owner}{/repo},https://api.github.com/users/seberg/subscriptions,https://api.github.com/users/seberg/orgs,https://api.github.com/users/seberg/repos,https://api.github.com/users/seberg/events{/privacy},https://api.github.com/users/seberg/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9992/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
806,https://api.github.com/repos/dask/dask/issues/9996,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9996/labels{/name},https://api.github.com/repos/dask/dask/issues/9996/comments,https://api.github.com/repos/dask/dask/issues/9996/events,https://github.com/dask/dask/issues/9996,1598210496,I_kwDOAbcwm85fQsHA,9996,P2P shuffling without a distributed scheduler?,"[{'id': 386719400, 'node_id': 'MDU6TGFiZWwzODY3MTk0MDA=', 'url': 'https://api.github.com/repos/dask/dask/labels/scheduler', 'name': 'scheduler', 'color': 'D10945', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-02-24T08:59:53Z,2023-03-27T01:53:28Z,,MEMBER,,"The current architecture of P2P shuffling would allow for it being used even outside of the distributed scheduler. To make this smooth, it would require a bit of cleaning up but the fundamental core should be working just fine.

Specifically, the class [`ShuffleRun`](https://github.com/dask/distributed/blob/8d239e91f6b61bd2b0048d373b20879ac88d2584/distributed/shuffle/_worker_extension.py#L49-L321) implements most of the logic. Typically this class is instantiated once on every worker but this is not strictly necessary. A single instance can perform the entire shuffle in theory.
There exist already tests that show how such a shuffle would look like using just this object, see https://github.com/dask/distributed/blob/8d239e91f6b61bd2b0048d373b20879ac88d2584/distributed/shuffle/tests/test_shuffle.py#L1153-L1231

Embedding this into dask/dask would likely even be even more trivial since I would expect there to only exit one instance and all threads would write to the same instance (the object is thread safe, of course).

This would effectively act as a replacement for partd.

The reason why this might be interesting is because we have some indication that this implementation is not working optimally either, see
- https://github.com/dask/distributed/issues/5554
- https://github.com/dask/distributed/issues/5502

At this stage I would not expect us to pull the trigger on this but I'd be more interested in running a couple of experiments and see if there are any performance gains to be had. _Eventually_ I would expect P2P to be sufficiently optimized to beat partd and `tasks` even in a memory-only, threaded environment. I doubt we're there yet but I don't know.",,https://api.github.com/repos/dask/dask/issues/9996/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9996/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
807,https://api.github.com/repos/dask/dask/issues/9998,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/9998/labels{/name},https://api.github.com/repos/dask/dask/issues/9998/comments,https://api.github.com/repos/dask/dask/issues/9998/events,https://github.com/dask/dask/pull/9998,1599228902,PR_kwDOAbcwm85Ku3FX,9998,Fix DataFrame rollling var/std to use provided ddof,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2023-02-24T20:17:21Z,2024-03-04T01:48:02Z,,FIRST_TIME_CONTRIBUTOR,,"Very small bug fix for `dataframe.rolling` methods for `var` and `std` to correctly pass the user-provided `ddof` parameter into `_call_method`. Currently, rolling `var` and `std` are computed using `ddof=1` regardless of what the user specifies. E.g, if the user wants to set `ddof=2`, these rolling methods will ignore this and incorrectly compute with `ddof=1`.

- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/9998/timeline,,,grusky,8650575,MDQ6VXNlcjg2NTA1NzU=,https://avatars.githubusercontent.com/u/8650575?v=4,,https://api.github.com/users/grusky,https://github.com/grusky,https://api.github.com/users/grusky/followers,https://api.github.com/users/grusky/following{/other_user},https://api.github.com/users/grusky/gists{/gist_id},https://api.github.com/users/grusky/starred{/owner}{/repo},https://api.github.com/users/grusky/subscriptions,https://api.github.com/users/grusky/orgs,https://api.github.com/users/grusky/repos,https://api.github.com/users/grusky/events{/privacy},https://api.github.com/users/grusky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/9998/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/9998,https://github.com/dask/dask/pull/9998,https://github.com/dask/dask/pull/9998.diff,https://github.com/dask/dask/pull/9998.patch,,,,,,,,,,,,,,,,,,,
808,https://api.github.com/repos/dask/dask/issues/10006,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10006/labels{/name},https://api.github.com/repos/dask/dask/issues/10006/comments,https://api.github.com/repos/dask/dask/issues/10006/events,https://github.com/dask/dask/pull/10006,1603279918,PR_kwDOAbcwm85K8S_s,10006,Warn user about eager compute when they do ``len(ddf)``,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2023-02-28T15:22:47Z,2023-04-03T01:50:49Z,,MEMBER,,"- [x] Closes #9857
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

Note this PR warns every time `len(ddf)` is called. It also warns when `list(ddf)`. I don't quite know why that is but I assume `list` calls `len` internally.

```python
In [1]: from dask.dataframe.io.demo import make_timeseries
   ...: 
   ...: ddf = make_timeseries()
   ...: len(ddf)
/home/jsignell/dask/dask/dataframe/core.py:846: EagerWarning: Calling ``len()`` on a dask.dataframe object triggers ``compute()``. It is better practice to use ``.shape[0]`` so that compute can be scheduled and intermediary results can be reused
  warnings.warn(
Out[1]: 2894400
In [2]: list(ddf)
/home/jsignell/dask/dask/dataframe/core.py:846: EagerWarning: Calling ``len()`` on a dask.dataframe object triggers ``compute()``. It is better practice to use ``.shape[0]`` so that compute can be scheduled and intermediary results can be reused
  warnings.warn(
Out[2]: ['name', 'id', 'x', 'y']
```",,https://api.github.com/repos/dask/dask/issues/10006/timeline,,,jsignell,4806877,MDQ6VXNlcjQ4MDY4Nzc=,https://avatars.githubusercontent.com/u/4806877?v=4,,https://api.github.com/users/jsignell,https://github.com/jsignell,https://api.github.com/users/jsignell/followers,https://api.github.com/users/jsignell/following{/other_user},https://api.github.com/users/jsignell/gists{/gist_id},https://api.github.com/users/jsignell/starred{/owner}{/repo},https://api.github.com/users/jsignell/subscriptions,https://api.github.com/users/jsignell/orgs,https://api.github.com/users/jsignell/repos,https://api.github.com/users/jsignell/events{/privacy},https://api.github.com/users/jsignell/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10006/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10006,https://github.com/dask/dask/pull/10006,https://github.com/dask/dask/pull/10006.diff,https://github.com/dask/dask/pull/10006.patch,,,,,,,,,,,,,,,,,,,
809,https://api.github.com/repos/dask/dask/issues/10010,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10010/labels{/name},https://api.github.com/repos/dask/dask/issues/10010/comments,https://api.github.com/repos/dask/dask/issues/10010/events,https://github.com/dask/dask/issues/10010,1605515342,I_kwDOAbcwm85fsjhO,10010,Make `DataFrame.head()` and `DataFrame.tail()` lazy,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450419, 'node_id': 'LA_kwDOAbcwm87iZ8Dz', 'url': 'https://api.github.com/repos/dask/dask/labels/deprecation', 'name': 'deprecation', 'color': 'f4e49a', 'default': False, 'description': 'Something is being removed'}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,2,2023-03-01T19:08:07Z,2023-04-03T01:50:46Z,,MEMBER,,"Currently `head()` and `tail()` trigger an implicit, immediate computation. This can be surprising to users since almost all Dask methods are lazily evaluated. Instead I think `head()` and `tail()` should return a Dask DataFrame that users can then call `compute()` on like most other methods. 

Since both these methods already have a `compute=` keyword that is `True` by default, I'll suggest we:

1. Deprecate the current `compute=True` default value and inform users that in the future `compute=` will default to `False`
2. After a while, change the default to `compute=False`  ",,https://api.github.com/repos/dask/dask/issues/10010/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10010/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
810,https://api.github.com/repos/dask/dask/issues/10014,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10014/labels{/name},https://api.github.com/repos/dask/dask/issues/10014/comments,https://api.github.com/repos/dask/dask/issues/10014/events,https://github.com/dask/dask/issues/10014,1607527567,I_kwDOAbcwm85f0OyP,10014,P2P shuffle fails on frames containing mixed dtype columns,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2023-03-02T21:27:05Z,2023-04-03T01:50:45Z,,MEMBER,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
The `p2p` shuffle algorithm fails when working with frames that contain columns of mixed numeric/string dtypes; this error occurs during computation when Arrow attempts to cast the entire column to a numeric dtype:

```
2023-03-02 13:12:52,204 - distributed.shuffle - ERROR - shuffle_transfer failed during shuffle 4b4e0d18244b9cc2b7aadf328a683932
Traceback (most recent call last):
  File ""/raid/charlesb/mambaforge/envs/bug-ci-failures-p2p/lib/python3.9/site-packages/distributed/shuffle/_shuffle.py"", line 58, in shuffle_transfer
    return _get_worker_extension().add_partition(
  File ""/raid/charlesb/mambaforge/envs/bug-ci-failures-p2p/lib/python3.9/site-packages/distributed/shuffle/_worker_extension.py"", line 628, in add_partition
    shuffle = self.get_or_create_shuffle(shuffle_id, type=type, **kwargs)
  File ""/raid/charlesb/mambaforge/envs/bug-ci-failures-p2p/lib/python3.9/site-packages/distributed/shuffle/_worker_extension.py"", line 879, in get_or_create_shuffle
    return sync(
  File ""/raid/charlesb/mambaforge/envs/bug-ci-failures-p2p/lib/python3.9/site-packages/distributed/utils.py"", line 405, in sync
    raise exc.with_traceback(tb)
  File ""/raid/charlesb/mambaforge/envs/bug-ci-failures-p2p/lib/python3.9/site-packages/distributed/utils.py"", line 378, in f
    result = yield future
  File ""/raid/charlesb/mambaforge/envs/bug-ci-failures-p2p/lib/python3.9/site-packages/tornado/gen.py"", line 769, in run
    value = future.result()
  File ""/raid/charlesb/mambaforge/envs/bug-ci-failures-p2p/lib/python3.9/site-packages/distributed/shuffle/_worker_extension.py"", line 709, in _get_or_create_shuffle
    shuffle = await self._refresh_shuffle(
  File ""/raid/charlesb/mambaforge/envs/bug-ci-failures-p2p/lib/python3.9/site-packages/distributed/shuffle/_worker_extension.py"", line 758, in _refresh_shuffle
    ""schema"": pa.Schema.from_pandas(kwargs[""empty""])
  File ""pyarrow/types.pxi"", line 1739, in pyarrow.lib.Schema.from_pandas
  File ""/raid/charlesb/mambaforge/envs/bug-ci-failures-p2p/lib/python3.9/site-packages/pyarrow/pandas_compat.py"", line 551, in dataframe_to_types
    type_ = pa.array(c, from_pandas=True).type
  File ""pyarrow/array.pxi"", line 316, in pyarrow.lib.array
  File ""pyarrow/array.pxi"", line 83, in pyarrow.lib._ndarray_to_array
  File ""pyarrow/error.pxi"", line 100, in pyarrow.lib.check_status
pyarrow.lib.ArrowInvalid: Could not convert 'a' with type str: tried to convert to double
2023-03-02 13:12:52,278 - distributed.worker - WARNING - Compute Failed
Key:       ('shuffle-transfer-4b4e0d18244b9cc2b7aadf328a683932', 0)
Function:  shuffle_transfer
args:      (     c  _partitions
0  0.1            0
1    a            0
2    b            0
3    c            0, '4b4e0d18244b9cc2b7aadf328a683932', 0, 1, '_partitions')
kwargs:    {}
Exception: ""RuntimeError('shuffle_transfer failed during shuffle 4b4e0d18244b9cc2b7aadf328a683932')""
```

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.dataframe as dd
from distributed import Client

client = Client()

ddf = dd.from_dict({
    ""c"": [0.1, ""a"", ""b"", ""c""]
}, npartitions=1)

with dask.config.set({""dataframe.shuffle.algorithm"" : ""p2p""}):
    res = ddf.groupby(""c"").apply(lambda x: x).compute()
```

**Anything else we need to know?**:
This failure can be avoided by manually setting `dataframe.shuffle.algorithm` to disk or tasks, not sure if this could be handled more gracefully with either a warning or implicit fallback behavior; opening because this change in behavior caused some failures downstream in dask-sql (xref https://github.com/dask-contrib/dask-sql/pull/1067).

**Environment**:

- Dask version: `main`
- Python version: 3.10
- Operating System: ubuntu-20.04
- Install method (conda, pip, source): source
",,https://api.github.com/repos/dask/dask/issues/10014/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10014/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
811,https://api.github.com/repos/dask/dask/issues/10016,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10016/labels{/name},https://api.github.com/repos/dask/dask/issues/10016/comments,https://api.github.com/repos/dask/dask/issues/10016/events,https://github.com/dask/dask/pull/10016,1607732067,PR_kwDOAbcwm85LLa8l,10016,"Add a new function `ravel_chunks`, to ravel arrays chunk by chunk","[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450414, 'node_id': 'LA_kwDOAbcwm87iZ8Du', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20review', 'name': 'needs review', 'color': '8c918c', 'default': False, 'description': 'Needs review from a contributor.'}]",open,False,,[],,7,2023-03-03T00:09:30Z,2024-03-04T01:47:59Z,,CONTRIBUTOR,,"Dear maintainers,
this pull request adds a new function to flatten arrays chunk by chunk as described in #4855.

- [x] Closes #4855
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

<details><summary>I have used this script to perform a basic benchmarking</summary>

```py
import dask
import numpy as np
import dask.array as da
import time
from dask.distributed import Client, progress
import matplotlib.pyplot as plt


client = Client(processes=False, threads_per_worker=4,
                n_workers=1, memory_limit='4GB')
exponent = np.arange(4,9)
n_elem = np.power(10, exponent)
dimx = 100
t_np = np.zeros(len(n_elem))
t_da = np.zeros(len(n_elem))
t_da_chunks = np.zeros(len(n_elem))
niter = 10
i = 0
for n in n_elem:
    dimy = int(n / dimx)
    x = np.random.randint(n, size=(dimx, dimy))
    a = da.from_array(x, chunks=(100,100))
    for ni in np.arange(niter):
        tic = time.perf_counter_ns()
        x.ravel()
        toc = time.perf_counter_ns()
        if ni:
            t_np[i] += (toc - tic)
    for ni in np.arange(niter):
        tic = time.perf_counter_ns()
        a.ravel().compute()
        toc = time.perf_counter_ns()
        if ni:
            t_da[i] += (toc - tic)
    for ni in np.arange(niter):
        tic = time.perf_counter_ns()
        a.ravel_chunks().compute()
        toc = time.perf_counter_ns()
        if ni:
            t_da_chunks[i] += (toc - tic)
    i += 1


client.close()

t_np /= niter - 1
t_da /= niter - 1
t_da_chunks /= niter - 1
print(f""Numpy ravel: {t_np}"")
print(f""Dask ravel: {t_da}"")
print(f""Dask ravel by chunk: {t_da_chunks}"")

# plot
fig, ax = plt.subplots()

plt.xscale('log')
plt.yscale('log')
plt.xlabel('number of elements')
plt.ylabel('time in nsec')

ax.plot(n_elem, t_da, linestyle='-', marker='o', label='ravel')
ax.plot(n_elem, t_da_chunks, linestyle='-', marker='o', label='ravel_chunks')
ax.legend()

plt.show()
```

</details>

The results are depending on the performances of the machine I used: they are plateauing at arrays with 10^8 elements.
![dask_ravel_chunks](https://user-images.githubusercontent.com/1662261/222594991-9b5cac49-04d5-4d0e-a1e4-41e66a7138af.png)

Thanks for considering this pull request!",,https://api.github.com/repos/dask/dask/issues/10016/timeline,,,cmarmo,1662261,MDQ6VXNlcjE2NjIyNjE=,https://avatars.githubusercontent.com/u/1662261?v=4,,https://api.github.com/users/cmarmo,https://github.com/cmarmo,https://api.github.com/users/cmarmo/followers,https://api.github.com/users/cmarmo/following{/other_user},https://api.github.com/users/cmarmo/gists{/gist_id},https://api.github.com/users/cmarmo/starred{/owner}{/repo},https://api.github.com/users/cmarmo/subscriptions,https://api.github.com/users/cmarmo/orgs,https://api.github.com/users/cmarmo/repos,https://api.github.com/users/cmarmo/events{/privacy},https://api.github.com/users/cmarmo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10016/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10016,https://github.com/dask/dask/pull/10016,https://github.com/dask/dask/pull/10016.diff,https://github.com/dask/dask/pull/10016.patch,,,,,,,,,,,,,,,,,,,
812,https://api.github.com/repos/dask/dask/issues/10019,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10019/labels{/name},https://api.github.com/repos/dask/dask/issues/10019/comments,https://api.github.com/repos/dask/dask/issues/10019/events,https://github.com/dask/dask/issues/10019,1609118512,I_kwDOAbcwm85f6TMw,10019,Annotate HLG with line of user code that created each layer,"[{'id': 2156573524, 'node_id': 'MDU6TGFiZWwyMTU2NTczNTI0', 'url': 'https://api.github.com/repos/dask/dask/labels/highlevelgraph', 'name': 'highlevelgraph', 'color': '8c24d6', 'default': False, 'description': 'Issues relating to HighLevelGraphs.'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,1,2023-03-03T19:04:20Z,2024-03-04T01:47:58Z,,MEMBER,,"`Computation`s on the scheduler currently capture the user code that called `compute`, for diagnostic purposes. This often misses the important part though, if the code that called `compute` and the code that actually generated the graph are in different places/functions/Jupyter notebook cells.

What might be more useful would be to track which line of user code created each layer in the HLG. This could be used for all sorts of purposes to help users better understand what's going on:
* Showing a ""line-profiler-style"" flamegraph about what lines of _user code_ are contributing the most to runtime or memory use; see https://github.com/dask/community/issues/301#issuecomment-1398668675.
* Mapping errors in tasks back to the line of user code that created the task
* ""Query-plan-style"" visualization of the HLG, showing progress, parallelism, and (a snippet of) the line of user code running?

Open question whether we'd want to capture:
* just the line number and file
* partial stack trace (line number and file of prev N frames)
* full stack trace
* any of the above, but also with the actual text of the code

xref https://github.com/dask/dask/issues/7933",,https://api.github.com/repos/dask/dask/issues/10019/timeline,,,gjoseph92,3309802,MDQ6VXNlcjMzMDk4MDI=,https://avatars.githubusercontent.com/u/3309802?v=4,,https://api.github.com/users/gjoseph92,https://github.com/gjoseph92,https://api.github.com/users/gjoseph92/followers,https://api.github.com/users/gjoseph92/following{/other_user},https://api.github.com/users/gjoseph92/gists{/gist_id},https://api.github.com/users/gjoseph92/starred{/owner}{/repo},https://api.github.com/users/gjoseph92/subscriptions,https://api.github.com/users/gjoseph92/orgs,https://api.github.com/users/gjoseph92/repos,https://api.github.com/users/gjoseph92/events{/privacy},https://api.github.com/users/gjoseph92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10019/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
813,https://api.github.com/repos/dask/dask/issues/10020,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10020/labels{/name},https://api.github.com/repos/dask/dask/issues/10020/comments,https://api.github.com/repos/dask/dask/issues/10020/events,https://github.com/dask/dask/issues/10020,1609128081,I_kwDOAbcwm85f6ViR,10020,Caching conda environment in CI,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450421, 'node_id': 'LA_kwDOAbcwm87iZ8D1', 'url': 'https://api.github.com/repos/dask/dask/labels/hygiene', 'name': 'hygiene', 'color': 'b5ccfa', 'default': False, 'description': 'Improve code quality and reduce maintenance overhead'}]",open,False,,[],,4,2023-03-03T19:12:21Z,2023-04-10T01:50:09Z,,CONTRIBUTOR,,"Hello

After submitting my PR recently, I've noticed that each test job took about 6 minutes to set up the conda environment. I've noticed that the workflow has no caching mechanism, even though a simple example solution can be found in the official [docs](https://github.com/conda-incubator/setup-miniconda#caching-environments) of the `conda-incubator/setup-miniconda` action.

What is more, a similar issue has been raised in the [dask distributed](https://github.com/dask/distributed/issues/6853) repo. I have some experience with GitHub Actions and would be happy to submit a similar PR.",,https://api.github.com/repos/dask/dask/issues/10020/timeline,,,krokosik,38408316,MDQ6VXNlcjM4NDA4MzE2,https://avatars.githubusercontent.com/u/38408316?v=4,,https://api.github.com/users/krokosik,https://github.com/krokosik,https://api.github.com/users/krokosik/followers,https://api.github.com/users/krokosik/following{/other_user},https://api.github.com/users/krokosik/gists{/gist_id},https://api.github.com/users/krokosik/starred{/owner}{/repo},https://api.github.com/users/krokosik/subscriptions,https://api.github.com/users/krokosik/orgs,https://api.github.com/users/krokosik/repos,https://api.github.com/users/krokosik/events{/privacy},https://api.github.com/users/krokosik/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10020/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
814,https://api.github.com/repos/dask/dask/issues/10029,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10029/labels{/name},https://api.github.com/repos/dask/dask/issues/10029/comments,https://api.github.com/repos/dask/dask/issues/10029/events,https://github.com/dask/dask/issues/10029,1613882671,I_kwDOAbcwm85gMeUv,10029,[pyarrow strings] Follow-up on test failures,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}, {'id': 3798450421, 'node_id': 'LA_kwDOAbcwm87iZ8D1', 'url': 'https://api.github.com/repos/dask/dask/labels/hygiene', 'name': 'hygiene', 'color': 'b5ccfa', 'default': False, 'description': 'Improve code quality and reduce maintenance overhead'}]",open,False,,[],,3,2023-03-07T17:18:10Z,2024-03-04T01:47:56Z,,MEMBER,,"**Describe the issue**:

Follow-up for https://github.com/dask/dask/pull/10000

The following tests were xfailed with pyarrow strings, for the time being. They need to be investigated, and might need a fix in `dask` and/or upstream:

 - [x] `dask/dataframe/io/tests/test_csv.py::test_different_columns_are_allowed` https://github.com/dask/dask/pull/10109
 - [ ] `dask/dataframe/io/tests/test_parquet.py::test_roundtrip_decimal_dtype` https://github.com/dask/dask/pull/10044
 - [x] `dask/dataframe/tests/test_indexing.py::test_loc_with_non_boolean_series` https://github.com/dask/dask/pull/10046
 - [x] `dask/dataframe/tests/test_shuffle.py::test_set_index_on_empty` https://github.com/dask/dask/pull/10054
 - [x] `dask/dataframe/tests/test_multi.py::test_melt` https://github.com/dask/dask/pull/10052
 
**Also see [this comment](https://github.com/dask/dask/issues/10029#issuecomment-1467135726) for an additional list of tests**.

**Environment**:

- Dask version:
- Python version:
- Operating System:
- Install method (conda, pip, source):
",,https://api.github.com/repos/dask/dask/issues/10029/timeline,,,j-bennet,637013,MDQ6VXNlcjYzNzAxMw==,https://avatars.githubusercontent.com/u/637013?v=4,,https://api.github.com/users/j-bennet,https://github.com/j-bennet,https://api.github.com/users/j-bennet/followers,https://api.github.com/users/j-bennet/following{/other_user},https://api.github.com/users/j-bennet/gists{/gist_id},https://api.github.com/users/j-bennet/starred{/owner}{/repo},https://api.github.com/users/j-bennet/subscriptions,https://api.github.com/users/j-bennet/orgs,https://api.github.com/users/j-bennet/repos,https://api.github.com/users/j-bennet/events{/privacy},https://api.github.com/users/j-bennet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10029/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
815,https://api.github.com/repos/dask/dask/issues/10034,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10034/labels{/name},https://api.github.com/repos/dask/dask/issues/10034/comments,https://api.github.com/repos/dask/dask/issues/10034/events,https://github.com/dask/dask/issues/10034,1614833261,I_kwDOAbcwm85gQGZt,10034,Non deterministic groupby result when using disk / partd shuffle method ,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1342304743, 'node_id': 'MDU6TGFiZWwxMzQyMzA0NzQz', 'url': 'https://api.github.com/repos/dask/dask/labels/core', 'name': 'core', 'color': '000000', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-03-08T08:13:32Z,2024-03-04T01:47:55Z,,MEMBER,,"When running a groupby using the default disk backend I am receiving non-deterministic results

```python
import dask.dataframe as dd
import pandas as pd

df = pd.DataFrame({
        'plain_int64': [1, 2, 3],
        'dup_strings': [0, 1, 0]
    })

ddf = dd.from_pandas(df, npartitions=2)
dd_series = ddf.groupby('dup_strings').transform('first')
dd_series.compute()
```

Most of the time, this example returns

 /  | plain_int64               
-- | --
1 | 2
0 | 1
2 | 1

but in about 2-3% I get a different result
 /  | plain_int64               
-- | --
1 | 2
2 | 3
0 | 3


pandas output is

 /  | plain_int64               
-- | --
0 | 1
1 | 2
2 | 1


When switching to the `tasks` backend using

```python
import dask
dask.config.set({""dataframe.shuffle.method"": ""tasks""})
``` 

this goes away.

Note: whoever is using a distributed cluster will automatically use the `tasks` or `p2p` backend and will not be affected by this",,https://api.github.com/repos/dask/dask/issues/10034/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10034/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
816,https://api.github.com/repos/dask/dask/issues/10045,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10045/labels{/name},https://api.github.com/repos/dask/dask/issues/10045/comments,https://api.github.com/repos/dask/dask/issues/10045/events,https://github.com/dask/dask/issues/10045,1618490840,I_kwDOAbcwm85geDXY,10045,Custom sort key for dataframe.read_parquet with multiple paths as input,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2023-03-10T07:25:13Z,2024-03-04T01:47:54Z,,NONE,,"[dask.dataframe.read_parquet](https://docs.dask.org/en/stable/generated/dask.dataframe.read_parquet.html) accepts a list of paths as input. It uses [natural_sort_key](https://pydocs.github.io/p/dask/2021.10.0/api/dask.utils.natural_sort_key) under the hood to sort the paths in several places. In my case parquet files are not in the natural order and I'd like to sort them outside and keep the same order inside the read_parquet, so I do monkey patching like this to make it work:

```
with (mock.patch.object(dask.dataframe.io.parquet.core, 'natural_sort_key', new=lambda p: p),
      mock.patch.object(dask.dataframe.io.parquet.utils, 'natural_sort_key', new=lambda p: p)):    
    return dd.read_parquet(paths, index='index', calculate_divisions=True)
```

It would be great if there was a parameter to control the sort key (disable natural_sort_key or provide my own).",,https://api.github.com/repos/dask/dask/issues/10045/timeline,,,alexgorban,1524085,MDQ6VXNlcjE1MjQwODU=,https://avatars.githubusercontent.com/u/1524085?v=4,,https://api.github.com/users/alexgorban,https://github.com/alexgorban,https://api.github.com/users/alexgorban/followers,https://api.github.com/users/alexgorban/following{/other_user},https://api.github.com/users/alexgorban/gists{/gist_id},https://api.github.com/users/alexgorban/starred{/owner}{/repo},https://api.github.com/users/alexgorban/subscriptions,https://api.github.com/users/alexgorban/orgs,https://api.github.com/users/alexgorban/repos,https://api.github.com/users/alexgorban/events{/privacy},https://api.github.com/users/alexgorban/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10045/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
817,https://api.github.com/repos/dask/dask/issues/10053,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10053/labels{/name},https://api.github.com/repos/dask/dask/issues/10053/comments,https://api.github.com/repos/dask/dask/issues/10053/events,https://github.com/dask/dask/issues/10053,1620084733,I_kwDOAbcwm85gkIf9,10053,"einsum will increase the dimension of tensor when we split the legs which will be contracted, that may cause out of memory","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-03-11T17:28:50Z,2024-02-26T01:45:26Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
See the following code. First we make two random tensors ```A``` and ```B``` which's size are both ```(N,D,D,D,D)```, with chunksize```(N//nN,D//nD,D//nD,D//nD,D//nD)```. Then perform the ```einsum``` and we get the tensor ```C```. The shape of tensor ```C``` becomes ```(D,D,D,D,D,D,D,D,nN)``` at Layer3. Especially in the case of $\text{nN} \neq 1$, the memory usage increases $\text{nN}$ times
![image](https://user-images.githubusercontent.com/89069722/224502561-40fff3ef-9667-4642-aef7-518b751197bb.png)


**Minimal Complete Verifiable Example**:
```python
import dask.array as da
import opt_einsum as oe

N = 1024
D = 16

nN = 4
nD = 2

chunks=(N//nN,D//nD,D//nD,D//nD,D//nD)

A = da.random.random((N,D,D,D,D), chunks=chunks)
B = da.random.random((N,D,D,D,D), chunks=chunks)
C = da.einsum(""aijkl,amnop->ijklmnop"", A, B)
#C = oe.contract(""aijkl,amnop->ijklmnop"", A, B)
C.dask
```

**Anything else we need to know?**:
I have done some tests. If we split the legs which will be contracted, the ```chunk_einsum``` operation for ```da.einsum``` or the ```tensordot``` operation for ```opt_einsum``` will increase the dimension of result. For example, size of the result of the following code is ```da.shape(C)=(16,16)```. But at Layer3, the size increases to ```(16,16,4,4,4)```, which will cause out of memory in the case of large tensor.
<details>
<summary>Simpler case</summary>

```python
import dask.array as da
import opt_einsum as oe

D = 16

nN = 4
nD = 4

chunks=(D//nD,D//nD,D//nD,D//nD)

A = da.random.random((D,D,D,D), chunks=chunks)
B = da.random.random((D,D,D,D), chunks=chunks)
C = da.einsum(""ijkl,ijkp->lp"", A, B)
C.dask
```

</details>

**Environment**:
- Dask version: 2023.1.1
- Python version: 3.10.9
- Operating System: Red Hat
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/10053/timeline,,,LUOXIAO92,89069722,MDQ6VXNlcjg5MDY5NzIy,https://avatars.githubusercontent.com/u/89069722?v=4,,https://api.github.com/users/LUOXIAO92,https://github.com/LUOXIAO92,https://api.github.com/users/LUOXIAO92/followers,https://api.github.com/users/LUOXIAO92/following{/other_user},https://api.github.com/users/LUOXIAO92/gists{/gist_id},https://api.github.com/users/LUOXIAO92/starred{/owner}{/repo},https://api.github.com/users/LUOXIAO92/subscriptions,https://api.github.com/users/LUOXIAO92/orgs,https://api.github.com/users/LUOXIAO92/repos,https://api.github.com/users/LUOXIAO92/events{/privacy},https://api.github.com/users/LUOXIAO92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10053/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
818,https://api.github.com/repos/dask/dask/issues/10057,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10057/labels{/name},https://api.github.com/repos/dask/dask/issues/10057/comments,https://api.github.com/repos/dask/dask/issues/10057/events,https://github.com/dask/dask/issues/10057,1622115255,I_kwDOAbcwm85gr4O3,10057,2023.3.1: docuemnattion not ready for sphinx 6.1.3,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,4,2023-03-13T19:25:07Z,2024-02-26T01:45:25Z,,NONE,,"Looks like it isn not possible to build `dask` documentation using latest sphinx 6.1.3
<details>

```console
+ /usr/bin/sphinx-build -n -T -b man docs/source build/sphinx/man
Running Sphinx v6.1.3
making output directory... done
[autosummary] generating autosummary for: 10-minutes-to-dask.rst, api.rst, array-api.rst, array-assignment.rst, array-best-practices.rst, array-chunks.rst, array-creation.rst, array-design.rst, array-gufunc.rst, array-overlap.rst, ..., scheduler-overview.rst, scheduling-policy.rst, scheduling.rst, shared.rst, spark.rst, spec.rst, support.rst, understanding-performance.rst, user-interfaces.rst, why.rst
[autosummary] generating autosummary for: /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.array.Array.all.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.array.Array.any.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.array.Array.argmax.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.array.Array.argmin.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.array.Array.argtopk.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.array.Array.astype.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.array.Array.blocks.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.array.Array.choose.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.array.Array.chunks.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.array.Array.chunksize.rst, ..., /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.dataframe.tseries.resample.Resampler.ohlc.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.dataframe.tseries.resample.Resampler.prod.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.dataframe.tseries.resample.Resampler.quantile.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.dataframe.tseries.resample.Resampler.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.dataframe.tseries.resample.Resampler.sem.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.dataframe.tseries.resample.Resampler.size.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.dataframe.tseries.resample.Resampler.std.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.dataframe.tseries.resample.Resampler.sum.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.dataframe.tseries.resample.Resampler.var.rst, /home/tkloczko/rpmbuild/BUILD/dask-2023.3.1/docs/source/generated/dask.dataframe.utils.make_meta.rst
building [mo]: targets for 0 po files that are out of date
writing output...
building [man]: all manpages
updating environment: [new config] 1018 added, 0 changed, 0 removed
executing 10-minutes-to-dask-minutes-to-dask
reading sources... [  2%] changelog
Traceback (most recent call last):
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 299, in next_line
    self.line = self.input_lines[self.line_offset]
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 1136, in __getitem__
    return self.data[i]
IndexError: list index out of range

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 226, in run
    self.next_line()
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 302, in next_line
    raise EOFError
EOFError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/usr/lib/python3.8/site-packages/sphinx/cmd/build.py"", line 284, in build_main
    app.build(args.force_all, args.filenames)
  File ""/usr/lib/python3.8/site-packages/sphinx/application.py"", line 347, in build
    self.builder.build_update()
  File ""/usr/lib/python3.8/site-packages/sphinx/builders/__init__.py"", line 308, in build_update
    self.build(['__all__'], to_build)
  File ""/usr/lib/python3.8/site-packages/sphinx/builders/__init__.py"", line 327, in build
    updated_docnames = set(self.read())
  File ""/usr/lib/python3.8/site-packages/sphinx/builders/__init__.py"", line 434, in read
    self._read_serial(docnames)
  File ""/usr/lib/python3.8/site-packages/sphinx/builders/__init__.py"", line 455, in _read_serial
    self.read_doc(docname)
  File ""/usr/lib/python3.8/site-packages/sphinx/builders/__init__.py"", line 511, in read_doc
    publisher.publish()
  File ""/usr/lib/python3.8/site-packages/docutils/core.py"", line 224, in publish
    self.document = self.reader.read(self.source, self.parser,
  File ""/usr/lib/python3.8/site-packages/sphinx/io.py"", line 105, in read
    self.parse()
  File ""/usr/lib/python3.8/site-packages/docutils/readers/__init__.py"", line 76, in parse
    self.parser.parse(self.input, document)
  File ""/usr/lib/python3.8/site-packages/sphinx/parsers.py"", line 80, in parse
    self.statemachine.run(inputlines, document, inliner=self.inliner)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 169, in run
    results = StateMachineWS.run(self, input_lines, input_offset,
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 233, in run
    context, next_state, result = self.check_line(
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 445, in check_line
    return method(match, context, next_state)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 2785, in underline
    self.section(title, source, style, lineno - 1, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 325, in section
    self.new_subsection(title, lineno, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 391, in new_subsection
    newabsoffset = self.nested_parse(
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 279, in nested_parse
    state_machine.run(block, input_offset, memo=self.memo,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 195, in run
    results = StateMachineWS.run(self, input_lines, input_offset)
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 233, in run
    context, next_state, result = self.check_line(
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 445, in check_line
    return method(match, context, next_state)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 2785, in underline
    self.section(title, source, style, lineno - 1, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 325, in section
    self.new_subsection(title, lineno, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 391, in new_subsection
    newabsoffset = self.nested_parse(
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 279, in nested_parse
    state_machine.run(block, input_offset, memo=self.memo,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 195, in run
    results = StateMachineWS.run(self, input_lines, input_offset)
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 233, in run
    context, next_state, result = self.check_line(
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 445, in check_line
    return method(match, context, next_state)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 2785, in underline
    self.section(title, source, style, lineno - 1, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 325, in section
    self.new_subsection(title, lineno, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 391, in new_subsection
    newabsoffset = self.nested_parse(
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 279, in nested_parse
    state_machine.run(block, input_offset, memo=self.memo,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 195, in run
    results = StateMachineWS.run(self, input_lines, input_offset)
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 233, in run
    context, next_state, result = self.check_line(
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 445, in check_line
    return method(match, context, next_state)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 1273, in bullet
    i, blank_finish = self.list_item(match.end())
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 1295, in list_item
    self.nested_parse(indented, input_offset=line_offset,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 279, in nested_parse
    state_machine.run(block, input_offset, memo=self.memo,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 195, in run
    results = StateMachineWS.run(self, input_lines, input_offset)
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 239, in run
    result = state.eof(context)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 2725, in eof
    self.blank(None, context, None)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 2716, in blank
    paragraph, literalnext = self.paragraph(
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 416, in paragraph
    textnodes, messages = self.inline_text(text, lineno)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 425, in inline_text
    nodes, messages = self.inliner.parse(text, lineno,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 649, in parse
    before, inlines, remaining, sysmessages = method(self, match,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 792, in interpreted_or_phrase_ref
    nodelist, messages = self.interpreted(rawsource, escaped, role,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 889, in interpreted
    nodes, messages2 = role_fn(role, rawsource, text, lineno, self)
  File ""/usr/lib/python3.8/site-packages/sphinx/ext/extlinks.py"", line 103, in role
    title = caption % part
TypeError: not all arguments converted during string formatting

Exception occurred:
  File ""/usr/lib/python3.8/site-packages/sphinx/ext/extlinks.py"", line 103, in role
    title = caption % part
TypeError: not all arguments converted during string formatting
The full traceback has been saved in /tmp/sphinx-err-3l5jo8g3.log, if you want to report the issue to the developers.
Please also report this if it was a user error, so that a better error message can be provided next time.
A bug report can be filed in the tracker at <https://github.com/sphinx-doc/sphinx/issues>. Thanks!


[tkloczko@pers-jacek SPECS]$ cat /tmp/sphinx-err-3l5jo8g3.log
# Platform:         linux; (Linux-6.1.10-200.fc37.x86_64-x86_64-with-glibc2.34)
# Sphinx version:   6.1.3
# Python version:   3.8.16 (CPython)
# Docutils version: 0.19
# Jinja2 version:   3.1.2
# Pygments version: 2.14.0

# Last messages:
#   reading sources... [  1%] array-slicing
#   reading sources... [  1%] array-sparse
#   reading sources... [  1%] array-stack
#   reading sources... [  1%] array-stats
#   reading sources... [  1%] bag
#   reading sources... [  1%] bag-api
#   reading sources... [  1%] bag-creation
#   reading sources... [  1%] best-practices
#   reading sources... [  1%] caching
#   reading sources... [  2%] changelog

# Loaded extensions:
#   sphinx.ext.mathjax (6.1.3)
#   sphinxcontrib.applehelp (1.0.4)
#   sphinxcontrib.devhelp (1.0.2)
#   sphinxcontrib.htmlhelp (2.0.0)
#   sphinxcontrib.serializinghtml (1.1.5)
#   sphinxcontrib.qthelp (1.0.3)
#   alabaster (0.7.13)
#   sphinx.ext.autodoc.preserve_defaults (6.1.3)
#   sphinx.ext.autodoc.type_comment (6.1.3)
#   sphinx.ext.autodoc.typehints (6.1.3)
#   sphinx.ext.autodoc (6.1.3)
#   sphinx.ext.doctest (6.1.3)
#   sphinx.ext.intersphinx (6.1.3)
#   sphinx.ext.autosummary (6.1.3)
#   sphinx_autosummary_accessors (2022.4.0)
#   sphinx.ext.extlinks (6.1.3)
#   sphinx.ext.viewcode (6.1.3)
#   numpydoc (1.5.0)
#   sphinx_click.ext (unknown version)
#   dask_sphinx_theme.ext.dask_config_sphinx_ext (0.1)
#   sphinx_tabs.tabs (unknown version)
#   sphinx_remove_toctrees (unknown version)
#   IPython.sphinxext.ipython_console_highlighting (unknown version)
#   IPython.sphinxext.ipython_directive (unknown version)
#   jupyter_sphinx (0.4.0)
#   sphinx_copybutton (0.5.1)

# Traceback:
Traceback (most recent call last):
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 299, in next_line
    self.line = self.input_lines[self.line_offset]
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 1136, in __getitem__
    return self.data[i]
IndexError: list index out of range

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 226, in run
    self.next_line()
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 302, in next_line
    raise EOFError
EOFError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/usr/lib/python3.8/site-packages/sphinx/cmd/build.py"", line 284, in build_main
    app.build(args.force_all, args.filenames)
  File ""/usr/lib/python3.8/site-packages/sphinx/application.py"", line 347, in build
    self.builder.build_update()
  File ""/usr/lib/python3.8/site-packages/sphinx/builders/__init__.py"", line 308, in build_update
    self.build(['__all__'], to_build)
  File ""/usr/lib/python3.8/site-packages/sphinx/builders/__init__.py"", line 327, in build
    updated_docnames = set(self.read())
  File ""/usr/lib/python3.8/site-packages/sphinx/builders/__init__.py"", line 434, in read
    self._read_serial(docnames)
  File ""/usr/lib/python3.8/site-packages/sphinx/builders/__init__.py"", line 455, in _read_serial
    self.read_doc(docname)
  File ""/usr/lib/python3.8/site-packages/sphinx/builders/__init__.py"", line 511, in read_doc
    publisher.publish()
  File ""/usr/lib/python3.8/site-packages/docutils/core.py"", line 224, in publish
    self.document = self.reader.read(self.source, self.parser,
  File ""/usr/lib/python3.8/site-packages/sphinx/io.py"", line 105, in read
    self.parse()
  File ""/usr/lib/python3.8/site-packages/docutils/readers/__init__.py"", line 76, in parse
    self.parser.parse(self.input, document)
  File ""/usr/lib/python3.8/site-packages/sphinx/parsers.py"", line 80, in parse
    self.statemachine.run(inputlines, document, inliner=self.inliner)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 169, in run
    results = StateMachineWS.run(self, input_lines, input_offset,
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 233, in run
    context, next_state, result = self.check_line(
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 445, in check_line
    return method(match, context, next_state)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 2785, in underline
    self.section(title, source, style, lineno - 1, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 325, in section
    self.new_subsection(title, lineno, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 391, in new_subsection
    newabsoffset = self.nested_parse(
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 279, in nested_parse
    state_machine.run(block, input_offset, memo=self.memo,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 195, in run
    results = StateMachineWS.run(self, input_lines, input_offset)
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 233, in run
    context, next_state, result = self.check_line(
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 445, in check_line
    return method(match, context, next_state)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 2785, in underline
    self.section(title, source, style, lineno - 1, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 325, in section
    self.new_subsection(title, lineno, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 391, in new_subsection
    newabsoffset = self.nested_parse(
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 279, in nested_parse
    state_machine.run(block, input_offset, memo=self.memo,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 195, in run
    results = StateMachineWS.run(self, input_lines, input_offset)
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 233, in run
    context, next_state, result = self.check_line(
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 445, in check_line
    return method(match, context, next_state)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 2785, in underline
    self.section(title, source, style, lineno - 1, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 325, in section
    self.new_subsection(title, lineno, messages)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 391, in new_subsection
    newabsoffset = self.nested_parse(
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 279, in nested_parse
    state_machine.run(block, input_offset, memo=self.memo,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 195, in run
    results = StateMachineWS.run(self, input_lines, input_offset)
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 233, in run
    context, next_state, result = self.check_line(
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 445, in check_line
    return method(match, context, next_state)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 1273, in bullet
    i, blank_finish = self.list_item(match.end())
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 1295, in list_item
    self.nested_parse(indented, input_offset=line_offset,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 279, in nested_parse
    state_machine.run(block, input_offset, memo=self.memo,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 195, in run
    results = StateMachineWS.run(self, input_lines, input_offset)
  File ""/usr/lib/python3.8/site-packages/docutils/statemachine.py"", line 239, in run
    result = state.eof(context)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 2725, in eof
    self.blank(None, context, None)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 2716, in blank
    paragraph, literalnext = self.paragraph(
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 416, in paragraph
    textnodes, messages = self.inline_text(text, lineno)
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 425, in inline_text
    nodes, messages = self.inliner.parse(text, lineno,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 649, in parse
    before, inlines, remaining, sysmessages = method(self, match,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 792, in interpreted_or_phrase_ref
    nodelist, messages = self.interpreted(rawsource, escaped, role,
  File ""/usr/lib/python3.8/site-packages/docutils/parsers/rst/states.py"", line 889, in interpreted
    nodes, messages2 = role_fn(role, rawsource, text, lineno, self)
  File ""/usr/lib/python3.8/site-packages/sphinx/ext/extlinks.py"", line 103, in role
    title = caption % part
```
</details>
Looks lie build fails in `sphinx_copybutton`.",,https://api.github.com/repos/dask/dask/issues/10057/timeline,,,kloczek,31284574,MDQ6VXNlcjMxMjg0NTc0,https://avatars.githubusercontent.com/u/31284574?v=4,,https://api.github.com/users/kloczek,https://github.com/kloczek,https://api.github.com/users/kloczek/followers,https://api.github.com/users/kloczek/following{/other_user},https://api.github.com/users/kloczek/gists{/gist_id},https://api.github.com/users/kloczek/starred{/owner}{/repo},https://api.github.com/users/kloczek/subscriptions,https://api.github.com/users/kloczek/orgs,https://api.github.com/users/kloczek/repos,https://api.github.com/users/kloczek/events{/privacy},https://api.github.com/users/kloczek/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10057/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
819,https://api.github.com/repos/dask/dask/issues/10059,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10059/labels{/name},https://api.github.com/repos/dask/dask/issues/10059/comments,https://api.github.com/repos/dask/dask/issues/10059/events,https://github.com/dask/dask/issues/10059,1623346680,I_kwDOAbcwm85gwk34,10059,Cannot pass axis parameter to DataFrame.mask / where,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2023-03-14T12:09:13Z,2024-02-26T01:45:24Z,,NONE,,"**Describe the issue**:

Pandas' `DataFrame.mask` has a required `axis` parameter, but that parameter cannot be passed to `dask.DataFrame.mask` resulting in TypeError. This also applies to the `where` method.

**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import dask.dataframe as dd

a = pd.DataFrame({""x"": [1,2], ""y"": [3,4]})
a.mask(a.x > 1, a.y, axis=0) # ok
b = dd.from_pandas(a, npartitions=1)
b.mask(b.x > 1, b.y, axis=0)
# TypeError: mask() got an unexpected keyword argument 'axis'
```

**Environment**:

- Dask version: 2023.3.0
- Python version: 3.9
- Operating System: macOS 13.0.1
- Install method (conda, pip, source): poetry
",,https://api.github.com/repos/dask/dask/issues/10059/timeline,,,Oreilles,33065839,MDQ6VXNlcjMzMDY1ODM5,https://avatars.githubusercontent.com/u/33065839?v=4,,https://api.github.com/users/Oreilles,https://github.com/Oreilles,https://api.github.com/users/Oreilles/followers,https://api.github.com/users/Oreilles/following{/other_user},https://api.github.com/users/Oreilles/gists{/gist_id},https://api.github.com/users/Oreilles/starred{/owner}{/repo},https://api.github.com/users/Oreilles/subscriptions,https://api.github.com/users/Oreilles/orgs,https://api.github.com/users/Oreilles/repos,https://api.github.com/users/Oreilles/events{/privacy},https://api.github.com/users/Oreilles/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10059/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
820,https://api.github.com/repos/dask/dask/issues/10060,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10060/labels{/name},https://api.github.com/repos/dask/dask/issues/10060/comments,https://api.github.com/repos/dask/dask/issues/10060/events,https://github.com/dask/dask/pull/10060,1623462071,PR_kwDOAbcwm85L_2PO,10060,Add axis and level parameters to where and mask dataframe methods,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,9,2023-03-14T13:16:41Z,2024-02-26T01:45:23Z,,FIRST_TIME_CONTRIBUTOR,,"- [x] Closes #10059
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10060/timeline,,,Oreilles,33065839,MDQ6VXNlcjMzMDY1ODM5,https://avatars.githubusercontent.com/u/33065839?v=4,,https://api.github.com/users/Oreilles,https://github.com/Oreilles,https://api.github.com/users/Oreilles/followers,https://api.github.com/users/Oreilles/following{/other_user},https://api.github.com/users/Oreilles/gists{/gist_id},https://api.github.com/users/Oreilles/starred{/owner}{/repo},https://api.github.com/users/Oreilles/subscriptions,https://api.github.com/users/Oreilles/orgs,https://api.github.com/users/Oreilles/repos,https://api.github.com/users/Oreilles/events{/privacy},https://api.github.com/users/Oreilles/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10060/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10060,https://github.com/dask/dask/pull/10060,https://github.com/dask/dask/pull/10060.diff,https://github.com/dask/dask/pull/10060.patch,,,,,,,,,,,,,,,,,,,
821,https://api.github.com/repos/dask/dask/issues/10061,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10061/labels{/name},https://api.github.com/repos/dask/dask/issues/10061/comments,https://api.github.com/repos/dask/dask/issues/10061/events,https://github.com/dask/dask/pull/10061,1623781317,PR_kwDOAbcwm85MA7qh,10061,Preserve ordering of user-provided path list in `read_parquet`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,5,2023-03-14T15:57:48Z,2024-02-26T01:45:22Z,,MEMBER,,"The current `read_parquet` implementation includes several hard-coded path-sorting operations, and multiple users have expressed an interest if making it possible to override this behavior. ~The solution in this PR is to add a new `sort_key` option~ (as suggested by @alexgorban). **[EDIT: The revised approach is to preserve the order of user-provided path-list input, but to use a ""natural"" sort for input containing a directory or glob-string pattern]**

- [x] Closes #10045
- [x] Closes #8829 
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10061/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10061/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10061,https://github.com/dask/dask/pull/10061,https://github.com/dask/dask/pull/10061.diff,https://github.com/dask/dask/pull/10061.patch,,,,,,,,,,,,,,,,,,,
822,https://api.github.com/repos/dask/dask/issues/10067,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10067/labels{/name},https://api.github.com/repos/dask/dask/issues/10067/comments,https://api.github.com/repos/dask/dask/issues/10067/events,https://github.com/dask/dask/pull/10067,1624534532,PR_kwDOAbcwm85MDdxP,10067,[WIP][Experimental] Attach default RangeIndex metadata to read_parquet tasks,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,0,2023-03-15T01:04:39Z,2023-03-15T01:05:03Z,,MEMBER,,"Experimental PR to start adding the necessary information to construct a global `RangeIndex` whenever `calculate_divisions=True`. This range information is also collected if/when the parquet metadata is parsed for other purposes, because it can be used to optimize `DataFrame.__len__`.

**Example Behavior**:

```python
import dask.dataframe as dd
from dask.datasets import timeseries

path = ""/datasets/rzamora/timeseries_test""
timeseries().to_parquet(path, overwrite=True)

# Get global RangeIndex if `index=False` and `calculate_divisions=True`
print(dd.read_parquet(path, index=False, calculate_divisions=True))
```
```
Dask DataFrame Structure:
                     timestamp    name     id        x        y
npartitions=30                                                 
0               datetime64[ns]  object  int64  float64  float64
86400                      ...     ...    ...      ...      ...
...                        ...     ...    ...      ...      ...
2505600                    ...     ...    ...      ...      ...
2592000                    ...     ...    ...      ...      ...
Dask Name: read-parquet, 1 graph layer
```
```python
# The default RangeIndex information is used to optimize length
# (even when the index is set to a parquet-data column)
ddf = dd.read_parquet(path, index=""timestamp"", calculate_divisions=True)
%time len(ddf)  # Optimized time is ~500x faster for this case
```
```
CPU times: user 26 s, sys: 6 s, total: 32 s
Wall time: 39.3 s
2592000
```


- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10067/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10067/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10067,https://github.com/dask/dask/pull/10067,https://github.com/dask/dask/pull/10067.diff,https://github.com/dask/dask/pull/10067.patch,,,,,,,,,,,,,,,,,,,
823,https://api.github.com/repos/dask/dask/issues/10069,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10069/labels{/name},https://api.github.com/repos/dask/dask/issues/10069/comments,https://api.github.com/repos/dask/dask/issues/10069/events,https://github.com/dask/dask/issues/10069,1625464228,I_kwDOAbcwm85g4p2k,10069,Improving support for pandas extension dtypes,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-03-15T12:48:51Z,2023-04-24T01:54:13Z,,MEMBER,,"<!-- Please do a quick search of existing issues to make sure that this has not been asked before. -->

Currently, support for Pandas extension dtypes in Dask is somewhat patchy, with many operations giving unexpected results or even failing outright; thought it might be worthwhile to gather some of the issues I've come across in one place (will continue updating as I encounter more issues):

Issues with nullable/pyarrow dtypes
-------------
- https://github.com/dask/dask/issues/6018
- https://github.com/dask/dask/issues/8530
- https://github.com/dask/dask/issues/9401
- https://github.com/dask/dask/issues/9765
- https://github.com/dask/dask/issues/9767

Issues with categorical dtype
-------------
- https://github.com/dask/dask/issues/5756
- https://github.com/dask/dask/issues/6587
- https://github.com/dask/dask/issues/7015
- https://github.com/dask/dask/issues/9467
- https://github.com/dask/dask/issues/9515
- https://github.com/dask/dask/issues/9966

Some thoughts that jump out to me:

- at the time of opening this, it seems like reading/writing categorical columns to parquet is a pretty common issue; I'm interested in if this has come up much in the work that Coiled is doing (from my perspective at RAPIDS, we haven't looked much into Dask's categorical support)
- I would imagine that resolving some of the issues with nullable columns (such as #9765, which is concerned with adding handling for `pd.NA` in places expecting only `np.nan`) would help us move towards wider adoption of pyarrow numeric types, which I know @jrbourbeau had been playing around with

Interested if anyone else has been thinking about an approach here, or if there are any issues I might've missed.",,https://api.github.com/repos/dask/dask/issues/10069/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10069/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
824,https://api.github.com/repos/dask/dask/issues/10072,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10072/labels{/name},https://api.github.com/repos/dask/dask/issues/10072/comments,https://api.github.com/repos/dask/dask/issues/10072/events,https://github.com/dask/dask/pull/10072,1625850798,PR_kwDOAbcwm85MH6Mj,10072,Use empty column projection to optimize `DataFrame.__len__`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,1,2023-03-15T16:22:29Z,2023-03-15T23:12:12Z,,MEMBER,,"While experimenting with https://github.com/dask/dask/pull/10067, I realized that we are not taking full advantage of `DataFrameIOLayer` column-projection within ~`DataFrame.index` or~ `DataFrame.__len__`. That is, there is no reason we need to read in **any** column data to do something like `len(dd.read_parquet(path))` unless one of the columns is being used as the index. Instead, we can just project an empty column-list into the read-parquet layer, and find the global length of the index (which may not require us to read in **any** file data at all).

The performance bump is most obvious for cases in which it is expensive to read a single column for each partition. For example, there is a 40x improvement for the 266GB Criteo dataset:

```python
import dask.dataframe as dd

ddf = dd.read_parquet(""/data/crit_pq_int"", blocksize=""1GiB"")
%time len(ddf)
```

New result:
```
CPU times: user 4.28 s, sys: 377 ms, total: 4.66 s
Wall time: 1.23 s
4373472305
```

Old result:
```
CPU times: user 1min 8s, sys: 2min 59s, total: 4min 8s
Wall time: 47.8 s
4373472305
```

The speedup is much less significant when you have many small partitions, because we still need to access the the file(s) for each partition.  However, we may be able to improve that case in the future as well.

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10072/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10072/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10072,https://github.com/dask/dask/pull/10072,https://github.com/dask/dask/pull/10072.diff,https://github.com/dask/dask/pull/10072.patch,,,,,,,,,,,,,,,,,,,
825,https://api.github.com/repos/dask/dask/issues/10074,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10074/labels{/name},https://api.github.com/repos/dask/dask/issues/10074/comments,https://api.github.com/repos/dask/dask/issues/10074/events,https://github.com/dask/dask/issues/10074,1626023994,I_kwDOAbcwm85g6yg6,10074,`da.store` is dropping all annotations even if low level fusion is deactivated,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,4,2023-03-15T18:11:42Z,2024-02-26T01:45:20Z,,MEMBER,,"## Problem

`da.store` is dropping all annotations from the input graph even if low level fusion is deactivated

## Example

```python
import dask
import dask.array as da
import numpy as np

# Low level fusion is on by default for arrays which is known to strip annotations
# Opting out doesn't help. When using `store` there is no way to preserve annotatoins
with dask.config.set({""optimization.fuse.active"": False}):
    with dask.annotate(retries=4):
        a = da.ones((4, 4), chunks=(2, 2))

    assert any(l.annotations for l in a.dask.layers.values())
    st = da.store([a], [_DevNull()], lock=False, compute=False)

    # Boom
    assert any(l.annotations for l in st.dask.layers.values())
```

## Why are we dropping these?

Looking at the code, we're actually leaving HLGs behind at this specific point. We're only extracting the keys but are not actually preserving the meta information that is attached to layers
 
https://github.com/dask/dask/blob/890de74381d89910097cd2e9409196db4ab5b5d9/dask/array/core.py#L1201-L1211

## Why does this matter

There is the general theme of users being able to control retries, priorities and resources with this. However, internally we are also relying on annotations to enable P2P shuffling or in this specific case rechunking.

A user reported this problem already https://github.com/dask/distributed/issues/7599#issuecomment-1458116131 and this is actually a major obstacle for adoption of P2P rechunking since `da.store` is very frequently used see also https://github.com/dask/dask/issues/9381.

https://github.com/dask/dask/issues/9381 in fact already proposes to migrate `da.store` to `Blockwise` which would be one option to fix this problem but the attempt ran into issues over in https://github.com/dask/dask/pull/9382

I do not care if this is using blockwise or not but I would like annotations to be preserved to enable usage of P2P rechunking.


## Related tickets
- https://github.com/dask/distributed/issues/7599
- https://github.com/dask/dask/issues/9541
- https://github.com/dask/dask/issues/9381",,https://api.github.com/repos/dask/dask/issues/10074/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10074/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
826,https://api.github.com/repos/dask/dask/issues/10075,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10075/labels{/name},https://api.github.com/repos/dask/dask/issues/10075/comments,https://api.github.com/repos/dask/dask/issues/10075/events,https://github.com/dask/dask/pull/10075,1626131703,PR_kwDOAbcwm85MI3TW,10075,[WIP][Experiment] Expose `left_shuffled` and `right_shuffled` options in `DataFrame.merge`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,0,2023-03-15T19:19:38Z,2023-03-15T20:57:36Z,,MEMBER,,"I have heard meany times in off-line discussion that Dask ends up shuffling the same data multiple times for real-world workflows requiring multiple merge operations. Although there are certainly ways for users to optimize their code to avoid doing this. It may also be useful to expose a `DataFrame.merge` argument through which the user can make a ""promise"" to Dask that a particular collection is already shuffled by the necessary columns. This PR is intended as a POC for such an option.",,https://api.github.com/repos/dask/dask/issues/10075/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10075/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10075,https://github.com/dask/dask/pull/10075,https://github.com/dask/dask/pull/10075.diff,https://github.com/dask/dask/pull/10075.patch,,,,,,,,,,,,,,,,,,,
827,https://api.github.com/repos/dask/dask/issues/10077,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10077/labels{/name},https://api.github.com/repos/dask/dask/issues/10077/comments,https://api.github.com/repos/dask/dask/issues/10077/events,https://github.com/dask/dask/issues/10077,1627000641,I_kwDOAbcwm85g-g9B,10077,Writing argwhere result to hdf5 fails,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2023-03-16T09:00:54Z,2023-04-17T01:53:21Z,,NONE,,"**Describe the issue**:

Writing the result of argwhere to a hdf5 file fails.

```
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""D:\APPS\Python38\lib\site-packages\dask\array\core.py"", line 1810, in to_hdf5
    return to_hdf5(filename, datapath, self, **kwargs)
  File ""D:\APPS\Python38\lib\site-packages\dask\array\core.py"", line 5375, in to_hdf5
    dsets = [
  File ""D:\APPS\Python38\lib\site-packages\dask\array\core.py"", line 5376, in <listcomp>
    f.require_dataset(
  File ""D:\APPS\Python38\lib\site-packages\h5py\_hl\group.py"", line 247, in require_dataset
    return self.create_dataset(name, *(shape, dtype), **kwds)
  File ""D:\APPS\Python38\lib\site-packages\h5py\_hl\group.py"", line 161, in create_dataset
    dsid = dataset.make_new_dset(group, shape, dtype, data, name, **kwds)
  File ""D:\APPS\Python38\lib\site-packages\h5py\_hl\dataset.py"", line 106, in make_new_dset
    dcpl = filters.fill_dcpl(
  File ""D:\APPS\Python38\lib\site-packages\h5py\_hl\filters.py"", line 256, in fill_dcpl
    plist.set_chunk(chunks)
  File ""h5py\_objects.pyx"", line 54, in h5py._objects.with_phil.wrapper
  File ""h5py\_objects.pyx"", line 55, in h5py._objects.with_phil.wrapper
  File ""h5py\h5p.pyx"", line 472, in h5py.h5p.PropDCID.set_chunk
  File ""h5py\utils.pyx"", line 105, in h5py.utils.convert_tuple
ValueError: cannot convert float NaN to integer
```

**Minimal Complete Verifiable Example**:

```python
import dask.array as da
arr = da.random.uniform(0, 1, size=(100, ))
out = da.argwhere(arr < 0.5)
out.to_hdf5(""out.hdf5"", ""/out"")
```

**Anything else we need to know?**:

`da.argwhere` seems to have other issues as well. I think it's materializing the input array instead of working on it in chunks.

**Environment**:

- Dask version: 2023.3.1
- Python version: 3.8.10
- Operating System: Windows 10
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10077/timeline,,,Dobatymo,7647594,MDQ6VXNlcjc2NDc1OTQ=,https://avatars.githubusercontent.com/u/7647594?v=4,,https://api.github.com/users/Dobatymo,https://github.com/Dobatymo,https://api.github.com/users/Dobatymo/followers,https://api.github.com/users/Dobatymo/following{/other_user},https://api.github.com/users/Dobatymo/gists{/gist_id},https://api.github.com/users/Dobatymo/starred{/owner}{/repo},https://api.github.com/users/Dobatymo/subscriptions,https://api.github.com/users/Dobatymo/orgs,https://api.github.com/users/Dobatymo/repos,https://api.github.com/users/Dobatymo/events{/privacy},https://api.github.com/users/Dobatymo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10077/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
828,https://api.github.com/repos/dask/dask/issues/10080,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10080/labels{/name},https://api.github.com/repos/dask/dask/issues/10080/comments,https://api.github.com/repos/dask/dask/issues/10080/events,https://github.com/dask/dask/issues/10080,1628626298,I_kwDOAbcwm85hEt16,10080,argwhere doesn't work chunk-wise,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,1,2023-03-17T03:26:40Z,2023-04-24T01:54:10Z,,NONE,,"**Describe the issue**:

argwhere doesn't work chunk-wise. Ie. it fully processes the input before it's starting to process it. The output in this case should be empty, since none of the elements are `< 0`.  However it's still running out of memory trying to process the input.

**Minimal Complete Verifiable Example**:

```python
from dask.diagnostics import ProgressBar
import dask.array as da
class DummyStore:
    def __setitem__(self, pos, item):
        print(""store"", pos)

with ProgressBar():
    arr = da.random.uniform(0, 1, size=(2000, 2000, 2000), chunks=(100, 100, 100)) < 0
    out = da.argwhere(arr)
    out.store(DummyStore())

```

**Anything else we need to know?**:

```
Traceback (most recent call last):
  File ""<stdin>"", line 4, in <module>
  File ""C:\Program Files\Python38\lib\site-packages\dask\array\core.py"", line 1768, in store
    r = store([self], [target], **kwargs)
  File ""C:\Program Files\Python38\lib\site-packages\dask\array\core.py"", line 1236, in store
    compute_as_if_collection(Array, store_dsk, map_keys, **kwargs)
  File ""C:\Program Files\Python38\lib\site-packages\dask\base.py"", line 341, in compute_as_if_collection
    return schedule(dsk2, keys, **kwargs)
  File ""C:\Program Files\Python38\lib\site-packages\dask\threaded.py"", line 89, in get
    results = get_async(
  File ""C:\Program Files\Python38\lib\site-packages\dask\local.py"", line 511, in get_async
    raise_exception(exc, tb)
  File ""C:\Program Files\Python38\lib\site-packages\dask\local.py"", line 319, in reraise
    raise exc
  File ""C:\Program Files\Python38\lib\site-packages\dask\local.py"", line 224, in execute_task
    result = _execute_task(task, data)
  File ""C:\Program Files\Python38\lib\site-packages\dask\core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
  File ""C:\Program Files\Python38\lib\site-packages\dask\array\chunk.py"", line 427, in getitem
    result = result.copy()
numpy.core._exceptions.MemoryError: Unable to allocate 31.7 MiB for an array with shape (25, 1000, 166) and data type int64
```

**Environment**:

- Dask version: 2023.3.1
- Python version: 3.8.10
- Operating System: Windows 10
- Install method (conda, pip, source): pip",,https://api.github.com/repos/dask/dask/issues/10080/timeline,,,Dobatymo,7647594,MDQ6VXNlcjc2NDc1OTQ=,https://avatars.githubusercontent.com/u/7647594?v=4,,https://api.github.com/users/Dobatymo,https://github.com/Dobatymo,https://api.github.com/users/Dobatymo/followers,https://api.github.com/users/Dobatymo/following{/other_user},https://api.github.com/users/Dobatymo/gists{/gist_id},https://api.github.com/users/Dobatymo/starred{/owner}{/repo},https://api.github.com/users/Dobatymo/subscriptions,https://api.github.com/users/Dobatymo/orgs,https://api.github.com/users/Dobatymo/repos,https://api.github.com/users/Dobatymo/events{/privacy},https://api.github.com/users/Dobatymo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10080/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
829,https://api.github.com/repos/dask/dask/issues/10083,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10083/labels{/name},https://api.github.com/repos/dask/dask/issues/10083/comments,https://api.github.com/repos/dask/dask/issues/10083/events,https://github.com/dask/dask/issues/10083,1629521033,I_kwDOAbcwm85hIISJ,10083,Consider using `pd.util.hash_pandas_object` for `pandas` tokenization,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450421, 'node_id': 'LA_kwDOAbcwm87iZ8D1', 'url': 'https://api.github.com/repos/dask/dask/labels/hygiene', 'name': 'hygiene', 'color': 'b5ccfa', 'default': False, 'description': 'Improve code quality and reduce maintenance overhead'}]",open,False,,[],,0,2023-03-17T15:35:56Z,2023-04-17T01:53:20Z,,MEMBER,,"`pandas` as a [`pd.util.hash_pandas_object` utility](https://pandas.pydata.org/docs/reference/api/pandas.util.hash_pandas_object.html) for hashing data in `pd.Index`, `pd.Series`, and `pd.DataFrame` objects. We might consider using this utility in our tokenization code, if the functionality suites our needs and doesn't introduce serious performance regressions, since we currently rely on some private `pandas` methods. I don't think this is high priority, just wanted to document this idea. 

cc @phofl for visibility",,https://api.github.com/repos/dask/dask/issues/10083/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10083/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
830,https://api.github.com/repos/dask/dask/issues/10084,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10084/labels{/name},https://api.github.com/repos/dask/dask/issues/10084/comments,https://api.github.com/repos/dask/dask/issues/10084/events,https://github.com/dask/dask/issues/10084,1629612679,I_kwDOAbcwm85hIeqH,10084,Fine performance metrics: decorate dask/dask,"[{'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-03-17T16:37:09Z,2024-02-19T01:45:18Z,,MEMBER,,"- Part of dask/distributed#7665

In the demo of dask/distributed#7586, you can spot ""I/O"" time in the collected metrics. This was possible by decorating I/O heavy dask/dask functions:

```patch
--- a/dask/dataframe/io/parquet/core.py
+++ b/dask/dataframe/io/parquet/core.py
@@ -27,6 +27,8 @@ from dask.highlevelgraph import HighLevelGraph
 from dask.layers import DataFrameIOLayer
 from dask.utils import apply, import_required, natural_sort_key, parse_bytes
 
+from distributed.metrics import context_meter
+
 __all__ = (""read_parquet"", ""to_parquet"")
 
 NONE_LABEL = ""__null_dask_index__""
@@ -158,6 +160,7 @@ class ToParquetFunctionWrapper:
             self.kwargs_pass,
         )
 
+    @context_meter.meter(""thread-I/O"")
     def __call__(self, df, block_index: tuple[int]):
         # Get partition index from block index tuple
         part_i = block_index[0]
@@ -643,6 +646,7 @@ def check_multi_support(engine):
     return hasattr(engine, ""multi_support"") and engine.multi_support()
 
 
+@context_meter.meter(""thread-I/O"")
 def read_parquet_part(
     fs, engine, meta, part, columns, index, use_nullable_dtypes, kwargs
 ):
```
without the above, I/O heavy tasks would be broadly classified as ""thread-noncpu"", which also includes GIL contention, higher load than there are physical CPUs, and context switch overhead.
We should decorate all functions in dask/dask that perform I/O as in the above example, with a trivial dummy contextmanager in case distributed is not installed.
",,https://api.github.com/repos/dask/dask/issues/10084/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10084/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
831,https://api.github.com/repos/dask/dask/issues/10107,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10107/labels{/name},https://api.github.com/repos/dask/dask/issues/10107/comments,https://api.github.com/repos/dask/dask/issues/10107/events,https://github.com/dask/dask/pull/10107,1636335748,PR_kwDOAbcwm85MrD-0,10107,install dask as part of the dask docs instructions,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,0,2023-03-22T18:56:35Z,2023-03-22T18:56:57Z,,MEMBER,,"- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10107/timeline,,,graingert,413772,MDQ6VXNlcjQxMzc3Mg==,https://avatars.githubusercontent.com/u/413772?v=4,,https://api.github.com/users/graingert,https://github.com/graingert,https://api.github.com/users/graingert/followers,https://api.github.com/users/graingert/following{/other_user},https://api.github.com/users/graingert/gists{/gist_id},https://api.github.com/users/graingert/starred{/owner}{/repo},https://api.github.com/users/graingert/subscriptions,https://api.github.com/users/graingert/orgs,https://api.github.com/users/graingert/repos,https://api.github.com/users/graingert/events{/privacy},https://api.github.com/users/graingert/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10107/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10107,https://github.com/dask/dask/pull/10107,https://github.com/dask/dask/pull/10107.diff,https://github.com/dask/dask/pull/10107.patch,,,,,,,,,,,,,,,,,,,
832,https://api.github.com/repos/dask/dask/issues/10117,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10117/labels{/name},https://api.github.com/repos/dask/dask/issues/10117/comments,https://api.github.com/repos/dask/dask/issues/10117/events,https://github.com/dask/dask/issues/10117,1641285992,I_kwDOAbcwm85h1Alo,10117,dask cannot handle data larger than its memory resources,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2023-03-27T03:07:11Z,2023-05-01T01:53:59Z,,NONE,,"I had some issues reading large tables with dask. dask cluster has three nodes, each node 1g memory, I need to read 5G size table in MPP database through this dask cluster, perform corresponding update operation and store back in MPP database. However, at the beginning of the read_sql_table statement, all three workers have failed. From the dask dashboard, you can see that the workers have spilled memory data to disk, but they still do not work. How can I avoid this situation? For Dask, I think it should be able to handle more data than its own memory resources.

The code is shown below:
`df = dd.read_sql_table('test_mpp_5g', conn, index_col=""id"", schema=""schema"")   # error`
`df = df[df[""col3""].notnull()]`
`df.to_sql(""test_after_process"", conn, if_exists=""replace"")`


![dask_error](https://user-images.githubusercontent.com/48116592/227831254-a9804ca4-ab72-4ada-be68-b313e80b18c3.png)
",,https://api.github.com/repos/dask/dask/issues/10117/timeline,,reopened,Reggieharden,48116592,MDQ6VXNlcjQ4MTE2NTky,https://avatars.githubusercontent.com/u/48116592?v=4,,https://api.github.com/users/Reggieharden,https://github.com/Reggieharden,https://api.github.com/users/Reggieharden/followers,https://api.github.com/users/Reggieharden/following{/other_user},https://api.github.com/users/Reggieharden/gists{/gist_id},https://api.github.com/users/Reggieharden/starred{/owner}{/repo},https://api.github.com/users/Reggieharden/subscriptions,https://api.github.com/users/Reggieharden/orgs,https://api.github.com/users/Reggieharden/repos,https://api.github.com/users/Reggieharden/events{/privacy},https://api.github.com/users/Reggieharden/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10117/reactions,0,0,0,0,0,0,0,0,0,Reggieharden,48116592.0,MDQ6VXNlcjQ4MTE2NTky,https://avatars.githubusercontent.com/u/48116592?v=4,,https://api.github.com/users/Reggieharden,https://github.com/Reggieharden,https://api.github.com/users/Reggieharden/followers,https://api.github.com/users/Reggieharden/following{/other_user},https://api.github.com/users/Reggieharden/gists{/gist_id},https://api.github.com/users/Reggieharden/starred{/owner}{/repo},https://api.github.com/users/Reggieharden/subscriptions,https://api.github.com/users/Reggieharden/orgs,https://api.github.com/users/Reggieharden/repos,https://api.github.com/users/Reggieharden/events{/privacy},https://api.github.com/users/Reggieharden/received_events,User,False,,,,,,,,,,,,,,,,,,,,,,,,
833,https://api.github.com/repos/dask/dask/issues/10119,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10119/labels{/name},https://api.github.com/repos/dask/dask/issues/10119/comments,https://api.github.com/repos/dask/dask/issues/10119/events,https://github.com/dask/dask/issues/10119,1642325227,I_kwDOAbcwm85h4-Tr,10119,Better indicate which utilities are private vs. public,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450421, 'node_id': 'LA_kwDOAbcwm87iZ8D1', 'url': 'https://api.github.com/repos/dask/dask/labels/hygiene', 'name': 'hygiene', 'color': 'b5ccfa', 'default': False, 'description': 'Improve code quality and reduce maintenance overhead'}]",open,False,,[],,6,2023-03-27T15:28:56Z,2023-05-01T01:53:58Z,,MEMBER,,"We have lots of utilities throughout our codebase and we're not very vigilant about indicating which ones are intended to be public and which are private. Some methods like `dask.utils._deprecated` are marked as private

https://github.com/dask/dask/blob/0cbc46ac89b6f6a2cf949f2fd73c4c1175419db5/dask/utils.py#L78-L85

but most aren't marked with a leading underscore and also aren't meant for public consumption. 

This lack of public vs. private specification causes issues like https://github.com/dask/dask/issues/10112. I think we should move utilities are that are intended to be private into a private module (e.g. `dask._utils`) -- we'll also want to emit deprecation warnings appropriately. 

Note that we do have [some public utilities](https://docs.dask.org/en/stable/api.html#utilities), so this wouldn't be a blanket ""move everything into private modules"". But I suspect most things in, for example, `dask.utils_test` and `dask.compatibility` can be moved over into private modules (xref https://github.com/dask/dask/pull/10114). 

cc @jacobtomlinson for visibility 

Also cc @fjetter @crusaderky @hendrikmakait as I think the same argument applies to `dask/distributed` 
",,https://api.github.com/repos/dask/dask/issues/10119/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10119/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
834,https://api.github.com/repos/dask/dask/issues/10131,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10131/labels{/name},https://api.github.com/repos/dask/dask/issues/10131/comments,https://api.github.com/repos/dask/dask/issues/10131/events,https://github.com/dask/dask/issues/10131,1649728914,I_kwDOAbcwm85iVN2S,10131,Retire `DataFrame.to_hdf`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450419, 'node_id': 'LA_kwDOAbcwm87iZ8Dz', 'url': 'https://api.github.com/repos/dask/dask/labels/deprecation', 'name': 'deprecation', 'color': 'f4e49a', 'default': False, 'description': 'Something is being removed'}]",open,False,,[],,5,2023-03-31T17:10:34Z,2023-05-08T01:53:08Z,,MEMBER,,"As suggested by @mrocklin in https://github.com/dask/distributed/pull/7720#issuecomment-1488800571, we should retire `DataFrame.to_hdf` as legacy storage format that causes some issues during maintenance.

**Open question**
Should we remove more HDF-related code?",,https://api.github.com/repos/dask/dask/issues/10131/timeline,,,hendrikmakait,2699097,MDQ6VXNlcjI2OTkwOTc=,https://avatars.githubusercontent.com/u/2699097?v=4,,https://api.github.com/users/hendrikmakait,https://github.com/hendrikmakait,https://api.github.com/users/hendrikmakait/followers,https://api.github.com/users/hendrikmakait/following{/other_user},https://api.github.com/users/hendrikmakait/gists{/gist_id},https://api.github.com/users/hendrikmakait/starred{/owner}{/repo},https://api.github.com/users/hendrikmakait/subscriptions,https://api.github.com/users/hendrikmakait/orgs,https://api.github.com/users/hendrikmakait/repos,https://api.github.com/users/hendrikmakait/events{/privacy},https://api.github.com/users/hendrikmakait/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10131/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
835,https://api.github.com/repos/dask/dask/issues/10132,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10132/labels{/name},https://api.github.com/repos/dask/dask/issues/10132/comments,https://api.github.com/repos/dask/dask/issues/10132/events,https://github.com/dask/dask/pull/10132,1649988162,PR_kwDOAbcwm85NYoLH,10132,Added warn function to simplify warn imports,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2023-03-31T20:28:18Z,2024-02-19T01:45:16Z,,FIRST_TIME_CONTRIBUTOR,,"- [x] Closes #9393
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10132/timeline,,,DavidNguyen2002,90231772,MDQ6VXNlcjkwMjMxNzcy,https://avatars.githubusercontent.com/u/90231772?v=4,,https://api.github.com/users/DavidNguyen2002,https://github.com/DavidNguyen2002,https://api.github.com/users/DavidNguyen2002/followers,https://api.github.com/users/DavidNguyen2002/following{/other_user},https://api.github.com/users/DavidNguyen2002/gists{/gist_id},https://api.github.com/users/DavidNguyen2002/starred{/owner}{/repo},https://api.github.com/users/DavidNguyen2002/subscriptions,https://api.github.com/users/DavidNguyen2002/orgs,https://api.github.com/users/DavidNguyen2002/repos,https://api.github.com/users/DavidNguyen2002/events{/privacy},https://api.github.com/users/DavidNguyen2002/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10132/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10132,https://github.com/dask/dask/pull/10132,https://github.com/dask/dask/pull/10132.diff,https://github.com/dask/dask/pull/10132.patch,,,,,,,,,,,,,,,,,,,
836,https://api.github.com/repos/dask/dask/issues/10139,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10139/labels{/name},https://api.github.com/repos/dask/dask/issues/10139/comments,https://api.github.com/repos/dask/dask/issues/10139/events,https://github.com/dask/dask/issues/10139,1652991322,I_kwDOAbcwm85ihqVa,10139,[FEEDBACK] User experience with `arrow` strings,"[{'id': 964975428, 'node_id': 'MDU6TGFiZWw5NjQ5NzU0Mjg=', 'url': 'https://api.github.com/repos/dask/dask/labels/community', 'name': 'community', 'color': 'd93f0b', 'default': False, 'description': ''}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 6137710172, 'node_id': 'LA_kwDOAbcwm88AAAABbdYGXA', 'url': 'https://api.github.com/repos/dask/dask/labels/convert-string', 'name': 'convert-string', 'color': 'd93f0b', 'default': False, 'description': ''}]",open,False,,[],,13,2023-04-04T00:57:15Z,2024-02-19T01:45:15Z,,MEMBER,,"This is an issue where you can report your experience with `arrow` strings.

Please let us know what works well, but also what doesn't. We'll help as best we can.",,https://api.github.com/repos/dask/dask/issues/10139/timeline,,,j-bennet,637013,MDQ6VXNlcjYzNzAxMw==,https://avatars.githubusercontent.com/u/637013?v=4,,https://api.github.com/users/j-bennet,https://github.com/j-bennet,https://api.github.com/users/j-bennet/followers,https://api.github.com/users/j-bennet/following{/other_user},https://api.github.com/users/j-bennet/gists{/gist_id},https://api.github.com/users/j-bennet/starred{/owner}{/repo},https://api.github.com/users/j-bennet/subscriptions,https://api.github.com/users/j-bennet/orgs,https://api.github.com/users/j-bennet/repos,https://api.github.com/users/j-bennet/events{/privacy},https://api.github.com/users/j-bennet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10139/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
837,https://api.github.com/repos/dask/dask/issues/10143,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10143/labels{/name},https://api.github.com/repos/dask/dask/issues/10143/comments,https://api.github.com/repos/dask/dask/issues/10143/events,https://github.com/dask/dask/pull/10143,1654272189,PR_kwDOAbcwm85Nmx2B,10143,Adapt RangeIndex for empty merge result with pandas 2.0,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-04-04T17:18:01Z,2024-02-19T01:45:15Z,,MEMBER,,"- [x] xref #9957
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

This would keep the RangeIndex for pandas 2.0 and up instead of the input Index.

The test is somewhat covered from other tests, but I like having an explicit test that is easy to understand.",,https://api.github.com/repos/dask/dask/issues/10143/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10143/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10143,https://github.com/dask/dask/pull/10143,https://github.com/dask/dask/pull/10143.diff,https://github.com/dask/dask/pull/10143.patch,,,,,,,,,,,,,,,,,,,
838,https://api.github.com/repos/dask/dask/issues/10151,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10151/labels{/name},https://api.github.com/repos/dask/dask/issues/10151/comments,https://api.github.com/repos/dask/dask/issues/10151/events,https://github.com/dask/dask/issues/10151,1655744612,I_kwDOAbcwm85isKhk,10151,Automatic versioning: use `setuptools_scm[toml]` over `versioneer`,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,4,2023-04-05T14:31:25Z,2024-02-19T01:45:14Z,,MEMBER,,"@douglasdavis I'm definitely in favour of dropping versioneer in favour of setuptools_scm or hatch-vcs would you like to open an issue for this?

_Originally posted by @graingert in https://github.com/dask/dask/pull/10102#discussion_r1158570277_

More info:

Using `versioneer` requires tracking an automatically generated file in the version control source tree; `setuptools_scm` (and other tools like `hatch-vcs`) generate the file only at build time (when preparing the sdist tarball and the wheel). Since Dask is using `setuptools`, it would be natural to use `setuptools_scm`. This doesn't change any requirements for Dask; it's just a build/packaging time requirement.",,https://api.github.com/repos/dask/dask/issues/10151/timeline,,,douglasdavis,3202090,MDQ6VXNlcjMyMDIwOTA=,https://avatars.githubusercontent.com/u/3202090?v=4,,https://api.github.com/users/douglasdavis,https://github.com/douglasdavis,https://api.github.com/users/douglasdavis/followers,https://api.github.com/users/douglasdavis/following{/other_user},https://api.github.com/users/douglasdavis/gists{/gist_id},https://api.github.com/users/douglasdavis/starred{/owner}{/repo},https://api.github.com/users/douglasdavis/subscriptions,https://api.github.com/users/douglasdavis/orgs,https://api.github.com/users/douglasdavis/repos,https://api.github.com/users/douglasdavis/events{/privacy},https://api.github.com/users/douglasdavis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10151/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
839,https://api.github.com/repos/dask/dask/issues/10158,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10158/labels{/name},https://api.github.com/repos/dask/dask/issues/10158/comments,https://api.github.com/repos/dask/dask/issues/10158/events,https://github.com/dask/dask/pull/10158,1657965284,PR_kwDOAbcwm85Ny-io,10158,Loosen optional `distributed` dependency to allow for patch releases,[],open,False,,[],,2,2023-04-06T19:58:15Z,2024-02-19T01:45:13Z,,MEMBER,,"This should make it such that future patch releases of distributed are picked up with `pip install dask[distributed]`

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10158/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10158/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10158,https://github.com/dask/dask/pull/10158,https://github.com/dask/dask/pull/10158.diff,https://github.com/dask/dask/pull/10158.patch,,,,,,,,,,,,,,,,,,,
840,https://api.github.com/repos/dask/dask/issues/10167,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10167/labels{/name},https://api.github.com/repos/dask/dask/issues/10167/comments,https://api.github.com/repos/dask/dask/issues/10167/events,https://github.com/dask/dask/pull/10167,1661692278,PR_kwDOAbcwm85N-4AS,10167,Modify pip install command for development,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,6,2023-04-11T03:00:33Z,2024-02-19T01:45:12Z,,MEMBER,,"Changes the `pip install` command used to set up a dev environment, in a way which should avoid the potential for the dependency conflicts seen in https://github.com/dask/dask/issues/9862 while also installing Distributed from source, which better matches what is being done in the conda dev environments.

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10167/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10167/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10167,https://github.com/dask/dask/pull/10167,https://github.com/dask/dask/pull/10167.diff,https://github.com/dask/dask/pull/10167.patch,,,,,,,,,,,,,,,,,,,
841,https://api.github.com/repos/dask/dask/issues/10174,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10174/labels{/name},https://api.github.com/repos/dask/dask/issues/10174/comments,https://api.github.com/repos/dask/dask/issues/10174/events,https://github.com/dask/dask/pull/10174,1662906672,PR_kwDOAbcwm85OC967,10174,Modify nightly version strings to avoid clashing with stable pinnings,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-04-11T17:03:21Z,2023-05-15T01:54:47Z,,MEMBER,,"Modifies the version/build strings of the published nightlies like so:

```
dask-core-2023.3.3a230410-py_g011f170f6_27 => dask-core-2023.3.3.a-py_230410_g011f170f6_27
```

The reasoning here is to get nightly versions parsed as `=2023.3.3.0a0`, which will prevent them from getting installed if we specify `dask==2023.3.2`.

xref https://github.com/dask/distributed/pull/7769

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10174/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10174/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10174,https://github.com/dask/dask/pull/10174,https://github.com/dask/dask/pull/10174.diff,https://github.com/dask/dask/pull/10174.patch,,,,,,,,,,,,,,,,,,,
842,https://api.github.com/repos/dask/dask/issues/10175,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10175/labels{/name},https://api.github.com/repos/dask/dask/issues/10175/comments,https://api.github.com/repos/dask/dask/issues/10175/events,https://github.com/dask/dask/issues/10175,1662912257,I_kwDOAbcwm85jHgcB,10175,Anything that imports dask.array.chunk_types will incur a 1GB spike in memory,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,6,2023-04-11T17:07:44Z,2024-02-12T01:45:00Z,,NONE,,"We discovered this while tracking down a memory spike induced by `importing xarray`, which we traced to [this cupy import in the dask code (in dask/array/chunk_types.py#L108](https://github.com/dask/dask/blob/35554159781b2f5b7fecbd967ea76e90f97cb63c/dask/array/chunk_types.py#L108):

Per the below, there's a handful of 100M shared libraries that all get opened.
```
files=$(strace -fTty python -c ""import cupy"" |& grep -v ""No such"" | grep open | grep -e pyc -e '.so' | cut -d' ' -f3)    
for file in $files; do file=$(echo $file | tr -d ""'"" | tr -d '""' | tr -d ','); if ls -Lsh $file 2>/dev/null & [ -f $file ]; then ls -Lsh $file; fi; done | grep ""M "" | sort | uniq | less

117M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/cupy_backends/cuda/libs/../../../../../libcublas.so.11
11M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/numpy/core/../../../../libcblas.so.3
11M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/numpy/linalg/../../../../libblas.so.3
11M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/numpy/linalg/../../../../liblapack.so.3
1.2M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/cupy_backends/cuda/libs/cusolver.cpython-38-x86_64-linux-gnu.so
12M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/cupy/_core/../../../../libstdc++.so.6
1.3M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/numpy/core/../../../../libgomp.so.1
1.5M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/cupy_backends/cuda/libs/cusparse.cpython-38-x86_64-linux-gnu.so
15M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/numpy/core/../../../../libmkl_vml_avx2.so.2
1.5M /company/software/rhel8/gcc-10.2.0/lib64/libgomp.so
17M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/numpy/core/../../../../libmkl_gf_lp64.so.2
205M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/cupy_backends/cuda/libs/../../../../../libcusolver.so.11
2.1M /usr/lib64/libm.so.6
225M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/cupy_backends/cuda/libs/../../../../../libcusparse.so.11
252M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/cupy_backends/cuda/libs/../../../../../libcublasLt.so.11
30M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/numpy/core/../../../../libmkl_gnu_thread.so.2
3.1M /usr/lib64/libc.so.6
3.2M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/lib-dynload/../../libcrypto.so.1.1
48M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/numpy/core/../../../../libmkl_avx2.so.2
5.3M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/numpy/core/_multiarray_umath.cpython-38-x86_64-linux-gnu.so
71M /team/public/conda/miniconda3-team.3/envs/team_conda3/lib/python3.8/site-packages/numpy/core/../../../../libmkl_core.so.2

```
Adding these sizes together yields a sum of ~1000MB

**Environment**:

- Dask version:
```
  - dask=2022.9.2=pyhd8ed1ab_0
  - dask-core=2022.9.2=pyhd8ed1ab_0
  - dask-jobqueue=0.8.1=pyhd8ed1ab_0
```
- Python version: 3.8
- Operating System: rhel 8.3
- Install method (conda, pip, source): conda

Is there any way to avoid this expensive import when importing dask, or xarray?",,https://api.github.com/repos/dask/dask/issues/10175/timeline,,,zbs,1444551,MDQ6VXNlcjE0NDQ1NTE=,https://avatars.githubusercontent.com/u/1444551?v=4,,https://api.github.com/users/zbs,https://github.com/zbs,https://api.github.com/users/zbs/followers,https://api.github.com/users/zbs/following{/other_user},https://api.github.com/users/zbs/gists{/gist_id},https://api.github.com/users/zbs/starred{/owner}{/repo},https://api.github.com/users/zbs/subscriptions,https://api.github.com/users/zbs/orgs,https://api.github.com/users/zbs/repos,https://api.github.com/users/zbs/events{/privacy},https://api.github.com/users/zbs/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10175/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
843,https://api.github.com/repos/dask/dask/issues/10178,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10178/labels{/name},https://api.github.com/repos/dask/dask/issues/10178/comments,https://api.github.com/repos/dask/dask/issues/10178/events,https://github.com/dask/dask/issues/10178,1663517204,I_kwDOAbcwm85jJ0IU,10178,"""Horizontal"" task aggregation - `delayed` argument to force single task?","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-04-12T01:39:21Z,2023-05-15T01:54:46Z,,NONE,,"# Idea
Would it not be useful to have a Boolean ""is_single_task"" argument in `delayed` to force calls to functions it wraps to be considered as a single task in `HighLevelGraph`s?
Is there another designed mechanism to make dask merge tasks ""horizontally"" (vs [`fuse`](https://docs.dask.org/en/latest/optimize.html#dask.optimization.fuse)'s ""vertical"" merging of linear tasks)?

With this functionality, a long list of quick computations from a single layer (whose scheduling and serialising overhead would be greater than execution) could be forced to execute in a fixed number of heavier tasks by calling a delayed function on batches of them.
Other functions or methods beside `delayed` might benefit from such an argument as well.

# Example use-case
What is the intended dask approach to optimising the following processing pattern (which could occur back-to-back in a broader project)?
  - Some (dask) dataframes go in
  - Many functions taking them as inputs and producing (varying numbers of) new columns are grouped in batches and executed
  - The new columns are `dd.concat`-enated into new dataframes (or added to the input dataframes)

The ideal way would be to let each batch-computation be a single task.

Currently, if the batching is attempted there is no effect on the `HighLevelGraph`, i.e. all individual tasks are still present (rather than one task per batch).
There is no obvious way to apply [optimisation functions](https://docs.dask.org/en/stable/optimize.html) to achieve ""horizontal"" task merging in [`delayed`](https://docs.dask.org/en/stable/delayed-api.html#dask.delayed.delayed) or on the [ `HighLevelGraph`](https://docs.dask.org/en/stable/high-level-graphs.html)s of the final objects.

# Slightly-related issues
Both issues deal only with ""vertical"" (and no ""horizontal"") task merging:
- #6219: approaches to using the `fuse` optimisation. This can be done in two ways; using the use-case above:
   ```Python
  from dask.optimization import fuse
  from dask.delayed import Delayed
  from dask import delayed
  
  # Set a name for the final graph node (the last `delayed` or dask dataframe operation)
  res_dfs = delayed(function_producing_dfs, nout = number_of_dfs)(some_arguments, dask_key_name = RECOGNISABLE_NAME)
  # Convert the graph to a dictionary and fuse it
  fused_graph, dependencies = fuse(res_dfs.dask.to_dict())
  # Create a new delayed object and compute it
  fused_delayed = Delayed(RECOGNISABLE_NAME, fused_graph)
  fused_delayed.compute()
  ```
  or, more succinctly,
  ```Python
  import dask
  
  with dask.config.set({'optimization.fuse.active': True, 'optimization.fuse.ave-width': 4}):
    res_df1, res_df2, ... = dask.optimize(res_df1, res_df2, ...)
  ```
- #8448: debating running `fuse` automatically for `delayed` objects",,https://api.github.com/repos/dask/dask/issues/10178/timeline,,,T-Flet,6699494,MDQ6VXNlcjY2OTk0OTQ=,https://avatars.githubusercontent.com/u/6699494?v=4,,https://api.github.com/users/T-Flet,https://github.com/T-Flet,https://api.github.com/users/T-Flet/followers,https://api.github.com/users/T-Flet/following{/other_user},https://api.github.com/users/T-Flet/gists{/gist_id},https://api.github.com/users/T-Flet/starred{/owner}{/repo},https://api.github.com/users/T-Flet/subscriptions,https://api.github.com/users/T-Flet/orgs,https://api.github.com/users/T-Flet/repos,https://api.github.com/users/T-Flet/events{/privacy},https://api.github.com/users/T-Flet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10178/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
844,https://api.github.com/repos/dask/dask/issues/10183,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10183/labels{/name},https://api.github.com/repos/dask/dask/issues/10183/comments,https://api.github.com/repos/dask/dask/issues/10183/events,https://github.com/dask/dask/issues/10183,1665343685,I_kwDOAbcwm85jQyDF,10183,Windows builds on Python 3.8 and 3.9 are failing,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-04-12T22:20:27Z,2023-05-15T01:54:45Z,,MEMBER,,"We started seeing some interesting (unrelated) failures on PRs with errors like 

```python
concurrent.futures.process.BrokenProcessPool: A process in the process pool was terminated
abruptly while the future was running or pending.
```

I ran a CI build against `main` and saw these failures (see [these](https://github.com/dask/dask/actions/runs/4682910082/jobs/8297351447) [build](https://github.com/dask/dask/actions/runs/4682910082/jobs/8297351582)) while the latest commit on `main` https://github.com/dask/dask/commit/fd31b9b67e105f4c63b391f5c24959e39e27a0cc doesn't have these failures. This makes me think that the source if these failures is outside of `dask/dask` itself. 

The next thing I would do here is `diff` the installed packages between the successful builds in https://github.com/dask/dask/commit/fd31b9b67e105f4c63b391f5c24959e39e27a0cc vs. the unsuccessful builds [here](https://github.com/dask/dask/actions/runs/4682910082/jobs/8297351447) and [here](https://github.com/dask/dask/actions/runs/4682910082/jobs/8297351582) to see what dependencies have changed. Hopefully that helps provide some insight. 

cc @rjzamora @charlesbluca @phofl @graingert is this something you have bandwidth to look into? ",,https://api.github.com/repos/dask/dask/issues/10183/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10183/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
845,https://api.github.com/repos/dask/dask/issues/10192,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10192/labels{/name},https://api.github.com/repos/dask/dask/issues/10192/comments,https://api.github.com/repos/dask/dask/issues/10192/events,https://github.com/dask/dask/pull/10192,1667441018,PR_kwDOAbcwm85OSQaZ,10192,Add workflow to build/publish nightly wheels,[],open,False,,[],,1,2023-04-14T03:10:55Z,2023-04-19T23:38:54Z,,MEMBER,,"Based on a discussion with @jakirkham and @vyasr in https://github.com/dask/dask/pull/10167, this adds a workflow to build and publish pre-release wheels to PyPI.

xref https://github.com/dask/distributed/pull/7775

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10192/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10192/reactions,1,0,0,0,1,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10192,https://github.com/dask/dask/pull/10192,https://github.com/dask/dask/pull/10192.diff,https://github.com/dask/dask/pull/10192.patch,,,,,,,,,,,,,,,,,,,
846,https://api.github.com/repos/dask/dask/issues/10193,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10193/labels{/name},https://api.github.com/repos/dask/dask/issues/10193/comments,https://api.github.com/repos/dask/dask/issues/10193/events,https://github.com/dask/dask/issues/10193,1667736506,I_kwDOAbcwm85jZ6O6,10193,Can I connect to the dask cluster through ingress,"[{'id': 964975428, 'node_id': 'MDU6TGFiZWw5NjQ5NzU0Mjg=', 'url': 'https://api.github.com/repos/dask/dask/labels/community', 'name': 'community', 'color': 'd93f0b', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2023-04-14T08:01:40Z,2024-02-12T01:44:58Z,,NONE,,The production environment requires cross cluster access. May I ask if it is possible to access the DASK cluster through ingress,,https://api.github.com/repos/dask/dask/issues/10193/timeline,,,ChenhanXmu,13248089,MDQ6VXNlcjEzMjQ4MDg5,https://avatars.githubusercontent.com/u/13248089?v=4,,https://api.github.com/users/ChenhanXmu,https://github.com/ChenhanXmu,https://api.github.com/users/ChenhanXmu/followers,https://api.github.com/users/ChenhanXmu/following{/other_user},https://api.github.com/users/ChenhanXmu/gists{/gist_id},https://api.github.com/users/ChenhanXmu/starred{/owner}{/repo},https://api.github.com/users/ChenhanXmu/subscriptions,https://api.github.com/users/ChenhanXmu/orgs,https://api.github.com/users/ChenhanXmu/repos,https://api.github.com/users/ChenhanXmu/events{/privacy},https://api.github.com/users/ChenhanXmu/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10193/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
847,https://api.github.com/repos/dask/dask/issues/10195,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10195/labels{/name},https://api.github.com/repos/dask/dask/issues/10195/comments,https://api.github.com/repos/dask/dask/issues/10195/events,https://github.com/dask/dask/issues/10195,1668123064,I_kwDOAbcwm85jbYm4,10195,Applying .map_overlap on an array returns array with small size,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-04-14T12:00:37Z,2024-02-12T01:44:57Z,,NONE,,"**Describe the issue**:
I want to apply a pixel classifier on a large image array (shape=(2704, 3556, 1748)). So I chunk it with dask to be able to fit it on the gpu. Then I use .map_overlap to generate the task and start the computation. The process seems to do the computation just fine, but it returns a tiny array (shape =(144, 484, 212)). I can't figure out why. 


**Minimal Complete Verifiable Example**:

```python
import apoc
import dask
import dask.array as da
import numpy as np
import h5py
import pyclesperanto_prototype as cle
print(cle.get_device())
cle.set_wait_for_kernel_finish(True)

image = np.random.randint(0, 128, size=(2704, 3556, 1748))
print(image.shape)
image_dask = da.from_array(image)
image_dask = image_dask.rechunk(chunks = (512,512,256))


features = apoc.PredefinedFeatureSet.object_size_3_to_8_px.value
def predict(image):
    print('processing image of size ',image.shape)
    features = apoc.PredefinedFeatureSet.object_size_3_to_8_px.value
    return classifier.predict(features=features, image = image)


classifier = apoc.PixelClassifier('pixel_classifier.txt')
classifier.output_probability_of_class = 1

print('compute map overlap')
mapped = image_dask.map_overlap(predict, depth = 10)

prediction = mapped.compute()
print(prediction.shape)



```

**Anything else we need to know?**:

I attached a working pixel classifier [pixel_classifier.txt](https://github.com/dask/dask/files/11232496/pixel_classifier.txt)
to reproduce the issue. I am running this on a NVIDIA GeForce RTX 3090 with 24GB of vram. The code behaves as expected when smaller images are used, so I don't know where something goes wrong. 

**Environment**:

- Dask version: 2023.3.2
- Python version:3.10
- Operating System: CentOS Linux 7 (Core)

- Install method (conda, pip, source): pip

",,https://api.github.com/repos/dask/dask/issues/10195/timeline,,,MalteMederacke,65277828,MDQ6VXNlcjY1Mjc3ODI4,https://avatars.githubusercontent.com/u/65277828?v=4,,https://api.github.com/users/MalteMederacke,https://github.com/MalteMederacke,https://api.github.com/users/MalteMederacke/followers,https://api.github.com/users/MalteMederacke/following{/other_user},https://api.github.com/users/MalteMederacke/gists{/gist_id},https://api.github.com/users/MalteMederacke/starred{/owner}{/repo},https://api.github.com/users/MalteMederacke/subscriptions,https://api.github.com/users/MalteMederacke/orgs,https://api.github.com/users/MalteMederacke/repos,https://api.github.com/users/MalteMederacke/events{/privacy},https://api.github.com/users/MalteMederacke/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10195/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
848,https://api.github.com/repos/dask/dask/issues/10196,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10196/labels{/name},https://api.github.com/repos/dask/dask/issues/10196/comments,https://api.github.com/repos/dask/dask/issues/10196/events,https://github.com/dask/dask/issues/10196,1668497574,I_kwDOAbcwm85jc0Cm,10196,Replace flake8 with ruff,"[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,6,2023-04-14T15:46:20Z,2024-02-12T01:44:56Z,,MEMBER,,"Ruff is a new linter written in Rust. 

Ruff is actively developed and would enable us to replace a bunch of different pre-commit hooks with ruff. pandas moved over a couple of months ago and we are quite happy with ruff. They are adding new rules constantly, so chances are high that we will be able to replace more stuff as time goes on. We could get rid of a couple of third party extensions like ``absolufy-imports``.

The readme explains most of the important things:

https://github.com/charliermarsh/ruff

cc @jrbourbeau @fjetter @crusaderky @graingert ",,https://api.github.com/repos/dask/dask/issues/10196/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10196/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
849,https://api.github.com/repos/dask/dask/issues/10198,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10198/labels{/name},https://api.github.com/repos/dask/dask/issues/10198/comments,https://api.github.com/repos/dask/dask/issues/10198/events,https://github.com/dask/dask/issues/10198,1668623743,I_kwDOAbcwm85jdS1_,10198,Can't rename column after read_csv when files have different column names,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,3,2023-04-14T17:07:36Z,2023-05-22T01:57:09Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**: When reading csv files with different column names `dask.dataframe.DataFrame.read_csv()`, renaming a column (shared by all files) before computing throws an error. This error doesn't occur if I don't do `.rename()` 

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd

data = dd.read_csv(""file*.csv"")
data.compute() # works fine
data.rename(columns=dict(c1=""c_new"")).compute() # error
```

```bash
$ cat file1.csv
c1,c2
1,1

$ cat file2.csv
c1,c3
1,1
```
Error:
```
ValueError: The columns in the computed data do not match the columns in the provided metadata
  Extra:   ['c3']
  Missing: ['c2']
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2023.3.0
- Python version: 3.11.0
- Operating System: Debian GNU/Linux 10
- Install method (conda, pip, source): conda (mamba)
",,https://api.github.com/repos/dask/dask/issues/10198/timeline,,,Puumanamana,39426440,MDQ6VXNlcjM5NDI2NDQw,https://avatars.githubusercontent.com/u/39426440?v=4,,https://api.github.com/users/Puumanamana,https://github.com/Puumanamana,https://api.github.com/users/Puumanamana/followers,https://api.github.com/users/Puumanamana/following{/other_user},https://api.github.com/users/Puumanamana/gists{/gist_id},https://api.github.com/users/Puumanamana/starred{/owner}{/repo},https://api.github.com/users/Puumanamana/subscriptions,https://api.github.com/users/Puumanamana/orgs,https://api.github.com/users/Puumanamana/repos,https://api.github.com/users/Puumanamana/events{/privacy},https://api.github.com/users/Puumanamana/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10198/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
850,https://api.github.com/repos/dask/dask/issues/10199,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10199/labels{/name},https://api.github.com/repos/dask/dask/issues/10199/comments,https://api.github.com/repos/dask/dask/issues/10199/events,https://github.com/dask/dask/issues/10199,1669291126,I_kwDOAbcwm85jf1x2,10199,reshape fails when the chunk size is larger than limit size,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-04-15T09:58:38Z,2024-02-12T01:44:54Z,,NONE,,"**Describe the issue**:
In my code, I try to reshape the array ```Y``` from shape ```(36,36,36,468)``` to ```(46656,468)``` and limit the max size to ```32MiB```. In this case, the chunk size of ```Y``` is ```(18,18,36,468)->(9,36,36,468)->(11664,468)```, which is larger than ```32MiB```(because the data type is complex128), so the chunk of ```Y``` is splited to ```(4266,468)```$\times 10$ and ```(3996,468)```$\times 1$. But when we compute or persist ```Y```, the following error arise:
```ValueError: cannot reshape array of size 5458752 into shape (4266,468)```
It seems that the dask array is trying to reshape the chunk ```(11664,468)``` to ```(4266,468)``` but not split.

**Minimal Complete Verifiable Example**:

```python
import dask.array as da
import numpy as np
Dcut=36
l=Dcut*13
N=int(Dcut**3)
n=2
rs = da.random.RandomState(seed=1234, RandomState=np.random.RandomState)

chunks_Y=(Dcut/n, Dcut/n, Dcut, l)
Y = rs.normal(size=(Dcut,Dcut,Dcut,l), chunks=chunks_Y).astype(np.complex128)
Y = da.reshape(Y, shape=(N,l), limit='32M')
Y=Y.persist()
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2023.1.1
- Python version: 3.10
- Operating System: Red Hat
- Install method (conda, pip, source): conda-forge
",,https://api.github.com/repos/dask/dask/issues/10199/timeline,,,LUOXIAO92,89069722,MDQ6VXNlcjg5MDY5NzIy,https://avatars.githubusercontent.com/u/89069722?v=4,,https://api.github.com/users/LUOXIAO92,https://github.com/LUOXIAO92,https://api.github.com/users/LUOXIAO92/followers,https://api.github.com/users/LUOXIAO92/following{/other_user},https://api.github.com/users/LUOXIAO92/gists{/gist_id},https://api.github.com/users/LUOXIAO92/starred{/owner}{/repo},https://api.github.com/users/LUOXIAO92/subscriptions,https://api.github.com/users/LUOXIAO92/orgs,https://api.github.com/users/LUOXIAO92/repos,https://api.github.com/users/LUOXIAO92/events{/privacy},https://api.github.com/users/LUOXIAO92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10199/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
851,https://api.github.com/repos/dask/dask/issues/10213,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10213/labels{/name},https://api.github.com/repos/dask/dask/issues/10213/comments,https://api.github.com/repos/dask/dask/issues/10213/events,https://github.com/dask/dask/issues/10213,1680743150,I_kwDOAbcwm85kLhru,10213,Drop Pandas 1,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-04-24T08:42:53Z,2024-02-12T01:44:53Z,,MEMBER,,"I expect the answer here to be ""whoa, not so fast"" but I thought I'd bring it up for discussion.

If we're spending non-trivial time supporting both then I think it's ok for us to do a bit of a clean break, especially if ...

-  this accelerates development
-  we don't see evidence that users are uncomfortable upgrading

Nothing for us to do right now, but I think that this is probably a valuable thought to have in the back of our minds.",,https://api.github.com/repos/dask/dask/issues/10213/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10213/reactions,1,0,0,0,0,0,0,1,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
852,https://api.github.com/repos/dask/dask/issues/10217,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10217/labels{/name},https://api.github.com/repos/dask/dask/issues/10217/comments,https://api.github.com/repos/dask/dask/issues/10217/events,https://github.com/dask/dask/issues/10217,1681038631,I_kwDOAbcwm85kMp0n,10217,matmul producing wrong results in local threaded mode in combination with Fortran-ordered arrays.,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,7,2023-04-24T11:24:56Z,2023-06-05T02:04:48Z,,NONE,,"**Describe the issue**:
While trying to dask-ify a somewhat complex memory-intensive numpy+scipy calculation which in theory is easily parallelizable into chunks (since it is basically rastering over the first two dimensions), I have found a bug leading to wrong and non-reproducible results.

 It works perfectly fine:
* without dask (pure numpy)
* with dask in the single-threaded scheduler. 
* with dask, but without without this particular operation

Based on my tests, it seems to be related to the numpy Fortran ordering of arrays (`inv_`)`matrix` below. The modulo operation is not important, you can also replace it with addition/subtraction. The error occurs if `inv_matrix` is Fortran-ordered, but `matrix` is not (or the other way around). If both are Fortran-ordered, it is also fine. However, the bug also only occurs if the previous reshape occurs.

```python
>>> b
<<< dask.array<reshape, shape=(7520000, 3), dtype=float64, chunksize=(2801200, 3), chunktype=numpy.ndarray>
>>> b2 = ((b @ inv_matrix) % 1 ) @ matrix  # modulo in a different basis, i.e. matrix, inv_matrix 3x3 numpy arrays with matrix @ inv_matrix ~= np.eye(3)
>>> b2 
<<< dask.array<getitem, shape=(7520000, 3), dtype=float64, chunksize=(2801200, 3), chunktype=numpy.ndarray>
```
lo and behold, calculations related to b2 start to give a different result each time:
```python
>>> ((b2)**2).sum(axis=1).max().compute()
<<< 9.46157028666362
>>> ((b2)**2).sum(axis=1).max().compute()
<<< 9.46157028666362
>>> ((b2)**2).sum(axis=1).max().compute()
<<< 470.2506360498207
```
<details>
  <summary>Computation visualisation of `b2` from minimum example below</summary>

![dask_bug2](https://user-images.githubusercontent.com/847751/234230336-4f8ab696-e20b-46c2-8789-15512ac8b6ba.svg)

</details>

**Minimal Complete Verifiable Example**:

```python
import numpy as np
import dask.array as da

mat = np.random.random((3, 3))
mat = np.asfortranarray(mat) # equivalently: mat = mat.T
mat_inv = np.linalg.inv(mat)
print(np.isfortran(mat), np.isfortran(mat_inv))

x = da.random.random((400, 400, 47, 3), chunks=(100, 400, 47, 3))
b = x.reshape(-1, 3)
b2 = ((b @ mat_inv) - 1) @ mat

print('[BUG] MT / ST')
while True:
    try:
        mt, st = b2.max().compute(), b2.max().compute(scheduler='single-threaded')
        print(f""[{'X' if mt != st else ' '}] {mt} / {st}"")
    except KeyboardInterrupt:
        break
```

Output
```
True False
[BUG] MT / ST
[ ] 0.010136448680771069 / 0.010136448680771069
[ ] 0.010136448680771069 / 0.010136448680771069
[X] 6.638389266935541 / 0.010136448680771069
[X] 6.5967108497788045 / 0.010136448680771069
[X] 6.527028598487698 / 0.010136448680771069
[X] 6.728268876668261 / 0.010136448680771069
[ ] 0.010136448680771069 / 0.010136448680771069
[X] 5.017877123758413 / 0.010136448680771069
[X] 3.729966956737955 / 0.010136448680771069
[X] 7.1588990147215075 / 0.010136448680771069
[ ] 0.010136448680771069 / 0.010136448680771069

Process finished with exit code 0


```


**Anything else we need to know?**:

**Environment**:

Tested configurations:

**bold** == no bug

- Dask version: **2.23.0**, **2020.12.0**, **2020.12.0+32.gff6c197f**, [2020.12.0+33.g51add4e5](https://github.com/dask/dask/commit/51add4e5c07fd0deb1b8cc179c7d66db9f8cc063), 2021.1.0, 2021.1.1, 2021.3.1, 2021.6.0, 2021.12.0, 2022.12.1, 2023.3.2, 2023.4.0
- Numpy Version: 1.17.5, 1.23.5, 1.24.0
- Install method (conda, pip, source): pip (in venv)

System 1:
- Python version: 3.11.2
- Operating System: Debian 12 (bookworm), Linux kernel 6.1.0
- CPU arch: x86_64 (AMD Ryzen 2200G)

System 2:
- Python version: 3.9.9
- Operating System: OpenSUSE Leap 15.4, Linux kernel 5.14.21
- CPU arch: x86_64 (Intel Xeon Gold 6244)",,https://api.github.com/repos/dask/dask/issues/10217/timeline,,,mueslo,847751,MDQ6VXNlcjg0Nzc1MQ==,https://avatars.githubusercontent.com/u/847751?v=4,,https://api.github.com/users/mueslo,https://github.com/mueslo,https://api.github.com/users/mueslo/followers,https://api.github.com/users/mueslo/following{/other_user},https://api.github.com/users/mueslo/gists{/gist_id},https://api.github.com/users/mueslo/starred{/owner}{/repo},https://api.github.com/users/mueslo/subscriptions,https://api.github.com/users/mueslo/orgs,https://api.github.com/users/mueslo/repos,https://api.github.com/users/mueslo/events{/privacy},https://api.github.com/users/mueslo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10217/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
853,https://api.github.com/repos/dask/dask/issues/10237,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10237/labels{/name},https://api.github.com/repos/dask/dask/issues/10237/comments,https://api.github.com/repos/dask/dask/issues/10237/events,https://github.com/dask/dask/pull/10237,1688616850,PR_kwDOAbcwm85PY8Rs,10237,Array.vindex performance improvements,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-04-28T14:01:17Z,2023-05-29T01:58:03Z,,FIRST_TIME_CONTRIBUTOR,,"This is a patch to `Array.vindex` that aims to:
1. Cut down on how long it takes to build the task graph
2. Reduce memory usage in some cases by avoiding copies of the index arrays

For execute time, I used the following code as a simple benchmark:
```python
import dask.array as da
import numpy as np
arr_1 = da.ones([6000, 6000], chunks=[3000, 3000])  # 36M elements in 4 chunks
idx = np.repeat(np.arange(0, 6000, 6), 1000)  # 1M index points
arr_2 = arr_1.vindex[idx, idx[::-1]]
```

Before this change the last line took 2.47s of wall clock time to execute. With this change it takes 22.1ms.

Regarding memory usage, I was motivated by my use case which involves accessing NetCDF files via Xarray and using `xarray.Dataset.isel`, which under the hood calls `da.Array.vindex` on many arrays using the same index values. The current `vindex` implementation always stores copies of the index arrays in the task graph, so an `isel` call could cause many index array copies to accumulate. This change stores the passed-in index arrays directly in the task graph, if possible.

This implementation essentially works the same way as the existing one, it just handles the bookkeeping data structures a bit differently. One consequence is that some of the index processing that used to happen when building the graph now happens at graph execution time. Nonetheless, in my testing graph execution performance also seems to have improved a bit: wall time for `arr_2.compute()` from the snippet above dropped from 632ms to 118ms.

I don't have much experience with Dask internals, but I hope this is a workable solution. Also, a couple questions:
1. Is it ok to store the passed-in index arrays directly in the task graph like this? If the caller goes on to mutate these arrays, this could cause surprising results. If it's not ok it'd be easy to change the code to make a copy and still benefit from the speedup. But I suspect it is ok, since a similar situation results just from calling `da.from_array` on a NumPy array.
2. From profing `vindex` I can see that more than half its time is now being spent hashing the index arrays in order to assign key names to graph nodes. Are there any alternatives for generating keys in this type of situation?",,https://api.github.com/repos/dask/dask/issues/10237/timeline,,,greg9q,9966211,MDQ6VXNlcjk5NjYyMTE=,https://avatars.githubusercontent.com/u/9966211?v=4,,https://api.github.com/users/greg9q,https://github.com/greg9q,https://api.github.com/users/greg9q/followers,https://api.github.com/users/greg9q/following{/other_user},https://api.github.com/users/greg9q/gists{/gist_id},https://api.github.com/users/greg9q/starred{/owner}{/repo},https://api.github.com/users/greg9q/subscriptions,https://api.github.com/users/greg9q/orgs,https://api.github.com/users/greg9q/repos,https://api.github.com/users/greg9q/events{/privacy},https://api.github.com/users/greg9q/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10237/reactions,3,3,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10237,https://github.com/dask/dask/pull/10237,https://github.com/dask/dask/pull/10237.diff,https://github.com/dask/dask/pull/10237.patch,,,,,,,,,,,,,,,,,,,
854,https://api.github.com/repos/dask/dask/issues/10238,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10238/labels{/name},https://api.github.com/repos/dask/dask/issues/10238/comments,https://api.github.com/repos/dask/dask/issues/10238/events,https://github.com/dask/dask/issues/10238,1689265116,I_kwDOAbcwm85ksCPc,10238,dask.array.store: support for distributed locks,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,3,2023-04-28T23:55:36Z,2024-02-05T01:45:53Z,,NONE,,"**Describe the issue**:
Calling `dask.array.store` with a `Lock`, a `distributed.Client` context, and a zarr target throws an error.

Please let me know if this should be filed elsewhere, with zarr or distributed.

**Minimal Complete Verifiable Example**:

```python
import dask.array as da
import zarr
from distributed import Client


def run_succeeds1():
    z_arr: zarr.Array = zarr.zeros(shape=(5, 5))
    d_arr: da.Array = da.from_zarr(z_arr)
    z = zarr.create(shape=d_arr.shape)
    with Client():
        return da.store(d_arr, z, lock=False)


def run_succeeds2():
    z_arr: zarr.Array = zarr.zeros(shape=(5, 5))
    d_arr: da.Array = da.from_zarr(z_arr)
    z = zarr.create(shape=d_arr.shape)
    return da.store(d_arr, z, lock=True)


def run_fails():
    z_arr: zarr.Array = zarr.zeros(shape=(5, 5))
    d_arr: da.Array = da.from_zarr(z_arr)
    z = zarr.create(shape=d_arr.shape)
    with Client():
        return da.store(d_arr, z, lock=True)


if __name__ == ""__main__"":
    run_succeeds1()
    run_succeeds2()
    # run_fails()

```

**Anything else we need to know?**:
The full stacktrace I get when I run `run_fails` is:

```
2023-04-28 19:51:54,465 - distributed.protocol.pickle - ERROR - Failed to serialize <ToPickle: HighLevelGraph with 1 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x7fb099e26560>
 0. 140396455233728
>.
Traceback (most recent call last):
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/distributed/protocol/pickle.py"", line 63, in dumps
    result = pickle.dumps(x, **dump_kwargs)
TypeError: cannot pickle '_thread.lock' object

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/distributed/protocol/pickle.py"", line 68, in dumps
    pickler.dump(x)
TypeError: cannot pickle '_thread.lock' object

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/distributed/protocol/pickle.py"", line 81, in dumps
    result = cloudpickle.dumps(x, **dump_kwargs)
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/cloudpickle/cloudpickle_fast.py"", line 73, in dumps
    cp.dump(obj)
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/cloudpickle/cloudpickle_fast.py"", line 632, in dump
    return Pickler.dump(self, obj)
TypeError: cannot pickle '_thread.lock' object
Traceback (most recent call last):
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/distributed/protocol/pickle.py"", line 63, in dumps
    result = pickle.dumps(x, **dump_kwargs)
TypeError: cannot pickle '_thread.lock' object

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/distributed/protocol/pickle.py"", line 68, in dumps
    pickler.dump(x)
TypeError: cannot pickle '_thread.lock' object

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/distributed/protocol/serialize.py"", line 350, in serialize
    header, frames = dumps(x, context=context) if wants_context else dumps(x)
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/distributed/protocol/serialize.py"", line 73, in pickle_dumps
    frames[0] = pickle.dumps(
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/distributed/protocol/pickle.py"", line 81, in dumps
    result = cloudpickle.dumps(x, **dump_kwargs)
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/cloudpickle/cloudpickle_fast.py"", line 73, in dumps
    cp.dump(obj)
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/cloudpickle/cloudpickle_fast.py"", line 632, in dump
    return Pickler.dump(self, obj)
TypeError: cannot pickle '_thread.lock' object

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/home/titanium/PycharmProjects/debug-ome-zarr/run.py"", line 32, in <module>
    run_fails()
  File ""/home/titanium/PycharmProjects/debug-ome-zarr/run.py"", line 26, in run_fails
    return da.store(d_arr, z, lock=True)
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/dask/array/core.py"", line 1237, in store
    compute_as_if_collection(Array, store_dsk, map_keys, **kwargs)
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/dask/base.py"", line 341, in compute_as_if_collection
    return schedule(dsk2, keys, **kwargs)
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/distributed/client.py"", line 3204, in get
    futures = self._graph_to_futures(
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/distributed/client.py"", line 3103, in _graph_to_futures
    header, frames = serialize(ToPickle(dsk), on_error=""raise"")
  File ""/home/titanium/.cache/pypoetry/virtualenvs/debug-ome-zarr-XhBiG45F-py3.10/lib/python3.10/site-packages/distributed/protocol/serialize.py"", line 372, in serialize
    raise TypeError(msg, str(x)[:10000]) from exc
TypeError: ('Could not serialize object of type HighLevelGraph', '<ToPickle: HighLevelGraph with 1 layers.\n<dask.highlevelgraph.HighLevelGraph object at 0x7fb099e26560>\n 0. 140396455233728\n>')

Process finished with exit code 1

```

**Environment**:
- Dask version: 2023.4.1
- Python version: 3.10.6
- Operating System: ubuntu 22.04
- Install method (conda, pip, source): poetry
",,https://api.github.com/repos/dask/dask/issues/10238/timeline,,,ahnsws,17461258,MDQ6VXNlcjE3NDYxMjU4,https://avatars.githubusercontent.com/u/17461258?v=4,,https://api.github.com/users/ahnsws,https://github.com/ahnsws,https://api.github.com/users/ahnsws/followers,https://api.github.com/users/ahnsws/following{/other_user},https://api.github.com/users/ahnsws/gists{/gist_id},https://api.github.com/users/ahnsws/starred{/owner}{/repo},https://api.github.com/users/ahnsws/subscriptions,https://api.github.com/users/ahnsws/orgs,https://api.github.com/users/ahnsws/repos,https://api.github.com/users/ahnsws/events{/privacy},https://api.github.com/users/ahnsws/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10238/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
855,https://api.github.com/repos/dask/dask/issues/10239,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10239/labels{/name},https://api.github.com/repos/dask/dask/issues/10239/comments,https://api.github.com/repos/dask/dask/issues/10239/events,https://github.com/dask/dask/issues/10239,1689526256,I_kwDOAbcwm85ktB_w,10239,The right way for a C extension to report CPU and GPU memory usage.,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,7,2023-04-29T11:18:26Z,2023-06-12T02:04:42Z,,CONTRIBUTOR,,"Hi Dask! I'm working on scaling XGBoost with Dask to larger datasets, one of the issues I encountered is this warning:

```
2023-04-08 02:03:01,840 - distributed.worker.memory - WARNING - Unmanaged memory use is high. This may indicate a memory leak or the memory may not be released to the OS; see https://distributed.dask.org/en/latest/worker-memory.html#memory-not-released-back-to-the-os for more information. -- Unmanaged memory: 73.54 GiB -- Worker memory limit: 93.72 GiB
2023-04-08 02:03:01,941 - distributed.worker.memory - WARNING - Unmanaged memory use is high. This may indicate a memory leak or the memory may not be released to the OS; see https://distributed.dask.org/en/latest/worker-memory.html#memory-not-released-back-to-the-os for more information. -- Unmanaged memory: 73.54 GiB -- Worker memory limit: 93.72 GiB
```
I think this is caused by XGBoost's data structures that don't report their memory usage to the Python interpretor nor Dask. I'm curious whether there are some protocals recommended by Dask for reporting memory usage for both CPU and GPU.

During training, XGBoost needs a lot of allocations that are not managed by dask, and the allocation happens inside a task (training). Adding a simple `__sizeof__` with basic estimation to some of the large structures doesn't seem to help change the warning.",,https://api.github.com/repos/dask/dask/issues/10239/timeline,,,trivialfis,16746409,MDQ6VXNlcjE2NzQ2NDA5,https://avatars.githubusercontent.com/u/16746409?v=4,,https://api.github.com/users/trivialfis,https://github.com/trivialfis,https://api.github.com/users/trivialfis/followers,https://api.github.com/users/trivialfis/following{/other_user},https://api.github.com/users/trivialfis/gists{/gist_id},https://api.github.com/users/trivialfis/starred{/owner}{/repo},https://api.github.com/users/trivialfis/subscriptions,https://api.github.com/users/trivialfis/orgs,https://api.github.com/users/trivialfis/repos,https://api.github.com/users/trivialfis/events{/privacy},https://api.github.com/users/trivialfis/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10239/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
856,https://api.github.com/repos/dask/dask/issues/10249,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10249/labels{/name},https://api.github.com/repos/dask/dask/issues/10249/comments,https://api.github.com/repos/dask/dask/issues/10249/events,https://github.com/dask/dask/pull/10249,1693774674,PR_kwDOAbcwm85PqG4O,10249,Re-implement mean to improve numerical stability and handle numeric_only,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,0,2023-05-03T10:10:50Z,2023-05-03T10:58:22Z,,MEMBER,,"- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`

This will need some refactoring, but want to check whether ci passes",,https://api.github.com/repos/dask/dask/issues/10249/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10249/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10249,https://github.com/dask/dask/pull/10249,https://github.com/dask/dask/pull/10249.diff,https://github.com/dask/dask/pull/10249.patch,,,,,,,,,,,,,,,,,,,
857,https://api.github.com/repos/dask/dask/issues/10265,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10265/labels{/name},https://api.github.com/repos/dask/dask/issues/10265/comments,https://api.github.com/repos/dask/dask/issues/10265/events,https://github.com/dask/dask/issues/10265,1697759484,I_kwDOAbcwm85lMcD8,10265,Clean up ``numeric_only`` tests to avoid generic fails,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450421, 'node_id': 'LA_kwDOAbcwm87iZ8D1', 'url': 'https://api.github.com/repos/dask/dask/labels/hygiene', 'name': 'hygiene', 'color': 'b5ccfa', 'default': False, 'description': 'Improve code quality and reduce maintenance overhead'}]",open,False,,[],,0,2023-05-05T14:53:41Z,2023-06-05T02:04:45Z,,MEMBER,,We should test for explicit error messages instead of generic xfailing tests. Can take care of this after the numeric_only PRs are merged.,,https://api.github.com/repos/dask/dask/issues/10265/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10265/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
858,https://api.github.com/repos/dask/dask/issues/10269,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10269/labels{/name},https://api.github.com/repos/dask/dask/issues/10269/comments,https://api.github.com/repos/dask/dask/issues/10269/events,https://github.com/dask/dask/pull/10269,1699182196,PR_kwDOAbcwm85P8ZZA,10269,Speed up graph_from_arraylike,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2023-05-07T18:30:32Z,2023-05-15T19:35:12Z,,CONTRIBUTOR,,"inspect is rather slow so it's not a good idea to trigger it multiple times like it was done with has_keyword.

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10269/timeline,,,Illviljan,14371165,MDQ6VXNlcjE0MzcxMTY1,https://avatars.githubusercontent.com/u/14371165?v=4,,https://api.github.com/users/Illviljan,https://github.com/Illviljan,https://api.github.com/users/Illviljan/followers,https://api.github.com/users/Illviljan/following{/other_user},https://api.github.com/users/Illviljan/gists{/gist_id},https://api.github.com/users/Illviljan/starred{/owner}{/repo},https://api.github.com/users/Illviljan/subscriptions,https://api.github.com/users/Illviljan/orgs,https://api.github.com/users/Illviljan/repos,https://api.github.com/users/Illviljan/events{/privacy},https://api.github.com/users/Illviljan/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10269/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10269,https://github.com/dask/dask/pull/10269,https://github.com/dask/dask/pull/10269.diff,https://github.com/dask/dask/pull/10269.patch,,,,,,,,,,,,,,,,,,,
859,https://api.github.com/repos/dask/dask/issues/10270,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10270/labels{/name},https://api.github.com/repos/dask/dask/issues/10270/comments,https://api.github.com/repos/dask/dask/issues/10270/events,https://github.com/dask/dask/issues/10270,1699217517,I_kwDOAbcwm85lSABt,10270,Poor performance with `read_csv` and many thousands of s3 files,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,"[{'login': 'milesgranger', 'id': 13764397, 'node_id': 'MDQ6VXNlcjEzNzY0Mzk3', 'avatar_url': 'https://avatars.githubusercontent.com/u/13764397?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/milesgranger', 'html_url': 'https://github.com/milesgranger', 'followers_url': 'https://api.github.com/users/milesgranger/followers', 'following_url': 'https://api.github.com/users/milesgranger/following{/other_user}', 'gists_url': 'https://api.github.com/users/milesgranger/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/milesgranger/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/milesgranger/subscriptions', 'organizations_url': 'https://api.github.com/users/milesgranger/orgs', 'repos_url': 'https://api.github.com/users/milesgranger/repos', 'events_url': 'https://api.github.com/users/milesgranger/events{/privacy}', 'received_events_url': 'https://api.github.com/users/milesgranger/received_events', 'type': 'User', 'site_admin': False}]",,4,2023-05-07T20:08:31Z,2023-06-12T02:04:39Z,,CONTRIBUTOR,,"## Use case
I'm trying to produce some rollups of cloudfront access log data. Cloudfront produces many thousands of csv files, usually very small (kilobytes). An example month of a relatively low usage cloudfront distribution is 30k files. It can be 100k+.

Rolling these up into parquet on a monthly basis is nice as it will make downstream operations much more efficient (interacting with thousands upon thousands of files on s3 adds a lot of overhead).

If listing millions of s3 objects didn't take forever I'd probably just create one giant parquet

## Issue

Something takes 15 minutes after calling `to_parquet` before a task graph appears on the scheduler.

I initially started with using `df.repartition(partition_size=""50mb"")`, I dropped it as I thought it might be the issue but it's not.

I did notice that `s3fs` had some poor performance when using a glob to get the monthly files (https://github.com/fsspec/s3fs/issues/733) . However fixing that it now takes just a few seconds to generate a list of 30k files to pass to `read_csv`. Then nothing happens. CPU/Network/Disk all remain low on my laptop, and on the remote scheduler.

When things finally start moving the resulting task graph is only about 20k tasks, nothing fancy. 

My intuition here is there's some very slow s3 api operation happening involving every file. I did some surface level poking into the `read_csv` code and did not get deep enough to find out what.  I suspect enabling logging for `aiohttp` might reveal a lot of http calls to s3 if that is the case.

Code here

```python
df = dd.read_csv(
                    files,
                    sep=""\t"",
                    names=list(dtypes.keys()),
                    dtype=dtypes,
                    comment=""#"",
                    on_bad_lines=""skip"",
                    compression=""gzip"",
                    sample=False,
                    blocksize=None,
                )
df.to_parquet(output_prefix, compression=""gzip"")
```

Given that I need to have a cluster up, whatever is happening is quite painful. The actual processing is done in seconds, but the cluster is up for the full 15 minutes burning $$ while the client seems to do something very mysterious to me as an average user.

Example cluster here https://cloud.coiled.io/clusters/210090/overview?account=shughes-uk . Only 4% of the uptime was actually spent doing anything relevant.",,https://api.github.com/repos/dask/dask/issues/10270/timeline,,,shughes-uk,546891,MDQ6VXNlcjU0Njg5MQ==,https://avatars.githubusercontent.com/u/546891?v=4,,https://api.github.com/users/shughes-uk,https://github.com/shughes-uk,https://api.github.com/users/shughes-uk/followers,https://api.github.com/users/shughes-uk/following{/other_user},https://api.github.com/users/shughes-uk/gists{/gist_id},https://api.github.com/users/shughes-uk/starred{/owner}{/repo},https://api.github.com/users/shughes-uk/subscriptions,https://api.github.com/users/shughes-uk/orgs,https://api.github.com/users/shughes-uk/repos,https://api.github.com/users/shughes-uk/events{/privacy},https://api.github.com/users/shughes-uk/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10270/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,milesgranger,13764397.0,MDQ6VXNlcjEzNzY0Mzk3,https://avatars.githubusercontent.com/u/13764397?v=4,,https://api.github.com/users/milesgranger,https://github.com/milesgranger,https://api.github.com/users/milesgranger/followers,https://api.github.com/users/milesgranger/following{/other_user},https://api.github.com/users/milesgranger/gists{/gist_id},https://api.github.com/users/milesgranger/starred{/owner}{/repo},https://api.github.com/users/milesgranger/subscriptions,https://api.github.com/users/milesgranger/orgs,https://api.github.com/users/milesgranger/repos,https://api.github.com/users/milesgranger/events{/privacy},https://api.github.com/users/milesgranger/received_events,User,False
860,https://api.github.com/repos/dask/dask/issues/10273,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10273/labels{/name},https://api.github.com/repos/dask/dask/issues/10273/comments,https://api.github.com/repos/dask/dask/issues/10273/events,https://github.com/dask/dask/issues/10273,1703006692,I_kwDOAbcwm85lgdHk,10273,Inconsistent handling when iterating Delayed objects with nout=1,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,4,2023-05-10T02:19:19Z,2024-02-05T01:45:51Z,,NONE,,"The following code causes a slice to be taken from a Delayed object when `_length==1`:
https://github.com/dask/dask/blob/e9845aadc7c32078e55354b61f5626ac759e8b28/dask/delayed.py#L619-L620

Here's a minimal example of the anomalous behavior from the case when nout=1

```python
>>> from dask.delayed import delayed
>>> @delayed(nout=1)
... def ret(x):
...     return x
...
>>> @delayed(nout=2)
... def echo(x):
...     return x,x
...
>>> d1 = ret([1,2,3])
>>> d2 = echo([1,2,3])
>>> for d in d1:
...     print(d.compute())
...
1
>>> for d in d2:
...     print(d.compute())
... 
[1, 2, 3]
[1, 2, 3]
```

I think the iteration of d1 should be the full output, i.e. [1, 2, 3], instead of just 1.

An inelegant fix could be:
```python
if self._length == 1:
    yield self
else:
    for i in range(self._length):
         yield self[i]
```",,https://api.github.com/repos/dask/dask/issues/10273/timeline,,,mdwgrogan,13625429,MDQ6VXNlcjEzNjI1NDI5,https://avatars.githubusercontent.com/u/13625429?v=4,,https://api.github.com/users/mdwgrogan,https://github.com/mdwgrogan,https://api.github.com/users/mdwgrogan/followers,https://api.github.com/users/mdwgrogan/following{/other_user},https://api.github.com/users/mdwgrogan/gists{/gist_id},https://api.github.com/users/mdwgrogan/starred{/owner}{/repo},https://api.github.com/users/mdwgrogan/subscriptions,https://api.github.com/users/mdwgrogan/orgs,https://api.github.com/users/mdwgrogan/repos,https://api.github.com/users/mdwgrogan/events{/privacy},https://api.github.com/users/mdwgrogan/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10273/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
861,https://api.github.com/repos/dask/dask/issues/10276,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10276/labels{/name},https://api.github.com/repos/dask/dask/issues/10276/comments,https://api.github.com/repos/dask/dask/issues/10276/events,https://github.com/dask/dask/issues/10276,1706019366,I_kwDOAbcwm85lr8om,10276,Mamba and conda solve of CI environment files installs ancient s3fs version causing poor performance,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,9,2023-05-11T15:08:45Z,2024-02-05T01:45:51Z,,MEMBER,,"When installing our test-environments that we are using in CI I am pulling in an ancient version of `s3fs` that is causing severe performance problems, see https://github.com/dask/dask/issues/10275 and https://github.com/fsspec/filesystem_spec/issues/1261

It should not be that easy to pull in an ancient version of such a critical library. Is there any way we can set lower pinnings for this? I don't know what's the cause of this pinning so I don't know how common this actually is when users install their environment

I haven't checked yet what version is installed in our CI jobs

<details>
<summary>conda export</summary>

```
# This file may be used to create an environment using:
# $ conda create --name <env> --file <this file>
# platform: osx-arm64
aiohttp=3.8.4=py310h8e9501a_0
aiosignal=1.3.1=pyhd8ed1ab_0
aom=3.5.0=h7ea286d_0
appnope=0.1.3=pyhd8ed1ab_0
arrow-cpp=10.0.1=hce30654_23_cpu
asciitree=0.3.3=py_2
asttokens=2.2.1=pyhd8ed1ab_0
async-timeout=4.0.2=pyhd8ed1ab_0
atk-1.0=2.38.0=hcb7b3dd_1
attrs=23.1.0=pyh71513ae_1
aws-c-auth=0.6.26=h0c2019c_6
aws-c-cal=0.5.26=h9c01cc2_0
aws-c-common=0.8.17=hb547adb_0
aws-c-compression=0.2.16=h7a7fafa_6
aws-c-event-stream=0.2.20=heb79caa_6
aws-c-http=0.7.7=h5140e40_3
aws-c-io=0.13.21=hc2875bd_3
aws-c-mqtt=0.8.6=h34492a6_15
aws-c-s3=0.2.8=h28047f4_4
aws-c-sdkutils=0.1.9=h7a7fafa_1
aws-checksums=0.1.14=h7a7fafa_6
aws-crt-cpp=0.19.9=h1ca6c90_5
aws-sam-translator=1.66.0=pyhd8ed1ab_0
aws-sdk-cpp=1.10.57=hc8901a9_10
aws-xray-sdk=2.12.0=pyhd8ed1ab_0
backcall=0.2.0=pyh9f0ad1d_0
backports=1.0=pyhd8ed1ab_3
backports.functools_lru_cache=1.6.4=pyhd8ed1ab_0
bcrypt=3.2.2=py310h8e9501a_1
blinker=1.6.2=pyhd8ed1ab_0
blosc=1.21.3=h1d6ff8b_0
bokeh=3.1.1=pyhd8ed1ab_0
boto3=1.26.132=pyhd8ed1ab_0
botocore=1.29.132=pyhd8ed1ab_0
brotli=1.0.9=h1a8c8d9_8
brotli-bin=1.0.9=h1a8c8d9_8
brotlipy=0.7.0=py310h8e9501a_1005
brunsli=0.1=h9f76cd9_0
bzip2=1.0.8=h3422bc3_4
c-ares=1.18.1=h3422bc3_0
c-blosc2=2.8.0=h303ed30_1
ca-certificates=2023.5.7=hf0a4a13_0
cached-property=1.5.2=hd8ed1ab_1
cached_property=1.5.2=pyha770c72_1
cachey=0.2.1=pyh9f0ad1d_0
cairo=1.16.0=h4741ed9_1015
certifi=2023.5.7=pyhd8ed1ab_0
cffi=1.15.1=py310h2399d43_3
cfgv=3.3.1=pyhd8ed1ab_0
cfitsio=4.2.0=h2f961c4_0
cfn-lint=0.77.5=pyhd8ed1ab_0
charls=2.4.1=hb7217d7_0
charset-normalizer=2.1.1=pyhd8ed1ab_0
click=8.1.3=unix_pyhd8ed1ab_2
cloudpickle=2.2.1=pyhd8ed1ab_0
colorama=0.4.6=pyhd8ed1ab_0
comm=0.1.3=pyhd8ed1ab_0
contourpy=1.0.7=py310h2887b22_0
coverage=7.2.5=py310h2aa6e3c_0
cramjam=2.6.2=py310h1dc5ec9_0
crick=0.0.3=py310hf1a086a_1003
cryptography=40.0.2=py310hfc83b78_0
curl=8.0.1=heffe338_0
cytoolz=0.12.0=py310h8e9501a_1
dask-core=2023.4.1=pyhd8ed1ab_0
dav1d=1.0.0=he4db4b2_1
debugpy=1.6.7=py310h0f1eb42_0
decorator=5.1.1=pyhd8ed1ab_0
distlib=0.3.6=pyhd8ed1ab_0
distributed=2023.4.1+12.g2d80271d=pypi_0
docker-py=6.1.0=pyhd8ed1ab_0
ecdsa=0.18.0=pyhd8ed1ab_1
entrypoints=0.4=pyhd8ed1ab_0
exceptiongroup=1.1.1=pyhd8ed1ab_0
execnet=1.9.0=pyhd8ed1ab_0
executing=1.2.0=pyhd8ed1ab_0
expat=2.5.0=hb7217d7_1
fasteners=0.17.3=pyhd8ed1ab_0
fastparquet=2023.4.0=py310hf1a086a_0
filelock=3.12.0=pyhd8ed1ab_0
flask=2.3.2=pyhd8ed1ab_0
flask_cors=3.0.10=pyhd3deb0d_0
font-ttf-dejavu-sans-mono=2.37=hab24e00_0
font-ttf-inconsolata=3.000=h77eed37_0
font-ttf-source-code-pro=2.038=h77eed37_0
font-ttf-ubuntu=0.83=hab24e00_0
fontconfig=2.14.2=h82840c6_0
fonts-conda-ecosystem=1=0
fonts-conda-forge=1=0
freetype=2.12.1=hd633e50_1
fribidi=1.0.10=h27ca646_0
frozenlist=1.3.3=py310h8e9501a_0
fsspec=2023.5.0=pyh1a96a4e_0
gdk-pixbuf=2.42.10=h1ac0d0d_2
gettext=0.21.1=h0186832_0
gflags=2.2.2=hc88da5d_1004
giflib=5.2.1=h1a8c8d9_3
glog=0.6.0=h6da1cb0_0
gmp=6.2.1=h9f76cd9_0
gmpy2=2.1.2=py310h2e6cad2_1
graphite2=1.3.13=h9f76cd9_1001
graphql-core=3.2.3=pyhd8ed1ab_0
graphviz=8.0.5=h10878c0_0
greenlet=2.0.2=py310h0f1eb42_0
gtk2=2.24.33=h57013de_2
gts=0.7.6=h4b6d4d6_2
h5py=3.8.0=nompi_py310h3c889c5_101
harfbuzz=7.3.0=h46e5fef_0
hdf5=1.14.0=nompi_h6b85c65_103
heapdict=1.0.1=py_0
httpretty=1.1.4=pyhd8ed1ab_0
icu=72.1=he12128b_0
identify=2.5.24=pyhd8ed1ab_0
idna=3.4=pyhd8ed1ab_0
imagecodecs=2023.1.23=py310hcb660b6_2
imageio=2.27.0=pyh24c5eb1_0
importlib-metadata=6.6.0=pyha770c72_0
importlib_metadata=6.6.0=hd8ed1ab_0
importlib_resources=5.12.0=pyhd8ed1ab_0
iniconfig=2.0.0=pyhd8ed1ab_0
ipycytoscape=1.3.3=pyhd8ed1ab_1
ipykernel=6.21.2=pyh736e0ef_0
ipython=8.13.2=pyhd1c38e8_0
ipywidgets=8.0.4=pyhd8ed1ab_0
itsdangerous=2.1.2=pyhd8ed1ab_0
jedi=0.18.2=pyhd8ed1ab_0
jinja2=3.1.2=pyhd8ed1ab_1
jmespath=1.0.1=pyhd8ed1ab_0
joblib=1.2.0=pyhd8ed1ab_0
jschema-to-python=1.2.3=pyhd8ed1ab_0
jsondiff=2.0.0=pyhd8ed1ab_0
jsonpatch=1.32=pyhd8ed1ab_0
jsonpickle=2.2.0=pyhd8ed1ab_0
jsonpointer=2.0=py_0
jsonschema=4.17.3=pyhd8ed1ab_0
jsonschema-spec=0.1.4=pyhd8ed1ab_0
junit-xml=1.9=pyh9f0ad1d_0
jupyter_client=8.2.0=pyhd8ed1ab_0
jupyter_core=5.3.0=py310hbe9552e_0
jupyterlab_widgets=3.0.7=pyhd8ed1ab_0
jxrlib=1.1=h27ca646_2
krb5=1.20.1=h69eda48_0
lazy-object-proxy=1.9.0=py310h8e9501a_0
lazy_loader=0.2=pyhd8ed1ab_0
lcms2=2.15=hd835a16_1
lerc=4.0.0=h9a09cb3_0
libabseil=20230125.0=cxx17_hb7217d7_1
libaec=1.0.6=hb7217d7_1
libarrow=10.0.1=hb50b599_23_cpu
libavif=0.11.1=h3d80962_0
libblas=3.9.0=16_osxarm64_openblas
libbrotlicommon=1.0.9=h1a8c8d9_8
libbrotlidec=1.0.9=h1a8c8d9_8
libbrotlienc=1.0.9=h1a8c8d9_8
libcblas=3.9.0=16_osxarm64_openblas
libcrc32c=1.1.2=hbdafb3b_0
libcurl=8.0.1=heffe338_0
libcxx=16.0.3=h4653b0c_0
libdeflate=1.18=h1a8c8d9_0
libedit=3.1.20191231=hc8eb9b7_2
libev=4.33=h642e427_1
libevent=2.1.12=h5643135_0
libexpat=2.5.0=hb7217d7_1
libffi=3.4.2=h3422bc3_5
libgd=2.3.3=h939342b_6
libgfortran=5.0.0=12_2_0_hd922786_31
libgfortran5=12.2.0=h0eea778_31
libglib=2.76.2=h24e9cb9_0
libgoogle-cloud=2.10.0=he22f4c0_0
libgrpc=1.54.2=h9dbdbd0_0
libiconv=1.17=he4db4b2_0
libjpeg-turbo=2.1.5.1=h1a8c8d9_0
liblapack=3.9.0=16_osxarm64_openblas
libllvm11=11.1.0=hfa12f05_5
libnghttp2=1.52.0=hae82a92_0
libopenblas=0.3.21=openmp_hc731615_3
libpng=1.6.39=h76d750c_0
libprotobuf=3.21.12=hb5ab8b9_0
librsvg=2.56.0=h6c0e662_0
libsodium=1.0.18=h27ca646_1
libsqlite=3.41.2=hb31c410_1
libssh2=1.10.0=h7a5bd25_3
libthrift=0.18.1=ha061701_1
libtiff=4.5.0=h4f7d55c_6
libtool=2.4.7=hb7217d7_0
libutf8proc=2.8.0=h1a8c8d9_0
libwebp=1.3.0=h66d6964_0
libwebp-base=1.3.0=h1a8c8d9_0
libxcb=1.13=h9b22ae9_1004
libxml2=2.10.4=h2aff0a6_0
libzlib=1.2.13=h03a7124_4
libzopfli=1.0.3=h9f76cd9_0
llvm-openmp=16.0.3=h1c12783_0
llvmlite=0.39.1=py310h1e34944_1
locket=1.0.0=pyhd8ed1ab_0
lz4=4.3.2=py310ha6df754_0
lz4-c=1.9.4=hb7217d7_0
markupsafe=2.1.2=py310h8e9501a_0
matplotlib-inline=0.1.6=pyhd8ed1ab_0
mimesis=9.0.0=pyhd8ed1ab_0
mmh3=3.0.0=py310h0f1eb42_3
moto=4.1.9=pyhd8ed1ab_0
mpc=1.3.1=h91ba8db_0
mpfr=4.2.0=he09a6ba_0
mpmath=1.3.0=pyhd8ed1ab_0
msgpack-python=1.0.5=py310h2887b22_0
multidict=6.0.4=py310h8e9501a_0
nbformat=5.8.0=pyhd8ed1ab_0
ncurses=6.3=h07bb92c_1
nest-asyncio=1.5.6=pyhd8ed1ab_0
networkx=2.8.8=pyhd8ed1ab_0
nodeenv=1.7.0=pyhd8ed1ab_0
numba=0.56.4=py310h3124f1e_1
numcodecs=0.11.0=py310h0f1eb42_1
numexpr=2.8.4=py310h2b830bf_0
numpy=1.23.5=py310h5d7c261_0
openapi-schema-validator=0.4.4=pyhd8ed1ab_0
openapi-spec-validator=0.5.6=pyhd8ed1ab_0
openjpeg=2.5.0=hbc2ba62_2
openssl=3.1.0=h53f4e23_3
orc=1.8.3=hef0d403_0
packaging=23.1=pyhd8ed1ab_0
pandas=1.5.3=py310h2b830bf_1
pango=1.50.14=h9f7e0c6_1
paramiko=3.1.0=pyhd8ed1ab_0
parquet-cpp=1.5.1=2
parso=0.8.3=pyhd8ed1ab_0
partd=1.4.0=pyhd8ed1ab_0
pathable=0.4.3=pyhd8ed1ab_0
pbr=5.11.1=pyhd8ed1ab_0
pcre2=10.40=hb34f9b4_0
pexpect=4.8.0=pyh1a96a4e_2
pickleshare=0.7.5=py_1003
pillow=9.5.0=py310h07496d3_0
pip=23.1.2=pyhd8ed1ab_0
pixman=0.40.0=h27ca646_0
pkgutil-resolve-name=1.3.10=pyhd8ed1ab_0
platformdirs=3.1.1=pyhd8ed1ab_0
pluggy=1.0.0=pyhd8ed1ab_5
pooch=1.7.0=pyha770c72_3
pre-commit=3.3.1=pyha770c72_0
prompt-toolkit=3.0.38=pyha770c72_0
prompt_toolkit=3.0.38=hd8ed1ab_0
psutil=5.9.5=py310h8e9501a_0
pthread-stubs=0.4=h27ca646_1001
ptyprocess=0.7.0=pyhd3deb0d_0
pure_eval=0.2.2=pyhd8ed1ab_0
py-cpuinfo=9.0.0=pyhd8ed1ab_0
py4j=0.10.9.7=pyhd8ed1ab_0
pyarrow=10.0.1=py310h89f3c6b_23_cpu
pyasn1=0.4.8=py_0
pycparser=2.21=pyhd8ed1ab_0
pydantic=1.10.7=py310h8e9501a_0
pygments=2.15.1=pyhd8ed1ab_0
pynacl=1.5.0=py310h8e9501a_2
pyopenssl=23.1.1=pyhd8ed1ab_0
pyparsing=3.0.9=pyhd8ed1ab_0
pyrsistent=0.19.3=py310h8e9501a_0
pysocks=1.7.1=pyha2e5f31_6
pyspark=3.4.0=pyhd8ed1ab_0
pytables=3.8.0=py310h7b1fd78_1
pytest=7.3.1=pyhd8ed1ab_0
pytest-cov=4.0.0=pyhd8ed1ab_0
pytest-rerunfailures=11.1.2=pyhd8ed1ab_0
pytest-timeout=2.1.0=pyhd8ed1ab_0
pytest-xdist=3.2.1=pyhd8ed1ab_0
python=3.10.11=h3ba56d0_0_cpython
python-cityhash=0.4.6=py310h1253130_3
python-dateutil=2.8.2=pyhd8ed1ab_0
python-fastjsonschema=2.16.3=pyhd8ed1ab_0
python-graphviz=0.20.1=pyh22cad53_0
python-jose=3.3.0=pyh6c4a22f_1
python-snappy=0.6.1=py310h7f31a72_0
python-xxhash=3.2.0=py310h8e9501a_0
python_abi=3.10=3_cp310
pytz=2023.3=pyhd8ed1ab_0
pywavelets=1.4.1=py310hf1a086a_0
pywin32-on-windows=0.1.0=pyh1179c8e_3
pyyaml=6.0=py310h8e9501a_5
pyzmq=25.0.2=py310hc407298_0
re2=2023.02.02=hb7217d7_0
readline=8.2=h92ec313_1
regex=2023.5.5=py310h2aa6e3c_0
requests=2.29.0=pyhd8ed1ab_0
responses=0.21.0=pyhd8ed1ab_0
rfc3339-validator=0.1.4=pyhd8ed1ab_0
rsa=4.9=pyhd8ed1ab_0
s3fs=0.4.2=py_0
s3transfer=0.6.1=pyhd8ed1ab_0
sarif-om=1.0.4=pyhd8ed1ab_0
scikit-image=0.20.0=py310h2b830bf_1
scikit-learn=1.2.2=py310h98c5782_1
scipy=1.10.1=py310ha0d8a01_2
setuptools=67.7.2=pyhd8ed1ab_0
six=1.16.0=pyh6c4a22f_0
snappy=1.1.10=h17c5cce_0
sortedcontainers=2.4.0=pyhd8ed1ab_0
sparse=0.14.0=pyhd8ed1ab_0
spectate=1.0.1=pyhd8ed1ab_0
sqlalchemy=1.4.46=py310h8e9501a_0
sshpubkeys=3.3.1=pyhd8ed1ab_0
stack_data=0.6.2=pyhd8ed1ab_0
sympy=1.11.1=pypyh9d50eac_103
tblib=1.7.0=pyhd8ed1ab_0
threadpoolctl=3.1.0=pyh8a188c0_0
tifffile=2023.4.12=pyhd8ed1ab_0
tiledb=2.11.3=h9bd36d0_1
tiledb-py=0.17.3=py310hc1e3be7_0
tk=8.6.12=he1e0b03_0
toml=0.10.2=pyhd8ed1ab_0
tomli=2.0.1=pyhd8ed1ab_0
toolz=0.12.0=pyhd8ed1ab_0
tornado=6.3=py310h8e9501a_0
traitlets=5.9.0=pyhd8ed1ab_0
typing-extensions=4.4.0=hd8ed1ab_0
typing_extensions=4.4.0=pyha770c72_0
tzdata=2023c=h71feb2d_0
ukkonen=1.0.1=py310h2887b22_3
urllib3=1.26.15=pyhd8ed1ab_0
virtualenv=20.21.1=pyhd8ed1ab_0
wcwidth=0.2.6=pyhd8ed1ab_0
websocket-client=1.5.1=pyhd8ed1ab_0
werkzeug=2.3.4=pyhd8ed1ab_0
wheel=0.40.0=pyhd8ed1ab_0
widgetsnbextension=4.0.7=pyhd8ed1ab_0
wrapt=1.15.0=py310h8e9501a_0
xarray=2023.4.2=pyhd8ed1ab_0
xmltodict=0.13.0=pyhd8ed1ab_0
xorg-libxau=1.0.9=h27ca646_0
xorg-libxdmcp=1.1.3=h27ca646_0
xxhash=0.8.1=h1a8c8d9_0
xyzservices=2023.2.0=pyhd8ed1ab_0
xz=5.2.6=h57fd34a_0
yaml=0.2.5=h3422bc3_2
yarl=1.9.1=py310h2aa6e3c_0
zarr=2.14.2=pyhd8ed1ab_0
zeromq=4.3.4=hbdafb3b_1
zfp=1.0.0=hb6e4faa_3
zict=3.0.0=pyhd8ed1ab_0
zipp=3.15.0=pyhd8ed1ab_0
zlib=1.2.13=h03a7124_4
zlib-ng=2.0.7=h1a8c8d9_0
zstd=1.5.2=hf913c23_6
```

</details>

cc @martindurant ",,https://api.github.com/repos/dask/dask/issues/10276/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10276/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
862,https://api.github.com/repos/dask/dask/issues/10277,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10277/labels{/name},https://api.github.com/repos/dask/dask/issues/10277/comments,https://api.github.com/repos/dask/dask/issues/10277/events,https://github.com/dask/dask/pull/10277,1706049512,PR_kwDOAbcwm85QTgwk,10277,Read file blocksize,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-05-11T15:26:07Z,2023-06-19T01:59:47Z,,CONTRIBUTOR,,"- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

This MR changes blocksize behaviour for non-lined json. Instead of raising error, this change repartitions the read json dataframe into equal sized partition with size <= blocksize.

Ref #9849",,https://api.github.com/repos/dask/dask/issues/10277/timeline,,,novdanody,98500306,U_kgDOBd7-0g,https://avatars.githubusercontent.com/u/98500306?v=4,,https://api.github.com/users/novdanody,https://github.com/novdanody,https://api.github.com/users/novdanody/followers,https://api.github.com/users/novdanody/following{/other_user},https://api.github.com/users/novdanody/gists{/gist_id},https://api.github.com/users/novdanody/starred{/owner}{/repo},https://api.github.com/users/novdanody/subscriptions,https://api.github.com/users/novdanody/orgs,https://api.github.com/users/novdanody/repos,https://api.github.com/users/novdanody/events{/privacy},https://api.github.com/users/novdanody/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10277/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10277,https://github.com/dask/dask/pull/10277,https://github.com/dask/dask/pull/10277.diff,https://github.com/dask/dask/pull/10277.patch,,,,,,,,,,,,,,,,,,,
863,https://api.github.com/repos/dask/dask/issues/10284,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10284/labels{/name},https://api.github.com/repos/dask/dask/issues/10284/comments,https://api.github.com/repos/dask/dask/issues/10284/events,https://github.com/dask/dask/issues/10284,1709465493,I_kwDOAbcwm85l5F-V,10284,"A bug in dask.array.linalg.tsqr, not fatal but annoying","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-05-15T07:15:10Z,2023-06-19T01:59:45Z,,NONE,,"**Describe the issue**:
When we use the ```da.linalg.svd()``` to compute svd for complex matrix, the following warning occurs.
```
..../dask/array/utils.py:101): ComplexWarning: Casting complex values to real discards the imaginary part
  meta = meta.astype(dtype)
```
Because in the ```dask.array.linalg``` module, the row 498 of ```tsqr()``` function is
```
s_meta = meta_from_array(data, len((n_s,)), ss.dtype)
```
, in which ```data``` is the matrix of which we want to do qr decomposition. In the case of complex matrix, the data type of singular value and matrix are different, so the the above warning occurs.


",,https://api.github.com/repos/dask/dask/issues/10284/timeline,,,LUOXIAO92,89069722,MDQ6VXNlcjg5MDY5NzIy,https://avatars.githubusercontent.com/u/89069722?v=4,,https://api.github.com/users/LUOXIAO92,https://github.com/LUOXIAO92,https://api.github.com/users/LUOXIAO92/followers,https://api.github.com/users/LUOXIAO92/following{/other_user},https://api.github.com/users/LUOXIAO92/gists{/gist_id},https://api.github.com/users/LUOXIAO92/starred{/owner}{/repo},https://api.github.com/users/LUOXIAO92/subscriptions,https://api.github.com/users/LUOXIAO92/orgs,https://api.github.com/users/LUOXIAO92/repos,https://api.github.com/users/LUOXIAO92/events{/privacy},https://api.github.com/users/LUOXIAO92/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10284/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
864,https://api.github.com/repos/dask/dask/issues/10297,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10297/labels{/name},https://api.github.com/repos/dask/dask/issues/10297/comments,https://api.github.com/repos/dask/dask/issues/10297/events,https://github.com/dask/dask/issues/10297,1715082119,I_kwDOAbcwm85mOhOH,10297,"ZeroDivisionError when chunksize=-1, and documentation error","[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-05-18T06:29:37Z,2024-02-05T01:45:49Z,,NONE,,"# 1. Bug (ZeroDivisionError)

```python
import dask

def process(i: int) -> int:
    return 2 * i

if __name__ == '__main__':
    jobs = [dask.delayed(process)(i) for i in range(4)]
    results = dask.compute(*jobs, scheduler='processes', num_workers=4, chunksize=-1)
```

This leads to the following error:

```
Traceback (most recent call last):
  File ""C:\Users\xxx\xxx\xxx\xxx\xxx\xxx\error.py"", line 8, in <module>
    results = dask.compute(*jobs, scheduler='processes', num_workers=4, chunksize=-1)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""C:\Users\...\.conda\envs\p311\Lib\site-packages\dask\base.py"", line 599, in compute
    results = schedule(dsk, keys, **kwargs)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""C:\Users\...\.conda\envs\p311\Lib\site-packages\dask\multiprocessing.py"", line 233, in get
    result = get_async(
             ^^^^^^^^^^
  File ""C:\Users\...\.conda\envs\p311\Lib\site-packages\dask\local.py"", line 499, in get_async
    fire_tasks(chunksize)
  File ""C:\Users\...\.conda\envs\p311\Lib\site-packages\dask\local.py"", line 490, in fire_tasks
    for i in range(-(len(args) // -chunksize)):
                     ~~~~~~~~~~^^~~~~~~~~~~~
ZeroDivisionError: integer division or modulo by zero
```

# 2. Documentation error
The documentation states that `chunksize` defaults to `5`, but `6` is actually used:

https://github.com/dask/dask/blob/cdb183a2dddfac6d1fb445be66f1c62f91434c13/dask/multiprocessing.py#L179-L184",,https://api.github.com/repos/dask/dask/issues/10297/timeline,,,kasparthommen,49198627,MDQ6VXNlcjQ5MTk4NjI3,https://avatars.githubusercontent.com/u/49198627?v=4,,https://api.github.com/users/kasparthommen,https://github.com/kasparthommen,https://api.github.com/users/kasparthommen/followers,https://api.github.com/users/kasparthommen/following{/other_user},https://api.github.com/users/kasparthommen/gists{/gist_id},https://api.github.com/users/kasparthommen/starred{/owner}{/repo},https://api.github.com/users/kasparthommen/subscriptions,https://api.github.com/users/kasparthommen/orgs,https://api.github.com/users/kasparthommen/repos,https://api.github.com/users/kasparthommen/events{/privacy},https://api.github.com/users/kasparthommen/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10297/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
865,https://api.github.com/repos/dask/dask/issues/10298,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10298/labels{/name},https://api.github.com/repos/dask/dask/issues/10298/comments,https://api.github.com/repos/dask/dask/issues/10298/events,https://github.com/dask/dask/issues/10298,1715398783,I_kwDOAbcwm85mPuh_,10298,Using `include_path_column` slows down reading multiple CSV and use excessive resources,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,3,2023-05-18T10:31:29Z,2023-06-26T02:08:54Z,,NONE,,"I have a simple task.
Merge 70k+ zip compressed CSV files (3KB compressed, 9KB unzipped) into a single parquet file, adding some metadata in the process.
The CSV files have only 4 columns inside, with 3 of them having float with a single decimal digit, so we're definitely not talking about ""BIG"" data here.

The serial version with Pandas works fine and has almost no impact on memory (and CPU).

```python
files = glob(""*.zip"")

dfs = []
for f in tqdm(files):
    df = pd.read_csv(f,
                     parse_dates=[0],
                     compression='zip')
    df['cell'] = re.findall(""(?:/)(\d{5})(?:_\d{4}.zip)"", f)[0]
    dfs.append(df)

final = pd.concat(dfs)
final.to_parquet('file.parquet', engine='fastparquet', compression='gzip')
```
takes about 2 minutes.
The resulting file is about 220MB, which is what I would expect given that the folder with all zipped files is about 200MB in size.

Now if I try to do the same thing with a Dask Local Cluster, which should clearly have the advantage in a similar task, 

```python
client = Client(n_workers=4)
df = dd.read_csv(""*.zip"",
                parse_dates=[0], compression='zip',
                blocksize=None, include_path_column=True)
df['cell'] = df.path.str.findall(""(?:/)(\d{5})(?:_\d{4}.zip)"")
df = df.drop(columns=['path'])
df.to_parquet.... # (or just df.compute)
```

The CPU and memory usage quickly skyrockets and the resulting parquet file is 1GB in size just at the beginning. I didn't even manage to reach the end because my computer would almost crash. 

What am I missing here? Which is the part of the process that is not optimized or using a lot of resources. From what I gather the only computationally ""expensive"" parts are

- parse the datetime column
- decompress the files
- execute the regex on the path column

but the serial version works just fine. 



",,https://api.github.com/repos/dask/dask/issues/10298/timeline,,,guidocioni,12760310,MDQ6VXNlcjEyNzYwMzEw,https://avatars.githubusercontent.com/u/12760310?v=4,,https://api.github.com/users/guidocioni,https://github.com/guidocioni,https://api.github.com/users/guidocioni/followers,https://api.github.com/users/guidocioni/following{/other_user},https://api.github.com/users/guidocioni/gists{/gist_id},https://api.github.com/users/guidocioni/starred{/owner}{/repo},https://api.github.com/users/guidocioni/subscriptions,https://api.github.com/users/guidocioni/orgs,https://api.github.com/users/guidocioni/repos,https://api.github.com/users/guidocioni/events{/privacy},https://api.github.com/users/guidocioni/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10298/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
866,https://api.github.com/repos/dask/dask/issues/10302,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10302/labels{/name},https://api.github.com/repos/dask/dask/issues/10302/comments,https://api.github.com/repos/dask/dask/issues/10302/events,https://github.com/dask/dask/issues/10302,1717469240,I_kwDOAbcwm85mXoA4,10302,`read_csv` with `include_path_column` and `dtype_backend='pyarrow'` generates a mix of String and Categorical which hurts Parquet usage,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,2,2023-05-19T15:55:15Z,2023-06-19T01:59:42Z,,NONE,,"**Describe the issue**:

Using `read_csv` to read CSVs as `pyarrow` dtypes with  `dtype_backend='pyarrow'`, then outputting a Parquet file set gives us a mix of PyArrow and `categorical` outputs. The categorical is the added `path` if `include_path_column=True`. 

Perhaps if `dtype_backend='pyarrow'` the behaviour of `include_path_column=True` should use a PyArrow string, not a `categorical`?

This came up when trying to load my Parquet output from Dask into Polars: https://github.com/pola-rs/polars/issues/8925

By subsequently removing `include_path_column=True` from the `dd.read_csv`, the pipeline generates an all-PyArrow output with no categorical (i.e. no `path` column but the 14 expected columns are all present).

Having removed `include_path_column` from this Parquet output, the resulting Parquet file-set can be read with Polars with no need to sub-select away the ""path"" column.

**Partial example**:

```python

# define a function to read each csv file
def read_results(file, sep):
    df = dd.read_csv(file,
                     delimiter=sep,
                     doublequote=False,
                     on_bad_lines='warn',
                     include_path_column=True, # FORCES a categorical column
                     parse_dates=['test_date'],
                     dtype_backend='pyarrow', # REQUEST all pyarrow dtypes and no categoricals
                    )
    return df

# some lines ommitted for date parsing and binding read_results to previously sniffed varying csv formats...

# inferred dtypes are all pyarrow as expected
ddf.dtypes
test_id               int64[pyarrow]
test_date             datetime64[ns]
test_class_id         int64[pyarrow]
fuel_type            string[pyarrow]
...14 in total, clipped for brevity, all pyarrow types
dtype: object

# generate the parquet output, let it process for 10 minutes
f = ddf.to_parquet('test_result.parquet', write_index=False, overwrite=True, compute=False).persist()
progress(f)


# now roundtrip the result back in and check what we've got
ddf_result = dd.read_parquet('test_result.parquet')
ddf_result.info(verbose=True)
<class 'dask.dataframe.core.DataFrame'>
Index: 639506962 entries, 0 to 791798
Data columns (total 15 columns):
 #   Column             Non-Null Count  Dtype
---  ------             --------------  -----
 0   test_id            639506962 non-null      int64[pyarrow]
 2   test_date          639506962 non-null      datetime64[ns]
 3   test_class_id      639506962 non-null      int64[pyarrow]
11   fuel_type          639506962 non-null      string
...14 in total as before and all pyarrow until...
14   path               639506962 non-null      category  # UNEXPECTED non-arrow category
dtypes: category(1), datetime64[ns](2), int64[pyarrow](5), string(7)
memory usage: 65.2 GB
```

**Anything else we need to know?**:

I'm guessing this is old-and-sensible behaviour from when NumPy was the default in Pandas but now that Arrow is a first-class citizen, maybe this behaviour needs updating?

**Environment**:

- Dask version: '2023.5.0'
- Python version: 3.11
- Operating System: Linux Mint, Ubuntu
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10302/timeline,,,ianozsvald,273210,MDQ6VXNlcjI3MzIxMA==,https://avatars.githubusercontent.com/u/273210?v=4,,https://api.github.com/users/ianozsvald,https://github.com/ianozsvald,https://api.github.com/users/ianozsvald/followers,https://api.github.com/users/ianozsvald/following{/other_user},https://api.github.com/users/ianozsvald/gists{/gist_id},https://api.github.com/users/ianozsvald/starred{/owner}{/repo},https://api.github.com/users/ianozsvald/subscriptions,https://api.github.com/users/ianozsvald/orgs,https://api.github.com/users/ianozsvald/repos,https://api.github.com/users/ianozsvald/events{/privacy},https://api.github.com/users/ianozsvald/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10302/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
867,https://api.github.com/repos/dask/dask/issues/10324,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10324/labels{/name},https://api.github.com/repos/dask/dask/issues/10324/comments,https://api.github.com/repos/dask/dask/issues/10324/events,https://github.com/dask/dask/issues/10324,1733188477,I_kwDOAbcwm85nTlt9,10324,`dask.array.to_zarr` incorrectly writes to local path on Linux when url is a `FSStore` and `storage_options` is used,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,3,2023-05-31T00:12:15Z,2023-07-03T02:07:13Z,,NONE,,"**Describe the issue**:
On Linux, the `dask.array.to_zarr` function incorrently writes to a local path when a `FSStore` instance pointing to a cloud storage (GCS, S3) path is passed as the `url` argument and the `storage_options` arg is used.

The below snippet should write a zarr array to `gs://my-bucket/zarr-test.zarr/tile0/0`
However, on my machine the array gets written to my current working directory `./my-bucket/zarr-test.zarr/tile0/0`

Setting `storage_options = None` results in writing to the correct location.

**Minimal Complete Verifiable Example**:
```python
import numpy as np
import dask.array as da
import zarr

store = zarr.storage.FSStore(url=""gs://my-bucket/zarr-test.zarr"", dimension_separator='/')
root_group = zarr.group(store=store, overwrite=True)
group = root_group.create_group(name=""tile0"")

d = da.ones(shape=(500, 500, 500), dtype=np.uint16, chunks=(100, 100, 100))

# A non-empty dictionary results in writing to a local path instead of the GCS bucket
# key-values picked arbitrarily
storage_options = {""chunks"": (100, 100, 100)}
# storage_options = None results in the correct write behavior

da.to_zarr(
    arr=d,
    url=group.store,
    component=group.path + ""/0"",
    storage_options=storage_options,
    dimension_separator=group._store._dimension_separator,
    compute=True,
    overwrite=True
)
```

**Anything else we need to know?**:
I only see this behavior with Linux (specifically CentOS 7 but haven't tried others), cannot reproduce on Windows 10.
It appears this was introduced in https://github.com/dask/dask/pull/9790 , as I see this behavior with all versions >= `2023.1.0`

**Environment**:

- Dask version: 2023.5.1
- Python version: 3.10.11
- Operating System: CentOS 7
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10324/timeline,,,carshadi,44130022,MDQ6VXNlcjQ0MTMwMDIy,https://avatars.githubusercontent.com/u/44130022?v=4,,https://api.github.com/users/carshadi,https://github.com/carshadi,https://api.github.com/users/carshadi/followers,https://api.github.com/users/carshadi/following{/other_user},https://api.github.com/users/carshadi/gists{/gist_id},https://api.github.com/users/carshadi/starred{/owner}{/repo},https://api.github.com/users/carshadi/subscriptions,https://api.github.com/users/carshadi/orgs,https://api.github.com/users/carshadi/repos,https://api.github.com/users/carshadi/events{/privacy},https://api.github.com/users/carshadi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10324/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
868,https://api.github.com/repos/dask/dask/issues/10325,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10325/labels{/name},https://api.github.com/repos/dask/dask/issues/10325/comments,https://api.github.com/repos/dask/dask/issues/10325/events,https://github.com/dask/dask/issues/10325,1734025431,I_kwDOAbcwm85nWyDX,10325,Should we disable fusion by default?,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2023-05-31T11:46:13Z,2023-07-03T02:07:11Z,,MEMBER,,"The setting `optimization.fuse.active: true` is problematic:

- It destroys annotations. This means that anybody who wishes to use, namely, resources together with collections will need to know they need to disable it, or nothing will work.

- It materializes the graph on the client instead of the scheduler; this in turn means that the (*non-parallelizable*) time to pickle, transfer, and unpickle the graph on `compute()` or `persist()` suddenly starts scaling with the number of chunks; this is particularly painful if the client-scheduler connection is relatively narrowband.
Namely, in Coiled the scheduler is on AWS EC2 while the client is typically on premises. I've tried submitting medium-sized computations to Coiled from a cafe's wifi and it was *not* a good user experience - the setting added several *minutes* to the head of the computation.

- It's an expensive operation in its own right, which can cause a net slowdown: #9795 

- Annotations, part 2: I'm currently implementing https://github.com/dask/distributed/issues/7860, which are based on annotations, and would like to use them in [coiled/benchmarks](https://github.com/coiled/benchmarks). I could, of course, disable fusion in coiled/benchmarks only - but that would mean it would benchmark something that is substantially different from the typical user experience - which goes against the whole idea behind the test suite.

#### Shouldn't we just set `optimization.fuse.active: false` by default?

I've run an A/B test on coiled/benchmarks, which shows mild to non-existent speed-up end-to-end. Note that these tests run in 2\~20 minutes each on a small-ish cluster (20\~80 CPUs), so the cost of optimization, pickle, graph transfer, and unpickle is modest overall.

![download](https://github.com/dask/dask/assets/6213168/48b49b13-6b82-4b8a-b00b-5d29a6cbceb4)


The A/B tests also show a noticeable increase in memory usage in a couple of tests, which I intend to investigate. 

![download (1)](https://github.com/dask/dask/assets/6213168/baaa1fac-a06d-49bd-8ee0-72032fdb3c97)

CC @fjetter @mrocklin @rjzamora @martindurant ",,https://api.github.com/repos/dask/dask/issues/10325/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10325/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
869,https://api.github.com/repos/dask/dask/issues/10327,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10327/labels{/name},https://api.github.com/repos/dask/dask/issues/10327/comments,https://api.github.com/repos/dask/dask/issues/10327/events,https://github.com/dask/dask/issues/10327,1736802481,I_kwDOAbcwm85nhYCx,10327,min/max fails arrays with empty chunks that are empty because of boolean selector,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-06-01T17:50:19Z,2023-07-03T02:07:10Z,,NONE,,"Presumably this is a missed corner case from handling [Issue #2794](https://github.com/dask/dask/issues/2794)

**Minimal Complete Verifiable Example**:
```python
import dask.array
""""""task overview:
- make a simple matrix
- select rows with ""big"" first column
- take the max value from each selected row
""""""
# works if there's NO empty chunks:
dda = dask.array.from_array([[1, 10], [2, 20], [3, 30], [4, 40]], chunks=((3, 1), 2))
big_dda = dda[dda[:, 0] > 2, :]   # take the two bottom rows, so each chunk has some data
print(big_dda.max(axis=1).compute())

# works if you pre-compute the boolean selector array
dda = dask.array.from_array([[1, 10], [2, 20], [3, 30], [4, 40]], chunks=((2, 2), 2))
big_dda = dda[(dda[:, 0] > 2).compute(), :]  # top chunk is empty, but the selector is computed
print(big_dda.max(axis=1).compute())

# fails if there's an empty chunk and you don't pre-compute the boolean selector array
dda = dask.array.from_array([[1, 10], [2, 20], [3, 30], [4, 40]], chunks=((2, 2), 2))
big_dda = dda[dda[:, 0] > 2, :]  # top chunk is empty
print(big_dda.max(axis=1).compute())
```

**Anything else we need to know?**:
I tracked this down when I got a `CancelledError`, because I was doing downstream processing with `delayed`. The CancelledError / exception stack made absolutely no reference to this operation, so it's a real head-scratcher for anyone who encounters it.

**Environment**:

- Dask version: 2023.3.0
- Python version: 3.10.6
- Operating System: macos 13.3.1 
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/10327/timeline,,,TedBrookings,6463752,MDQ6VXNlcjY0NjM3NTI=,https://avatars.githubusercontent.com/u/6463752?v=4,,https://api.github.com/users/TedBrookings,https://github.com/TedBrookings,https://api.github.com/users/TedBrookings/followers,https://api.github.com/users/TedBrookings/following{/other_user},https://api.github.com/users/TedBrookings/gists{/gist_id},https://api.github.com/users/TedBrookings/starred{/owner}{/repo},https://api.github.com/users/TedBrookings/subscriptions,https://api.github.com/users/TedBrookings/orgs,https://api.github.com/users/TedBrookings/repos,https://api.github.com/users/TedBrookings/events{/privacy},https://api.github.com/users/TedBrookings/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10327/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
870,https://api.github.com/repos/dask/dask/issues/10337,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10337/labels{/name},https://api.github.com/repos/dask/dask/issues/10337/comments,https://api.github.com/repos/dask/dask/issues/10337/events,https://github.com/dask/dask/issues/10337,1746653629,I_kwDOAbcwm85oG9G9,10337,dask.array.store behavior is inconsistent for `compute=True` and `compute=False`,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,"[{'login': 'crusaderky', 'id': 6213168, 'node_id': 'MDQ6VXNlcjYyMTMxNjg=', 'avatar_url': 'https://avatars.githubusercontent.com/u/6213168?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/crusaderky', 'html_url': 'https://github.com/crusaderky', 'followers_url': 'https://api.github.com/users/crusaderky/followers', 'following_url': 'https://api.github.com/users/crusaderky/following{/other_user}', 'gists_url': 'https://api.github.com/users/crusaderky/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/crusaderky/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/crusaderky/subscriptions', 'organizations_url': 'https://api.github.com/users/crusaderky/orgs', 'repos_url': 'https://api.github.com/users/crusaderky/repos', 'events_url': 'https://api.github.com/users/crusaderky/events{/privacy}', 'received_events_url': 'https://api.github.com/users/crusaderky/received_events', 'type': 'User', 'site_admin': False}]",,8,2023-06-07T20:46:31Z,2023-07-17T02:10:05Z,,MEMBER,,"**Describe the issue**:

I've been working to diagnosis an issue where some embarrassingly parallel `dask+distributed+zarr` workloads accumulate memory until the point of failure. The example below communicates the basic workflow that is failing which hinges on whether `compute` is set to True or False in `dask.array.store`. When `compute=False` and the resulting object is computed, the workflow succeeds but when `compute=True`, memory on the workers steadily climbs.

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.array as da
from dask.distributed import Client

# target zarr store
store = ""s3://test-bucket""

# Create Dask LocalCluster / Client
dclient = Client()

# Write random dask array to store
state = da.random.RandomState(1234)
arr = state.random((500, 17999, 36000), chunks=(5, 1799, 3600))

# this works
tsk = arr.to_zarr(store, component='compute_false', compute=False)
dask.compute(tsk)

# this eventually runs out of memory
arr.to_zarr(store, component='compute_true', compute=True)
```

**Anything else we need to know?**:

Looking at at the source code for `dask.array.store` I've zeroed in on what may (or may not) be an important detail. when `compute=True`, a `HighLevelGraph` is created and computed on using `compute_as_if_collection`. When `compute=False`, an additional task is added to the `HighLevelGraph` and a `delayed` object is returned: 

https://github.com/dask/dask/blob/596d74dbc72db663efac606d42d5c93c5a917fb9/dask/array/core.py#L1235-L1245

What I don't understand is why/how dask is able to better execute the graph formed in the later case? Why doesn't dask create the same graph in both cases, then (optionally) compute?

**Environment**:

- Dask version: 2023.5.0 (same for distributed)
- Python version: 3.10.11
- Operating System: Linux / Ubuntu
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/10337/timeline,,,jhamman,2443309,MDQ6VXNlcjI0NDMzMDk=,https://avatars.githubusercontent.com/u/2443309?v=4,,https://api.github.com/users/jhamman,https://github.com/jhamman,https://api.github.com/users/jhamman/followers,https://api.github.com/users/jhamman/following{/other_user},https://api.github.com/users/jhamman/gists{/gist_id},https://api.github.com/users/jhamman/starred{/owner}{/repo},https://api.github.com/users/jhamman/subscriptions,https://api.github.com/users/jhamman/orgs,https://api.github.com/users/jhamman/repos,https://api.github.com/users/jhamman/events{/privacy},https://api.github.com/users/jhamman/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10337/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,crusaderky,6213168.0,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False
871,https://api.github.com/repos/dask/dask/issues/10339,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10339/labels{/name},https://api.github.com/repos/dask/dask/issues/10339/comments,https://api.github.com/repos/dask/dask/issues/10339/events,https://github.com/dask/dask/pull/10339,1747951643,PR_kwDOAbcwm85She-R,10339,Improve performance of histogram when using scalar_bins,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2023-06-08T13:58:39Z,2024-01-29T01:45:05Z,,FIRST_TIME_CONTRIBUTOR,,"Hey all,

I did not first make this an issue for I feel I could provide a possible solution.
If it is better etiquette to first make an issue before creating a pull request, let me know and I will do so in the future.

~~- [ ] Closes #xxxx~~
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

This pull request is inspired by this forum post:
https://dask.discourse.group/t/how-does-da-histogram-work/1907

The performance of `dask.array.histogram` is significantly worse than that of `numpy.histogram` when a scalar is supplied as the `bins`argument. I am assuming a single threaded case here, since the difference in performance can be overcome by solving lots of tasks in parallel.

It seems to me this difference in performance between scalars and arrays relates to an array being able have bins that are not equally spaced, though I am not familiar with the details of the Numpy implementation and I could be wrong about the reason. 

In the dask implementation any scalar is turned int an array at this line:
https://github.com/dask/dask/blob/453bd7031828f72e4602498c1a1f776280794bea/dask/array/routines.py#L1002
This happens before `_block_hist` is called. Therefore Dask always provides `_block_hist` (and thus by extension `numpy.histogram`) with an array, even when initially presented with a scalar.

In this pull request I move the call to `_linspace_from_delayed` after the call to `_block_hist`. The aim of this change is to provide a scalar to the Numpy implementation of `histogram` if a scalar was provided to the Dask implementation of histogram, but still return `bins` as an array from the `dask.array.histogram` function.

This seems to improve the performance. I ran a simple benchmark where I plot the number of samples vs the duration.
The Dask runs had access to 12 cores.
![image](https://github.com/dask/dask/assets/45204355/85a6eaac-7c98-4866-8e82-c5a169218730)

I understand a risk of my implementation is that the bins estimated by `_linspace_from_delayed` could be different than those estimated by Numpy when presented with a scalar. I would argue that the unit tests in dask/array/tests/test_routines.py are sufficient to verify this.

This is my first pull request and I am open to any feedback.

Cheers,
Timo
",,https://api.github.com/repos/dask/dask/issues/10339/timeline,,,tmillenaar,45204355,MDQ6VXNlcjQ1MjA0MzU1,https://avatars.githubusercontent.com/u/45204355?v=4,,https://api.github.com/users/tmillenaar,https://github.com/tmillenaar,https://api.github.com/users/tmillenaar/followers,https://api.github.com/users/tmillenaar/following{/other_user},https://api.github.com/users/tmillenaar/gists{/gist_id},https://api.github.com/users/tmillenaar/starred{/owner}{/repo},https://api.github.com/users/tmillenaar/subscriptions,https://api.github.com/users/tmillenaar/orgs,https://api.github.com/users/tmillenaar/repos,https://api.github.com/users/tmillenaar/events{/privacy},https://api.github.com/users/tmillenaar/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10339/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10339,https://github.com/dask/dask/pull/10339,https://github.com/dask/dask/pull/10339.diff,https://github.com/dask/dask/pull/10339.patch,,,,,,,,,,,,,,,,,,,
872,https://api.github.com/repos/dask/dask/issues/10366,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10366/labels{/name},https://api.github.com/repos/dask/dask/issues/10366/comments,https://api.github.com/repos/dask/dask/issues/10366/events,https://github.com/dask/dask/issues/10366,1765861496,I_kwDOAbcwm85pQOh4,10366,RecursionError: maximum recursion depth exceeded while calling a Python object,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-06-20T17:41:32Z,2023-07-24T01:54:47Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
When I loop 1500 times, there is no problem, but when I loop 17000 times I got the following error: 

Traceback (most recent call last):
  File ""/home/qiahan/.conda/envs/firstEnv/lib/python3.9/site-packages/xarray/core/variable.py"", line 264, in _as_array_or_item
    data = np.asarray(data)
  File ""/home/qiahan/.local/lib/python3.9/site-packages/dask/array/core.py"", line 1701, in __array__
    x = self.compute()
  File ""/home/qiahan/.local/lib/python3.9/site-packages/dask/base.py"", line 314, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/home/qiahan/.local/lib/python3.9/site-packages/dask/base.py"", line 599, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/home/qiahan/.local/lib/python3.9/site-packages/dask/threaded.py"", line 89, in get
    results = get_async(
  File ""/home/qiahan/.local/lib/python3.9/site-packages/dask/local.py"", line 511, in get_async
    raise_exception(exc, tb)
  File ""/home/qiahan/.local/lib/python3.9/site-packages/dask/local.py"", line 319, in reraise
    raise exc
  File ""/home/qiahan/.local/lib/python3.9/site-packages/dask/local.py"", line 224, in execute_task
    result = _execute_task(task, data)
  File ""/home/qiahan/.local/lib/python3.9/site-packages/dask/core.py"", line 119, in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
RecursionError: maximum recursion depth exceeded while calling a Python object
**Minimal Complete Verifiable Example**:

```python
for count_i,t in enumerate(all_resample.time.to_numpy()[96:17137],96):#zip(range(100), all_resample.time.to_numpy()[500:502]): 
      print(t)
      ds_era5land = all_resample.sel(time=t, method='nearest').compute()
      ds = xr.merge([ds_era5land])
      ds_ss = xr.Dataset()
      ds_ss[""Rin""] = Rin.sel(time=t, method='nearest').compute()
      ds_ss[""Rli""] = Rli.sel(time=t, method='nearest').compute()
      ds_ss[""p""] = ds[""sp""]/100   # Pa -> hPa
      ds_ss[""Ta""] = ds[""t2m""] - 273.15  # K -> degC
      ds_ss[""ea""] = vc.calculate_es(ds[""d2m""] - 273.15)
      ds_ss[""u""] = (ds[""u10""] ** 2 + ds[""v10""] ** 2) ** 0.5
      ds_ss[""Precip_msr""] = ds[""tp""]*1000   # mm
      ds_ss['LAI'] = lai.sel(time=t, method='nearest').compute()
      ds_ss['CO2'] = ds_co2_10km.sel(time=t, method='nearest').compute()
      ds_ss['SSM'] = SSM.sel(time=t, method='nearest').compute()

      ds_ss = ds_ss.to_array()
      Rin_line = ds_ss[0,:,:].to_numpy().reshape(1, ds_ss.latitude.size*ds_ss.longitude.size)
      Rli_line = ds_ss[1,:,:].to_numpy().reshape(1, ds_ss.latitude.size*ds_ss.longitude.size)
      p_line = ds_ss[2,:,:].to_numpy().reshape(1, ds_ss.latitude.size*ds_ss.longitude.size)
      Ta_line = ds_ss[3,:,:].to_numpy().reshape(1, ds_ss.latitude.size*ds_ss.longitude.size)
      ea_line = ds_ss[4,:,:].to_numpy().reshape(1, ds_ss.latitude.size*ds_ss.longitude.size)
      u_line = ds_ss[5,:,:].to_numpy().reshape(1, ds_ss.latitude.size*ds_ss.longitude.size)
      Precip_msr_line = ds_ss[6,:,:].to_numpy().reshape(1, ds_ss.latitude.size*ds_ss.longitude.size)
      LAI_line = ds_ss[7,:,:].to_numpy().reshape(1, ds_ss.latitude.size*ds_ss.longitude.size)
      CO2_line = ds_ss[8,:,:].to_numpy().reshape(1, ds_ss.latitude.size*ds_ss.longitude.size)
      SSM_line = ds_ss[9,:,:].to_numpy().reshape(1, ds_ss.latitude.size*ds_ss.longitude.size)

      features_arr = np.concatenate((Rin_line, Rli_line, p_line, Ta_line,ea_line, u_line, Precip_msr_line,
                                     LAI_line, hc_line, CO2_line, SSM_line, Vcmo_line,
                                     IGBP1, IGBP2, IGBP3,IGBP4,IGBP5,IGBP6,IGBP7,IGBP8,IGBP9,IGBP10,IGBP11))
      features_arr = features_arr.transpose()

      # Nan value.
      df_features = pd.DataFrame(data=features_arr)
      df_features_drop_nan = df_features.dropna()
      invalid_index = sorted(set(df_features.index.to_list()) - set(df_features_drop_nan.index.to_list()))

      # # Convert the nan value as 0 for the calculation
      where_are_NaNs = np.isnan(features_arr)
      features_arr[where_are_NaNs] = 0

      estimated_LEH = rfLEHmulti.predict(features_arr)
```

**Anything else we need to know?**:

**Environment**:

- Dask version:2023.1.0
- Python version:3.9.16
- Operating System:linux
- Install method (conda, pip, source):conda
",,https://api.github.com/repos/dask/dask/issues/10366/timeline,,,QianqianHan96,90645468,MDQ6VXNlcjkwNjQ1NDY4,https://avatars.githubusercontent.com/u/90645468?v=4,,https://api.github.com/users/QianqianHan96,https://github.com/QianqianHan96,https://api.github.com/users/QianqianHan96/followers,https://api.github.com/users/QianqianHan96/following{/other_user},https://api.github.com/users/QianqianHan96/gists{/gist_id},https://api.github.com/users/QianqianHan96/starred{/owner}{/repo},https://api.github.com/users/QianqianHan96/subscriptions,https://api.github.com/users/QianqianHan96/orgs,https://api.github.com/users/QianqianHan96/repos,https://api.github.com/users/QianqianHan96/events{/privacy},https://api.github.com/users/QianqianHan96/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10366/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
873,https://api.github.com/repos/dask/dask/issues/10368,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10368/labels{/name},https://api.github.com/repos/dask/dask/issues/10368/comments,https://api.github.com/repos/dask/dask/issues/10368/events,https://github.com/dask/dask/issues/10368,1769384416,I_kwDOAbcwm85pdqng,10368,dask.array.reshape() fails on large chunks,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-06-22T10:19:28Z,2024-01-29T01:45:04Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
When using dask.array.reshape on chunks that are larger than the `array.chunk-size` limit it will fail if the number of dimensions change. 

**Minimal Complete Verifiable Example**:

```python
# %%
import dask.array as da
import dask

dask.config.set(
    **{""array.slicing.split_large_chunks"": True, ""array.chunk-size"": ""1KiB""}
)

da.random.random((100, 100, 48)).rechunk((5, 5, 6)).reshape((100, 100, 2, 24))
```

**Anything else we need to know?**:
Affects Xarray https://github.com/pydata/xarray/issues/7931

**Environment**:

- Dask version: 2023.6.0
- Python version: 3.10
- Operating System: Linux
- Install method (conda, pip, source): source
",,https://api.github.com/repos/dask/dask/issues/10368/timeline,,,ska-incom,79853012,MDQ6VXNlcjc5ODUzMDEy,https://avatars.githubusercontent.com/u/79853012?v=4,,https://api.github.com/users/ska-incom,https://github.com/ska-incom,https://api.github.com/users/ska-incom/followers,https://api.github.com/users/ska-incom/following{/other_user},https://api.github.com/users/ska-incom/gists{/gist_id},https://api.github.com/users/ska-incom/starred{/owner}{/repo},https://api.github.com/users/ska-incom/subscriptions,https://api.github.com/users/ska-incom/orgs,https://api.github.com/users/ska-incom/repos,https://api.github.com/users/ska-incom/events{/privacy},https://api.github.com/users/ska-incom/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10368/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
874,https://api.github.com/repos/dask/dask/issues/10369,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10369/labels{/name},https://api.github.com/repos/dask/dask/issues/10369/comments,https://api.github.com/repos/dask/dask/issues/10369/events,https://github.com/dask/dask/pull/10369,1769505219,PR_kwDOAbcwm85TpbKS,10369,[WIP] Pass non HLG objects wout materialization,[],open,False,,[],,2,2023-06-22T11:41:54Z,2024-01-16T13:18:29Z,,MEMBER,,Sibling and description https://github.com/dask/distributed/pull/7942,,https://api.github.com/repos/dask/dask/issues/10369/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10369/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10369,https://github.com/dask/dask/pull/10369,https://github.com/dask/dask/pull/10369.diff,https://github.com/dask/dask/pull/10369.patch,,,,,,,,,,,,,,,,,,,
875,https://api.github.com/repos/dask/dask/issues/10374,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10374/labels{/name},https://api.github.com/repos/dask/dask/issues/10374/comments,https://api.github.com/repos/dask/dask/issues/10374/events,https://github.com/dask/dask/issues/10374,1775461005,I_kwDOAbcwm85p02KN,10374,Support drop_duplicates(subset=...),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,1,2023-06-26T19:36:21Z,2024-01-29T01:45:03Z,,MEMBER,,"(This is a little ramble-y.  Sorry.)

Probably we could make drop_duplicates more scalable in the case where folks subset on columns.  We would still probably have to fit information about every row for the relevant columns in memory, but this is quite different from reducing the entire dataset (all columns) to a single partition. 

My thinking is that for each value of the subsetted columns we want to know that only a single partition will hold onto that value.  One way to do this would be to build up a mapping of value to partition number like the following:

```python
df.drop_duplicates(subset=[""id""])
```
```python
{ 
    (100,): 3,
    (101,): 0,
    (102,): 5,
    ...
}
```

Where the keys are values and the values are the partition index in which they should be allowed.  Building this mapping requires a full reduction of this column to a single dataframe (or we could split things up if we wanted to I guess, similar to split_out).  Actually that could probably be a pandas DataFrame with a multi-index?.

Then we would need to broadcast that data out to all of the partitions again.  ",,https://api.github.com/repos/dask/dask/issues/10374/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10374/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
876,https://api.github.com/repos/dask/dask/issues/10375,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10375/labels{/name},https://api.github.com/repos/dask/dask/issues/10375/comments,https://api.github.com/repos/dask/dask/issues/10375/events,https://github.com/dask/dask/issues/10375,1777203428,I_kwDOAbcwm85p7fjk,10375,"tokenize is non-deterministic for scipy.sparse.{csr,csc}_array","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-06-27T15:11:20Z,2023-07-31T01:52:12Z,,NONE,,"**Describe the issue**:

`tokenize` is non-deterministic for the new [scipy.sparse array classes](https://docs.scipy.org/doc/scipy/reference/sparse.html#sparse-array-classes). This is not the case for the older `_matrix` classes.

**Minimal Complete Verifiable Example**:

```python
from scipy import sparse
from dask.base import tokenize

mtx = sparse.random(100, 100, format=""csr"")
arr = sparse.csr_array(mtx)

assert tokenize(mtx) == tokenize(mtx)
assert tokenize(arr) == tokenize(arr)
```

```pytb
---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
Cell In[1], line 8
      5 arr = sparse.csr_array(mtx)
      7 assert tokenize(mtx) == tokenize(mtx)
----> 8 assert tokenize(arr) == tokenize(arr)

AssertionError: 
```

The same result occurs for the `csc_array` class.

**Anything else we need to know?**:

**Environment**:

- Dask version: 2023.6.1
- Python version: 3.9.16
- Operating System: macOS-13.4.1-x86_64-i386-64bit
- Install method (conda, pip, source): pip

<details>
<summary> `session_info` output </summary>

```python
-----
IPython             8.14.0
dask                2023.6.1
scipy               1.11.0
session_info        1.0.0
-----
asttokens           NA
backcall            0.2.0
cloudpickle         2.0.0
colorama            0.4.4
cython_runtime      NA
cytoolz             0.10.1
decorator           5.1.0
executing           0.8.2
google              NA
importlib_metadata  NA
jedi                0.18.1
jinja2              3.1.1
markupsafe          2.1.1
mpl_toolkits        NA
numpy               1.24.3
packaging           23.0
parso               0.8.2
pexpect             4.8.0
pickleshare         0.7.5
prompt_toolkit      3.0.38
psutil              5.9.0
ptyprocess          0.7.0
pure_eval           0.2.1
pygments            2.13.0
ruamel              NA
sitecustomize       NA
six                 1.16.0
sphinxcontrib       NA
stack_data          0.1.4
tblib               1.7.0
tlz                 0.10.1
toolz               0.12.0
traitlets           5.6.0
typing_extensions   NA
wcwidth             0.2.5
xxhash              NA
yaml                5.4.1
zipp                NA
-----
Python 3.9.16 (main, Dec  7 2022, 10:15:13) [Clang 13.0.0 (clang-1300.0.29.30)]
macOS-13.4.1-x86_64-i386-64bit
-----
Session information updated at 2023-06-27 17:08
```

</details>
",,https://api.github.com/repos/dask/dask/issues/10375/timeline,,,ivirshup,8238804,MDQ6VXNlcjgyMzg4MDQ=,https://avatars.githubusercontent.com/u/8238804?v=4,,https://api.github.com/users/ivirshup,https://github.com/ivirshup,https://api.github.com/users/ivirshup/followers,https://api.github.com/users/ivirshup/following{/other_user},https://api.github.com/users/ivirshup/gists{/gist_id},https://api.github.com/users/ivirshup/starred{/owner}{/repo},https://api.github.com/users/ivirshup/subscriptions,https://api.github.com/users/ivirshup/orgs,https://api.github.com/users/ivirshup/repos,https://api.github.com/users/ivirshup/events{/privacy},https://api.github.com/users/ivirshup/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10375/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
877,https://api.github.com/repos/dask/dask/issues/10376,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10376/labels{/name},https://api.github.com/repos/dask/dask/issues/10376/comments,https://api.github.com/repos/dask/dask/issues/10376/events,https://github.com/dask/dask/pull/10376,1777381046,PR_kwDOAbcwm85UDu8A,10376,Basic support for scipy.sparse array classes,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3028194444, 'node_id': 'MDU6TGFiZWwzMDI4MTk0NDQ0', 'url': 'https://api.github.com/repos/dask/dask/labels/dispatch', 'name': 'dispatch', 'color': 'fc03db', 'default': False, 'description': 'Related to `Dispatch` extension objects'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-06-27T16:56:14Z,2023-07-31T01:52:11Z,,FIRST_TIME_CONTRIBUTOR,,"- [x] Closes #10375
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

This PR adds basic support for the scipy sparse array classes. Currently, this just implements tokenization and concatenation.

These classes are currently under development, so some less than ideal code has been needed for concatenation. Ideally this could be removed once scipy allows concatenating sparse arrays such that an array (and not a matrix) is returned. However, I'm not totally clear on how dask does minimum versions of its dependencies.

Update: I have found some info on minimum test versions via failing tests ",,https://api.github.com/repos/dask/dask/issues/10376/timeline,,,ivirshup,8238804,MDQ6VXNlcjgyMzg4MDQ=,https://avatars.githubusercontent.com/u/8238804?v=4,,https://api.github.com/users/ivirshup,https://github.com/ivirshup,https://api.github.com/users/ivirshup/followers,https://api.github.com/users/ivirshup/following{/other_user},https://api.github.com/users/ivirshup/gists{/gist_id},https://api.github.com/users/ivirshup/starred{/owner}{/repo},https://api.github.com/users/ivirshup/subscriptions,https://api.github.com/users/ivirshup/orgs,https://api.github.com/users/ivirshup/repos,https://api.github.com/users/ivirshup/events{/privacy},https://api.github.com/users/ivirshup/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10376/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10376,https://github.com/dask/dask/pull/10376,https://github.com/dask/dask/pull/10376.diff,https://github.com/dask/dask/pull/10376.patch,,,,,,,,,,,,,,,,,,,
878,https://api.github.com/repos/dask/dask/issues/10386,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10386/labels{/name},https://api.github.com/repos/dask/dask/issues/10386/comments,https://api.github.com/repos/dask/dask/issues/10386/events,https://github.com/dask/dask/issues/10386,1781926985,I_kwDOAbcwm85qNgxJ,10386,`dd.read_parquet` raised `KeyError` when reading a level from a `multiIndex` parquet file,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,2,2023-06-30T05:35:23Z,2023-08-14T01:44:49Z,,NONE,,"**Describe the issue**:
Crashed when read one index level of a parquet file with `multi-index` using the method `dd.read_parquet`.

df
```
     a  b
x y      
0 1  2  3
```

Error
```
File ~\dask\dataframe\io\parquet\arrow.py:690, in ArrowDatasetEngine.read_partition(cls, fs, pieces, columns, index, dtype_backend, categories, partitions, filters, schema, **kwargs)
    688         index = False
    689         columns_and_parts = list(set(columns_and_parts) - set(df.index.names))
--> 690 df = df[list(columns_and_parts)]
    692 if index:
    693     df = df.set_index(index)

File ~\pandas\core\indexes\base.py:5935, in Index._raise_if_missing(self, key, indexer, axis_name)
   5933     if use_interval_msg:
   5934         key = list(key)
-> 5935     raise KeyError(f""None of [{key}] are in the [{axis_name}]"")
   5937 not_found = list(ensure_index(key)[missing_mask.nonzero()[0]].unique())
   5938 raise KeyError(f""{not_found} not in index"")

KeyError: ""None of [Index(['x'], dtype='object')] are in the [columns]""
```

**Minimal Complete Verifiable Example**:
See Python code

```python
import pandas as pd
import pyarrow as pa
import pyarrow.parquet as pq
from dask import dataframe as dd

df = pd.DataFrame(
    [[0, 1, 2, 3]],
    columns = ['x', 'y', 'a', 'b'], 
).set_index(['x', 'y'])
print(df)

table = pa.Table.from_pandas(df)
pq.write_table(table=table, where='data.parquet', compression='zstd')

d = dd.read_parquet(
    'data.parquet', 
    index=False, 
    columns=['x'], 
    engine='pyarrow',
).compute()
d
```

**Anything else we need to know?**:
When the parquet file is not multiIndex, it works as expected.

**Environment**:

- Dask version: 2023.6.1
- Python version: 3.9.15
- Operating System: Window 10
- Install method (conda, pip, source): pip default
",,https://api.github.com/repos/dask/dask/issues/10386/timeline,,,seanslma,30691708,MDQ6VXNlcjMwNjkxNzA4,https://avatars.githubusercontent.com/u/30691708?v=4,,https://api.github.com/users/seanslma,https://github.com/seanslma,https://api.github.com/users/seanslma/followers,https://api.github.com/users/seanslma/following{/other_user},https://api.github.com/users/seanslma/gists{/gist_id},https://api.github.com/users/seanslma/starred{/owner}{/repo},https://api.github.com/users/seanslma/subscriptions,https://api.github.com/users/seanslma/orgs,https://api.github.com/users/seanslma/repos,https://api.github.com/users/seanslma/events{/privacy},https://api.github.com/users/seanslma/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10386/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
879,https://api.github.com/repos/dask/dask/issues/10387,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10387/labels{/name},https://api.github.com/repos/dask/dask/issues/10387/comments,https://api.github.com/repos/dask/dask/issues/10387/events,https://github.com/dask/dask/issues/10387,1782164200,I_kwDOAbcwm85qOaro,10387,`dask.array` module should expose dtype objects and  the `isdtype` function,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,2,2023-06-30T08:59:03Z,2024-02-28T12:58:19Z,,MEMBER,,"```python
>>> import dask.array as da
>>> da.float32
Traceback (most recent call last):
  Cell In[5], line 1
    da.float32
AttributeError: module 'dask.array' has no attribute 'float32'
>>> da.isdtype
Traceback (most recent call last):
  Cell In[6], line 1
    da.isdtype
AttributeError: module 'dask.array' has no attribute 'isdtype'
```

See:

- https://data-apis.org/array-api/latest/API_specification/generated/array_api.isdtype.html
- https://data-apis.org/array-api/latest/API_specification/data_types.html

It's not clear if the dtype objects should be all exposed as attributes of the top level module but this usually the case in other implementations of the spec:

```python
>>> import numpy.array_api as xp
<ipython-input-7-e68880e64b48>:1: UserWarning: The numpy.array_api submodule is still experimental. See NEP 47.
  import numpy.array_api as xp
>>> xp.float32
dtype('float32')
>>> xp.float64
dtype('float64')
>>> xp.isdtype(xp.zeros(shape=5, dtype=xp.float32), ""real floating"")
True
>>> numpy.array_api.float32 == numpy.float32
True
```

Since dask arrays use numpy arrays by default, I think that dask could just alias `numpy.float32` as `dask.array.float32` (and similarly for the other numpy dtypes).

Unfortunately, `numpy.isdtype` does not exist yet. Maybe `dask.array` could lazily alias `numpy.array_api.isdtype` as `dask.array.isdtype` with some module level `__getattr__` to not raise the `numpy.array_api` experimental warning by default.

Alternative, `dask.array` could ship its own implementation of `isdtype` (maybe vendoring/forking the one from `numpy.array_api`).",,https://api.github.com/repos/dask/dask/issues/10387/timeline,,,ogrisel,89061,MDQ6VXNlcjg5MDYx,https://avatars.githubusercontent.com/u/89061?v=4,,https://api.github.com/users/ogrisel,https://github.com/ogrisel,https://api.github.com/users/ogrisel/followers,https://api.github.com/users/ogrisel/following{/other_user},https://api.github.com/users/ogrisel/gists{/gist_id},https://api.github.com/users/ogrisel/starred{/owner}{/repo},https://api.github.com/users/ogrisel/subscriptions,https://api.github.com/users/ogrisel/orgs,https://api.github.com/users/ogrisel/repos,https://api.github.com/users/ogrisel/events{/privacy},https://api.github.com/users/ogrisel/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10387/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
880,https://api.github.com/repos/dask/dask/issues/10388,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10388/labels{/name},https://api.github.com/repos/dask/dask/issues/10388/comments,https://api.github.com/repos/dask/dask/issues/10388/events,https://github.com/dask/dask/issues/10388,1782170821,I_kwDOAbcwm85qOcTF,10388,`dask.array.linalg.qr` does not conform to the Array API spec,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2023-06-30T09:03:27Z,2023-07-03T09:39:03Z,,MEMBER,,"It should expose a `mode=""reduced""/""complete""` kwarg:

- https://data-apis.org/array-api/latest/extensions/generated/array_api.linalg.qr.html",,https://api.github.com/repos/dask/dask/issues/10388/timeline,,,ogrisel,89061,MDQ6VXNlcjg5MDYx,https://avatars.githubusercontent.com/u/89061?v=4,,https://api.github.com/users/ogrisel,https://github.com/ogrisel,https://api.github.com/users/ogrisel/followers,https://api.github.com/users/ogrisel/following{/other_user},https://api.github.com/users/ogrisel/gists{/gist_id},https://api.github.com/users/ogrisel/starred{/owner}{/repo},https://api.github.com/users/ogrisel/subscriptions,https://api.github.com/users/ogrisel/orgs,https://api.github.com/users/ogrisel/repos,https://api.github.com/users/ogrisel/events{/privacy},https://api.github.com/users/ogrisel/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10388/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
881,https://api.github.com/repos/dask/dask/issues/10389,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10389/labels{/name},https://api.github.com/repos/dask/dask/issues/10389/comments,https://api.github.com/repos/dask/dask/issues/10389/events,https://github.com/dask/dask/issues/10389,1782183579,I_kwDOAbcwm85qOfab,10389,`dask.array.linalg.svd` does not conform to the Array API spec,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,1,2023-06-30T09:12:17Z,2023-06-30T17:11:47Z,,MEMBER,,"It lacks the `full_matrices=True/False` kwarg.

- https://data-apis.org/array-api/latest/extensions/generated/array_api.linalg.svd

dask currently implements the `full_matrices=False` case, while `full_matrices=True` is the default in the spec.

It would be nice to at least expose `full_matrices=False` and raise `NotImplementedError` when calling `full_matrices=True` to make Array API consuming code be able to use dask while staying backend agnostic when they only need the `full_matrices=False` case (which is the most commonly used in my opinion).",,https://api.github.com/repos/dask/dask/issues/10389/timeline,,,ogrisel,89061,MDQ6VXNlcjg5MDYx,https://avatars.githubusercontent.com/u/89061?v=4,,https://api.github.com/users/ogrisel,https://github.com/ogrisel,https://api.github.com/users/ogrisel/followers,https://api.github.com/users/ogrisel/following{/other_user},https://api.github.com/users/ogrisel/gists{/gist_id},https://api.github.com/users/ogrisel/starred{/owner}{/repo},https://api.github.com/users/ogrisel/subscriptions,https://api.github.com/users/ogrisel/orgs,https://api.github.com/users/ogrisel/repos,https://api.github.com/users/ogrisel/events{/privacy},https://api.github.com/users/ogrisel/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10389/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
882,https://api.github.com/repos/dask/dask/issues/10396,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10396/labels{/name},https://api.github.com/repos/dask/dask/issues/10396/comments,https://api.github.com/repos/dask/dask/issues/10396/events,https://github.com/dask/dask/issues/10396,1786562134,I_kwDOAbcwm85qfMZW,10396,Cache is not thread safe,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-07-03T17:22:25Z,2023-08-14T01:44:48Z,,NONE,,"**Describe the issue**:

Computing any dask graphs while using the same cache on multiple threads can cause errors.

This has been previously reported in a variety of issues (e.g. https://github.com/dask/dask/issues/896, https://github.com/dask/distributed/issues/2372, https://github.com/napari/napari/issues/5591, https://github.com/haesleinhuepf/napari-time-slicer/pull/6), but I wrote a new issue with a reproducer to clarify one underlying cause.

**Minimal Complete Verifiable Example**:

The following Python code should always raise an exception on the non-main thread.

```python
import numpy as np
import dask.array as da
from dask.cache import Cache
from threading import Condition, RLock, Thread

# Extend the regular cache so that we block execution in the _posttask callback
class BlockingCache(Cache):
    def __init__(self, cache):
        super().__init__(cache)
        self.task_finished = Condition()
        self.posttask_lock = RLock()

    def _posttask(self, key, value, dsk, state, id):
        with self.task_finished:
            self.task_finished.notify()
        with self.posttask_lock:
            super()._posttask(key, value, dsk, state, id)


def cached_array_index(cache, array, index):
    with cache:
        return array[index].compute()


def test_multithreaded_access():
    array = da.from_array([0, 1])
    # Cache size is irrelevant because we don't need it here.
    cache = BlockingCache(1)
    thread = Thread(target=cached_array_index, args=(cache, array, 0))
    # Hold the posttask_lock to prevent the other thread from
    # executing the actual cache's _posttask callback.
    with cache.posttask_lock:
        with cache.task_finished:
            thread.start()
            # Wait for the other thread to reach _posttask.
            cache.task_finished.wait()
        # Execute the whole graph on the main thread.
        cached_array_index(cache, array, 1)
    # Wait for the other thread to finish executing.
    thread.join()

if __name__ == '__main__':
    test_multithreaded_access()
```

Here is the error I get on my local machine.

```
Exception in thread Thread-1:
Traceback (most recent call last):
  File ""/Users/asweet/software/miniconda3/envs/napari-cryoet-data-portal-dev/lib/python3.9/threading.py"", line 980, in _bootstrap_inner
    self.run()
  File ""/Users/asweet/software/miniconda3/envs/napari-cryoet-data-portal-dev/lib/python3.9/threading.py"", line 917, in run
    self._target(*self._args, **self._kwargs)
  File ""/Users/asweet/data/bugs/5591/simplified_dask.py"", line 23, in cached_array_index
    return array[index].compute()
  File ""/Users/asweet/software/miniconda3/envs/napari-cryoet-data-portal-dev/lib/python3.9/site-packages/dask/base.py"", line 310, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/Users/asweet/software/miniconda3/envs/napari-cryoet-data-portal-dev/lib/python3.9/site-packages/dask/base.py"", line 595, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/Users/asweet/software/miniconda3/envs/napari-cryoet-data-portal-dev/lib/python3.9/site-packages/dask/threaded.py"", line 89, in get
    results = get_async(
  File ""/Users/asweet/software/miniconda3/envs/napari-cryoet-data-portal-dev/lib/python3.9/site-packages/dask/local.py"", line 516, in get_async
    f(key, res, dsk, state, worker_id)
  File ""/Users/asweet/data/bugs/5591/simplified_dask.py"", line 18, in _posttask
    super()._posttask(key, value, dsk, state, id)
  File ""/Users/asweet/software/miniconda3/envs/napari-cryoet-data-portal-dev/lib/python3.9/site-packages/dask/cache.py"", line 58, in _posttask
    duration = default_timer() - self.starttimes[key]
KeyError: ('getitem-8d24cd8febbf60810a2497062186234f',)
```

I also [created a diagram to show what's happening here](https://github.com/andy-sweet/napari-diagrams/blob/main/dask-cache-multithread-error.drawio.svg).

Note that in this case, the tasks are different, but that doesn't matter since `Cache._finish` clears `Cache.starttimes`. There is another more interesting variant of this bug where the cache actually gets used.

```python
def test_multithreaded_access_same_key():
    array = da.from_array([0, 1])
    # Cache is not big enough to store even one result, so each
    # array access will cause a task to be executed.
    cache = BlockingCache(1)
    thread = Thread(target=cached_array_index, args=(cache, array, 0))
    with cache.posttask_lock:
        with cache.task_finished:
            thread.start()
            cache.task_finished.wait()
        cached_array_index(cache, array, 0)
    thread.join()
```

Any fix here should probably fix both of these tests as a minimum.

**Anything else we need to know?**:

I'm mostly coming here from napari (https://github.com/napari/napari/pull/5610). Based on comments from the related issues, it sounds like there was no intent to make `Cache` thread safe and there may not be much motivation to make it thread safe in the future. I think that's fine, but hope this issue is still hopeful for others running into the same issue.

One potential fix is to change the implementation of `Cache._posttask` and `Cache._finish` to be the following.

```python
    def _posttask(self, key, value, dsk, state, id):
        if starttime := self.starttimes.pop(key, None):
            duration = default_timer() - starttime
            if deps := state[""dependencies""][key]:
                duration += max(self.durations.get(k, 0) for k in deps)
            self.durations[key] = duration
            nb = self._nbytes(value) + overhead + sys.getsizeof(key) * 4
            self.cache.put(key, value, cost=duration / nb / 1e9, nbytes=nb)

    def _finish(self, dsk, state, errored):
        self.durations.clear()
```

This fixes the tests above and seems to make some vague sense to me (i.e. don't update the cache when a stale task finishes), but I don't know enough about dask to state that with much certainty.

**Environment**:

- Dask version: 2023.6.1
- Python version: Python 3.9.6
- Operating System: macOS 13.4 (Intel)
- Install method (conda, pip, source): pip",,https://api.github.com/repos/dask/dask/issues/10396/timeline,,,andy-sweet,2608297,MDQ6VXNlcjI2MDgyOTc=,https://avatars.githubusercontent.com/u/2608297?v=4,,https://api.github.com/users/andy-sweet,https://github.com/andy-sweet,https://api.github.com/users/andy-sweet/followers,https://api.github.com/users/andy-sweet/following{/other_user},https://api.github.com/users/andy-sweet/gists{/gist_id},https://api.github.com/users/andy-sweet/starred{/owner}{/repo},https://api.github.com/users/andy-sweet/subscriptions,https://api.github.com/users/andy-sweet/orgs,https://api.github.com/users/andy-sweet/repos,https://api.github.com/users/andy-sweet/events{/privacy},https://api.github.com/users/andy-sweet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10396/reactions,2,1,0,0,0,0,1,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
883,https://api.github.com/repos/dask/dask/issues/10399,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10399/labels{/name},https://api.github.com/repos/dask/dask/issues/10399/comments,https://api.github.com/repos/dask/dask/issues/10399/events,https://github.com/dask/dask/issues/10399,1791586091,I_kwDOAbcwm85qyW8r,10399,map_blocks with arrays of different sizes,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-07-06T13:38:21Z,2024-01-22T01:49:32Z,,NONE,,"**Describe the issue**:
A function that is supplied to `dask.array.map_blocks` can be called with multiple Dask arrays as input.
This generally works if the shape of the input arrays is the same.
If however the input arrays have a different shape, unexpected behavior can arise.
The chunks and shapes are often not as expected.
Sometimes calling `compute()` on the result will yield an incorrect array and sometimes it errors with
`*** IndexError: tuple index out of range`

**Minimal Complete Verifiable Example**:
In this example I define a function where the second argument is unused and the first argument is returned unmodified.
The expectation therefore is that the result is unaffected by the second array.
```python
import numpy as np
import dask.array as da

def foo(arr1, arr2):
    return arr1

arr_3d = da.stack(3*[da.eye(2)])
arr_2d = da.stack(3*[da.arange(2)])

print(""Shape of arr_3d:"", arr_3d.shape)
print(""Shape of arr_2d:"", arr_2d.shape)

result =  da.map_blocks(foo, arr_3d, arr_2d)
print(""Shape of result:"", result.shape)
```
This returns:
```
Shape of arr_3d: (3, 2, 2)
Shape of arr_2d: (3, 2)
Shape of result: (3, 3, 2)
```
Of course I would have expected the shape of the result to be (3, 2, 2) and not (3, 3, 2).
What is possibly even more telling than the shape are the chunks. If I run the code above but print the chunks instead of the shape I get:
```
Chunks of arr_3d: ((1, 1, 1), (2,), (2,))
Chunks of arr_2d: ((1, 1, 1), (2,))
Chunks of result: ((1, 1, 1), (1, 1, 1), (2,))
```
If instead of supplying `arr_2d` to the function, I supply any non-dask object, the function works as expected. In this case I supplied None instead:
```
Chunks of arr_3d: ((1, 1, 1), (2,), (2,))
Chunks of result: ((1, 1, 1), (2,), (2,))
```

So the mere presence of the second array will mess up the chunking and shape of the return array.

**Anything else we need to know?**:

I think the problem might be originating in the creation of `argpairs` here:
https://github.com/dask/dask/blob/461355e117958354ed30e29893afecd5e9258ff0/dask/array/core.py#L802-L805

The variable `argpairs` will have the length of the respective arrays, but it gets inverted. 
In this example, the indices that go with the `argpairs` are (2, 1, 0) for the first array where the corresponding chunks are ((1, 1, 1), (2,), (2,)). For the second array we have the indices (1, 0) with the corresponding chunks ((1, 1, 1), (2,)).
What I was assuming when calling the function was that the chunks are matched in order. Instead now we have the (1,1,1) corresponding to index 1 of the second argument overwriting the (2,) corresponding to index 1 of the first argument.
The overwrite is occurring here:
https://github.com/dask/dask/blob/461355e117958354ed30e29893afecd5e9258ff0/dask/array/blockwise.py#L192-L195

I have not tried to fiddle with `argpairs` yet for I am not very familiar with Dasks internals and I want to check here first if this is even supported functionality.

**Workaround**
It does work if we create an extra (dummy) dimension on the second array so it matches the number of axes of the first.
The following works as expected:
`arr_2d = da.expand_dims(arr_2d, 2)`

Which gives the chunks:
```
Chunks of arr_3d: ((1, 1, 1), (2,), (2,))
Chunks of arr_2d: ((1, 1, 1), (2,), (1,))
Chunks of result: ((1, 1, 1), (2,), (2,))
```

**Expectation of solution**:
I am unsure if this is feature is meant to be supported.
While I would love for this feature to be supported, another possible outcome of this issue could of course be the statement that we do not support `map_blocks` on arrays of different sizes.
In that case an explicit error could be beneficial.


**Environment**:

- Dask version: 2023.3.2 and 2023.5.0
- Python version: 3.8.10
- Operating System: Ubuntu 20.04 LTS (focal)
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10399/timeline,,,tmillenaar,45204355,MDQ6VXNlcjQ1MjA0MzU1,https://avatars.githubusercontent.com/u/45204355?v=4,,https://api.github.com/users/tmillenaar,https://github.com/tmillenaar,https://api.github.com/users/tmillenaar/followers,https://api.github.com/users/tmillenaar/following{/other_user},https://api.github.com/users/tmillenaar/gists{/gist_id},https://api.github.com/users/tmillenaar/starred{/owner}{/repo},https://api.github.com/users/tmillenaar/subscriptions,https://api.github.com/users/tmillenaar/orgs,https://api.github.com/users/tmillenaar/repos,https://api.github.com/users/tmillenaar/events{/privacy},https://api.github.com/users/tmillenaar/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10399/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
884,https://api.github.com/repos/dask/dask/issues/10409,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10409/labels{/name},https://api.github.com/repos/dask/dask/issues/10409/comments,https://api.github.com/repos/dask/dask/issues/10409/events,https://github.com/dask/dask/issues/10409,1801961494,I_kwDOAbcwm85rZ8AW,10409,"""Workers"" tab in dashboard can not utilize the whole screen space","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,3,2023-07-13T00:55:28Z,2024-05-08T17:40:51Z,,NONE,,"the div column width is fixed to 810px, so the whole datatable is condensed in a small box, looks like below:

![image](https://github.com/dask/dask/assets/9129006/a16fe53a-6093-469e-9464-0bb4dc3663a8)

is there a simple way to hack the source code to make the table wider?",,https://api.github.com/repos/dask/dask/issues/10409/timeline,,,goldenbull,9129006,MDQ6VXNlcjkxMjkwMDY=,https://avatars.githubusercontent.com/u/9129006?v=4,,https://api.github.com/users/goldenbull,https://github.com/goldenbull,https://api.github.com/users/goldenbull/followers,https://api.github.com/users/goldenbull/following{/other_user},https://api.github.com/users/goldenbull/gists{/gist_id},https://api.github.com/users/goldenbull/starred{/owner}{/repo},https://api.github.com/users/goldenbull/subscriptions,https://api.github.com/users/goldenbull/orgs,https://api.github.com/users/goldenbull/repos,https://api.github.com/users/goldenbull/events{/privacy},https://api.github.com/users/goldenbull/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10409/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
885,https://api.github.com/repos/dask/dask/issues/10413,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10413/labels{/name},https://api.github.com/repos/dask/dask/issues/10413/comments,https://api.github.com/repos/dask/dask/issues/10413/events,https://github.com/dask/dask/pull/10413,1806149297,PR_kwDOAbcwm85VlmCm,10413,Add full_matrices argument to linalg.svd (#10389),"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-07-15T14:51:46Z,2023-08-21T01:44:28Z,,CONTRIBUTOR,,"- [x] Closes #10389
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10413/timeline,,,mesejo,8579156,MDQ6VXNlcjg1NzkxNTY=,https://avatars.githubusercontent.com/u/8579156?v=4,,https://api.github.com/users/mesejo,https://github.com/mesejo,https://api.github.com/users/mesejo/followers,https://api.github.com/users/mesejo/following{/other_user},https://api.github.com/users/mesejo/gists{/gist_id},https://api.github.com/users/mesejo/starred{/owner}{/repo},https://api.github.com/users/mesejo/subscriptions,https://api.github.com/users/mesejo/orgs,https://api.github.com/users/mesejo/repos,https://api.github.com/users/mesejo/events{/privacy},https://api.github.com/users/mesejo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10413/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10413,https://github.com/dask/dask/pull/10413,https://github.com/dask/dask/pull/10413.diff,https://github.com/dask/dask/pull/10413.patch,,,,,,,,,,,,,,,,,,,
886,https://api.github.com/repos/dask/dask/issues/10415,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10415/labels{/name},https://api.github.com/repos/dask/dask/issues/10415/comments,https://api.github.com/repos/dask/dask/issues/10415/events,https://github.com/dask/dask/issues/10415,1808422154,I_kwDOAbcwm85rylUK,10415,Improve discoverability of scheduler keyword documentation,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-07-17T19:07:30Z,2023-08-21T01:44:27Z,,NONE,,"The [documetnation for schedulers](https://docs.dask.org/en/stable/scheduler-overview.html#configuring-the-schedulers) says:

>Additionally, each scheduler may take a few extra keywords specific to that scheduler. For example, the multiprocessing and threaded schedulers each take a num_workers keyword, which sets the number of processes or threads to use (defaults to number of cores). This can be set by passing the keyword when calling compute:

There is no link signposting where to find out keywords that different schedulers support however, and I'm struggling to find that information by searching the docs. It would be great to add a link to the scheduler API docs here (which I'm also strugging to find!).",,https://api.github.com/repos/dask/dask/issues/10415/timeline,,,dstansby,6197628,MDQ6VXNlcjYxOTc2Mjg=,https://avatars.githubusercontent.com/u/6197628?v=4,,https://api.github.com/users/dstansby,https://github.com/dstansby,https://api.github.com/users/dstansby/followers,https://api.github.com/users/dstansby/following{/other_user},https://api.github.com/users/dstansby/gists{/gist_id},https://api.github.com/users/dstansby/starred{/owner}{/repo},https://api.github.com/users/dstansby/subscriptions,https://api.github.com/users/dstansby/orgs,https://api.github.com/users/dstansby/repos,https://api.github.com/users/dstansby/events{/privacy},https://api.github.com/users/dstansby/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10415/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
887,https://api.github.com/repos/dask/dask/issues/10416,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10416/labels{/name},https://api.github.com/repos/dask/dask/issues/10416/comments,https://api.github.com/repos/dask/dask/issues/10416/events,https://github.com/dask/dask/issues/10416,1810040349,I_kwDOAbcwm85r4wYd,10416,Document that describe is using approximate algorithms,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,"[{'login': 'AmirAflak', 'id': 84932095, 'node_id': 'MDQ6VXNlcjg0OTMyMDk1', 'avatar_url': 'https://avatars.githubusercontent.com/u/84932095?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/AmirAflak', 'html_url': 'https://github.com/AmirAflak', 'followers_url': 'https://api.github.com/users/AmirAflak/followers', 'following_url': 'https://api.github.com/users/AmirAflak/following{/other_user}', 'gists_url': 'https://api.github.com/users/AmirAflak/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/AmirAflak/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/AmirAflak/subscriptions', 'organizations_url': 'https://api.github.com/users/AmirAflak/orgs', 'repos_url': 'https://api.github.com/users/AmirAflak/repos', 'events_url': 'https://api.github.com/users/AmirAflak/events{/privacy}', 'received_events_url': 'https://api.github.com/users/AmirAflak/received_events', 'type': 'User', 'site_admin': False}]",,5,2023-07-18T14:21:28Z,2024-04-22T10:06:22Z,,MEMBER,,"Calculating quantiles is difficult and expensive. For operations like `{DataFrame|Series}.describe` or `quantile` we're actually automatically falling back to an approximate algorithm.

This can be confusing, particularly for new users who are comparing results with pandas directly. While [quantile](https://docs.dask.org/en/stable/generated/dask.dataframe.DataFrame.quantile.html#dask.dataframe.DataFrame.quantile) is mentioning that this is approximate, [describe](https://docs.dask.org/en/stable/generated/dask.dataframe.Series.describe.html#dask.dataframe.Series.describe) doesn't even documenting the argument `percentile_method` since it's just inheriting the doc string from pandas",,https://api.github.com/repos/dask/dask/issues/10416/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10416/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
888,https://api.github.com/repos/dask/dask/issues/10417,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10417/labels{/name},https://api.github.com/repos/dask/dask/issues/10417/comments,https://api.github.com/repos/dask/dask/issues/10417/events,https://github.com/dask/dask/pull/10417,1810298471,PR_kwDOAbcwm85VzkVU,10417,Add mode optional argument to qr (#10388),"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-07-18T16:33:19Z,2023-08-21T01:44:25Z,,CONTRIBUTOR,,"- [x] Closes #10388
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10417/timeline,,,mesejo,8579156,MDQ6VXNlcjg1NzkxNTY=,https://avatars.githubusercontent.com/u/8579156?v=4,,https://api.github.com/users/mesejo,https://github.com/mesejo,https://api.github.com/users/mesejo/followers,https://api.github.com/users/mesejo/following{/other_user},https://api.github.com/users/mesejo/gists{/gist_id},https://api.github.com/users/mesejo/starred{/owner}{/repo},https://api.github.com/users/mesejo/subscriptions,https://api.github.com/users/mesejo/orgs,https://api.github.com/users/mesejo/repos,https://api.github.com/users/mesejo/events{/privacy},https://api.github.com/users/mesejo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10417/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10417,https://github.com/dask/dask/pull/10417,https://github.com/dask/dask/pull/10417.diff,https://github.com/dask/dask/pull/10417.patch,,,,,,,,,,,,,,,,,,,
889,https://api.github.com/repos/dask/dask/issues/10430,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10430/labels{/name},https://api.github.com/repos/dask/dask/issues/10430/comments,https://api.github.com/repos/dask/dask/issues/10430/events,https://github.com/dask/dask/issues/10430,1823087413,I_kwDOAbcwm85sqhs1,10430,"read_csv function does not support ""\\?\"" prefix to enable long path support on Windows","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,2,2023-07-26T20:08:51Z,2023-09-18T01:45:18Z,,NONE,,"The dask read_csv function does not support the `\\?\\ `prefix to enable long file path support on windows, whereas Pandas allows for this for the read_csv function. If the final file_path is over 255 characters, the FileNotFoundError is raised.

**Minimal Complete Verifiable Example**:
```python
import dask.dataframe as dd
file_path = r""C:\Users\username\[continued_path]\my_file_path_over_255_chars.csv""
df = dd.read_csv(fr'\\?\\{file_path}')
```

**Error raised when file_path is over 255 char**:
```python
FileNotFoundError: [WinError 3] The system cannot find the path specified: [file_path]
```

**Environment**:

- Dask version: 2022.5.0
- Python version: 3.10.6
- Operating System: Windows 10
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/10430/timeline,,,toozinger,6016897,MDQ6VXNlcjYwMTY4OTc=,https://avatars.githubusercontent.com/u/6016897?v=4,,https://api.github.com/users/toozinger,https://github.com/toozinger,https://api.github.com/users/toozinger/followers,https://api.github.com/users/toozinger/following{/other_user},https://api.github.com/users/toozinger/gists{/gist_id},https://api.github.com/users/toozinger/starred{/owner}{/repo},https://api.github.com/users/toozinger/subscriptions,https://api.github.com/users/toozinger/orgs,https://api.github.com/users/toozinger/repos,https://api.github.com/users/toozinger/events{/privacy},https://api.github.com/users/toozinger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10430/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
890,https://api.github.com/repos/dask/dask/issues/10431,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10431/labels{/name},https://api.github.com/repos/dask/dask/issues/10431/comments,https://api.github.com/repos/dask/dask/issues/10431/events,https://github.com/dask/dask/issues/10431,1824012329,I_kwDOAbcwm85suDgp,10431,Generate arrays of same shape and randomized content,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-07-27T09:46:41Z,2023-08-28T01:45:08Z,,NONE,,"I would like to be able to create a Dask array of the same shape as another Dask array of unknown length and with contents that are randomized.
For example I have an array like this
`dask.array<getitem, shape=(nan,), dtype=float64, chunksize=(nan,), chunktype=numpy.ndarray>`
and I want a Dask array of the same shape, without computing chunk sizes. The contents of the new array are randomized and I can, for example, multiply it with my original array.

I know PyTorch has a function like this (`torch.randn_like`) but I could not find such a thing in Dask. It would be especially useful in Dask because of the unknown lengths in Dask. I also think the function should be able to use or be part of the random number generator API (which is not true for PyTorch).",,https://api.github.com/repos/dask/dask/issues/10431/timeline,,,jrueb,30041073,MDQ6VXNlcjMwMDQxMDcz,https://avatars.githubusercontent.com/u/30041073?v=4,,https://api.github.com/users/jrueb,https://github.com/jrueb,https://api.github.com/users/jrueb/followers,https://api.github.com/users/jrueb/following{/other_user},https://api.github.com/users/jrueb/gists{/gist_id},https://api.github.com/users/jrueb/starred{/owner}{/repo},https://api.github.com/users/jrueb/subscriptions,https://api.github.com/users/jrueb/orgs,https://api.github.com/users/jrueb/repos,https://api.github.com/users/jrueb/events{/privacy},https://api.github.com/users/jrueb/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10431/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
891,https://api.github.com/repos/dask/dask/issues/10432,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10432/labels{/name},https://api.github.com/repos/dask/dask/issues/10432/comments,https://api.github.com/repos/dask/dask/issues/10432/events,https://github.com/dask/dask/pull/10432,1826839824,PR_kwDOAbcwm85WrU1Y,10432,Prevent an error caused by concurrent use of a cache on multiple threads,[],open,False,,[],,3,2023-07-28T17:54:10Z,2023-07-28T20:28:54Z,,FIRST_TIME_CONTRIBUTOR,,"This modifies the cache's cost calculation so that determining the start time of the task never raises a `KeyError`. This can happen due to interleaving of the cache's `_posttask` method (which accesses `starttimes`) and the `_finish` method (which clears `starttimes`). Now, when the start time is not present, the initial duration (not including dependencies) is 0, so that the task has no extra power to evict other results from the cache, but can still be put in there when there's space. This also makes access of `starttimes` more consistent with `durations`.

This adds a parametrized test to reproduce that specific case as described in #10396. That test needs some specific concurrency control, so seems a little artificial, but it does reproduce a possible interleaving of task and callback execution. The control also means that it runs fast and should not be flaky.

This also adds implementation comments to explain the new code and some of the existing code.

Closes #10396
",,https://api.github.com/repos/dask/dask/issues/10432/timeline,,,andy-sweet,2608297,MDQ6VXNlcjI2MDgyOTc=,https://avatars.githubusercontent.com/u/2608297?v=4,,https://api.github.com/users/andy-sweet,https://github.com/andy-sweet,https://api.github.com/users/andy-sweet/followers,https://api.github.com/users/andy-sweet/following{/other_user},https://api.github.com/users/andy-sweet/gists{/gist_id},https://api.github.com/users/andy-sweet/starred{/owner}{/repo},https://api.github.com/users/andy-sweet/subscriptions,https://api.github.com/users/andy-sweet/orgs,https://api.github.com/users/andy-sweet/repos,https://api.github.com/users/andy-sweet/events{/privacy},https://api.github.com/users/andy-sweet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10432/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10432,https://github.com/dask/dask/pull/10432,https://github.com/dask/dask/pull/10432.diff,https://github.com/dask/dask/pull/10432.patch,,,,,,,,,,,,,,,,,,,
892,https://api.github.com/repos/dask/dask/issues/10433,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10433/labels{/name},https://api.github.com/repos/dask/dask/issues/10433/comments,https://api.github.com/repos/dask/dask/issues/10433/events,https://github.com/dask/dask/issues/10433,1827012653,I_kwDOAbcwm85s5gAt,10433,Bag Generic Typing,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,3,2023-07-28T19:50:17Z,2024-01-22T01:49:27Z,,NONE,,"I'd like to make `dask.bag.Bag` a generic type, so that type checkers and function signatures could include information about what's in a dask bag. For example

```python
def add_lengths(bag: dask.bag.Bag[list[dict[str, Any]]]) -> dask.bag.Bag[list[dict[str, Any]]]:
    return bag.map(add_length)

def add_length(item: dict[str, Any]) -> dict[str, Any]:
    item[""length""] = len(item[""document""])
```

I would be happy to write the PR for this, but I wanted to make sure that y'all would be interested in that, and to see if there are any foreseeable pitfalls here.",,https://api.github.com/repos/dask/dask/issues/10433/timeline,,,jordan-jack-schneider,124743827,U_kgDOB29wkw,https://avatars.githubusercontent.com/u/124743827?v=4,,https://api.github.com/users/jordan-jack-schneider,https://github.com/jordan-jack-schneider,https://api.github.com/users/jordan-jack-schneider/followers,https://api.github.com/users/jordan-jack-schneider/following{/other_user},https://api.github.com/users/jordan-jack-schneider/gists{/gist_id},https://api.github.com/users/jordan-jack-schneider/starred{/owner}{/repo},https://api.github.com/users/jordan-jack-schneider/subscriptions,https://api.github.com/users/jordan-jack-schneider/orgs,https://api.github.com/users/jordan-jack-schneider/repos,https://api.github.com/users/jordan-jack-schneider/events{/privacy},https://api.github.com/users/jordan-jack-schneider/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10433/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
893,https://api.github.com/repos/dask/dask/issues/10442,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10442/labels{/name},https://api.github.com/repos/dask/dask/issues/10442/comments,https://api.github.com/repos/dask/dask/issues/10442/events,https://github.com/dask/dask/issues/10442,1850267294,I_kwDOAbcwm85uSNae,10442,"`Dataframe.to_csv` does not work as expected with `mode=""x""`","[{'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,"[{'login': 'hendrikmakait', 'id': 2699097, 'node_id': 'MDQ6VXNlcjI2OTkwOTc=', 'avatar_url': 'https://avatars.githubusercontent.com/u/2699097?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/hendrikmakait', 'html_url': 'https://github.com/hendrikmakait', 'followers_url': 'https://api.github.com/users/hendrikmakait/followers', 'following_url': 'https://api.github.com/users/hendrikmakait/following{/other_user}', 'gists_url': 'https://api.github.com/users/hendrikmakait/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/hendrikmakait/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/hendrikmakait/subscriptions', 'organizations_url': 'https://api.github.com/users/hendrikmakait/orgs', 'repos_url': 'https://api.github.com/users/hendrikmakait/repos', 'events_url': 'https://api.github.com/users/hendrikmakait/events{/privacy}', 'received_events_url': 'https://api.github.com/users/hendrikmakait/received_events', 'type': 'User', 'site_admin': False}]",,2,2023-08-14T17:56:56Z,2024-01-15T01:48:51Z,,MEMBER,,"**Case 1: Using `mode=""x""`**

```python3
def test_to_csv_with_exclusive_mode():
    df0 = pd.DataFrame(
        {""x"": [""a"", ""b"", ""c"", ""d""], ""y"": [1, 2, 3, 4]}
    )
    df = dd.from_pandas(df0, npartitions=2)
    with tmpdir() as dir:
        df.to_csv(dir, index=False, mode=""x"")
        result = dd.read_csv(os.path.join(dir, ""*"")).compute()
    assert_eq(result, df0, check_index=False)
```
raises `FileExistsError`.

<details>
  <summary>Full traceback</summary>

```
_________________ test_to_csv_with_exclusive_mode _________________

    def test_to_csv_with_single_file_and_exclusive_mode():
        df0 = pd.DataFrame(
            {""x"": [""a"", ""b"", ""c"", ""d""], ""y"": [1, 2, 3, 4]}
        )
        df = dd.from_pandas(df0, npartitions=2)
        with tmpdir() as dir:
            csv_path = os.path.join(dir, ""test.csv"")
>           df.to_csv(dir, index=False, mode=""x"")#, single_file=True)

dask/dataframe/io/tests/test_csv.py:1550: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
dask/dataframe/core.py:1860: in to_csv
    return to_csv(self, filename, **kwargs)
dask/dataframe/io/csv.py:994: in to_csv
    return list(dask.compute(*values, **compute_kwargs))
dask/base.py:666: in compute
    results = schedule(dsk, keys, **kwargs)
dask/threaded.py:89: in get
    results = get_async(
dask/local.py:511: in get_async
    raise_exception(exc, tb)
dask/local.py:319: in reraise
    raise exc
dask/local.py:224: in execute_task
    result = _execute_task(task, data)
dask/core.py:121: in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
dask/utils.py:73: in apply
    return func(*args, **kwargs)
dask/dataframe/io/csv.py:792: in _write_csv
    with fil as f:
/opt/homebrew/Caskroom/mambaforge/base/envs/dask-dev/lib/python3.10/site-packages/fsspec/core.py:102: in __enter__
    f = self.fs.open(self.path, mode=mode)
/opt/homebrew/Caskroom/mambaforge/base/envs/dask-dev/lib/python3.10/site-packages/fsspec/spec.py:1241: in open
    f = self._open(
/opt/homebrew/Caskroom/mambaforge/base/envs/dask-dev/lib/python3.10/site-packages/fsspec/implementations/local.py:184: in _open
    return LocalFileOpener(path, mode, fs=self, **kwargs)
/opt/homebrew/Caskroom/mambaforge/base/envs/dask-dev/lib/python3.10/site-packages/fsspec/implementations/local.py:315: in __init__
    self._open()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <fsspec.implementations.local.LocalFileOpener object at 0x163610520>

    def _open(self):
        if self.f is None or self.f.closed:
            if self.autocommit or ""w"" not in self.mode:
>               self.f = open(self.path, mode=self.mode)
E               FileExistsError: [Errno 17] File exists: '/var/folders/jz/xz58q0h563q9yps50sxjm9l80000gn/T/tmpv34_uizm'

/opt/homebrew/Caskroom/mambaforge/base/envs/dask-dev/lib/python3.10/site-packages/fsspec/implementations/local.py:320: FileExistsError
```
</details>


Instead, I would have expected this function to expand paths and write to multiple files similar to `mode=""w""`.

**Case 2: Using `mode=""x""` with a `single_file=True`**
```python3
def test_to_csv_with_single_file_and_exclusive_mode():
    df0 = pd.DataFrame(
        {""x"": [""a"", ""b"", ""c"", ""d""], ""y"": [1, 2, 3, 4]}
    )
    df = dd.from_pandas(df0, npartitions=2)
    with tmpdir() as dir:
        csv_path = os.path.join(dir, ""test.csv"")
        df.to_csv(csv_path, index=False, mode="""", single_file=True)
        result = dd.read_csv(os.path.join(dir, ""*"")).compute()
    assert_eq(result, df0, check_index=False)
```
raises `ValueError: must have exactly one of create/read/write/append mode`.

<details>
  <summary>Full traceback</summary>

```
_________________ test_to_csv_with_single_file_and_exclusive_mode _________________

    def test_to_csv_with_single_file_and_exclusive_mode():
        df0 = pd.DataFrame(
            {""x"": [""a"", ""b"", ""c"", ""d""], ""y"": [1, 2, 3, 4]}
        )
        df = dd.from_pandas(df0, npartitions=2)
        with tmpdir() as dir:
            csv_path = os.path.join(dir, ""test.csv"")
>           df.to_csv(csv_path, index=False, mode=""x"", single_file=True)

dask/dataframe/io/tests/test_csv.py:1550: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
dask/dataframe/core.py:1860: in to_csv
    return to_csv(self, filename, **kwargs)
dask/dataframe/io/csv.py:994: in to_csv
    return list(dask.compute(*values, **compute_kwargs))
dask/base.py:666: in compute
    results = schedule(dsk, keys, **kwargs)
dask/threaded.py:89: in get
    results = get_async(
dask/local.py:511: in get_async
    raise_exception(exc, tb)
dask/local.py:319: in reraise
    raise exc
dask/local.py:224: in execute_task
    result = _execute_task(task, data)
dask/core.py:121: in _execute_task
    return func(*(_execute_task(a, cache) for a in args))
dask/utils.py:73: in apply
    return func(*args, **kwargs)
dask/dataframe/io/csv.py:792: in _write_csv
    with fil as f:
/opt/homebrew/Caskroom/mambaforge/base/envs/dask-dev/lib/python3.10/site-packages/fsspec/core.py:102: in __enter__
    f = self.fs.open(self.path, mode=mode)
/opt/homebrew/Caskroom/mambaforge/base/envs/dask-dev/lib/python3.10/site-packages/fsspec/spec.py:1241: in open
    f = self._open(
/opt/homebrew/Caskroom/mambaforge/base/envs/dask-dev/lib/python3.10/site-packages/fsspec/implementations/local.py:184: in _open
    return LocalFileOpener(path, mode, fs=self, **kwargs)
/opt/homebrew/Caskroom/mambaforge/base/envs/dask-dev/lib/python3.10/site-packages/fsspec/implementations/local.py:315: in __init__
    self._open()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <fsspec.implementations.local.LocalFileOpener object at 0x15f0105b0>

    def _open(self):
        if self.f is None or self.f.closed:
            if self.autocommit or ""w"" not in self.mode:
>               self.f = open(self.path, mode=self.mode)
E               ValueError: must have exactly one of create/read/write/append mode

/opt/homebrew/Caskroom/mambaforge/base/envs/dask-dev/lib/python3.10/site-packages/fsspec/implementations/local.py:320: ValueError
```
</details>

Instead, I would have expected this function to be able to write to the single file similar to `mode=""w""`. (See https://github.com/dask/dask/pull/10441#discussion_r1293437311 for a pointer to where the problem might be.) cc @benrutter",,https://api.github.com/repos/dask/dask/issues/10442/timeline,,,hendrikmakait,2699097,MDQ6VXNlcjI2OTkwOTc=,https://avatars.githubusercontent.com/u/2699097?v=4,,https://api.github.com/users/hendrikmakait,https://github.com/hendrikmakait,https://api.github.com/users/hendrikmakait/followers,https://api.github.com/users/hendrikmakait/following{/other_user},https://api.github.com/users/hendrikmakait/gists{/gist_id},https://api.github.com/users/hendrikmakait/starred{/owner}{/repo},https://api.github.com/users/hendrikmakait/subscriptions,https://api.github.com/users/hendrikmakait/orgs,https://api.github.com/users/hendrikmakait/repos,https://api.github.com/users/hendrikmakait/events{/privacy},https://api.github.com/users/hendrikmakait/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10442/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,hendrikmakait,2699097.0,MDQ6VXNlcjI2OTkwOTc=,https://avatars.githubusercontent.com/u/2699097?v=4,,https://api.github.com/users/hendrikmakait,https://github.com/hendrikmakait,https://api.github.com/users/hendrikmakait/followers,https://api.github.com/users/hendrikmakait/following{/other_user},https://api.github.com/users/hendrikmakait/gists{/gist_id},https://api.github.com/users/hendrikmakait/starred{/owner}{/repo},https://api.github.com/users/hendrikmakait/subscriptions,https://api.github.com/users/hendrikmakait/orgs,https://api.github.com/users/hendrikmakait/repos,https://api.github.com/users/hendrikmakait/events{/privacy},https://api.github.com/users/hendrikmakait/received_events,User,False
894,https://api.github.com/repos/dask/dask/issues/10444,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10444/labels{/name},https://api.github.com/repos/dask/dask/issues/10444/comments,https://api.github.com/repos/dask/dask/issues/10444/events,https://github.com/dask/dask/pull/10444,1852676580,PR_kwDOAbcwm85YCOon,10444,Update versioneer version to >= 0.28,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-08-16T07:32:59Z,2023-09-18T01:45:15Z,,FIRST_TIME_CONTRIBUTOR,,"versioneer [released](https://github.com/python-versioneer/python-versioneer/releases/tag/0.29) version 0.29

I'm not sure how to test this properly. I was able to install this package locally using `pip install .`

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10444/timeline,,,tjni,3806110,MDQ6VXNlcjM4MDYxMTA=,https://avatars.githubusercontent.com/u/3806110?v=4,,https://api.github.com/users/tjni,https://github.com/tjni,https://api.github.com/users/tjni/followers,https://api.github.com/users/tjni/following{/other_user},https://api.github.com/users/tjni/gists{/gist_id},https://api.github.com/users/tjni/starred{/owner}{/repo},https://api.github.com/users/tjni/subscriptions,https://api.github.com/users/tjni/orgs,https://api.github.com/users/tjni/repos,https://api.github.com/users/tjni/events{/privacy},https://api.github.com/users/tjni/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10444/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10444,https://github.com/dask/dask/pull/10444,https://github.com/dask/dask/pull/10444.diff,https://github.com/dask/dask/pull/10444.patch,,,,,,,,,,,,,,,,,,,
895,https://api.github.com/repos/dask/dask/issues/10448,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10448/labels{/name},https://api.github.com/repos/dask/dask/issues/10448/comments,https://api.github.com/repos/dask/dask/issues/10448/events,https://github.com/dask/dask/pull/10448,1854609217,PR_kwDOAbcwm85YIwe1,10448,Remove unused variables in merge,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-08-17T09:24:43Z,2023-09-18T01:45:14Z,,MEMBER,,"- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10448/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10448/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10448,https://github.com/dask/dask/pull/10448,https://github.com/dask/dask/pull/10448.diff,https://github.com/dask/dask/pull/10448.patch,,,,,,,,,,,,,,,,,,,
896,https://api.github.com/repos/dask/dask/issues/10451,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10451/labels{/name},https://api.github.com/repos/dask/dask/issues/10451/comments,https://api.github.com/repos/dask/dask/issues/10451/events,https://github.com/dask/dask/pull/10451,1857891307,PR_kwDOAbcwm85YT2uK,10451,Fix test_pandas_timestamp_overflow_pyarrow condition,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,2,2023-08-19T22:41:41Z,2024-03-01T00:56:40Z,,MEMBER,,"The new behavior in pyarrow only occurs with Pandas 2.0 as well.

As noted in the upstream issue https://github.com/apache/arrow/issues/33321

- [n/a] Closes #xxxx
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10451/timeline,,,QuLogic,302469,MDQ6VXNlcjMwMjQ2OQ==,https://avatars.githubusercontent.com/u/302469?v=4,,https://api.github.com/users/QuLogic,https://github.com/QuLogic,https://api.github.com/users/QuLogic/followers,https://api.github.com/users/QuLogic/following{/other_user},https://api.github.com/users/QuLogic/gists{/gist_id},https://api.github.com/users/QuLogic/starred{/owner}{/repo},https://api.github.com/users/QuLogic/subscriptions,https://api.github.com/users/QuLogic/orgs,https://api.github.com/users/QuLogic/repos,https://api.github.com/users/QuLogic/events{/privacy},https://api.github.com/users/QuLogic/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10451/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10451,https://github.com/dask/dask/pull/10451,https://github.com/dask/dask/pull/10451.diff,https://github.com/dask/dask/pull/10451.patch,,,,,,,,,,,,,,,,,,,
897,https://api.github.com/repos/dask/dask/issues/10452,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10452/labels{/name},https://api.github.com/repos/dask/dask/issues/10452/comments,https://api.github.com/repos/dask/dask/issues/10452/events,https://github.com/dask/dask/issues/10452,1858663577,I_kwDOAbcwm85uyPSZ,10452,"using dask.array.full_like can raise strange ""no Client active"" error","[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2023-08-21T06:07:21Z,2023-09-25T01:45:33Z,,NONE,,"Under dask and distributed 2023.6.0, using the `dask.array.full_like` function can lead to a strange error claiming that there is ""no Client active."" This occurs when a `LocalCluster` is used which has been created with more than one thread per worker. To reproduce this, use the following code:

```python
import dask.array as da
from distributed import Client, LocalCluster

def driver():
    arr = da.random.default_rng().random((100, 100), chunks=(30, 30))
    mean = da.nanmean(arr)
    like_arr = da.full_like(arr, fill_value=mean).compute()

if __name__ == '__main__':
    cluster = LocalCluster(n_workers=2, threads_per_worker=2)
    client = Client(cluster)

    driver()
```

Sometimes I have to run this multiple times to generate the failure, but it typically happens within 5 attempts. The error message looks like this:

```
  File ""/python/lib/python3.10/site-packages/dask/array/wrap.py"", line 140, in _broadcast_trick_inner
    return np.broadcast_to(func(meta, *args, shape=null_shape, **kwargs), shape)
  File ""<__array_function__ internals>"", line 180, in full_like
  File ""/python/lib/python3.10/site-packages/numpy/core/numeric.py"", line 423, in full_like
    multiarray.copyto(res, fill_value, casting='unsafe')
  File ""<__array_function__ internals>"", line 180, in copyto
  File ""/python/lib/python3.10/site-packages/dask/array/core.py"", line 1750, in __array_function__
    return handle_nonmatching_names(func, args, kwargs)
  File ""/python/lib/python3.10/site-packages/dask/array/core.py"", line 1726, in handle_nonmatching_names
    args, kwargs = compute(args, kwargs)
  File ""/python/lib/python3.10/site-packages/dask/base.py"", line 583, in compute
    schedule = get_scheduler(
  File ""/python/lib/python3.10/site-packages/dask/base.py"", line 1403, in get_scheduler
    return get_scheduler(scheduler=config.get(""scheduler"", None))
  File ""/python/lib/python3.10/site-packages/dask/base.py"", line 1378, in get_scheduler
    raise RuntimeError(
RuntimeError: Requested dask.distributed scheduler but no Client active.
```

I've truncated the stack trace somewhat but I can post a longer one that goes back to the original call if that would be useful.

This toy example is distilled from a real example that we have in our codebase. We have not observed this failure with non-local clusters, but it does crop up with some regularity in CI, where we use a `LocalCluster` fixture for our testing. This is the only place where this error happens, and it goes away if I replace `da.full_like(arr, fill_value=mean)` with `da.full(arr.shape, fill_value=mean)`. The error also goes away if I create the `LocalCluster` with `threads_per_worker=1`.

When debugging this issue, I drilled deep down into the `distributed/client.py` file where `default_client` is called (the error which gives rise to this `RuntimeError`) and I noticed that placing a delay after the line `c = c or _get_global_client()` eliminated this error; I discovered this by accident while trying to dump some information about the state of the client to a file. 

**Environment**:

- Dask version: 2023.6.0
- Python version: 3.10
- Operating System: OS X, as well as linux/aarch64 (docker)
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10452/timeline,,,jerry-kobold,97456409,U_kgDOBc8RGQ,https://avatars.githubusercontent.com/u/97456409?v=4,,https://api.github.com/users/jerry-kobold,https://github.com/jerry-kobold,https://api.github.com/users/jerry-kobold/followers,https://api.github.com/users/jerry-kobold/following{/other_user},https://api.github.com/users/jerry-kobold/gists{/gist_id},https://api.github.com/users/jerry-kobold/starred{/owner}{/repo},https://api.github.com/users/jerry-kobold/subscriptions,https://api.github.com/users/jerry-kobold/orgs,https://api.github.com/users/jerry-kobold/repos,https://api.github.com/users/jerry-kobold/events{/privacy},https://api.github.com/users/jerry-kobold/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10452/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
898,https://api.github.com/repos/dask/dask/issues/10463,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10463/labels{/name},https://api.github.com/repos/dask/dask/issues/10463/comments,https://api.github.com/repos/dask/dask/issues/10463/events,https://github.com/dask/dask/issues/10463,1866564646,I_kwDOAbcwm85vQYQm,10463,Issue with pipeline resilience when using `to_parquet` and preemptible workers,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,"[{'login': 'hyenal', 'id': 12529987, 'node_id': 'MDQ6VXNlcjEyNTI5OTg3', 'avatar_url': 'https://avatars.githubusercontent.com/u/12529987?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/hyenal', 'html_url': 'https://github.com/hyenal', 'followers_url': 'https://api.github.com/users/hyenal/followers', 'following_url': 'https://api.github.com/users/hyenal/following{/other_user}', 'gists_url': 'https://api.github.com/users/hyenal/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/hyenal/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/hyenal/subscriptions', 'organizations_url': 'https://api.github.com/users/hyenal/orgs', 'repos_url': 'https://api.github.com/users/hyenal/repos', 'events_url': 'https://api.github.com/users/hyenal/events{/privacy}', 'received_events_url': 'https://api.github.com/users/hyenal/received_events', 'type': 'User', 'site_admin': False}, {'login': 'rjzamora', 'id': 20461013, 'node_id': 'MDQ6VXNlcjIwNDYxMDEz', 'avatar_url': 'https://avatars.githubusercontent.com/u/20461013?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/rjzamora', 'html_url': 'https://github.com/rjzamora', 'followers_url': 'https://api.github.com/users/rjzamora/followers', 'following_url': 'https://api.github.com/users/rjzamora/following{/other_user}', 'gists_url': 'https://api.github.com/users/rjzamora/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/rjzamora/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/rjzamora/subscriptions', 'organizations_url': 'https://api.github.com/users/rjzamora/orgs', 'repos_url': 'https://api.github.com/users/rjzamora/repos', 'events_url': 'https://api.github.com/users/rjzamora/events{/privacy}', 'received_events_url': 'https://api.github.com/users/rjzamora/received_events', 'type': 'User', 'site_admin': False}]",,0,2023-08-25T08:09:06Z,2023-09-25T01:45:32Z,,NONE,,"Hello everyone, and first of all thanks a lot for Dask :D 

This feature request stems from a conversation on [dask discourse](https://dask.discourse.group/t/improving-pipeline-resilience-when-using-to-parquet-and-preemptible-workers/2141).

Most of the information are in the post but I will try to synthetize it here.

When using preemptible workers with dask, using `to_parquet` can be an issue because the last task `store-to-parquet` will wait for all partitions to be saved. So your worker will hold results in memory for a part of the graphs that has been computed and saved.
But your workers are preemptible, so can be restarted anytime, thus even if you saved results in memory you may have to recompute them because your worker has been killed.

On the one hand tying things together is neat and avoid the overhead of concatenating results on the client.
On the other hand when using preemptible workers you would want to return the last `map_partitions` instead so that you could release memory as soon as possible if you wish to.

I made a [PR](https://github.com/hyenal/dask/pull/1) on my own fork there and would be happy to submit a PR to this repository if this is deemed good to go.

In the PR I made the return of `map_partitions` a default when we are not writing the metadata file but could make it optional instead.

Thanks a lot in advance",,https://api.github.com/repos/dask/dask/issues/10463/timeline,,,hyenal,12529987,MDQ6VXNlcjEyNTI5OTg3,https://avatars.githubusercontent.com/u/12529987?v=4,,https://api.github.com/users/hyenal,https://github.com/hyenal,https://api.github.com/users/hyenal/followers,https://api.github.com/users/hyenal/following{/other_user},https://api.github.com/users/hyenal/gists{/gist_id},https://api.github.com/users/hyenal/starred{/owner}{/repo},https://api.github.com/users/hyenal/subscriptions,https://api.github.com/users/hyenal/orgs,https://api.github.com/users/hyenal/repos,https://api.github.com/users/hyenal/events{/privacy},https://api.github.com/users/hyenal/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10463/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,hyenal,12529987.0,MDQ6VXNlcjEyNTI5OTg3,https://avatars.githubusercontent.com/u/12529987?v=4,,https://api.github.com/users/hyenal,https://github.com/hyenal,https://api.github.com/users/hyenal/followers,https://api.github.com/users/hyenal/following{/other_user},https://api.github.com/users/hyenal/gists{/gist_id},https://api.github.com/users/hyenal/starred{/owner}{/repo},https://api.github.com/users/hyenal/subscriptions,https://api.github.com/users/hyenal/orgs,https://api.github.com/users/hyenal/repos,https://api.github.com/users/hyenal/events{/privacy},https://api.github.com/users/hyenal/received_events,User,False
899,https://api.github.com/repos/dask/dask/issues/10464,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10464/labels{/name},https://api.github.com/repos/dask/dask/issues/10464/comments,https://api.github.com/repos/dask/dask/issues/10464/events,https://github.com/dask/dask/issues/10464,1866790321,I_kwDOAbcwm85vRPWx,10464,pandas will raise for GroupBy.idxmax starting in 3.0 with all NA values,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-08-25T10:28:27Z,2024-01-15T01:48:46Z,,MEMBER,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

We compute the idxmax per partition and then do an aggregation. This is problematic if one partition is all NA but not the whole column. We have to address this somehow.

**Minimal Complete Verifiable Example**:

```python
pdf = pd.DataFrame({""a"": 1, ""b"": [np.nan, np.nan, 2, 3]})
df = dd.from_pandas(pdf, npartitions=2)
df.groupby(""a"").idxmax(skipna=False).compute()
```

This shouldn't raise a warning but does at the moment

cc @jrbourbeau 

**Anything else we need to know?**:

**Environment**:

- Dask version: main
- Python version: 3.11
- Operating System: Mac
- Install method (conda, pip, source): condo
",,https://api.github.com/repos/dask/dask/issues/10464/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10464/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
900,https://api.github.com/repos/dask/dask/issues/10465,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10465/labels{/name},https://api.github.com/repos/dask/dask/issues/10465/comments,https://api.github.com/repos/dask/dask/issues/10465/events,https://github.com/dask/dask/issues/10465,1867127708,I_kwDOAbcwm85vShuc,10465,ParserError: Error tokenizing data. C error: EOF inside string starting at row,"[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-08-25T14:09:15Z,2023-09-25T01:45:29Z,,NONE,,"Hello. 

Testing out Dask to help me deal with over 46M rows of data. I'm loading it like so:

`dask_df = dd.read_csv(FILE_PATH)`

and when I, for example, look at the head I see the head of the DataFrame:

`dask_df.head()`

so far so good. 

But when I try to do any action that requires computation I'm getting the following error:

> ParserError: Error tokenizing data. C error: EOF inside string starting at row 325771

It doesn't matter what it is.

When I open the same dataset with pandas:

`pd.read_csv(FILE_PATH)`

I get no issues. I look at the row mentioned in the error message (325_771) and find nothing wrong with it. Same with the previous and next row (just to make sure).

There are **8 columns** in the dataset that pandas is interpreting the first **6 as objects** and the last **2 as int64**, 'though more precisely **4 could be str**, **2 are lat/long geodata**, and **the 2 int64 could be bool**. 

The **4 columns that could be str contain information in many different languages**, including in row 325_771, and **different alphabets** (not the case in row 325_771).

Not sure if it's the **encodings**, the **lat/long geodata**, or **something else**, but any idea to test as to how to solve/deal with this would be appreciated.

Anything else I can provide that can be of assistance (except for the data :/), let me know.

Thank you,

**Environment**:

- Dask version: 2023.6.0
- Python version: 3.11.4 (main, Jul  5 2023, 08:41:25) [Clang 14.0.6 ]
- Operating System: macOS Ventura 13.4.1 (c) (22F770820d)
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/10465/timeline,,,duarteharris,10074430,MDQ6VXNlcjEwMDc0NDMw,https://avatars.githubusercontent.com/u/10074430?v=4,,https://api.github.com/users/duarteharris,https://github.com/duarteharris,https://api.github.com/users/duarteharris/followers,https://api.github.com/users/duarteharris/following{/other_user},https://api.github.com/users/duarteharris/gists{/gist_id},https://api.github.com/users/duarteharris/starred{/owner}{/repo},https://api.github.com/users/duarteharris/subscriptions,https://api.github.com/users/duarteharris/orgs,https://api.github.com/users/duarteharris/repos,https://api.github.com/users/duarteharris/events{/privacy},https://api.github.com/users/duarteharris/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10465/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
901,https://api.github.com/repos/dask/dask/issues/10466,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10466/labels{/name},https://api.github.com/repos/dask/dask/issues/10466/comments,https://api.github.com/repos/dask/dask/issues/10466/events,https://github.com/dask/dask/issues/10466,1867877467,I_kwDOAbcwm85vVYxb,10466,Incomplete LU factorization,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-08-26T03:17:48Z,2023-10-02T01:45:42Z,,NONE,,"Given sparse matrix `A` as either
```python
A = np.random.random([100,100])
A[A<.95] = 0

A1 = sparse.GCXS(A)
# or
i,j,v = scipy.sparse.find(A)
A2 = scipy.sparse.coo_matrix((v, (i,j)), shape=A.shape).tocsc()
```

I would like to compute the incomplete LU factorization (for use as preconditioner in the GMRES iterative solver).

```python
scipy.sparse.linalg.spilu(A1)
# and
scipy.sparse.linalg.spilu(A2)
```

work as expected, and return a `SuperLU` which can be handed off to `scipy.sparse.linalg.LinearOperator`

But

```python
A1b = da.from_array(A1, asarray=False)
scipy.sparse.linalg.spilu(A1b)
# -> fails because dask tries to call
# scipy\sparse\linalg\_dsolve\linsolve.py:436
# 436     A = csc_matrix(A)

# and
A2b =  da.from_array(A2, asarray=False)
scipy.sparse.linalg.spilu(A2b)
# -> fails because dask tries to call
# scipy\sparse\_compressed.py:80
# 80     arg1 = np.asarray(arg1)
```

Sparse matrixes of the kind I am working with come from the finite element assembly, and are approaching 1M x 1M, so dense methods are just not feasible. I'm also pushing the limits of the single desktop, and I would very much like to adapt my codes to run on an HPC cluster, which is how I ended up here, on Dask.

The bottle neck at the moment is in the ILU factorization, which is why i'm trying to get that specifically to work with dask. So...

Is support for `scipy.sparse.linalg` (broadly) or ILU factorization / GMRES (narrowly) a possible future feature?",,https://api.github.com/repos/dask/dask/issues/10466/timeline,,,gatling-nrl,38136423,MDQ6VXNlcjM4MTM2NDIz,https://avatars.githubusercontent.com/u/38136423?v=4,,https://api.github.com/users/gatling-nrl,https://github.com/gatling-nrl,https://api.github.com/users/gatling-nrl/followers,https://api.github.com/users/gatling-nrl/following{/other_user},https://api.github.com/users/gatling-nrl/gists{/gist_id},https://api.github.com/users/gatling-nrl/starred{/owner}{/repo},https://api.github.com/users/gatling-nrl/subscriptions,https://api.github.com/users/gatling-nrl/orgs,https://api.github.com/users/gatling-nrl/repos,https://api.github.com/users/gatling-nrl/events{/privacy},https://api.github.com/users/gatling-nrl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10466/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
902,https://api.github.com/repos/dask/dask/issues/10467,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10467/labels{/name},https://api.github.com/repos/dask/dask/issues/10467/comments,https://api.github.com/repos/dask/dask/issues/10467/events,https://github.com/dask/dask/issues/10467,1869930931,I_kwDOAbcwm85vdOGz,10467,How to upload dataframe with numpy array column using to_parquet in dask.dataframe? ,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,2,2023-08-28T14:56:43Z,2024-05-30T16:00:06Z,,NONE,,"I want to upload dataframe with array column!
Under code rise type error.
Any suggestions on how to further troubleshoot, how to fix this, or where else I could ask for help would be greatly appreciated!
Or if this function is not working, can you add a function?

```
import numpy as np
import pandas as pd
from dask import dataframe as dd. ## dask version == 2023.5.0

data = {
    'float_array_column': [
        np.array([1.1, 2.2, 3.3]),
        np.array([4.4, 5.5]),
        np.array([6.6, 7.7, 8.8, 9.9])
    ]
}
path = {storage_path}
storage_option = {storage_option}

df = pd.DataFrame(data)
df = dd.from_pandas(df, chunksize=5368709)

dd.to_parquet(df, path, engine='pyarrow', storage_options=storage_option)
```

```
ValueError: Failed to convert partition to expected pyarrow schema:
    `ArrowTypeError(""Expected bytes, got a 'numpy.ndarray' object"", 'Conversion failed for column float_array_column with type object')`

Expected partition schema:
    float_array_column: string
    __null_dask_index__: int64

Received partition schema:
    float_array_column: list<item: double>
      child 0, item: double
    __null_dask_index__: int64

This error *may* be resolved by passing in schema information for
the mismatched column(s) using the `schema` keyword in `to_parquet`.
````


Change data numpy to list is also got errored.

```
data = {
    'float_array_column': [
        [1.1, 2.2, 3.3],
        [4.4, 5.5],
        [6.6, 7.7, 8.8, 9.9]
    ]
}
```

```
ValueError: Failed to convert partition to expected pyarrow schema:
    `ArrowTypeError(""Expected bytes, got a 'list' object"", 'Conversion failed for column float_array_column with type object')`

Expected partition schema:
    float_array_column: string
    __null_dask_index__: int64

Received partition schema:
    float_array_column: list<item: double>
      child 0, item: double
    __null_dask_index__: int64

This error *may* be resolved by passing in schema information for
the mismatched column(s) using the `schema` keyword in `to_parquet`.
````

When using dd.from_array is also got errored.

```
data = {
    'float_array_column': [
        dd.from_array(np.array([1.1, 2.2, 3.3])),
        dd.from_array(np.array([4.4, 5.5])),
        dd.from_array(np.array([6.6, 7.7, 8.8, 9.9]))
    ]
}
```

```
ArrowTypeError: (""Expected bytes, got a 'Series' object"", 'Conversion failed for column float_array_column with type object')

During handling of the above exception, another exception occurred:
```",,https://api.github.com/repos/dask/dask/issues/10467/timeline,,,hjlee9182,46337218,MDQ6VXNlcjQ2MzM3MjE4,https://avatars.githubusercontent.com/u/46337218?v=4,,https://api.github.com/users/hjlee9182,https://github.com/hjlee9182,https://api.github.com/users/hjlee9182/followers,https://api.github.com/users/hjlee9182/following{/other_user},https://api.github.com/users/hjlee9182/gists{/gist_id},https://api.github.com/users/hjlee9182/starred{/owner}{/repo},https://api.github.com/users/hjlee9182/subscriptions,https://api.github.com/users/hjlee9182/orgs,https://api.github.com/users/hjlee9182/repos,https://api.github.com/users/hjlee9182/events{/privacy},https://api.github.com/users/hjlee9182/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10467/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
903,https://api.github.com/repos/dask/dask/issues/10478,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10478/labels{/name},https://api.github.com/repos/dask/dask/issues/10478/comments,https://api.github.com/repos/dask/dask/issues/10478/events,https://github.com/dask/dask/pull/10478,1872258169,PR_kwDOAbcwm85ZEQ75,10478,Delay row-wise parquet filtering until just after IO,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,"[{'login': 'rjzamora', 'id': 20461013, 'node_id': 'MDQ6VXNlcjIwNDYxMDEz', 'avatar_url': 'https://avatars.githubusercontent.com/u/20461013?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/rjzamora', 'html_url': 'https://github.com/rjzamora', 'followers_url': 'https://api.github.com/users/rjzamora/followers', 'following_url': 'https://api.github.com/users/rjzamora/following{/other_user}', 'gists_url': 'https://api.github.com/users/rjzamora/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/rjzamora/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/rjzamora/subscriptions', 'organizations_url': 'https://api.github.com/users/rjzamora/orgs', 'repos_url': 'https://api.github.com/users/rjzamora/repos', 'events_url': 'https://api.github.com/users/rjzamora/events{/privacy}', 'received_events_url': 'https://api.github.com/users/rjzamora/received_events', 'type': 'User', 'site_admin': False}]",,1,2023-08-29T19:19:26Z,2024-01-15T01:48:44Z,,MEMBER,,"While investigating benchmark results in dask-expr, @phofl noticed that predicate pushdown was giving us surprisingly bad performance in some cases. Although defining `filters` is clearly beneficial when we can drop entire row-groups from the dataset, the row-wise filtering step that pyarrow applies at read time is much less beneficial. In fact, it is typically faster to delay the row-wise filtering step until just **after** IO is complete (either with pandas or pyarrow).

This PR proposes the minimal possible change needed to delay the row-wise filtering step until just after IO. Note that row-groups and hive-partitions will already have been filtered before the modified function is executed. Therefore, these changes do **not** mean that we will **need** data to be in memory for filtering.",,https://api.github.com/repos/dask/dask/issues/10478/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10478/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10478,https://github.com/dask/dask/pull/10478,https://github.com/dask/dask/pull/10478.diff,https://github.com/dask/dask/pull/10478.patch,,rjzamora,20461013.0,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False
904,https://api.github.com/repos/dask/dask/issues/10480,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10480/labels{/name},https://api.github.com/repos/dask/dask/issues/10480/comments,https://api.github.com/repos/dask/dask/issues/10480/events,https://github.com/dask/dask/issues/10480,1872501965,I_kwDOAbcwm85vnBzN,10480,"Processes scheduler does not work partition wise, leading to OOM","[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,4,2023-08-29T21:26:46Z,2024-01-08T01:47:01Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

For some graphs, the processes scheduler does not completely process a partition before starting on a new one, which leads to Out Of Memory issues when processing larger than memory data.

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.dataframe as dd

dataframe = dd.from_dict({""id"": [0, 1], ""url"": [""a"", ""b""]}, npartitions=2)


def process_partition(df):
    counter = 0
    while counter < 100000000:
        counter += 1
    return df


dataframe = dataframe.map_partitions(process_partition)

index_df = dataframe[[""id""]]
url_df = dataframe[[""url""]]
write_tasks = [
    dd.to_parquet(index_df, ""/tmp/id"", compute=False),
    dd.to_parquet(url_df, ""/tmp/url"", compute=False)
]

if __name__ == ""__main__"":
    dask.visualize(*write_tasks, filename=""graph.png"")
    dd.compute(*write_tasks, scheduler=""processes"", num_workers=1)
```

This example creates a dataset with 2 partitions, and processes it in a way I believe should be embarrassingly parallel. The `map_partitions` is meant to introduce a delay simulating processing. The execution is limited to 1 worker so both partitions need to be processed sequentially on the same worker.

After running the example above, check the creation time of the produced files using:

```bash
ls --full-time /tmp/url
```

When using `scheduler=""threads""`, there will be a couple of seconds between both files. When using `scheduler=""processes""`, both files are created at the same time, which is at the end of the execution.

Task graph:
<img src=""https://github.com/dask/dask/assets/20990866/ca82d25b-1222-47d2-8ac8-6da534c65022"" width=""200"">

**Anything else we need to know?**:

Possibly related: #10080 

**Environment**:

- Dask version:
2023.8.1
- Python version:
3.10
- Operating System:
Ubuntu 22.04.2
- Install method (conda, pip, source):
pip
",,https://api.github.com/repos/dask/dask/issues/10480/timeline,,,RobbeSneyders,20990866,MDQ6VXNlcjIwOTkwODY2,https://avatars.githubusercontent.com/u/20990866?v=4,,https://api.github.com/users/RobbeSneyders,https://github.com/RobbeSneyders,https://api.github.com/users/RobbeSneyders/followers,https://api.github.com/users/RobbeSneyders/following{/other_user},https://api.github.com/users/RobbeSneyders/gists{/gist_id},https://api.github.com/users/RobbeSneyders/starred{/owner}{/repo},https://api.github.com/users/RobbeSneyders/subscriptions,https://api.github.com/users/RobbeSneyders/orgs,https://api.github.com/users/RobbeSneyders/repos,https://api.github.com/users/RobbeSneyders/events{/privacy},https://api.github.com/users/RobbeSneyders/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10480/reactions,4,4,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
905,https://api.github.com/repos/dask/dask/issues/10486,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10486/labels{/name},https://api.github.com/repos/dask/dask/issues/10486/comments,https://api.github.com/repos/dask/dask/issues/10486/events,https://github.com/dask/dask/pull/10486,1874142466,PR_kwDOAbcwm85ZKkO7,10486,Change `to_parquet` when `compute=False` so that we allow more user control,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-08-30T18:04:33Z,2023-10-02T01:45:35Z,,FIRST_TIME_CONTRIBUTOR,,"- [x] Closes [#10463](https://github.com/dask/dask/issues/10463)
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`

This MR remove the `Scalar` object returned when `compute`=False in `to_parquet`. Instead we give the user more control over the final `map_partitions` task.

This would allow the user to do things like [in this post](https://dask.discourse.group/t/improving-pipeline-resilience-when-using-to-parquet-and-preemptible-workers/2141) where we would release memory as soon as possible.

I feel like we could add the following snipped in the [resilience docs](https://examples.dask.org/resilience.html) for users that are using preemptible tasks

```
    ddf = df.to_parquet(name, compute=False)

    parquet_files = ddf.to_delayed()

    client: dask.distributed.Client = dask.distributed.get_client()
    futures = client.compute(parquet_files)

    for future in as_completed(futures):
        # Release memory
        future.result()
        future.release()
```

I am using it on my own project right now and it seems to work but I am happy to hear about downside of such approach as well :) 

Some comments were also left in a local [PR here](https://github.com/hyenal/dask/pull/1).",,https://api.github.com/repos/dask/dask/issues/10486/timeline,,,hyenal,12529987,MDQ6VXNlcjEyNTI5OTg3,https://avatars.githubusercontent.com/u/12529987?v=4,,https://api.github.com/users/hyenal,https://github.com/hyenal,https://api.github.com/users/hyenal/followers,https://api.github.com/users/hyenal/following{/other_user},https://api.github.com/users/hyenal/gists{/gist_id},https://api.github.com/users/hyenal/starred{/owner}{/repo},https://api.github.com/users/hyenal/subscriptions,https://api.github.com/users/hyenal/orgs,https://api.github.com/users/hyenal/repos,https://api.github.com/users/hyenal/events{/privacy},https://api.github.com/users/hyenal/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10486/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10486,https://github.com/dask/dask/pull/10486,https://github.com/dask/dask/pull/10486.diff,https://github.com/dask/dask/pull/10486.patch,,,,,,,,,,,,,,,,,,,
906,https://api.github.com/repos/dask/dask/issues/10494,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10494/labels{/name},https://api.github.com/repos/dask/dask/issues/10494/comments,https://api.github.com/repos/dask/dask/issues/10494/events,https://github.com/dask/dask/issues/10494,1883705174,I_kwDOAbcwm85wRw9W,10494,Incompatibility with package db-dtypes results in casts of object to string types,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}, {'id': 6137710172, 'node_id': 'LA_kwDOAbcwm88AAAABbdYGXA', 'url': 'https://api.github.com/repos/dask/dask/labels/convert-string', 'name': 'convert-string', 'color': 'd93f0b', 'default': False, 'description': ''}]",open,False,,[],,2,2023-09-06T10:21:25Z,2024-01-08T01:46:59Z,,NONE,,"**Describe the issue**:

When the package [db-dtypes](https://pypi.org/project/db-dtypes/) is installed dask will convert object-type columns (at least those containing arrays) to strings when converting a pandas dataframe to a dask dataframe. 

This is unfortunate as db-dtypes is important when using BigQuery with Python. Arrays within cells (""repeated fields"" in Bigquery) are also quite common.

**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import numpy as np
import dask.dataframe as dd
import dask.bag as db
import dask

if __name__ == ""__main__"":
    df = pd.DataFrame({""a"": [np.array([5, 6, 7, 8])]})
    print(type(df.iloc[0][""a""]))
    df_dask = dd.from_pandas(df, npartitions=1)
    print(type(df_dask.compute().iloc[0][""a""]))
```
This usually yields

```
<class 'numpy.ndarray'>
<class 'numpy.ndarray'>
```

As soon as db-dtypes is installed, the result is

```
<class 'numpy.ndarray'>
<class 'str'>
```


**Anything else we need to know?**:
Minimal requirements.txt:
```
dask==2023.9.0
db-dtypes==1.1.1
```

**Environment**:

- Dask version:
2023.9.0
- Python version:
3.10
- Operating System: 
  OS x
- Install method (conda, pip, source): 
  pip
",,https://api.github.com/repos/dask/dask/issues/10494/timeline,,,HHarald99,52377213,MDQ6VXNlcjUyMzc3MjEz,https://avatars.githubusercontent.com/u/52377213?v=4,,https://api.github.com/users/HHarald99,https://github.com/HHarald99,https://api.github.com/users/HHarald99/followers,https://api.github.com/users/HHarald99/following{/other_user},https://api.github.com/users/HHarald99/gists{/gist_id},https://api.github.com/users/HHarald99/starred{/owner}{/repo},https://api.github.com/users/HHarald99/subscriptions,https://api.github.com/users/HHarald99/orgs,https://api.github.com/users/HHarald99/repos,https://api.github.com/users/HHarald99/events{/privacy},https://api.github.com/users/HHarald99/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10494/reactions,2,1,0,0,0,0,0,0,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
907,https://api.github.com/repos/dask/dask/issues/10508,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10508/labels{/name},https://api.github.com/repos/dask/dask/issues/10508/comments,https://api.github.com/repos/dask/dask/issues/10508/events,https://github.com/dask/dask/pull/10508,1894240948,PR_kwDOAbcwm85aOEoj,10508,General updates to the HPC docs page,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,4,2023-09-13T10:33:32Z,2024-01-08T01:46:58Z,,MEMBER,,"I've recently started working more with Dask on HPC and thought it is a good opportunity to update the docs page.

High-level changes:
- Improve Dask MPI section.
- Discuss the differences in deployment model between dask-jobqueue and dask-mpi more thoroughly.
- Add Dask Gateway section.
- Update the Jupyter section to use the new `--jupyter` flag.
- General hierarchy updates.

It might also be nice to update the High Performance Network section to talk about UCX, but I could only find NVIDIA/GPU specific examples. It would be good to be more generic here and just talk about IB. cc @pentschev in case you have thoughts

I also haven't added a GPU section, but it might be useful to folks and we could talk at a high level and then direct them to RAPIDS docs for this. Wanted to check with folks like @mrocklin, @jrbourbeau, @fjetter before doing this. I can always add this in a follow up.

cc @kmpaul for dask-mpi",,https://api.github.com/repos/dask/dask/issues/10508/timeline,,,jacobtomlinson,1610850,MDQ6VXNlcjE2MTA4NTA=,https://avatars.githubusercontent.com/u/1610850?v=4,,https://api.github.com/users/jacobtomlinson,https://github.com/jacobtomlinson,https://api.github.com/users/jacobtomlinson/followers,https://api.github.com/users/jacobtomlinson/following{/other_user},https://api.github.com/users/jacobtomlinson/gists{/gist_id},https://api.github.com/users/jacobtomlinson/starred{/owner}{/repo},https://api.github.com/users/jacobtomlinson/subscriptions,https://api.github.com/users/jacobtomlinson/orgs,https://api.github.com/users/jacobtomlinson/repos,https://api.github.com/users/jacobtomlinson/events{/privacy},https://api.github.com/users/jacobtomlinson/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10508/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10508,https://github.com/dask/dask/pull/10508,https://github.com/dask/dask/pull/10508.diff,https://github.com/dask/dask/pull/10508.patch,,,,,,,,,,,,,,,,,,,
908,https://api.github.com/repos/dask/dask/issues/10510,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10510/labels{/name},https://api.github.com/repos/dask/dask/issues/10510/comments,https://api.github.com/repos/dask/dask/issues/10510/events,https://github.com/dask/dask/issues/10510,1896254686,I_kwDOAbcwm85xBoze,10510,performance issue with da.unique,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,"[{'login': 'AkisPanagiotopoulos', 'id': 93475298, 'node_id': 'U_kgDOBZJR4g', 'avatar_url': 'https://avatars.githubusercontent.com/u/93475298?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/AkisPanagiotopoulos', 'html_url': 'https://github.com/AkisPanagiotopoulos', 'followers_url': 'https://api.github.com/users/AkisPanagiotopoulos/followers', 'following_url': 'https://api.github.com/users/AkisPanagiotopoulos/following{/other_user}', 'gists_url': 'https://api.github.com/users/AkisPanagiotopoulos/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/AkisPanagiotopoulos/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/AkisPanagiotopoulos/subscriptions', 'organizations_url': 'https://api.github.com/users/AkisPanagiotopoulos/orgs', 'repos_url': 'https://api.github.com/users/AkisPanagiotopoulos/repos', 'events_url': 'https://api.github.com/users/AkisPanagiotopoulos/events{/privacy}', 'received_events_url': 'https://api.github.com/users/AkisPanagiotopoulos/received_events', 'type': 'User', 'site_admin': False}]",,3,2023-09-14T10:23:28Z,2024-01-08T01:46:57Z,,NONE,,"Hi,
I'm experiencing performance problems with `da.unique`. Any idea why dask is so slow here?  

```
 import dask.array as da
 arr = da.random.randint(500, size=500**3)
 uni, c = da.unique(arr, return_counts=True)
 %timeit c.compute()
37.1 s  846 ms per loop (mean  std. dev. of 7 runs, 1 loop each)
```

Where as with numpy:

```
import numpy as np
arr = np.random.randint(500, size=500**3)
%timeit np.unique(arr, return_counts=True)
3.11 s  94.6 ms per loop (mean  std. dev. of 7 runs, 1 loop each)
```
The problem gets even worse on larger arrays. 


**Environment**:

- Dask version: '2023.9.0'
- Python version: Python 3.9.18 
- Operating System: linux arch
- Install method (conda, pip, source): conda
- CPU:  i7-11850H (8/16) cores
",,https://api.github.com/repos/dask/dask/issues/10510/timeline,,,MariusCausemann,25132217,MDQ6VXNlcjI1MTMyMjE3,https://avatars.githubusercontent.com/u/25132217?v=4,,https://api.github.com/users/MariusCausemann,https://github.com/MariusCausemann,https://api.github.com/users/MariusCausemann/followers,https://api.github.com/users/MariusCausemann/following{/other_user},https://api.github.com/users/MariusCausemann/gists{/gist_id},https://api.github.com/users/MariusCausemann/starred{/owner}{/repo},https://api.github.com/users/MariusCausemann/subscriptions,https://api.github.com/users/MariusCausemann/orgs,https://api.github.com/users/MariusCausemann/repos,https://api.github.com/users/MariusCausemann/events{/privacy},https://api.github.com/users/MariusCausemann/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10510/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,AkisPanagiotopoulos,93475298.0,U_kgDOBZJR4g,https://avatars.githubusercontent.com/u/93475298?v=4,,https://api.github.com/users/AkisPanagiotopoulos,https://github.com/AkisPanagiotopoulos,https://api.github.com/users/AkisPanagiotopoulos/followers,https://api.github.com/users/AkisPanagiotopoulos/following{/other_user},https://api.github.com/users/AkisPanagiotopoulos/gists{/gist_id},https://api.github.com/users/AkisPanagiotopoulos/starred{/owner}{/repo},https://api.github.com/users/AkisPanagiotopoulos/subscriptions,https://api.github.com/users/AkisPanagiotopoulos/orgs,https://api.github.com/users/AkisPanagiotopoulos/repos,https://api.github.com/users/AkisPanagiotopoulos/events{/privacy},https://api.github.com/users/AkisPanagiotopoulos/received_events,User,False
909,https://api.github.com/repos/dask/dask/issues/10512,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10512/labels{/name},https://api.github.com/repos/dask/dask/issues/10512/comments,https://api.github.com/repos/dask/dask/issues/10512/events,https://github.com/dask/dask/pull/10512,1897474384,PR_kwDOAbcwm85aZByV,10512,doc: add missing detail to deploying-cli.rst,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-09-14T23:21:25Z,2023-10-16T01:46:07Z,,CONTRIBUTOR,,Missing detail on using the correct keyword for worker port configuration.,,https://api.github.com/repos/dask/dask/issues/10512/timeline,,,SultanOrazbayev,20208402,MDQ6VXNlcjIwMjA4NDAy,https://avatars.githubusercontent.com/u/20208402?v=4,,https://api.github.com/users/SultanOrazbayev,https://github.com/SultanOrazbayev,https://api.github.com/users/SultanOrazbayev/followers,https://api.github.com/users/SultanOrazbayev/following{/other_user},https://api.github.com/users/SultanOrazbayev/gists{/gist_id},https://api.github.com/users/SultanOrazbayev/starred{/owner}{/repo},https://api.github.com/users/SultanOrazbayev/subscriptions,https://api.github.com/users/SultanOrazbayev/orgs,https://api.github.com/users/SultanOrazbayev/repos,https://api.github.com/users/SultanOrazbayev/events{/privacy},https://api.github.com/users/SultanOrazbayev/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10512/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10512,https://github.com/dask/dask/pull/10512,https://github.com/dask/dask/pull/10512.diff,https://github.com/dask/dask/pull/10512.patch,,,,,,,,,,,,,,,,,,,
910,https://api.github.com/repos/dask/dask/issues/10516,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10516/labels{/name},https://api.github.com/repos/dask/dask/issues/10516/comments,https://api.github.com/repos/dask/dask/issues/10516/events,https://github.com/dask/dask/issues/10516,1900928687,I_kwDOAbcwm85xTd6v,10516,Unexpected DataFrame map_overlap timedelta post-filtering,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-09-18T13:19:58Z,2023-10-23T01:45:38Z,,CONTRIBUTOR,,"The current implementation of `map_overlap()` is using a fixed number of rows to post-filter additional rows that has been added to the original partition. This behavior is incompatible with any user function that may add or delete rows.

**Minimal Complete Verifiable Example**:

```python
dd = dask.datasets.timeseries()
dd
```
![image](https://github.com/dask/dask/assets/1694892/ce9a8c42-43bc-4515-87d9-3162a8715eb8)

```python
def func(part):
    return part.tail(1)

dd.map_overlap(func, before=pd.to_timedelta('1d'), after=0).compute()
# Expecting 30 rows (i.e.: 1 tail row per partition)
```
![image](https://github.com/dask/dask/assets/1694892/84e9bf68-da2a-447d-aadb-098128893204)



Because `before=1d` added many rows in front of every partition, the output frame is then reduced by the same number of rows, causing the user data to completely disappear except for the 1st partition where no rows were initially prepended.


**Suggestion**:

In `rolling.py:overlap_chunk`, If divisions are known, then can we simply remove all data outside of the current partition index boundaries?

**Environment**:

- Dask version: 2023.9.2
- Python version: 3.9
",,https://api.github.com/repos/dask/dask/issues/10516/timeline,,,epizut,1694892,MDQ6VXNlcjE2OTQ4OTI=,https://avatars.githubusercontent.com/u/1694892?v=4,,https://api.github.com/users/epizut,https://github.com/epizut,https://api.github.com/users/epizut/followers,https://api.github.com/users/epizut/following{/other_user},https://api.github.com/users/epizut/gists{/gist_id},https://api.github.com/users/epizut/starred{/owner}{/repo},https://api.github.com/users/epizut/subscriptions,https://api.github.com/users/epizut/orgs,https://api.github.com/users/epizut/repos,https://api.github.com/users/epizut/events{/privacy},https://api.github.com/users/epizut/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10516/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
911,https://api.github.com/repos/dask/dask/issues/10517,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10517/labels{/name},https://api.github.com/repos/dask/dask/issues/10517/comments,https://api.github.com/repos/dask/dask/issues/10517/events,https://github.com/dask/dask/issues/10517,1901552045,I_kwDOAbcwm85xV2Gt,10517,Groupby aggregation with custom aggregation and median causes TypeError,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-09-18T18:51:34Z,2023-10-23T01:45:38Z,,NONE,,"**Describe the issue**:
Providing a custom `Aggregation` object and ""median"" to `DataFrameGroupBy.agg` causes a `TypeError` to be thrown. It seems like a different code path is being taken that mishandles the custom aggregation object.

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import numpy as np
import pandas as pd


# Taken from documentation: https://docs.dask.org/en/latest/dataframe-groupby.html#dataframe-groupby-aggregate
nunique = dd.Aggregation(
    name=""nunique"",
    chunk=lambda s: s.apply(lambda x: list(set(x))),
    agg=lambda s0: s0.obj.groupby(
        level=list(range(s0.obj.index.nlevels))
    ).sum(),
    finalize=lambda s1: s1.apply(lambda final: len(set(final))),
)


df = dd.from_pandas(
    pd.DataFrame({""A"": [1, 1, 3, 4, 4, 5, 5, 5, 6, 6], ""B"": np.arange(10)}),
    npartitions=2,
)
print(""df:"")
print(df.compute())
gdf = df.groupby(""A"")
print(gdf.agg([nunique], shuffle=""tasks"").compute())
print(gdf.agg([""median""], shuffle=""tasks"").compute())
print(""nunique and median:"")
print(gdf.agg([nunique, ""median""], shuffle=""tasks"").compute())
```
<details>

```python
df:
   A  B
0  1  0
1  1  1
2  3  2
3  4  3
4  4  4
5  5  5
6  5  6
7  5  7
8  6  8
9  6  9
        B
  nunique
A
1       6
3       3
4       6
5       7
6       6
       B
  median
A
1    0.5
3    2.0
4    3.5
5    6.0
6    8.5
nunique and median:
Traceback (most recent call last):
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/utils.py"", line 194, in raise_on_meta_error
    yield
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/core.py"", line 6895, in _emulate
    return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/groupby.py"", line 461, in _groupby_aggregate_spec
    return df.groupby(level=levels, sort=sort, **observed, **dropna).aggregate(
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 1442, in aggregate
    result = op.agg()
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/apply.py"", line 178, in agg
    return self.agg_list_like()
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/apply.py"", line 311, in agg_list_like
    return self.agg_or_apply_list_like(op_name=""agg"")
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/apply.py"", line 1353, in agg_or_apply_list_like
    keys, results = self.compute_list_like(op_name, selected_obj, kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/apply.py"", line 370, in compute_list_like
    new_res = getattr(colg, op_name)(func, *args, **kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 252, in aggregate
    ret = self._aggregate_multiple_funcs(func, *args, **kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 357, in _aggregate_multiple_funcs
    results[key] = self.aggregate(func, *args, **kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 289, in aggregate
    return self._python_agg_general(func, *args, **kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 322, in _python_agg_general
    result = self.grouper.agg_series(obj, f)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/ops.py"", line 850, in agg_series
    result = self._aggregate_series_pure_python(obj, func)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/ops.py"", line 871, in _aggregate_series_pure_python
    res = func(group)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 319, in <lambda>
    f = lambda x: func(x, *args, **kwargs)
TypeError: 'Aggregation' object is not callable

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File ""/home/fred/work/fs/rmrs/scratch/ddissue/example.py"", line 27, in <module>
    print(gdf.agg([nunique, ""median""], shuffle=""tasks"").compute())
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/groupby.py"", line 367, in wrapper
    return func(self, *args, **kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/groupby.py"", line 2953, in agg
    return self.aggregate(
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/groupby.py"", line 2942, in aggregate
    return super().aggregate(
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/groupby.py"", line 2347, in aggregate
    result = _shuffle_aggregate(
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/groupby.py"", line 3327, in _shuffle_aggregate
    result = result.map_partitions(aggregate, **aggregate_kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/core.py"", line 1046, in map_partitions
    return map_partitions(func, self, *args, **kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/core.py"", line 6965, in map_partitions
    meta = _get_meta_map_partitions(args, dfs, func, kwargs, meta, parent_meta)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/core.py"", line 7076, in _get_meta_map_partitions
    meta = _emulate(func, *args, udf=True, **kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/core.py"", line 6895, in _emulate
    return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/contextlib.py"", line 137, in __exit__
    self.gen.throw(typ, value, traceback)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/utils.py"", line 215, in raise_on_meta_error
    raise ValueError(msg) from e
ValueError: Metadata inference failed in `_groupby_aggregate_spec`.

You have supplied a custom function and Dask is unable to
determine the type of output that that function returns.

To resolve this please provide a meta= keyword.
The docstring of the Dask function you ran should have more information.

Original error is below:
------------------------
TypeError(""'Aggregation' object is not callable"")

Traceback:
---------
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/utils.py"", line 194, in raise_on_meta_error
    yield
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/core.py"", line 6895, in _emulate
    return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/dask/dataframe/groupby.py"", line 461, in _groupby_aggregate_spec
    return df.groupby(level=levels, sort=sort, **observed, **dropna).aggregate(
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 1442, in aggregate
    result = op.agg()
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/apply.py"", line 178, in agg
    return self.agg_list_like()
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/apply.py"", line 311, in agg_list_like
    return self.agg_or_apply_list_like(op_name=""agg"")
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/apply.py"", line 1353, in agg_or_apply_list_like
    keys, results = self.compute_list_like(op_name, selected_obj, kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/apply.py"", line 370, in compute_list_like
    new_res = getattr(colg, op_name)(func, *args, **kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 252, in aggregate
    ret = self._aggregate_multiple_funcs(func, *args, **kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 357, in _aggregate_multiple_funcs
    results[key] = self.aggregate(func, *args, **kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 289, in aggregate
    return self._python_agg_general(func, *args, **kwargs)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 322, in _python_agg_general
    result = self.grouper.agg_series(obj, f)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/ops.py"", line 850, in agg_series
    result = self._aggregate_series_pure_python(obj, func)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/ops.py"", line 871, in _aggregate_series_pure_python
    res = func(group)
  File ""/home/fred/anaconda3/envs/ddissue/lib/python3.9/site-packages/pandas/core/groupby/generic.py"", line 319, in <lambda>
    f = lambda x: func(x, *args, **kwargs)
```

</details>

**Anything else we need to know?**:

**Environment**:

- Dask version: 2023.9.2
- Python version: Python 3.9.18
- Operating System: Kubuntu 22.04 Linux 5.15.0-83-generic
- Install method (conda, pip, source): conda (conda-forge)
",,https://api.github.com/repos/dask/dask/issues/10517/timeline,,,fbunt,7178572,MDQ6VXNlcjcxNzg1NzI=,https://avatars.githubusercontent.com/u/7178572?v=4,,https://api.github.com/users/fbunt,https://github.com/fbunt,https://api.github.com/users/fbunt/followers,https://api.github.com/users/fbunt/following{/other_user},https://api.github.com/users/fbunt/gists{/gist_id},https://api.github.com/users/fbunt/starred{/owner}{/repo},https://api.github.com/users/fbunt/subscriptions,https://api.github.com/users/fbunt/orgs,https://api.github.com/users/fbunt/repos,https://api.github.com/users/fbunt/events{/privacy},https://api.github.com/users/fbunt/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10517/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
912,https://api.github.com/repos/dask/dask/issues/10518,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10518/labels{/name},https://api.github.com/repos/dask/dask/issues/10518/comments,https://api.github.com/repos/dask/dask/issues/10518/events,https://github.com/dask/dask/issues/10518,1902861433,I_kwDOAbcwm85xa1x5,10518,JIT graph building,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,8,2023-09-19T12:20:46Z,2024-01-08T01:46:56Z,,NONE,,"Here's a motivating example for what I'm referring to:

```python
import dask.array as da 
import time 

zero = da.zeros((10000,5000,5000,5), dtype='float32', chunks=(1000,500,25,1))
data = da.overlap.overlap(zero, depth={0:10, 1:2, 2:2}, boundary=-1)


# Compiling the graph takes ~43 seconds for ~4.3 million tasks
start = time.time()
tasks = len(data.dask)
print(f'{time.time()-start:.2f} seconds to compile graph')
print(f'Graph contains {tasks:,} tasks')

# Computing the first block takes ~3 seconds since the graph is now compiled
start = time.time()
data.blocks[0,0,0,0].compute()
print(f'{time.time()-start:.2f} seconds to compute the first block\n')


# Create a fresh data graph
data = da.overlap.overlap(zero, depth={0:10, 1:2, 2:2}, boundary=-1)

# Computing the first block immediately takes ~43 seconds (as it will
# interally compile the whole graph, thus taking around the same time)
start = time.time()
data.blocks[0,0,0,0].compute()
print(f'{time.time()-start:.2f} seconds to compute the first block')

# Computing any other blocks is quick, now that the graph is compiled
start = time.time()
data.blocks[1,0,0,0].compute()
print(f'{time.time()-start:.2f} seconds to compute a different block')

# Graph is already compiled, so checking total tasks is now immediate
start = time.time()
tasks = len(data.dask)
print(f'{time.time()-start:.2f} seconds to compile graph')
print(f'Graph contains {tasks:,} tasks')
```

In the actual data I'm working with, the graph takes a significant amount of time to create before the first block can even start work. 

In this case it's due to the rather large amount of operations that need to take place in `dask.layers.ArrayOverlapLayer`, but the general idea I'm discussing is: how feasible would it be to allow just-in-time graph compilation, in order to remove startup time dependency on the size of the data / overall number of tasks? Is it possible to allow compiling only the exact task dependency graph for a given object when it's computed, rather than having to build all tasks at the outset?",,https://api.github.com/repos/dask/dask/issues/10518/timeline,,,BrandonSmithJ,1062829,MDQ6VXNlcjEwNjI4Mjk=,https://avatars.githubusercontent.com/u/1062829?v=4,,https://api.github.com/users/BrandonSmithJ,https://github.com/BrandonSmithJ,https://api.github.com/users/BrandonSmithJ/followers,https://api.github.com/users/BrandonSmithJ/following{/other_user},https://api.github.com/users/BrandonSmithJ/gists{/gist_id},https://api.github.com/users/BrandonSmithJ/starred{/owner}{/repo},https://api.github.com/users/BrandonSmithJ/subscriptions,https://api.github.com/users/BrandonSmithJ/orgs,https://api.github.com/users/BrandonSmithJ/repos,https://api.github.com/users/BrandonSmithJ/events{/privacy},https://api.github.com/users/BrandonSmithJ/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10518/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
913,https://api.github.com/repos/dask/dask/issues/10522,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10522/labels{/name},https://api.github.com/repos/dask/dask/issues/10522/comments,https://api.github.com/repos/dask/dask/issues/10522/events,https://github.com/dask/dask/issues/10522,1905276396,I_kwDOAbcwm85xkDXs,10522,`dask.array.to_zarr()` does not parse for `chunks` kwarg ,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,4,2023-09-20T15:45:42Z,2024-01-08T01:46:55Z,,NONE,,"I was trying to specify chunk size for the output zarr when writing from a dask array: 
```python
# cc_img is a dask array
cc_img.to_zarr(ccd_zarr_path,
               component=f""0/{current_pyr_lvl}"",
               overwrite=True,
               compressor=compressor,
               chunks=(1,1,1,256,256)
               )
``` 
`cc_img`'s chunks were `(1,1,3,256,256)`

I started getting a hard error, that `zarr.create` gets multiple instances of `chunks` keyword. 

This is easily fixeable by changing expression `chunks = [c[0] for c in arr.chunks]` to `chunks = [c[0] for c in arr.chunks] if 'chunks' not in kwargs.keys() else kwargs.pop('chunks')` [on line 3714](https://github.com/dask/dask/blob/da256320ef0167992f7183c3a275d092f5727f62/dask/array/core.py#L3714C22-L3714C22). 

Overall, `da.to_zarr()` needs a way to resolve this, as right now it implies the chunks' shape from an input array ",,https://api.github.com/repos/dask/dask/issues/10522/timeline,,,aaptss,12582599,MDQ6VXNlcjEyNTgyNTk5,https://avatars.githubusercontent.com/u/12582599?v=4,,https://api.github.com/users/aaptss,https://github.com/aaptss,https://api.github.com/users/aaptss/followers,https://api.github.com/users/aaptss/following{/other_user},https://api.github.com/users/aaptss/gists{/gist_id},https://api.github.com/users/aaptss/starred{/owner}{/repo},https://api.github.com/users/aaptss/subscriptions,https://api.github.com/users/aaptss/orgs,https://api.github.com/users/aaptss/repos,https://api.github.com/users/aaptss/events{/privacy},https://api.github.com/users/aaptss/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10522/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
914,https://api.github.com/repos/dask/dask/issues/10525,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10525/labels{/name},https://api.github.com/repos/dask/dask/issues/10525/comments,https://api.github.com/repos/dask/dask/issues/10525/events,https://github.com/dask/dask/issues/10525,1909107899,I_kwDOAbcwm85xyqy7,10525,read_parquet() filters not applied for pivot_table(),"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-09-22T15:21:57Z,2023-10-23T01:45:36Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
When loading a parquet file using filters, these filters are not applied when pivoting the table. I am currently working with GHCN-Daily data and trying to only read in a few variables from the dataset. Using there `filters=()` keyword seems to filter the data when looking at only the unique values in the DataFrame, but if the DataFrame is pivoted, then a column is created for all possible variables in the dataset, not just those defined by the filter.


**Minimal Complete Verifiable Example**:

```python
from dask import dataframe

# Load in the data
data  = dataframe.read_parquet(
    ""s3://noaa-ghcn-pds/parquet/by_year/YEAR=2020/"",
    storage_options={""anon"": True},
    filters = [(ELEMENT', 'in', ['AWND', 'TMAX', 'RHAV'])],
    columns=[""ID"", ""DATE"", ""DATA_VALUE"", ""ELEMENT""],
)

# Filter data to just one station
data = data[data.ID == 'USS0019L42S']

""""""
A look at only the unique ELEMENTS (i.e., variable names) gives:

>>> print(data.ELEMENT.unique().compute())

0    AWND
1    TMAX
Name: ELEMENT, dtype: category
Categories (74, object): ['ADPT', 'ASLP', 'ASTP', 'AWBT', ..., 'WT09', 'WT10', 'WT11', 'WT18']

And the table looks like this:

Dask DataFrame Structure:
                    ID    DATE DATA_VALUE          ELEMENT
npartitions=11                                            
                string  string      int64  category[known]
                   ...     ...        ...              ...
...                ...     ...        ...              ...
                   ...     ...        ...              ...
                   ...     ...        ...              ...
Dask Name: getitem, 4 graph layers

""""""

# pivot the data
piv = data.pivot_table(
    columns='ELEMENT',
    index='DATE',
    values='DATA_VALUE',
    aggfunc='first',
)

""""""
Pivoted table looks like:

Dask DataFrame Structure:
                ADPT   ASLP   ASTP   AWBT   AWDR   AWND   DAPR   DASF   DATN   DATX   DWPR   EVAP   MDPR   MDSF   MDTN   MDTX   MNPN   MXPN   PGTM   PRCP   PSUN   RHAV   RHMN   RHMX   SN31   SN32   SN33   SN35   SN36   SN51   SN52   SN53   SN55   SN56   SNOW   SNWD   SX31   SX32   SX33   SX35   SX36   SX51   SX52   SX53   SX55   SX56   TAVG   THIC   TMAX   TMIN   TOBS   TSUN   WDF2   WDF5   WDFG   WDMV   WESD   WESF   WSF2   WSF5   WSFG   WSFI   WT01   WT02   WT03   WT04   WT05   WT06   WT07   WT08   WT09   WT10   WT11   WT18
npartitions=1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
               int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64  int64
                 ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...    ...
Dask Name: pivot_table_first-agg, 6 graph layers
""""""
```

I would expect that the pivoted table had only those variables defined by the filter and not all the possible variables.

**Anything else we need to know?**:
I tried to 'solve' this issue by using the `drop.na()` method to drop columns with all NaN values, however, this method does not seem to accept the `axis` keyword. The documentation for the method suggests that `axis` is a valid keyword, but it is missing from the signature.

https://docs.dask.org/en/latest/generated/dask.dataframe.DataFrame.dropna.html

**Environment**:

- Dask version: 2023.9.2
- Python version: 3.11.4 | packaged by conda-forge | (main, Jun 10 2023, 18:08:17) [GCC 12.2.0]
- Operating System: Running in Docker using  jupyter/datascience-notebook:latest base image (Digest:sha256:d6311a89c4d618190372149245a4d68b67406201aca00d8b0d08119fe09ee3cb)

- Install method (conda, pip, source):
",,https://api.github.com/repos/dask/dask/issues/10525/timeline,,,kwodzicki,19718721,MDQ6VXNlcjE5NzE4NzIx,https://avatars.githubusercontent.com/u/19718721?v=4,,https://api.github.com/users/kwodzicki,https://github.com/kwodzicki,https://api.github.com/users/kwodzicki/followers,https://api.github.com/users/kwodzicki/following{/other_user},https://api.github.com/users/kwodzicki/gists{/gist_id},https://api.github.com/users/kwodzicki/starred{/owner}{/repo},https://api.github.com/users/kwodzicki/subscriptions,https://api.github.com/users/kwodzicki/orgs,https://api.github.com/users/kwodzicki/repos,https://api.github.com/users/kwodzicki/events{/privacy},https://api.github.com/users/kwodzicki/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10525/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
915,https://api.github.com/repos/dask/dask/issues/10530,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10530/labels{/name},https://api.github.com/repos/dask/dask/issues/10530/comments,https://api.github.com/repos/dask/dask/issues/10530/events,https://github.com/dask/dask/pull/10530,1911951458,PR_kwDOAbcwm85bJgig,10530,Run tests with ``crick=0.0.4`` release,[],open,False,,[],,5,2023-09-25T17:10:51Z,2024-01-01T01:50:15Z,,MEMBER,,"There's a new `crick=0.0.4` release out (on PyPI, not yet on conda-forge). This release makes sure we test against this latest release in at least one of our CI builds (Python 3.11). The other Python versions are still testing against `crick=0.0.3` from conda-forge for now and will automatically start pulling in the new version once it's available on conda-forge. ",,https://api.github.com/repos/dask/dask/issues/10530/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10530/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10530,https://github.com/dask/dask/pull/10530,https://github.com/dask/dask/pull/10530.diff,https://github.com/dask/dask/pull/10530.patch,,,,,,,,,,,,,,,,,,,
916,https://api.github.com/repos/dask/dask/issues/10533,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10533/labels{/name},https://api.github.com/repos/dask/dask/issues/10533/comments,https://api.github.com/repos/dask/dask/issues/10533/events,https://github.com/dask/dask/issues/10533,1913751842,I_kwDOAbcwm85yEYki,10533,"astype('bool') gives wrong result, astype('boolean') yields TypeError","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}, {'id': 6137710172, 'node_id': 'LA_kwDOAbcwm88AAAABbdYGXA', 'url': 'https://api.github.com/repos/dask/dask/labels/convert-string', 'name': 'convert-string', 'color': 'd93f0b', 'default': False, 'description': ''}]",open,False,,[],,3,2023-09-26T15:15:48Z,2024-01-01T01:50:14Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
When converting a series containing both boolean values and pd.NA to bool using astype(bool), False will erroneously become True. 
Converting the same series using dask.DataFrame.astype('boolean') yields TypeError(""Need to pass bool-like values"")

**Minimal Complete Verifiable Example**:

```python
import pandas as pd, dask.dataframe as dd
df = dd.from_dict({'x':[True,False,pd.NA]},npartitions=1)
df0 = pd.DataFrame({'x':[True,False,pd.NA]})
print(df0['x'].astype('boolean')) # gives correct result: [True, False, <NA>]
print(df['x'].astype('bool').compute()) # [True, True, False] rather than expected [True, False, <NA>]
print(df['x'].astype('boolean').compute())  #TypeError: Need to pass bool-like values
```

**Anything else we need to know?**:
Possible cause: dask treats series with pd.NA as 'string' series, for which both 'True' and 'False' converts to bool value True.
```python
>>> df = dd.from_dict({'x':[True,False,pd.NA]},npartitions=1)
>>> df
Dask DataFrame Structure:
                    x
npartitions=1
0              string
2                 ...
Dask Name: to_pyarrow_string, 2 graph layers
```

**Environment**:

- Dask version: 2023.9.2
- Python version: 3.10.12
- Operating System: Ubuntu 22.04 64bit, Windows 10 64bit
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10533/timeline,,,ligonliu,3859493,MDQ6VXNlcjM4NTk0OTM=,https://avatars.githubusercontent.com/u/3859493?v=4,,https://api.github.com/users/ligonliu,https://github.com/ligonliu,https://api.github.com/users/ligonliu/followers,https://api.github.com/users/ligonliu/following{/other_user},https://api.github.com/users/ligonliu/gists{/gist_id},https://api.github.com/users/ligonliu/starred{/owner}{/repo},https://api.github.com/users/ligonliu/subscriptions,https://api.github.com/users/ligonliu/orgs,https://api.github.com/users/ligonliu/repos,https://api.github.com/users/ligonliu/events{/privacy},https://api.github.com/users/ligonliu/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10533/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
917,https://api.github.com/repos/dask/dask/issues/10534,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10534/labels{/name},https://api.github.com/repos/dask/dask/issues/10534/comments,https://api.github.com/repos/dask/dask/issues/10534/events,https://github.com/dask/dask/pull/10534,1913812279,PR_kwDOAbcwm85bP19M,10534,Allow partial graph computation without full materialization,[],open,False,,[],,6,2023-09-26T15:45:52Z,2024-05-17T11:17:18Z,,FIRST_TIME_CONTRIBUTOR,,"Closes #10518.

This mainly does three things:
- Modifies `ArrayOverlapLayer` to allow partial materialization (i.e. {key:value} creation for only part of the full layer keys)
- Allows querying the number of tasks in an `ArrayOverlapLayer` object, without needing to materialize the layer
- Substitutes `get_all_external_keys` call within `HighLevelGraph.cull`, thus allowing the graph to be culled without materializing the full graph

The consequence of these changes are that subgraphs can now be created and computed independently of the overall data/graph size. See the issue referenced above for more details. 

I've tried to make minimal adjustments to the code to allow things to work and pass tests, so the substitution for `get_all_external_keys` just creates a thin wrapper around required functionality for `Layer.cull`. 

As well, I've taken a brute-force approach for the full multi-dimensional length calculation in `ArrayOverlapLayer`. This can be replaced with an analytic solution, but I haven't yet fully worked out the formula for dimensions > 2. ",,https://api.github.com/repos/dask/dask/issues/10534/timeline,,,BrandonSmithJ,1062829,MDQ6VXNlcjEwNjI4Mjk=,https://avatars.githubusercontent.com/u/1062829?v=4,,https://api.github.com/users/BrandonSmithJ,https://github.com/BrandonSmithJ,https://api.github.com/users/BrandonSmithJ/followers,https://api.github.com/users/BrandonSmithJ/following{/other_user},https://api.github.com/users/BrandonSmithJ/gists{/gist_id},https://api.github.com/users/BrandonSmithJ/starred{/owner}{/repo},https://api.github.com/users/BrandonSmithJ/subscriptions,https://api.github.com/users/BrandonSmithJ/orgs,https://api.github.com/users/BrandonSmithJ/repos,https://api.github.com/users/BrandonSmithJ/events{/privacy},https://api.github.com/users/BrandonSmithJ/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10534/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10534,https://github.com/dask/dask/pull/10534,https://github.com/dask/dask/pull/10534.diff,https://github.com/dask/dask/pull/10534.patch,,,,,,,,,,,,,,,,,,,
918,https://api.github.com/repos/dask/dask/issues/10536,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10536/labels{/name},https://api.github.com/repos/dask/dask/issues/10536/comments,https://api.github.com/repos/dask/dask/issues/10536/events,https://github.com/dask/dask/pull/10536,1915538357,PR_kwDOAbcwm85bVqef,10536,Add ~/.dask to list of directories to search for config,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-09-27T12:59:43Z,2023-10-30T01:45:51Z,,MEMBER,,I've run into a class of users for which `~/.config` is locked down. Falling back to `~/.dask` seems harmless.,,https://api.github.com/repos/dask/dask/issues/10536/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10536/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10536,https://github.com/dask/dask/pull/10536,https://github.com/dask/dask/pull/10536.diff,https://github.com/dask/dask/pull/10536.patch,,,,,,,,,,,,,,,,,,,
919,https://api.github.com/repos/dask/dask/issues/10537,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10537/labels{/name},https://api.github.com/repos/dask/dask/issues/10537/comments,https://api.github.com/repos/dask/dask/issues/10537/events,https://github.com/dask/dask/issues/10537,1915846203,I_kwDOAbcwm85yMX47,10537,`dask.config.write` API,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-09-27T15:33:52Z,2023-10-30T01:45:49Z,,MEMBER,,"Sometimes third party libraries want to re-use the dask config system (Coiled for instance).

What we currently do is to write some global state into the `~/.config/dask/` directory to store some user specific global state (e.g. an account name).

Since the config system is a bit elaborate and there are actually many places where this config may live, it would be nice for dask to offer an API to do just this.

```python
# dask.config
def write(basename: str, config_dict: dict):
    """"""
    basename: str
         The filename for the new config file
    config_dict: str
        The configuration that should be written to this file
    """"""
```

The path of that file would then be determined by dask in precedence order. Trying to write to the location with highest precedence (accounting for environment vars and everything) and walking backwards in case the directory is protected or something similar prohibits us from creating this file (e.g. https://github.com/dask/dask/pull/10536)

This way, whoever calls `dask.config.write` can be certain that the configuration will also be read by dask",,https://api.github.com/repos/dask/dask/issues/10537/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10537/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
920,https://api.github.com/repos/dask/dask/issues/10538,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10538/labels{/name},https://api.github.com/repos/dask/dask/issues/10538/comments,https://api.github.com/repos/dask/dask/issues/10538/events,https://github.com/dask/dask/issues/10538,1917570224,I_kwDOAbcwm85yS8yw,10538,"Dask Task Graph is choosing the wrong path, which makes me run out of RAM.","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,5,2023-09-27T18:45:18Z,2023-10-30T01:45:49Z,,NONE,,"Hi Guys. I have built a python quantitive investment algorithm in python (mostly cupy). It is quite long and complex, therefore, when even though it is fully vectorized, I need to use for loops to avoid memory issues. Im currently adapting this algorithm to work with dask, so that I can scale up without needing for loops to handle memory issues. Im working with a distributed scheduler and dask-cuda on colab. My issue is that given the complexity of the algorithm, I need it to run in a very specific order to avoid memory overflow. Im having difficulties because of the way Dask's task graph is built (seems like a black box, I don't know what order of operations is being made and why, given that the graph is too big to be seen). I need to have 100% control of how/order the operations/tasks are done, so that I can replicate exactly the way my loops in pure python/cupy were being executed, which had no memory issues. I'm using mostly dask arrays for this code.",,https://api.github.com/repos/dask/dask/issues/10538/timeline,,,raphael7777777,55267169,MDQ6VXNlcjU1MjY3MTY5,https://avatars.githubusercontent.com/u/55267169?v=4,,https://api.github.com/users/raphael7777777,https://github.com/raphael7777777,https://api.github.com/users/raphael7777777/followers,https://api.github.com/users/raphael7777777/following{/other_user},https://api.github.com/users/raphael7777777/gists{/gist_id},https://api.github.com/users/raphael7777777/starred{/owner}{/repo},https://api.github.com/users/raphael7777777/subscriptions,https://api.github.com/users/raphael7777777/orgs,https://api.github.com/users/raphael7777777/repos,https://api.github.com/users/raphael7777777/events{/privacy},https://api.github.com/users/raphael7777777/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10538/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
921,https://api.github.com/repos/dask/dask/issues/10540,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10540/labels{/name},https://api.github.com/repos/dask/dask/issues/10540/comments,https://api.github.com/repos/dask/dask/issues/10540/events,https://github.com/dask/dask/issues/10540,1919593404,I_kwDOAbcwm85yaqu8,10540,Add `DataFrame.equals` method,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,2,2023-09-29T16:38:38Z,2023-11-06T01:46:26Z,,MEMBER,,"I was reaching for this today, but then saw it hasn't been implemented yet ",,https://api.github.com/repos/dask/dask/issues/10540/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10540/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
922,https://api.github.com/repos/dask/dask/issues/10541,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10541/labels{/name},https://api.github.com/repos/dask/dask/issues/10541/comments,https://api.github.com/repos/dask/dask/issues/10541/events,https://github.com/dask/dask/issues/10541,1919608471,I_kwDOAbcwm85yauaX,10541,Support Dask collections in `dd.from_dict`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,1,2023-09-29T16:50:46Z,2023-11-13T01:46:32Z,,MEMBER,,"Currently `dd.from_dict` doesn't support Dask collections as inputs

https://github.com/dask/dask/blob/2b45b215e13e6d7893853ef33cb4b1796c477a9e/dask/dataframe/io/io.py#L357-L360

My guess is this isn't implemented because it wasn't needed initially, not because of some technical limitation. @rjzamora is that the case? Do see any issue with supporting collection in `dd.from_dict`? ",,https://api.github.com/repos/dask/dask/issues/10541/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10541/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
923,https://api.github.com/repos/dask/dask/issues/10543,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10543/labels{/name},https://api.github.com/repos/dask/dask/issues/10543/comments,https://api.github.com/repos/dask/dask/issues/10543/events,https://github.com/dask/dask/pull/10543,1924940072,PR_kwDOAbcwm85b1VtI,10543,Add typing to empty_like,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-10-03T21:01:07Z,2024-05-20T20:20:24Z,,FIRST_TIME_CONTRIBUTOR,,"- [ ] Closes #xxxx
- [ ] Tests added / passed
- [x] Passes `pre-commit run --all-files`

This PR adds type hints to `dask.array.creation.empty_like()`. I wanted to open this PR to see if adding type hinting more generally (initially I'd like to add it to all the array creation functions) would be welcome work? If so I'd be happy to either carry on and add type hints in one big PR, or split it all off into one PR per function.

I couldn't find much discussion around type hints in the issue tracker / pull requests, so sorry if I missed any context around this!",,https://api.github.com/repos/dask/dask/issues/10543/timeline,,,dstansby,6197628,MDQ6VXNlcjYxOTc2Mjg=,https://avatars.githubusercontent.com/u/6197628?v=4,,https://api.github.com/users/dstansby,https://github.com/dstansby,https://api.github.com/users/dstansby/followers,https://api.github.com/users/dstansby/following{/other_user},https://api.github.com/users/dstansby/gists{/gist_id},https://api.github.com/users/dstansby/starred{/owner}{/repo},https://api.github.com/users/dstansby/subscriptions,https://api.github.com/users/dstansby/orgs,https://api.github.com/users/dstansby/repos,https://api.github.com/users/dstansby/events{/privacy},https://api.github.com/users/dstansby/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10543/reactions,1,0,0,0,0,0,0,1,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10543,https://github.com/dask/dask/pull/10543,https://github.com/dask/dask/pull/10543.diff,https://github.com/dask/dask/pull/10543.patch,,,,,,,,,,,,,,,,,,,
924,https://api.github.com/repos/dask/dask/issues/10545,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10545/labels{/name},https://api.github.com/repos/dask/dask/issues/10545/comments,https://api.github.com/repos/dask/dask/issues/10545/events,https://github.com/dask/dask/issues/10545,1927080273,I_kwDOAbcwm85y3OlR,10545,"""Failed to deserialize"" when using dd.from_delayed on pd.read_sql-generated DFs","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-10-04T22:38:04Z,2023-11-13T01:46:29Z,,NONE,,"**Describe the issue**:
I'm currently trying to read from a database in parallel using Dask and Pandas. I'm creating a collection of Dask delayed objects using pd.read_sql and then using Dask's from_delayed method to produce a Dask DataFrame. Unfortunately I'm working with a secure database so I can't provide a copy/paste-able example, but the following code comes pretty close:

**Minimal Complete Verifiable Example**:
```
import dask.dataframe as dd
from dask.delayed import delayed
import pandas as pd
import pyodbc
from sqlalchemy.engine import URL

def load_table_in_parallel(metadata, table_name, index_column):

    # Construct database connection URI and create engine
    connection_uri = ""sybaseiq://username:password@XX.XX.XX.XX:XXXX/XXX""
   engine = create_engine(connection_uri)

    # Create column metadata
    dd.utils.make_meta(pd.read_sql_query(f""SELECT TOP 1 * FROM {table_name}"", 
                                         connection_uri))

    # Create Table object that reflects requested database table
    table = Table(table_name, metadata, autoload_with_engine, quote=False)
    
    return dd.read_sql_query(select(table),
                             connection_uri,
                             index_column,
                             npartitions=16,
                             meta=meta,
                             head_rows=0)

# This line is where the error occurs
load_table_in_parallel().compute()
                                         
                                             
```

I get a long error message (which I can't export due to privacy restrictions) which begins with ""Failed to deserialize"" and ends with ""CanceledError: ('from-delayed-c9f959ldkjfd8032a', 1)""

**Environment**:

- Dask version: 2023.6.0
- Python version: 3.11.3
- Operating System: RedHat Linux
- Install method (conda, pip, source): Conda 
",,https://api.github.com/repos/dask/dask/issues/10545/timeline,,,arjun-shanmugam,65803362,MDQ6VXNlcjY1ODAzMzYy,https://avatars.githubusercontent.com/u/65803362?v=4,,https://api.github.com/users/arjun-shanmugam,https://github.com/arjun-shanmugam,https://api.github.com/users/arjun-shanmugam/followers,https://api.github.com/users/arjun-shanmugam/following{/other_user},https://api.github.com/users/arjun-shanmugam/gists{/gist_id},https://api.github.com/users/arjun-shanmugam/starred{/owner}{/repo},https://api.github.com/users/arjun-shanmugam/subscriptions,https://api.github.com/users/arjun-shanmugam/orgs,https://api.github.com/users/arjun-shanmugam/repos,https://api.github.com/users/arjun-shanmugam/events{/privacy},https://api.github.com/users/arjun-shanmugam/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10545/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
925,https://api.github.com/repos/dask/dask/issues/10546,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10546/labels{/name},https://api.github.com/repos/dask/dask/issues/10546/comments,https://api.github.com/repos/dask/dask/issues/10546/events,https://github.com/dask/dask/issues/10546,1929405169,I_kwDOAbcwm85zAGLx,10546,Unexpected behavior with Pyarrow string conversion,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}, {'id': 6137710172, 'node_id': 'LA_kwDOAbcwm88AAAABbdYGXA', 'url': 'https://api.github.com/repos/dask/dask/labels/convert-string', 'name': 'convert-string', 'color': 'd93f0b', 'default': False, 'description': ''}]",open,False,,[],,1,2023-10-06T04:15:41Z,2024-01-29T19:31:45Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

**Minimal Complete Verifiable Example**:

```python
# Put your MCVE code here
import pandas as pd
import dask.dataframe as dd

df = dd.from_pandas(pd.DataFrame({""col1"": [""a"",""a"",""a"", ""b"", ""c"", ""c""], ""col2"": [1,2,3,4,5,6], ""col3"": [43,23,12,32,65,76]}), npartitions=2)
df.groupby(""col1"").agg({""col2"": list, ""col3"": ""first""}).reset_index().compute().info()
```

**Anything else we need to know?**:
In this example, the column 'col2' is being converted to a string instead of an array (object), which makes future processing more difficult. Is there a way to ignore certain columns from auto string conversion? I am aware of the configuration setting dataframe.convert-string, but it applies to all columns.
##### Dataframe
<img width=""130"" alt=""image"" src=""https://github.com/dask/dask/assets/10769536/7c61fc56-466e-4a4f-a9cd-7263ce489db7"">

##### Dataframe after groupby
<img width=""265"" alt=""image"" src=""https://github.com/dask/dask/assets/10769536/ba62a788-182b-4245-acd2-5f3d8b80e33c"">
<img width=""660"" alt=""image"" src=""https://github.com/dask/dask/assets/10769536/d0522b30-3be1-4a70-bd50-dd5d44389f64"">



**Environment**:

- Dask version: 2023.9.3
- Python version: 3.9.15
- Operating System: Centos 7
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/10546/timeline,,,JaguarPaw2409,10769536,MDQ6VXNlcjEwNzY5NTM2,https://avatars.githubusercontent.com/u/10769536?v=4,,https://api.github.com/users/JaguarPaw2409,https://github.com/JaguarPaw2409,https://api.github.com/users/JaguarPaw2409/followers,https://api.github.com/users/JaguarPaw2409/following{/other_user},https://api.github.com/users/JaguarPaw2409/gists{/gist_id},https://api.github.com/users/JaguarPaw2409/starred{/owner}{/repo},https://api.github.com/users/JaguarPaw2409/subscriptions,https://api.github.com/users/JaguarPaw2409/orgs,https://api.github.com/users/JaguarPaw2409/repos,https://api.github.com/users/JaguarPaw2409/events{/privacy},https://api.github.com/users/JaguarPaw2409/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10546/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
926,https://api.github.com/repos/dask/dask/issues/10548,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10548/labels{/name},https://api.github.com/repos/dask/dask/issues/10548/comments,https://api.github.com/repos/dask/dask/issues/10548/events,https://github.com/dask/dask/issues/10548,1930214120,I_kwDOAbcwm85zDLro,10548,Config file path can not be updated using DASK_CONFIG,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-10-06T13:43:33Z,2023-11-06T01:46:24Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

When we set the `DASK_CONFIG` environment variable to the path of a YAML file, the content of this file can be changed and reloaded but the path can not be changed and lead to inconsistent behavior. As you can see in the MCVE bellow, changing the `DASK_CONFIG` variable programmatically is properly reflected in the result of `dask.config.collect()` but the new file is actually not loaded by `dask.config.refresh()`. So it's not consistent.

As far as I can see, the internal config paths are globally set during the import phase and are not updated afterwards (see https://github.com/dask/dask/blob/main/dask/config.py#L41). So I think the `dask.config.refresh()` should also refresh the path list.

Or maybe this behavior is expected? But that would be a bit weird IMO.

**Minimal Complete Verifiable Example**:

```python
import os
import yaml

with open(""initial_config.yml"", ""w"", encoding=""utf-8"") as f:
    yaml.dump({""foo"": ""bar""}, f)

with open(""new_config.yml"", ""w"", encoding=""utf-8"") as f:
    yaml.dump({""foo"": ""not_bar""}, f)

os.environ[""DASK_CONFIG""] = ""initial_config.yml""

import dask

print(""Initial config:"", dask.config.get(""foo""))
print(""Initial dask.config.collect():"", dask.config.collect())

dask.config.refresh()
print(""Config after refresh:"", dask.config.get(""foo""))

os.environ[""DASK_CONFIG""] = ""new_config.yml""
dask.config.refresh()
print(""Config after refresh with new DASK_CONFIG:"", dask.config.get(""foo""))
print(""Final dask.config.collect():"", dask.config.collect())
```

ouput:
```bash
Initial config: bar
Initial dask.config.collect(): {'foo': 'bar', 'config': 'initial_config.yml'}
Config after refresh: bar
Config after refresh with new DASK_CONFIG: bar
Final dask.config.collect(): {'foo': 'bar', 'config': 'new_config.yml'}
```

**Environment**:

- Dask version: 2023.9.3
- Python version: 3.10.12
- Operating System: Linux
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10548/timeline,,,adrien-berchet,11536226,MDQ6VXNlcjExNTM2MjI2,https://avatars.githubusercontent.com/u/11536226?v=4,,https://api.github.com/users/adrien-berchet,https://github.com/adrien-berchet,https://api.github.com/users/adrien-berchet/followers,https://api.github.com/users/adrien-berchet/following{/other_user},https://api.github.com/users/adrien-berchet/gists{/gist_id},https://api.github.com/users/adrien-berchet/starred{/owner}{/repo},https://api.github.com/users/adrien-berchet/subscriptions,https://api.github.com/users/adrien-berchet/orgs,https://api.github.com/users/adrien-berchet/repos,https://api.github.com/users/adrien-berchet/events{/privacy},https://api.github.com/users/adrien-berchet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10548/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
927,https://api.github.com/repos/dask/dask/issues/10550,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10550/labels{/name},https://api.github.com/repos/dask/dask/issues/10550/comments,https://api.github.com/repos/dask/dask/issues/10550/events,https://github.com/dask/dask/issues/10550,1932805866,I_kwDOAbcwm85zNEbq,10550,Nunique dropping NaN values,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-10-09T10:56:56Z,2023-12-25T01:46:41Z,,NONE,,"When calling nunique on a groupby dataframe (with dropna=False) all NaN values are dropped.

```python
import dask.dataframe as dd
import pandas as pd

df = pd.DataFrame(
    {
        ""a"": [1, 2, 3, 4, None, None, 7, 8],
        ""b"": [4, 5, 6, 3, 2, 1, 0, 0],
    }
)
ddf = dd.from_pandas(df, npartitions=1)
res = ddf.groupby([""a""], dropna=False)[""b""].nunique()
res.compute()
```
```python
a
1.0    1
2.0    1
3.0    1
4.0    1
7.0    1
8.0    1
Name: b, dtype: int64
```
Whereas in Pandas it works correctly:

```python
import pandas as pd

df = pd.DataFrame(
    {
        ""a"": [1, 2, 3, 4, None, None, 7, 8],
        ""b"": [4, 5, 6, 3, 2, 1, 0, 0],
    }
)
res = df.groupby([""a""], dropna=False)[""b""].nunique()
```
```python
a
1.0    1
2.0    1
3.0    1
4.0    1
7.0    1
8.0    1
NaN    2
Name: b, dtype: int64
```
**Environment**:

- Dask version: 2023.9.1
- Python version: 3.10.11
- Operating System: Linux
",,https://api.github.com/repos/dask/dask/issues/10550/timeline,,,manschoe,80762836,MDQ6VXNlcjgwNzYyODM2,https://avatars.githubusercontent.com/u/80762836?v=4,,https://api.github.com/users/manschoe,https://github.com/manschoe,https://api.github.com/users/manschoe/followers,https://api.github.com/users/manschoe/following{/other_user},https://api.github.com/users/manschoe/gists{/gist_id},https://api.github.com/users/manschoe/starred{/owner}{/repo},https://api.github.com/users/manschoe/subscriptions,https://api.github.com/users/manschoe/orgs,https://api.github.com/users/manschoe/repos,https://api.github.com/users/manschoe/events{/privacy},https://api.github.com/users/manschoe/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10550/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
928,https://api.github.com/repos/dask/dask/issues/10554,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10554/labels{/name},https://api.github.com/repos/dask/dask/issues/10554/comments,https://api.github.com/repos/dask/dask/issues/10554/events,https://github.com/dask/dask/issues/10554,1936057156,I_kwDOAbcwm85zZeNE,10554,Broken static typing of `Array.shape`,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-10-10T19:21:03Z,2023-11-13T01:46:28Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

While trying to define an array-api compliant array protocol I came upon the following problem:

The static typing of `Array.shape` is broken.
Mypy and pyright both report Any / Unkown.
It should be `tuple[T_IntOrNaN, ...]`

**Minimal Complete Verifiable Example**:

```python
from dask.array import from_array

a = from_array([1, 2, 3])
reveal_type(a.shape)
# mypy output:
# note: Revealed type is ""Any""
# pyright output:
# information: Type of ""a.shape"" is ""Unknown""
```

**Fix**:

Change https://github.com/dask/dask/blob/1a9ba0107995eb0c9c7d91c71adf31877b7de440/dask/utils.py#L1976 to

```python
class cached_property(functools.cached_property, Generic[T]):
    """"""Read only version of functools.cached_property.""""""

    def __init__(self, func: Callable[[Any], T]) -> None:
        super().__init__(func)

    def __set__(self, instance, val) -> NoReturn:
        """"""Raise an error when attempting to set a cached property.""""""
        raise AttributeError(""Can't set attribute"")

    def __get__(self, instance, owner=None) -> T:
        return super().__get__(instance, owner)
```

**Anything else we need to know?**:

On a side note: Is there any reason why you use `float(""nan"")` instead of None for undefined shapes?
The array api standard recommends to use None in this case.

**Environment**:

- Dask version: 2023.9.3
- Python version: 3.9
- Operating System: win10
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10554/timeline,,,headtr1ck,43316012,MDQ6VXNlcjQzMzE2MDEy,https://avatars.githubusercontent.com/u/43316012?v=4,,https://api.github.com/users/headtr1ck,https://github.com/headtr1ck,https://api.github.com/users/headtr1ck/followers,https://api.github.com/users/headtr1ck/following{/other_user},https://api.github.com/users/headtr1ck/gists{/gist_id},https://api.github.com/users/headtr1ck/starred{/owner}{/repo},https://api.github.com/users/headtr1ck/subscriptions,https://api.github.com/users/headtr1ck/orgs,https://api.github.com/users/headtr1ck/repos,https://api.github.com/users/headtr1ck/events{/privacy},https://api.github.com/users/headtr1ck/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10554/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
929,https://api.github.com/repos/dask/dask/issues/10555,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10555/labels{/name},https://api.github.com/repos/dask/dask/issues/10555/comments,https://api.github.com/repos/dask/dask/issues/10555/events,https://github.com/dask/dask/issues/10555,1937390835,I_kwDOAbcwm85zejzz,10555,Selecting an empty slice with negative step size from a dask array returns a non-empty array.,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-10-11T10:17:50Z,2023-11-13T01:46:27Z,,NONE,,"**Describe the issue**:

I found a case where the behavior of dask array slicing deviates from that of Numpy and others.  The cause is an erroneous normalization in `dask.array.slicing.normalize_slice`.  I have included a possible fix.

**Minimal Complete Verifiable Example**:

```python
import dask.array as da

# Dask behavior:
da.arange(3)[-5:-5:-2].compute()
 => array([2, 0])

# Regular Python behavior:
[0, 1, 2][-5,-5,-2]
 => []
```

This handling of slices in Dask is notably different from all other slicing functions in Python and Numpy.  I tracked the problem down to the function `dask.array.slicing.normalize_slice`.  In case the step size is negative, the start or end of the resulting slice is possibly set to `None` without checking whether the slice is empty or not.

**Anything else we need to know?**:

I think a possible fix would be to simplify `normalize_slice` to something like this:

```python
def normalize_slice(idx, dim):
    if isinstance(idx, slice):
        if math.isnan(dim):
            return idx
        return slice(*idx.indices)
    return idx
```

**Environment**:

- Dask version: 2023.5.0
- Python version: 3.9.5
- Operating System: Linux
- Install method: pip
",,https://api.github.com/repos/dask/dask/issues/10555/timeline,,,marcoheisig,6522938,MDQ6VXNlcjY1MjI5Mzg=,https://avatars.githubusercontent.com/u/6522938?v=4,,https://api.github.com/users/marcoheisig,https://github.com/marcoheisig,https://api.github.com/users/marcoheisig/followers,https://api.github.com/users/marcoheisig/following{/other_user},https://api.github.com/users/marcoheisig/gists{/gist_id},https://api.github.com/users/marcoheisig/starred{/owner}{/repo},https://api.github.com/users/marcoheisig/subscriptions,https://api.github.com/users/marcoheisig/orgs,https://api.github.com/users/marcoheisig/repos,https://api.github.com/users/marcoheisig/events{/privacy},https://api.github.com/users/marcoheisig/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10555/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
930,https://api.github.com/repos/dask/dask/issues/10558,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10558/labels{/name},https://api.github.com/repos/dask/dask/issues/10558/comments,https://api.github.com/repos/dask/dask/issues/10558/events,https://github.com/dask/dask/issues/10558,1940184055,I_kwDOAbcwm85zpNv3,10558,test_concat_categorical fails on pandas >= 2.2.0.dev0 or 3.12,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-10-12T14:58:09Z,2023-11-20T01:46:58Z,,MEMBER,,"here's the failure found by https://github.com/dask/dask/pull/10549#issuecomment-1757439251

```
FAILED dask/dataframe/tests/test_multi.py::test_concat_categorical[True-False-True] - AssertionError: Series are different

Series values are different (26.66667 %)
[index]: [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4]
[left]:  ['a', 'a', 'b', 'b', 'b', ..., 'b', 'b', 'a', 'c', 'c']
Length: 15
Categories (3, object): ['a', 'b', 'c']
[right]: ['a', 'a', 'b', 'b', 'c', ..., 'b', 'b', 'a', 'c', 'c']
Length: 15
Categories (3, object): ['a', 'b', 'c']
At positional index 4, first diff: b != c
FAILED dask/dataframe/tests/test_multi.py::test_concat_categorical[False-False-True] - AssertionError: Series are different

Series values are different (26.66667 %)
[index]: [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4]
[left]:  ['a', 'a', 'b', 'b', 'b', ..., 'b', 'b', 'a', 'c', 'c']
Length: 15
Categories (3, object): ['a', 'b', 'c']
[right]: ['a', 'a', 'b', 'b', 'c', ..., 'b', 'b', 'a', 'c', 'c']
Length: 15
Categories (3, object): ['a', 'b', 'c']
At positional index 4, first diff: b != c
```",,https://api.github.com/repos/dask/dask/issues/10558/timeline,,,graingert,413772,MDQ6VXNlcjQxMzc3Mg==,https://avatars.githubusercontent.com/u/413772?v=4,,https://api.github.com/users/graingert,https://github.com/graingert,https://api.github.com/users/graingert/followers,https://api.github.com/users/graingert/following{/other_user},https://api.github.com/users/graingert/gists{/gist_id},https://api.github.com/users/graingert/starred{/owner}{/repo},https://api.github.com/users/graingert/subscriptions,https://api.github.com/users/graingert/orgs,https://api.github.com/users/graingert/repos,https://api.github.com/users/graingert/events{/privacy},https://api.github.com/users/graingert/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10558/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
931,https://api.github.com/repos/dask/dask/issues/10561,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10561/labels{/name},https://api.github.com/repos/dask/dask/issues/10561/comments,https://api.github.com/repos/dask/dask/issues/10561/events,https://github.com/dask/dask/pull/10561,1945204369,PR_kwDOAbcwm85c5jcF,10561,Infer the shape only if chunks is not supplied by the caller of to_zarr,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-10-16T13:18:54Z,2024-02-25T13:41:30Z,,CONTRIBUTOR,,"- [x] Closes #10522
- [ ] Tests added / passed
- [x] Passes `pre-commit run --all-files`
- [ ] Investigate unintended effects. What happens if `chunks` is incorrect? Can we ""chunk arrays along any dimension""?
",,https://api.github.com/repos/dask/dask/issues/10561/timeline,,,bartbroere,2715782,MDQ6VXNlcjI3MTU3ODI=,https://avatars.githubusercontent.com/u/2715782?v=4,,https://api.github.com/users/bartbroere,https://github.com/bartbroere,https://api.github.com/users/bartbroere/followers,https://api.github.com/users/bartbroere/following{/other_user},https://api.github.com/users/bartbroere/gists{/gist_id},https://api.github.com/users/bartbroere/starred{/owner}{/repo},https://api.github.com/users/bartbroere/subscriptions,https://api.github.com/users/bartbroere/orgs,https://api.github.com/users/bartbroere/repos,https://api.github.com/users/bartbroere/events{/privacy},https://api.github.com/users/bartbroere/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10561/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10561,https://github.com/dask/dask/pull/10561,https://github.com/dask/dask/pull/10561.diff,https://github.com/dask/dask/pull/10561.patch,,,,,,,,,,,,,,,,,,,
932,https://api.github.com/repos/dask/dask/issues/10564,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10564/labels{/name},https://api.github.com/repos/dask/dask/issues/10564/comments,https://api.github.com/repos/dask/dask/issues/10564/events,https://github.com/dask/dask/issues/10564,1946949472,I_kwDOAbcwm850DBdg,10564,to_csv doesn't support file-like objects,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,3,2023-10-17T09:17:35Z,2023-12-25T01:46:37Z,,NONE,,,,https://api.github.com/repos/dask/dask/issues/10564/timeline,,,Martmists-GH,16361449,MDQ6VXNlcjE2MzYxNDQ5,https://avatars.githubusercontent.com/u/16361449?v=4,,https://api.github.com/users/Martmists-GH,https://github.com/Martmists-GH,https://api.github.com/users/Martmists-GH/followers,https://api.github.com/users/Martmists-GH/following{/other_user},https://api.github.com/users/Martmists-GH/gists{/gist_id},https://api.github.com/users/Martmists-GH/starred{/owner}{/repo},https://api.github.com/users/Martmists-GH/subscriptions,https://api.github.com/users/Martmists-GH/orgs,https://api.github.com/users/Martmists-GH/repos,https://api.github.com/users/Martmists-GH/events{/privacy},https://api.github.com/users/Martmists-GH/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10564/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
933,https://api.github.com/repos/dask/dask/issues/10566,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10566/labels{/name},https://api.github.com/repos/dask/dask/issues/10566/comments,https://api.github.com/repos/dask/dask/issues/10566/events,https://github.com/dask/dask/issues/10566,1949436753,I_kwDOAbcwm850MgtR,10566,DataFrameGroupBy.agg numeric_only incompatible with pd.NamedAgg,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,7,2023-10-18T10:45:17Z,2024-02-19T12:28:43Z,,NONE,,"due to .agg being wrapped with `numeric_only_not_implemented`, I need to explicitly pass `numeric_only=True` (not doing so results in `NotImplementedError: 'numeric_only=False' is not implemented in Dask.`). However, this argument is never popped from kwargs, meaning `reconstruct_func` is called with `numeric_only=True` still in kwargs, and results in `is_multi_agg_with_relabel` returning False, as it doesn't match a relabel aggregation. This causes a `TypeError: Must provide 'func' or tuples of '(column, aggfunc).`",,https://api.github.com/repos/dask/dask/issues/10566/timeline,,,Martmists-GH,16361449,MDQ6VXNlcjE2MzYxNDQ5,https://avatars.githubusercontent.com/u/16361449?v=4,,https://api.github.com/users/Martmists-GH,https://github.com/Martmists-GH,https://api.github.com/users/Martmists-GH/followers,https://api.github.com/users/Martmists-GH/following{/other_user},https://api.github.com/users/Martmists-GH/gists{/gist_id},https://api.github.com/users/Martmists-GH/starred{/owner}{/repo},https://api.github.com/users/Martmists-GH/subscriptions,https://api.github.com/users/Martmists-GH/orgs,https://api.github.com/users/Martmists-GH/repos,https://api.github.com/users/Martmists-GH/events{/privacy},https://api.github.com/users/Martmists-GH/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10566/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
934,https://api.github.com/repos/dask/dask/issues/10567,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10567/labels{/name},https://api.github.com/repos/dask/dask/issues/10567/comments,https://api.github.com/repos/dask/dask/issues/10567/events,https://github.com/dask/dask/issues/10567,1949556555,I_kwDOAbcwm850M99L,10567,Bug in the graph optimization causing exception to be thrown,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-10-18T11:50:54Z,2023-11-20T01:46:56Z,,NONE,,"**Describe the issue**:
The compute on  DASK collection raises an exception (see below) when calling compute() without any arguments, but succeeds when using compute(optimize_graph=False)

```python-traceback

ValueError                                Traceback (most recent call last)
Input In [27], in <cell line: 2>()
      1 import dask.dataframe
----> 2 dask.dataframe.from_dask_array(prox, columns = ""test"").value_counts().compute()

File ~/.conda/envs/ml4del_concise_plus/lib/python3.9/site-packages/dask/dataframe/optimize.py:25, in optimize(dsk, keys, **kwargs)
     22 else:
     23     # Perform Blockwise optimizations for HLG input
     24     dsk = optimize_dataframe_getitem(dsk, keys=keys)
---> 25     dsk = optimize_blockwise(dsk, keys=keys)
     26     dsk = fuse_roots(dsk, keys=keys)
     27 dsk = dsk.cull(set(keys))

File ~/.conda/envs/ml4del_concise_plus/lib/python3.9/site-packages/dask/blockwise.py:1077, in optimize_blockwise(graph, keys)
   1052 def optimize_blockwise(graph, keys=()):
   1053     """"""High level optimization of stacked Blockwise layers
   1054 
   1055     For operations that have multiple Blockwise operations one after the other, like
   (...)
   1075     rewrite_blockwise
   1076     """"""
-> 1077     out = _optimize_blockwise(graph, keys=keys)
   1078     while out.dependencies != graph.dependencies:
   1079         graph = out

File ~/.conda/envs/ml4del_concise_plus/lib/python3.9/site-packages/dask/blockwise.py:1154, in _optimize_blockwise(full_graph, keys)
   1151             stack.append(d)
   1153 # Merge these Blockwise layers into one
-> 1154 new_layer = rewrite_blockwise([layers[l] for l in blockwise_layers])
   1155 out[layer] = new_layer
   1157 # Get the new (external) dependencies for this layer.
   1158 # This corresponds to the dependencies defined in
   1159 # full_graph.dependencies and are not in blockwise_layers

File ~/.conda/envs/ml4del_concise_plus/lib/python3.9/site-packages/dask/blockwise.py:1281, in rewrite_blockwise(inputs)
   1273 dependents = reverse_dict(dependencies)
   1275 new_index_iter = (
   1276     c + (str(d) if d else """")  # A, B, ... A1, B1, ...
   1277     for d in itertools.count()
   1278     for c in ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
   1279 )
-> 1281 [root] = [k for k, v in dependents.items() if not v]
   1283 # Our final results.  These will change during fusion below
   1284 indices = list(inputs[root].indices)

ValueError: too many values to unpack (expected 1)
```

**Minimal Complete Verifiable Example**:

Sadly enough I didn't succeed to produce a minimally complete verifiable example, without throwing the whole code and data out at this, as apparently the DASK dataframe underlying the example below needs to have some level of complexity for this to show up.  The immediate line of code producing this looks like the following:

````python
dask_df[dask_df[""my_bool_col""]].compute()
````
The following succeeds without error

````python
dask_df[dask_df[""my_bool_col""]].compute(optimize_graph=False)
````

**Anything else we need to know?**:

The best way to look into this would probably be to export the task graph that fails in optimization some useful way allowing you to reconstitute it and feed it into the optimizer. Please advise how that best can be done in a way most useful to you . For the moment I did execute the 

```python
str(dask_df[dask_df[""my_bool_col""]].__dask_graph__().to_dict())
````
the result of this is the file below
[task_graph.dict.txt](https://github.com/dask/dask/files/13021531/task_graph.dict.txt)

**Environment**:

- Dask version: 2023.8.0 
- Python version: 3.9
- Operating System: linux (CentOS7)
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/10567/timeline,,,AnsgarSchuffenhauer,65599632,MDQ6VXNlcjY1NTk5NjMy,https://avatars.githubusercontent.com/u/65599632?v=4,,https://api.github.com/users/AnsgarSchuffenhauer,https://github.com/AnsgarSchuffenhauer,https://api.github.com/users/AnsgarSchuffenhauer/followers,https://api.github.com/users/AnsgarSchuffenhauer/following{/other_user},https://api.github.com/users/AnsgarSchuffenhauer/gists{/gist_id},https://api.github.com/users/AnsgarSchuffenhauer/starred{/owner}{/repo},https://api.github.com/users/AnsgarSchuffenhauer/subscriptions,https://api.github.com/users/AnsgarSchuffenhauer/orgs,https://api.github.com/users/AnsgarSchuffenhauer/repos,https://api.github.com/users/AnsgarSchuffenhauer/events{/privacy},https://api.github.com/users/AnsgarSchuffenhauer/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10567/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
935,https://api.github.com/repos/dask/dask/issues/10568,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10568/labels{/name},https://api.github.com/repos/dask/dask/issues/10568/comments,https://api.github.com/repos/dask/dask/issues/10568/events,https://github.com/dask/dask/issues/10568,1949650381,I_kwDOAbcwm850NU3N,10568,FutureWarning from pandas: The previous implementation of stack is deprecated and will be removed in a future version of panda,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}]",open,False,,[],,2,2023-10-18T12:36:11Z,2023-12-25T01:46:35Z,,MEMBER,,calls to DataFrame.stack now need the future_stack=True kwarg to avoid a FutureWarning,,https://api.github.com/repos/dask/dask/issues/10568/timeline,,,graingert,413772,MDQ6VXNlcjQxMzc3Mg==,https://avatars.githubusercontent.com/u/413772?v=4,,https://api.github.com/users/graingert,https://github.com/graingert,https://api.github.com/users/graingert/followers,https://api.github.com/users/graingert/following{/other_user},https://api.github.com/users/graingert/gists{/gist_id},https://api.github.com/users/graingert/starred{/owner}{/repo},https://api.github.com/users/graingert/subscriptions,https://api.github.com/users/graingert/orgs,https://api.github.com/users/graingert/repos,https://api.github.com/users/graingert/events{/privacy},https://api.github.com/users/graingert/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10568/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
936,https://api.github.com/repos/dask/dask/issues/10572,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10572/labels{/name},https://api.github.com/repos/dask/dask/issues/10572/comments,https://api.github.com/repos/dask/dask/issues/10572/events,https://github.com/dask/dask/issues/10572,1949856119,I_kwDOAbcwm850OHF3,10572,"dask.dataframe groupby results in pandas FutureWarning: When grouping with a length-1 list-like, ...","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-10-18T14:10:11Z,2023-11-20T01:46:54Z,,MEMBER,,"when running against pandas 2.2.0.dev0+390.g59d4e84128 when using group_by a deprecation warning is raised:

```python
>>> import pandas as pd
>>> import dask.dataframe as dd
>>> dd.from_pandas(pd.DataFrame([{""foo"": 10, ""bar"": 4}]), npartitions=1).groupby(""foo"").get_group(10).compute()
/home/graingert/projects/dask/dask/dataframe/groupby.py:274: FutureWarning: When grouping with a length-1 list-like, you will need to pass a length-1 tuple to get_group in a future version of pandas. Pass `(name,)` instead of `name` to silence this warning.
  return grouped.get_group(get_key)
   foo  bar
0   10    4
>>> 
```",,https://api.github.com/repos/dask/dask/issues/10572/timeline,,,graingert,413772,MDQ6VXNlcjQxMzc3Mg==,https://avatars.githubusercontent.com/u/413772?v=4,,https://api.github.com/users/graingert,https://github.com/graingert,https://api.github.com/users/graingert/followers,https://api.github.com/users/graingert/following{/other_user},https://api.github.com/users/graingert/gists{/gist_id},https://api.github.com/users/graingert/starred{/owner}{/repo},https://api.github.com/users/graingert/subscriptions,https://api.github.com/users/graingert/orgs,https://api.github.com/users/graingert/repos,https://api.github.com/users/graingert/events{/privacy},https://api.github.com/users/graingert/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10572/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
937,https://api.github.com/repos/dask/dask/issues/10573,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10573/labels{/name},https://api.github.com/repos/dask/dask/issues/10573/comments,https://api.github.com/repos/dask/dask/issues/10573/events,https://github.com/dask/dask/issues/10573,1950019526,I_kwDOAbcwm850Ou_G,10573,dask.dataframe groupby cov warns with DataFrameGroupBy.apply operated on the grouping columns FutureWarning,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-10-18T15:22:52Z,2023-11-20T01:46:53Z,,MEMBER,,"running the following with pandas 2.2.0.dev0+390.g59d4e84128 (nightly)
```python
import dask.dataframe as dd
import pandas as pd

pdf = pd.DataFrame(
    {""a"": [1, 2, 6, 4, 4, 6, 4, 3, 7], ""b"": [4, 2, 7, 3, 3, 1, 1, 1, 2]},
    index=[0, 1, 3, 5, 6, 8, 9, 9, 9],
)
ddf = dd.from_pandas(pdf, npartitions=3)
ddf.groupby(""b"").a.cov().compute()
```

outputs the following:

```
/home/graingert/projects/dask/dask/dataframe/groupby.py:674: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.
  mul = g.apply(_mul_cols, cols=cols).reset_index(level=-1, drop=True)
/home/graingert/projects/dask/dask/dataframe/groupby.py:732: FutureWarning: The previous implementation of stack is deprecated and will be removed in a future version of pandas. See the What's New notes for pandas 2.1.0 for details. Specify future_stack=True to adopt the new implementation and silence this warning.
  s_result = result.stack(dropna=False)
/home/graingert/projects/dask/dask/dataframe/groupby.py:674: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.
  mul = g.apply(_mul_cols, cols=cols).reset_index(level=-1, drop=True)
/home/graingert/projects/dask/dask/dataframe/groupby.py:674: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.
  mul = g.apply(_mul_cols, cols=cols).reset_index(level=-1, drop=True)
/home/graingert/projects/dask/dask/dataframe/groupby.py:674: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.
  mul = g.apply(_mul_cols, cols=cols).reset_index(level=-1, drop=True)
/home/graingert/projects/dask/dask/dataframe/groupby.py:592: RuntimeWarning: invalid value encountered in scalar divide
  val = (df[mul_col] - df[i] * df[j] / n).values[0] / div.values[0]
/home/graingert/projects/dask/dask/dataframe/groupby.py:592: RuntimeWarning: invalid value encountered in scalar divide
  val = (df[mul_col] - df[i] * df[j] / n).values[0] / div.values[0]
/home/graingert/projects/dask/dask/dataframe/groupby.py:732: FutureWarning: The previous implementation of stack is deprecated and will be removed in a future version of pandas. See the What's New notes for pandas 2.1.0 for details. Specify future_stack=True to adopt the new implementation and silence this warning.
  s_result = result.stack(dropna=False)
```
",,https://api.github.com/repos/dask/dask/issues/10573/timeline,,,graingert,413772,MDQ6VXNlcjQxMzc3Mg==,https://avatars.githubusercontent.com/u/413772?v=4,,https://api.github.com/users/graingert,https://github.com/graingert,https://api.github.com/users/graingert/followers,https://api.github.com/users/graingert/following{/other_user},https://api.github.com/users/graingert/gists{/gist_id},https://api.github.com/users/graingert/starred{/owner}{/repo},https://api.github.com/users/graingert/subscriptions,https://api.github.com/users/graingert/orgs,https://api.github.com/users/graingert/repos,https://api.github.com/users/graingert/events{/privacy},https://api.github.com/users/graingert/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10573/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
938,https://api.github.com/repos/dask/dask/issues/10583,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10583/labels{/name},https://api.github.com/repos/dask/dask/issues/10583/comments,https://api.github.com/repos/dask/dask/issues/10583/events,https://github.com/dask/dask/issues/10583,1955173513,I_kwDOAbcwm850iZSJ,10583,Handle date and decimal dtypes in parquet data,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,3,2023-10-21T00:50:11Z,2023-11-27T01:46:56Z,,MEMBER,,"Decimal and date datatypes are interpretted today as dtype `pyarrow[string]`.  We should find some better representation for these data types.  

I don't actually know where this goes.  Arrow?  Pandas?  Dask DataFrame?  Hopefully we find a good answer here.",,https://api.github.com/repos/dask/dask/issues/10583/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10583/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
939,https://api.github.com/repos/dask/dask/issues/10586,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10586/labels{/name},https://api.github.com/repos/dask/dask/issues/10586/comments,https://api.github.com/repos/dask/dask/issues/10586/events,https://github.com/dask/dask/issues/10586,1955684693,I_kwDOAbcwm850kWFV,10586,"CancelledError: ('head-1-5-from_pandas-e2c5fdfb410a02a25a2bdc76c0f6967b', 0)","[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,3,2023-10-21T22:27:39Z,2023-11-27T01:46:55Z,,NONE,,"Hello ! 

Im starting to use Dask.  But I having problems running a task in a local cluster. I have a similar code like the one below: 


```
from dask.distributed import Client, LocalCluster

# Crear un clster local
cluster = LocalCluster()

# Conectar un cliente a ese clster
client = Client(address=cluster, timeout=""600s"", name=""ETL"")

#from dask.distributed import Client
#client = Client(timeout=""600s"")  # Aumenta segn sea necesario

import pandas as pd 
import dask.dataframe as dd 

# Crear un pandas DF 

test = {""nombre"":[""Orlando"", ""Fernando"", ""Rosario"", ""Cuah"", ""Vernica""],
        ""sexo"":[""M"", ""M"",""F"",""M"",""F""], 
        ""edad"":[30,40,50,60,56]}

test=pd.DataFrame(data=test)

# Creamos un dask df a partir de un pandas df
test= dd.from_pandas(data=test, npartitions=2)
print(""Tipo de objeto:"", type(test))
test.head()

```


The problem comes at the end when I pass from a pandas DF to Dask DF. I get the following error when I want to see  the content of my dask df (using .head()). 

`CancelledError: ('head-1-5-from_pandas-375c4c87e7cf346616f57a65a2dfc407', 0)`


The code works perfectly If I dont create a Client and Local Cluster. I am running this in a Mac book pro with a Apple M2 chip. 
This same code works fine in a windows machine.  

Best regards, 
Orlando 
",,https://api.github.com/repos/dask/dask/issues/10586/timeline,,,orlandombaa,48104481,MDQ6VXNlcjQ4MTA0NDgx,https://avatars.githubusercontent.com/u/48104481?v=4,,https://api.github.com/users/orlandombaa,https://github.com/orlandombaa,https://api.github.com/users/orlandombaa/followers,https://api.github.com/users/orlandombaa/following{/other_user},https://api.github.com/users/orlandombaa/gists{/gist_id},https://api.github.com/users/orlandombaa/starred{/owner}{/repo},https://api.github.com/users/orlandombaa/subscriptions,https://api.github.com/users/orlandombaa/orgs,https://api.github.com/users/orlandombaa/repos,https://api.github.com/users/orlandombaa/events{/privacy},https://api.github.com/users/orlandombaa/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10586/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
940,https://api.github.com/repos/dask/dask/issues/10587,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10587/labels{/name},https://api.github.com/repos/dask/dask/issues/10587/comments,https://api.github.com/repos/dask/dask/issues/10587/events,https://github.com/dask/dask/issues/10587,1956690864,I_kwDOAbcwm850oLuw,10587,SeriesGroupBy.value_counts does not support normalize=True,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-10-23T09:02:07Z,2023-11-27T01:46:54Z,,NONE,,"**Describe the issue**:

trying to run `df[x].groupby(df[y]).value_counts(normalize=True)` raises `TypeError: SeriesGroupBy.value_counts() got an unexpected keyword argument 'normalize'`

**Minimal Complete Verifiable Example**:

```python
>>> import pandas as pd
>>> import dask.dataframe as dd
>>> df = dd.from_pandas(pd.DataFrame({""a"":[1,1,2,2],""b"":[1,1,2,3]}), npartitions=1) 
>>> df[""b""].groupby(df[""a""]).value_counts(normalize=True)
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
TypeError: SeriesGroupBy.value_counts() got an unexpected keyword argument 'normalize'
>>> df = pd.DataFrame({""a"":[1,1,2,2],""b"":[1,1,2,3]})                               
>>> df[""b""].groupby(df[""a""]).value_counts(normalize=True)
a  b
1  1    1.0
2  2    0.5
   3    0.5
Name: proportion, dtype: float64
```

**Anything else we need to know?**: N/A

**Environment**:

- Dask version: 2023.10.0
- Python version: 3.11.5
- Operating System: Windows
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10587/timeline,,,Martmists-GH,16361449,MDQ6VXNlcjE2MzYxNDQ5,https://avatars.githubusercontent.com/u/16361449?v=4,,https://api.github.com/users/Martmists-GH,https://github.com/Martmists-GH,https://api.github.com/users/Martmists-GH/followers,https://api.github.com/users/Martmists-GH/following{/other_user},https://api.github.com/users/Martmists-GH/gists{/gist_id},https://api.github.com/users/Martmists-GH/starred{/owner}{/repo},https://api.github.com/users/Martmists-GH/subscriptions,https://api.github.com/users/Martmists-GH/orgs,https://api.github.com/users/Martmists-GH/repos,https://api.github.com/users/Martmists-GH/events{/privacy},https://api.github.com/users/Martmists-GH/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10587/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
941,https://api.github.com/repos/dask/dask/issues/10595,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10595/labels{/name},https://api.github.com/repos/dask/dask/issues/10595/comments,https://api.github.com/repos/dask/dask/issues/10595/events,https://github.com/dask/dask/issues/10595,1959752231,I_kwDOAbcwm850z3In,10595,`except Exception` in `compute_meta` makes custom functions and schedulers difficult,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-10-24T17:36:34Z,2023-11-27T01:46:52Z,,CONTRIBUTOR,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

There is an `except Exception` block in `compute_meta` when running the function being called.

https://github.com/dask/dask/blame/1203b1bb6d52b1fb00d54656af4af8e6e35aa615/dask/array/utils.py#L162-L163

The commit message for this change mentions avoiding numpy warnings, but those should already be ignored by the `errstate` at the top of the function.

https://github.com/dask/dask/commit/aa5d4ac8eefa4cbcadd0ca112651d53b1403e0a8

In Satpy we use a `CustomScheduler` class in our testing and debugging to verify that we are not computing dask arrays until we expect to. We do this by raising a `RuntimeError` when the scheduler is told to compute more than N times. See:

https://github.com/pytroll/satpy/blob/bc32c9434815365d180b1c6d38c00b2b6b4d5f7e/satpy/tests/utils.py#L275-L290

However, it was recently discovered that this doesn't work if any of our functions require computing the meta array (ex. map_blocks, etc). Most recently it was when passing `xarray.DataArray`s to a `da.where` function by mistake (we're still not sure if this is a problem).

**Minimal Complete Verifiable Example**:

```python
import dask
import dask.array as da
import xarray as xr

class CustomScheduler(object):
    """"""Scheduler raising an exception if data are computed too many times.""""""

    def __init__(self, max_computes=1):
        """"""Set starting and maximum compute counts.""""""
        self.max_computes = max_computes
        self.total_computes = 0

    def __call__(self, dsk, keys, **kwargs):
        """"""Compute dask task and keep track of number of times we do so.""""""
        import dask
        self.total_computes += 1
        if self.total_computes > self.max_computes:
            raise RuntimeError(""Too many dask computations were scheduled: ""
                               ""{}"".format(self.total_computes))
        return dask.get(dsk, keys, **kwargs)

with dask.config.set(scheduler=CustomScheduler(1)):
    da.where(xr.DataArray(da.zeros((5, 5))), xr.DataArray(da.zeros((5, 5))), xr.DataArray(da.ones((5, 5)))).compute()
```

Exception:

```
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
Cell In[22], line 2
      1 with dask.config.set(scheduler=CustomScheduler(1)):
----> 2     da.where(xr.DataArray(da.zeros((5, 5))), xr.DataArray(da.zeros((5, 5))), xr.DataArray(da.ones((5, 5)))).compute()

File ~/miniconda3/envs/polar2grid_py310/lib/python3.10/site-packages/dask/base.py:312, in DaskMethodsMixin.compute(self, **kwargs)
    288 def compute(self, **kwargs):
    289     """"""Compute this dask collection
    290
    291     This turns a lazy Dask collection into its in-memory equivalent.
   (...)
    310     dask.base.compute
    311     """"""
--> 312     (result,) = compute(self, traverse=False, **kwargs)
    313     return result

File ~/miniconda3/envs/polar2grid_py310/lib/python3.10/site-packages/dask/base.py:600, in compute(traverse, optimize_graph, scheduler, get, *args, **kwargs)
    597     keys.append(x.__dask_keys__())
    598     postcomputes.append(x.__dask_postcompute__())
--> 600 results = schedule(dsk, keys, **kwargs)
    601 return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])

Cell In[13], line 14, in CustomScheduler.__call__(self, dsk, keys, **kwargs)
     12 self.total_computes += 1
     13 if self.total_computes > self.max_computes:
---> 14     raise RuntimeError(""Too many dask computations were scheduled: ""
     15                        ""{}"".format(self.total_computes))
     16 return dask.get(dsk, keys, **kwargs)

RuntimeError: Too many dask computations were scheduled: 4

```

Note how the error message says there were 4 computations when there should have only been 2 when the `if self.total_computes > self.max_computes` check is triggered. This is due to `compute_meta` computing the DataArrays as far as I can tell and hiding the `RuntimeError` from trickling up to the user.

**Anything else we need to know?**:

**Environment**:

- Dask version: 2023.9.2 (above code run with a 2022.05.2 but 2023.9.2 also produces it)
- Python version: 3.10 and 3.11
- Operating System: Linux
- Install method (conda, pip, source): conda-forge
",,https://api.github.com/repos/dask/dask/issues/10595/timeline,,,djhoese,1828519,MDQ6VXNlcjE4Mjg1MTk=,https://avatars.githubusercontent.com/u/1828519?v=4,,https://api.github.com/users/djhoese,https://github.com/djhoese,https://api.github.com/users/djhoese/followers,https://api.github.com/users/djhoese/following{/other_user},https://api.github.com/users/djhoese/gists{/gist_id},https://api.github.com/users/djhoese/starred{/owner}{/repo},https://api.github.com/users/djhoese/subscriptions,https://api.github.com/users/djhoese/orgs,https://api.github.com/users/djhoese/repos,https://api.github.com/users/djhoese/events{/privacy},https://api.github.com/users/djhoese/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10595/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
942,https://api.github.com/repos/dask/dask/issues/10598,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10598/labels{/name},https://api.github.com/repos/dask/dask/issues/10598/comments,https://api.github.com/repos/dask/dask/issues/10598/events,https://github.com/dask/dask/issues/10598,1963181122,I_kwDOAbcwm851A8RC,10598,Gather-pq-parts takes a while,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,2,2023-10-26T10:15:11Z,2023-11-27T01:46:51Z,,MEMBER,,"I'm reading a large parquet dataset with 128 MiB files and finding that `gather-pq-parts` takes a while when first creating the dataset.  I'm wondering under what conditions this is triggered.  I tried looking through the code, but it was fairly complex.  

@rjzamora any help?",,https://api.github.com/repos/dask/dask/issues/10598/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10598/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
943,https://api.github.com/repos/dask/dask/issues/10602,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10602/labels{/name},https://api.github.com/repos/dask/dask/issues/10602/comments,https://api.github.com/repos/dask/dask/issues/10602/events,https://github.com/dask/dask/issues/10602,1964065078,I_kwDOAbcwm851EUE2,10602,Parquet Reboot,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,18,2023-10-26T17:54:40Z,2024-01-17T14:01:31Z,,MEMBER,,"Our parquet performance is bad.  I get 20MB/s in real-world use cases on the cloud where I would expect 500 MB/s.  This accounts for ~80% of our runtime in complex dataframe queries in TPC-H.  Systems like P2P, the GIL, Pandas copy-on-write, PyArrow strings, etc, are all inconsequential relative to this performance bottleneck.

Unfortunately, improving this situation is difficult because our current Parquet implementation has many layers and many systems all interwoven with each other.  What should be a relatively simple system is today somewhat opaque.  I would like for us to consider a rewrite.

There are many things to consider here.  I'll follow up with some personal thoughts, and I welcome thoughts from others.",,https://api.github.com/repos/dask/dask/issues/10602/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10602/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
944,https://api.github.com/repos/dask/dask/issues/10603,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10603/labels{/name},https://api.github.com/repos/dask/dask/issues/10603/comments,https://api.github.com/repos/dask/dask/issues/10603/events,https://github.com/dask/dask/issues/10603,1964385123,I_kwDOAbcwm851FiNj,10603,Bug with automatic rechunking on reshape,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,4,2023-10-26T21:19:27Z,2024-02-27T10:20:44Z,,MEMBER,,"From https://github.com/pydata/xarray/issues/8345

```python
import dask.array
array = dask.array.ones(shape=(2, 1000, 100, 4800), chunks=(2, 1000, 100, 83))
with dask.config.set({'array.slicing.split_large_chunks': True}):
    array = array.reshape(2, 1000, 100, 4, 1200)
array
```

```python
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
Cell In[16], line 3
      1 array = dask.array.ones(shape=(2, 1000, 100, 4800), chunks=(2, 1000, 100, 83))
      2 with dask.config.set({'array.slicing.split_large_chunks': True}):
----> 3     array = array.reshape(2, 1000, 100, 4, 1200)
      4 array

File ~/miniforge3/envs/xarray-release/lib/python3.11/site-packages/dask/array/core.py:2219, in Array.reshape(self, merge_chunks, limit, *shape)
   2217 if len(shape) == 1 and not isinstance(shape[0], Number):
   2218     shape = shape[0]
-> 2219 return reshape(self, shape, merge_chunks=merge_chunks, limit=limit)

File ~/miniforge3/envs/xarray-release/lib/python3.11/site-packages/dask/array/reshape.py:285, in reshape(x, shape, merge_chunks, limit)
    283             else:
    284                 chunk_plan.append(""auto"")
--> 285         outchunks = normalize_chunks(
    286             chunk_plan,
    287             shape=shape,
    288             limit=limit,
    289             dtype=x.dtype,
    290             previous_chunks=inchunks,
    291         )
    293 x2 = x.rechunk(inchunks)
    295 # Construct graph

File ~/miniforge3/envs/xarray-release/lib/python3.11/site-packages/dask/array/core.py:3095, in normalize_chunks(chunks, shape, limit, dtype, previous_chunks)
   3092 chunks = tuple(""auto"" if isinstance(c, str) and c != ""auto"" else c for c in chunks)
   3094 if any(c == ""auto"" for c in chunks):
-> 3095     chunks = auto_chunks(chunks, shape, limit, dtype, previous_chunks)
   3097 if shape is not None:
   3098     chunks = tuple(c if c not in {None, -1} else s for c, s in zip(chunks, shape))

File ~/miniforge3/envs/xarray-release/lib/python3.11/site-packages/dask/array/core.py:3218, in auto_chunks(chunks, shape, limit, dtype, previous_chunks)
   3212 largest_block = math.prod(
   3213     cs if isinstance(cs, Number) else max(cs) for cs in chunks if cs != ""auto""
   3214 )
   3216 if previous_chunks:
   3217     # Base ideal ratio on the median chunk size of the previous chunks
-> 3218     result = {a: np.median(previous_chunks[a]) for a in autos}
   3220     ideal_shape = []
   3221     for i, s in enumerate(shape):

File ~/miniforge3/envs/xarray-release/lib/python3.11/site-packages/dask/array/core.py:3218, in <dictcomp>(.0)
   3212 largest_block = math.prod(
   3213     cs if isinstance(cs, Number) else max(cs) for cs in chunks if cs != ""auto""
   3214 )
   3216 if previous_chunks:
   3217     # Base ideal ratio on the median chunk size of the previous chunks
-> 3218     result = {a: np.median(previous_chunks[a]) for a in autos}
   3220     ideal_shape = []
   3221     for i, s in enumerate(shape):

IndexError: tuple index out of range
```",,https://api.github.com/repos/dask/dask/issues/10603/timeline,,,dcherian,2448579,MDQ6VXNlcjI0NDg1Nzk=,https://avatars.githubusercontent.com/u/2448579?v=4,,https://api.github.com/users/dcherian,https://github.com/dcherian,https://api.github.com/users/dcherian/followers,https://api.github.com/users/dcherian/following{/other_user},https://api.github.com/users/dcherian/gists{/gist_id},https://api.github.com/users/dcherian/starred{/owner}{/repo},https://api.github.com/users/dcherian/subscriptions,https://api.github.com/users/dcherian/orgs,https://api.github.com/users/dcherian/repos,https://api.github.com/users/dcherian/events{/privacy},https://api.github.com/users/dcherian/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10603/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
945,https://api.github.com/repos/dask/dask/issues/10606,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10606/labels{/name},https://api.github.com/repos/dask/dask/issues/10606/comments,https://api.github.com/repos/dask/dask/issues/10606/events,https://github.com/dask/dask/issues/10606,1967125161,I_kwDOAbcwm851P_Kp,10606,.explode not working,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,4,2023-10-29T19:30:48Z,2023-12-20T15:03:29Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
explode method returns unchanged lists even in test `dask/dataframe/tests/test_dataframe.py::test_series_explode`

**Minimal Complete Verifiable Example**:

```python
# Put your MCVE code here
import dask.dataframe as dd
import pandas as pd

s = pd.Series([[1, 2, 3], ""foo"", [3, 4]])
exploded_s = s.explode()
ds = dd.from_pandas(s, npartitions=2)

print('\npandas:')
print(exploded_s)
print('\nDASK:')
print(ds.compute())


pandas:
0      1
0      2
0      3
1    foo
2      3
2      4
dtype: object

DASK:
0    [1, 2, 3]
1          foo
2       [3, 4]
dtype: string
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2023.10.1
- Python version: 3.11.4
- Operating System: win 10
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10606/timeline,,,TsiVit,40140211,MDQ6VXNlcjQwMTQwMjEx,https://avatars.githubusercontent.com/u/40140211?v=4,,https://api.github.com/users/TsiVit,https://github.com/TsiVit,https://api.github.com/users/TsiVit/followers,https://api.github.com/users/TsiVit/following{/other_user},https://api.github.com/users/TsiVit/gists{/gist_id},https://api.github.com/users/TsiVit/starred{/owner}{/repo},https://api.github.com/users/TsiVit/subscriptions,https://api.github.com/users/TsiVit/orgs,https://api.github.com/users/TsiVit/repos,https://api.github.com/users/TsiVit/events{/privacy},https://api.github.com/users/TsiVit/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10606/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
946,https://api.github.com/repos/dask/dask/issues/10607,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10607/labels{/name},https://api.github.com/repos/dask/dask/issues/10607/comments,https://api.github.com/repos/dask/dask/issues/10607/events,https://github.com/dask/dask/issues/10607,1967207100,I_kwDOAbcwm851QTK8,10607,"Unexpected exception ""ValueError: divisions must be sorted"" when resampling sorted time index","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-10-29T23:20:40Z,2023-12-04T01:46:53Z,,NONE,,"**Describe the issue**:
When resampling a sorted time index I raise an unexpected exception:  ValueError: divisions must be sorted.

**MCVE**
I wish I had a more complete bug report, but I likely will lose time to generate a true mcve and I want to report what I have.  

After seeing some odd behavior, I expected the following to *be* a good mcve, however it doesn't show the bug.  

```python
from dask.datasets import timeseries
import dask.dataframe as dd
import dask
import pandas as pd
print('dask: ', dask.__version__)
print('pandas:', pd.__version__)
```
```
dask:  2023.10.1
pandas: 2.0.3
```
```python
ddf = timeseries(start='2023-01-01', end='2023-12-31', freq='1d')
print(ddf.resample('Q').size().compute())
print(ddf.resample('QS').size().compute())
```
```
timestamp
2023-03-31    90
2023-06-30    91
2023-09-30    92
Freq: Q-DEC, dtype: int64
timestamp
2023-01-01    90
2023-04-01    91
2023-07-01    92
2023-10-01    91
Freq: QS-JAN, dtype: int64
```

Here is the best I can extract from the running code that does show unexpected (to me) behavior.  I'm hoping someone with better Dask-fu than myself can use this info to craft a proper mcve.  My guess is that it has to do with an index with repeated values in the index, but I haven't been able to test that yet.  

In a dataframe with the following divisions:

```python
new_ddf.divisions
```
```
(Timestamp('2008-03-11 22:02:00'),
 Timestamp('2008-04-01 22:02:00'),
 Timestamp('2008-05-01 22:02:00'),
 Timestamp('2008-06-01 22:02:00'),
 Timestamp('2008-07-01 22:02:00'),
 Timestamp('2008-08-01 22:02:00'),
 Timestamp('2008-09-01 22:02:00'),
 Timestamp('2008-10-01 22:02:00'),
 Timestamp('2008-11-01 22:02:00'),
 Timestamp('2008-12-01 22:02:00'),
 Timestamp('2008-12-31 23:58:00'))
```
This works:
```python
new_ddf.resample('QS').size().compute()
```
```
occurred
2008-01-01      85310
2008-04-01     832889
2008-07-01     580117
2008-10-01    1283544
Freq: QS-JAN, dtype: int64
```
And this fails:
```python
new_ddf.resample('Q').size().compute()
```
```python-traceback
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[31], line 1
----> 1 new_ddf.resample('Q').size().compute()

File ~/anaconda3/lib/python3.11/site-packages/dask/dataframe/tseries/resample.py:255, in Resampler.size(self)
    253 @derived_from(pd_Resampler)
    254 def size(self):
--> 255     return self._agg(""size"", fill_value=0)

File ~/anaconda3/lib/python3.11/site-packages/dask/dataframe/tseries/resample.py:199, in Resampler._agg(self, how, meta, fill_value, how_args, how_kwargs)
    197 if isinstance(meta, pd.DataFrame):
    198     return DataFrame(graph, name, meta, outdivs)
--> 199 return Series(graph, name, meta, outdivs)

File ~/anaconda3/lib/python3.11/site-packages/dask/dataframe/core.py:419, in _Frame.__init__(self, dsk, name, meta, divisions)
    414     raise TypeError(
    415         f""Expected meta to specify type {type(self).__name__}, got type ""
    416         f""{typename(type(meta))}""
    417     )
    418 self._meta = meta
--> 419 self.divisions = tuple(divisions)
    421 # Optionally cast object dtypes to `pyarrow` strings.
    422 # By default, if `pyarrow` and `pandas>=2` are installed,
    423 # we convert to pyarrow strings.
    424 if pyarrow_strings_enabled():

File ~/anaconda3/lib/python3.11/site-packages/dask/dataframe/core.py:552, in _Frame.divisions(self, value)
    548     if not (
    549         isinstance(index_dtype, pd.CategoricalDtype) and index_dtype.ordered
    550     ):
    551         if value != tuple(sorted(value)):
--> 552             raise ValueError(""divisions must be sorted"")
    554 self._divisions = value

ValueError: divisions must be sorted
```
With a very interesting  value for the variable `value` in that deepest function call.  I captured the value with a debugger below:  the last timestamp is a *duplicate of a prior value* and *out of order*.  So, it appears that `resample` (in at least some scenarios) might not be generating a properly sorted index for use in the outgoing Dask dataframe.

```python
> /Users/mfenner/anaconda3/lib/python3.11/site-packages/dask/dataframe/core.py(552)divisions()
    550             ):
    551                 if value != tuple(sorted(value)):
--> 552                     raise ValueError(""divisions must be sorted"")
    553 
    554         self._divisions = value

ipdb> p value
(Timestamp('2008-03-31 00:00:00'), Timestamp('2008-06-30 00:00:00'), Timestamp('2008-09-30 00:00:00'), Timestamp('2008-12-31 00:00:00'), Timestamp('2008-09-30 00:00:00'))
```

**Environment**:

- Dask version:  dask:  2023.10.1 / pandas: 2.0.3
- Python version: 3.11.5
- Operating System: OSX
- Install method (conda, pip, source): conda + conda-forge for more recent dask
",,https://api.github.com/repos/dask/dask/issues/10607/timeline,,,mfenner1,913036,MDQ6VXNlcjkxMzAzNg==,https://avatars.githubusercontent.com/u/913036?v=4,,https://api.github.com/users/mfenner1,https://github.com/mfenner1,https://api.github.com/users/mfenner1/followers,https://api.github.com/users/mfenner1/following{/other_user},https://api.github.com/users/mfenner1/gists{/gist_id},https://api.github.com/users/mfenner1/starred{/owner}{/repo},https://api.github.com/users/mfenner1/subscriptions,https://api.github.com/users/mfenner1/orgs,https://api.github.com/users/mfenner1/repos,https://api.github.com/users/mfenner1/events{/privacy},https://api.github.com/users/mfenner1/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10607/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
947,https://api.github.com/repos/dask/dask/issues/10612,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10612/labels{/name},https://api.github.com/repos/dask/dask/issues/10612/comments,https://api.github.com/repos/dask/dask/issues/10612/events,https://github.com/dask/dask/pull/10612,1976217129,PR_kwDOAbcwm85eidRW,10612,Handle `split_out=None` deprecation warning to `drop_duplicates`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,1,2023-11-03T13:33:49Z,2023-12-04T01:46:52Z,,MEMBER,,"Looks like we didn't add handling for `split_out=None` with #10542, causing us to get an error like:

```python-traceback
shuffle = None, split_out = None

    def _determine_split_out_shuffle(shuffle, split_out):
        """"""Determine the default shuffle behavior based on split_out""""""
        if shuffle is None:
>           if split_out > 1:
E           TypeError: '>' not supported between instances of 'NoneType' and 'int'

/datasets/charlesb/micromamba/envs/dask-sql-py39/lib/python3.9/site-packages/dask/dataframe/core.py:202: TypeError
```

This PR adds a warning for the deprecated use and falls back to the default of `split_out=1`

cc @rjzamora

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10612/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10612/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10612,https://github.com/dask/dask/pull/10612,https://github.com/dask/dask/pull/10612.diff,https://github.com/dask/dask/pull/10612.patch,,,,,,,,,,,,,,,,,,,
948,https://api.github.com/repos/dask/dask/issues/10614,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10614/labels{/name},https://api.github.com/repos/dask/dask/issues/10614/comments,https://api.github.com/repos/dask/dask/issues/10614/events,https://github.com/dask/dask/issues/10614,1980770124,I_kwDOAbcwm852ECdM,10614,Deletion of index column after merging on Dask Dataframe,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,2,2023-11-07T08:02:12Z,2023-12-11T01:47:00Z,,NONE,,"For a particular operation I would like to perform using Dask I am interested in a left join on a not-index column. However, after the merge operation, the index column is removed from the dataframe. Why is the merge operation implemented such that the index is removed after merging? As far as I could test, the index column is only maintained when the join operation is performed on the index itself. I think that more use-cases should exist where one would want to maintain the index after adding information using a left-join operation. 

```python
import dask.dataframe as dd
import pandas as pd

data_left = dd.from_pandas(pd.DataFrame({'index': [""id_A"", ""id_B1"", ""id_C""], 'key': ['A', 'B', 'C'], 'value1': ['aa','bb','cc']}), npartitions=1)
data_left = data_left.set_index('index', sort=True)

data_right = dd.from_pandas(pd.DataFrame({'key': [""A"", ""B"", ""C""], 'value2': ['aa','bb','cc']}), npartitions=1)

merged_df = data_left.merge(data_right, how='left', left_on='key', right_on='key')

print(merged_df.compute())
```

This gives the output (without the index column):
```
   key value1 value2
0   A     aa     aa
1   B     bb     bb
2   C     cc     cc

```


**Environment**:

- Dask version: 2023.10.0
- Python version: Python 3.11.2
- Operating System: Windows 10 Enterprise
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10614/timeline,,,joelplantinga,36266064,MDQ6VXNlcjM2MjY2MDY0,https://avatars.githubusercontent.com/u/36266064?v=4,,https://api.github.com/users/joelplantinga,https://github.com/joelplantinga,https://api.github.com/users/joelplantinga/followers,https://api.github.com/users/joelplantinga/following{/other_user},https://api.github.com/users/joelplantinga/gists{/gist_id},https://api.github.com/users/joelplantinga/starred{/owner}{/repo},https://api.github.com/users/joelplantinga/subscriptions,https://api.github.com/users/joelplantinga/orgs,https://api.github.com/users/joelplantinga/repos,https://api.github.com/users/joelplantinga/events{/privacy},https://api.github.com/users/joelplantinga/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10614/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
949,https://api.github.com/repos/dask/dask/issues/10615,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10615/labels{/name},https://api.github.com/repos/dask/dask/issues/10615/comments,https://api.github.com/repos/dask/dask/issues/10615/events,https://github.com/dask/dask/issues/10615,1981036482,I_kwDOAbcwm852FDfC,10615,Indicate variable chunking for dask arrays in string repr,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798602129, 'node_id': 'LA_kwDOAbcwm87iahGR', 'url': 'https://api.github.com/repos/dask/dask/labels/enhancement', 'name': 'enhancement', 'color': 'C2E0C6', 'default': True, 'description': 'Improve existing functionality or make things work better'}]",open,False,,[],,5,2023-11-07T10:31:02Z,2024-02-27T14:52:42Z,,NONE,,"When dask arrays have variable chunking along a dimension, the string repr doesn't reflect this. As an example,

```python
import dask.array as da

# Fixed chunking
x = da.ones(100, chunks=5)
x
```

```
dask.array<ones_like, shape=(100,), dtype=float64, chunksize=(5,), chunktype=numpy.ndarray>
```

The `chunksize` reported here is `(5,)`, which is accurate. However if we rechunk to have variable sizes:


```python
x.rechunk(((20, 30, 50),))
```

```
dask.array<rechunk-merge, shape=(100,), dtype=float64, chunksize=(50,), chunktype=numpy.ndarray>
```

The reported chunk size is `(50,)` which isn't accurate for all chunks. AFAICT, this just reports the maximum chunksize for each dimension. 

It can be confusing that there is no indication in the string repr that these arrays are different:

```python
x.rechunk((10, 20, 20, 50,))
x.rechunk((50,))
```

I think it would be nice if there was some indication the chunks were variable along a particular dimension. Not sure what the best solution here would be, but some thoughts:

* It could be that it was just `.chunks`, but that can get quite long for some cases. Maybe this can be auto-ellipsed? `chunksize=((10, ..., 50),)`
* Special `var` character, similar to `nan` for unknown `chunksize=(var,)`  though this loses any size info
* Special modifier to indicate the value is a max `chunksize=(var(50),)` or `chunksize=(max(50),)`",,https://api.github.com/repos/dask/dask/issues/10615/timeline,,,ivirshup,8238804,MDQ6VXNlcjgyMzg4MDQ=,https://avatars.githubusercontent.com/u/8238804?v=4,,https://api.github.com/users/ivirshup,https://github.com/ivirshup,https://api.github.com/users/ivirshup/followers,https://api.github.com/users/ivirshup/following{/other_user},https://api.github.com/users/ivirshup/gists{/gist_id},https://api.github.com/users/ivirshup/starred{/owner}{/repo},https://api.github.com/users/ivirshup/subscriptions,https://api.github.com/users/ivirshup/orgs,https://api.github.com/users/ivirshup/repos,https://api.github.com/users/ivirshup/events{/privacy},https://api.github.com/users/ivirshup/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10615/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
950,https://api.github.com/repos/dask/dask/issues/10617,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10617/labels{/name},https://api.github.com/repos/dask/dask/issues/10617/comments,https://api.github.com/repos/dask/dask/issues/10617/events,https://github.com/dask/dask/issues/10617,1982411152,I_kwDOAbcwm852KTGQ,10617,Series.str.join does not work like Pandas,"[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}, {'id': 6137710172, 'node_id': 'LA_kwDOAbcwm88AAAABbdYGXA', 'url': 'https://api.github.com/repos/dask/dask/labels/convert-string', 'name': 'convert-string', 'color': 'd93f0b', 'default': False, 'description': ''}]",open,False,,[],,2,2023-11-07T23:19:40Z,2023-12-11T01:46:59Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**: [dask.dataframe.Series.str.join](https://docs.dask.org/en/latest/generated/dask.dataframe.Series.str.join.html) promises to do the same thing as Pandas (by having the same docstring) but it does something different.

**Minimal Complete Verifiable Example**:

```python
import pandas
import dask.dataframe as dd
s = dd.from_pandas(pandas.DataFrame({'foo': ['bar/baz', 'baz/quux']}), npartitions=2).foo
print(s.str.split('/').str.join(' ').compute())
```

The output _should_ be

```
0     bar baz
1    baz quux
Name: foo, dtype: string
```

but it actually is

```
0      [ ' b a r ' ,   ' b a z ' ]
1    [ ' b a z ' ,   ' q u u x ' ]
Name: foo, dtype: string
```

**Anything else we need to know?**: Nope

**Environment**:

- Dask version: 2023.10.1
- Python version: 3.10.13
- Operating System: Linux
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10617/timeline,,,zmbc,13357648,MDQ6VXNlcjEzMzU3NjQ4,https://avatars.githubusercontent.com/u/13357648?v=4,,https://api.github.com/users/zmbc,https://github.com/zmbc,https://api.github.com/users/zmbc/followers,https://api.github.com/users/zmbc/following{/other_user},https://api.github.com/users/zmbc/gists{/gist_id},https://api.github.com/users/zmbc/starred{/owner}{/repo},https://api.github.com/users/zmbc/subscriptions,https://api.github.com/users/zmbc/orgs,https://api.github.com/users/zmbc/repos,https://api.github.com/users/zmbc/events{/privacy},https://api.github.com/users/zmbc/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10617/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
951,https://api.github.com/repos/dask/dask/issues/10626,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10626/labels{/name},https://api.github.com/repos/dask/dask/issues/10626/comments,https://api.github.com/repos/dask/dask/issues/10626/events,https://github.com/dask/dask/issues/10626,1987241706,I_kwDOAbcwm852cubq,10626,Sensitivity to parquet file RG splits,"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,2,2023-11-10T09:25:46Z,2023-12-13T08:47:36Z,,MEMBER,,"It turns out we do have performance tests that cover the edge case of very large files w/ row groups after all, see https://github.com/dask/dask/pull/10600

The data we have stored in https://s3.console.aws.amazon.com/s3/buckets/coiled-runtime-ci?prefix=ookla-open-data/type%3Dfixed/&region=us-east-2

The files in there are 400-500MB on disk (Still have to check details about the RGs. We're splitting this up into 61 parts, i.e. we have on average 4.7 RGs/tasks per file)

This is used by the `test_read_hive_partitioned_data` in coiled benchmarks

`Wall Clock`
![image](https://github.com/dask/dask/assets/8629629/fd77e1ea-b887-4ef4-aef2-e4d422aae672)

`Average Memory`
![image](https://github.com/dask/dask/assets/8629629/85289319-6ae0-42f4-9150-793887cb42c7)


With this change, this test no longer splits the files into smaller tasks. Therefore, the memory goes up since the operation performed on this dataset reduces immediately. This is expected.
The walltime performance is however very misleading since there are a couple of things happening here
- Since we no longer split the files we now have fewer tasks and can't utilize all the workers. That alone explains a drop of at least 13% (13/15)
- There is some sort of S3 caching problem going on as well that seems to be exacerbated by having fewer tasks. If I warm up s3, this runtime goes down from 50 to ~13s (vs 9s with a warm cache for the split row groups w/ already cached PQ statistics). This puts us in a range where the performance difference may be explained by the change in available, participating workers (we're still missing 10-15% but I also didn't measure the statistics gathering here)


What I find interesting with this is that with the split into row groups, the effect of having S3 be warm seems to be much 
less severe.

|   | Cold S3 |  Warm S3 | Delta |
| - | - | - | - |
| No Split  | 45-50  | 13 | -75% |
| Split  | ~18  | 9 | -50% |

I suspect that with the split rowgroups approach, S3 naturally warms up since we are touching the files multiple times such that the first row group access is slow but the later ones are fast.

I wonder if we can leverage this somehow. Can we warm up files that are going to be loaded later on with very simple requests (like reading the footer N times)? Can this be done by a scheduler plugin or a dangling extra task such that workers will never/rarely encounter cold files?
",,https://api.github.com/repos/dask/dask/issues/10626/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10626/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
952,https://api.github.com/repos/dask/dask/issues/10628,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10628/labels{/name},https://api.github.com/repos/dask/dask/issues/10628/comments,https://api.github.com/repos/dask/dask/issues/10628/events,https://github.com/dask/dask/issues/10628,1989330763,I_kwDOAbcwm852ksdL,10628,"DataFrame.apply(meta=(None, 'object')) converts to pyarrow's string","[{'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}, {'id': 6137710172, 'node_id': 'LA_kwDOAbcwm88AAAABbdYGXA', 'url': 'https://api.github.com/repos/dask/dask/labels/convert-string', 'name': 'convert-string', 'color': 'd93f0b', 'default': False, 'description': ''}]",open,False,,[],,4,2023-11-12T09:56:23Z,2024-01-19T15:08:20Z,,NONE,,"**Describe the issue**:

Using `dask.dataframe.DataFrame.apply(..., meta=(None, 'object'), ...)` converts to pyarrow's string

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import pandas as pd

def as_tuple(series):
    return series['int'], series['str'], series['datetime']

df = pd.DataFrame(
    data={
        'int': range(1, 4),
        'str': list('ABC'),
        'datetime': pd.date_range(start='2023-01-01', periods=3, freq='D')
    },
)
ddf = dd.from_pandas(data=df, npartitions=1)
```
```python
>> df
     int    str    datetime
0    1      A      2023-01-01
1    2      B      2023-01-02
2    3      C      2023-01-03

>> ddf
Dask DataFrame Structure:
     int      str       datetime
npartitions=1
0    int64    string    datetime64[ns]
2    ...      ...       ...
Dask Name: to_pyarrow_string, 2 graph layers
```

```python
>> df.apply(func=as_tuple, axis='columns')
0    (1, A, 2023-01-01 00:00:00)
1    (2, B, 2023-01-02 00:00:00)
2    (3, C, 2023-01-03 00:00:00)
dtype: object

>> df.apply(func=as_tuple, axis='columns').dtype
dtype('O')
```
```python
>> ddf.apply(func=as_tuple, axis='columns', meta=(None, 'object'))
Dask Series Structure:
npartitions=1
0    string
2       ...
dtype: string
Dask Name: to_pyarrow_string, 4 graph layers

>> ddf.apply(func=as_tuple, axis='columns', meta=(None, 'object')).dtype
string[pyarrow]
```
```python
>> ddf.apply(func=as_tuple, axis='columns', meta=(None, 'object')).compute()
0    (1, 'A', Timestamp('2023-01-01 00:00:00'))
1    (2, 'B', Timestamp('2023-01-02 00:00:00'))
2    (3, 'C', Timestamp('2023-01-03 00:00:00'))
dtype: string

>> ddf.apply(func=as_tuple, axis='columns', meta=(None, 'object')).compute().dtype
string[pyarrow]
```

**Environment**:

| Name                          | Version      | Build                 | Channel     |
|:------------------------------|:-------------|:----------------------|:------------|
| _libgcc_mutex                 | 0.1          | conda_forge           | conda-forge |
| _openmp_mutex                 | 4.5          | 2_gnu                 | conda-forge |
| asttokens                     | 2.4.1        | pyhd8ed1ab_0          | conda-forge |
| aws-c-auth                    | 0.7.6        | h37ad1db_0            | conda-forge |
| aws-c-cal                     | 0.6.9        | h3b91eb8_1            | conda-forge |
| aws-c-common                  | 0.9.8        | hd590300_0            | conda-forge |
| aws-c-compression             | 0.2.17       | hfd9eb17_6            | conda-forge |
| aws-c-event-stream            | 0.3.2        | hae413d4_6            | conda-forge |
| aws-c-http                    | 0.7.14       | h162056d_1            | conda-forge |
| aws-c-io                      | 0.13.35      | hc23c90e_8            | conda-forge |
| aws-c-mqtt                    | 0.9.9        | h1387108_0            | conda-forge |
| aws-c-s3                      | 0.3.23       | h7630044_1            | conda-forge |
| aws-c-sdkutils                | 0.1.12       | hfd9eb17_5            | conda-forge |
| aws-checksums                 | 0.1.17       | hfd9eb17_5            | conda-forge |
| aws-crt-cpp                   | 0.24.5       | h270613d_5            | conda-forge |
| aws-sdk-cpp                   | 1.11.182     | h8df25a1_5            | conda-forge |
| backports                     | 1.0          | pyhd8ed1ab_3          | conda-forge |
| backports.functools_lru_cache | 1.6.5        | pyhd8ed1ab_0          | conda-forge |
| bokeh                         | 3.3.1        | pyhd8ed1ab_0          | conda-forge |
| boto3                         | 1.28.84      | pyhd8ed1ab_0          | conda-forge |
| botocore                      | 1.31.84      | pyhd8ed1ab_0          | conda-forge |
| bottleneck                    | 1.3.7        | py311h1f0f07a_1       | conda-forge |
| brotli-python                 | 1.1.0        | py311hb755f60_1       | conda-forge |
| bzip2                         | 1.0.8        | hd590300_5            | conda-forge |
| c-ares                        | 1.21.0       | hd590300_0            | conda-forge |
| ca-certificates               | 2023.7.22    | hbcca054_0            | conda-forge |
| certifi                       | 2023.7.22    | pyhd8ed1ab_0          | conda-forge |
| charset-normalizer            | 3.3.2        | pyhd8ed1ab_0          | conda-forge |
| click                         | 8.1.7        | unix_pyh707e725_0     | conda-forge |
| cloudpickle                   | 3.0.0        | pyhd8ed1ab_0          | conda-forge |
| comm                          | 0.1.4        | pyhd8ed1ab_0          | conda-forge |
| contourpy                     | 1.2.0        | py311h9547e67_0       | conda-forge |
| cytoolz                       | 0.12.2       | py311h459d7ec_1       | conda-forge |
| daal4py                       | 2023.2.1     | py311he14880b_0       | conda-forge |
| dal                           | 2023.2.1     | ha770c72_1033         | conda-forge |
| dask                          | 2023.11.0    | pyhd8ed1ab_0          | conda-forge |
| dask-core                     | 2023.11.0    | pyhd8ed1ab_0          | conda-forge |
| debugpy                       | 1.8.0        | py311hb755f60_1       | conda-forge |
| decorator                     | 5.1.1        | pyhd8ed1ab_0          | conda-forge |
| distributed                   | 2023.11.0    | pyhd8ed1ab_0          | conda-forge |
| exceptiongroup                | 1.1.3        | pyhd8ed1ab_0          | conda-forge |
| executing                     | 2.0.1        | pyhd8ed1ab_0          | conda-forge |
| freetype                      | 2.12.1       | h267a509_2            | conda-forge |
| fsspec                        | 2023.10.0    | pyhca7485f_0          | conda-forge |
| gflags                        | 2.2.2        | he1b5a44_1004         | conda-forge |
| glog                          | 0.6.0        | h6f12383_0            | conda-forge |
| greenlet                      | 3.0.1        | py311hb755f60_0       | conda-forge |
| icu                           | 73.2         | h59595ed_0            | conda-forge |
| idna                          | 3.4          | pyhd8ed1ab_0          | conda-forge |
| importlib-metadata            | 6.8.0        | pyha770c72_0          | conda-forge |
| importlib_metadata            | 6.8.0        | hd8ed1ab_0            | conda-forge |
| ipykernel                     | 6.26.0       | pyhf8b6a83_0          | conda-forge |
| ipython                       | 8.17.2       | pyh41d4057_0          | conda-forge |
| jedi                          | 0.19.1       | pyhd8ed1ab_0          | conda-forge |
| jinja2                        | 3.1.2        | pyhd8ed1ab_1          | conda-forge |
| jmespath                      | 1.0.1        | pyhd8ed1ab_0          | conda-forge |
| joblib                        | 1.3.2        | pyhd8ed1ab_0          | conda-forge |
| jupyter_client                | 8.6.0        | pyhd8ed1ab_0          | conda-forge |
| jupyter_core                  | 5.5.0        | py311h38be061_0       | conda-forge |
| keyutils                      | 1.6.1        | h166bdaf_0            | conda-forge |
| krb5                          | 1.21.2       | h659d440_0            | conda-forge |
| lcms2                         | 2.15         | hb7c19ff_3            | conda-forge |
| ld_impl_linux-64              | 2.40         | h41732ed_0            | conda-forge |
| lerc                          | 4.0.0        | h27087fc_0            | conda-forge |
| libabseil                     | 20230802.1   | cxx17_h59595ed_0      | conda-forge |
| libarrow                      | 14.0.1       | h0406937_1_cpu        | conda-forge |
| libarrow-acero                | 14.0.1       | h59595ed_1_cpu        | conda-forge |
| libarrow-dataset              | 14.0.1       | h59595ed_1_cpu        | conda-forge |
| libarrow-flight               | 14.0.1       | h120cb0d_1_cpu        | conda-forge |
| libarrow-flight-sql           | 14.0.1       | h61ff412_1_cpu        | conda-forge |
| libarrow-gandiva              | 14.0.1       | hacb8726_1_cpu        | conda-forge |
| libarrow-substrait            | 14.0.1       | h61ff412_1_cpu        | conda-forge |
| libblas                       | 3.9.0        | 19_linux64_openblas   | conda-forge |
| libbrotlicommon               | 1.1.0        | hd590300_1            | conda-forge |
| libbrotlidec                  | 1.1.0        | hd590300_1            | conda-forge |
| libbrotlienc                  | 1.1.0        | hd590300_1            | conda-forge |
| libcblas                      | 3.9.0        | 19_linux64_openblas   | conda-forge |
| libcrc32c                     | 1.1.2        | h9c3ff4c_0            | conda-forge |
| libcurl                       | 8.4.0        | hca28451_0            | conda-forge |
| libdeflate                    | 1.19         | hd590300_0            | conda-forge |
| libedit                       | 3.1.20191231 | he28a2e2_2            | conda-forge |
| libev                         | 4.33         | h516909a_1            | conda-forge |
| libevent                      | 2.1.12       | hf998b51_1            | conda-forge |
| libexpat                      | 2.5.0        | hcb278e6_1            | conda-forge |
| libffi                        | 3.4.2        | h7f98852_5            | conda-forge |
| libgcc-ng                     | 13.2.0       | h807b86a_3            | conda-forge |
| libgfortran-ng                | 13.2.0       | h69a702a_3            | conda-forge |
| libgfortran5                  | 13.2.0       | ha4646dd_3            | conda-forge |
| libgomp                       | 13.2.0       | h807b86a_3            | conda-forge |
| libgoogle-cloud               | 2.12.0       | h5206363_4            | conda-forge |
| libgrpc                       | 1.59.2       | hd6c4280_0            | conda-forge |
| libhwloc                      | 2.9.3        | default_h554bfaf_1009 | conda-forge |
| libiconv                      | 1.17         | h166bdaf_0            | conda-forge |
| libjpeg-turbo                 | 3.0.0        | hd590300_1            | conda-forge |
| liblapack                     | 3.9.0        | 19_linux64_openblas   | conda-forge |
| libllvm14                     | 14.0.6       | hcd5def8_4            | conda-forge |
| libllvm15                     | 15.0.7       | h5cf9203_3            | conda-forge |
| libnghttp2                    | 1.58.0       | h47da74e_0            | conda-forge |
| libnsl                        | 2.0.1        | hd590300_0            | conda-forge |
| libnuma                       | 2.0.16       | h0b41bf4_1            | conda-forge |
| libopenblas                   | 0.3.24       | pthreads_h413a1c8_0   | conda-forge |
| libparquet                    | 14.0.1       | h352af49_1_cpu        | conda-forge |
| libpng                        | 1.6.39       | h753d276_0            | conda-forge |
| libpq                         | 16.1         | hfc447b1_0            | conda-forge |
| libprotobuf                   | 4.24.4       | hf27288f_0            | conda-forge |
| libre2-11                     | 2023.06.02   | h7a70373_0            | conda-forge |
| libsodium                     | 1.0.18       | h36c2ea0_1            | conda-forge |
| libsqlite                     | 3.44.0       | h2797004_0            | conda-forge |
| libssh2                       | 1.11.0       | h0841786_0            | conda-forge |
| libstdcxx-ng                  | 13.2.0       | h7e041cc_3            | conda-forge |
| libthrift                     | 0.19.0       | hb90f79a_1            | conda-forge |
| libtiff                       | 4.6.0        | ha9c0a0a_2            | conda-forge |
| libutf8proc                   | 2.8.0        | h166bdaf_0            | conda-forge |
| libuuid                       | 2.38.1       | h0b41bf4_0            | conda-forge |
| libwebp-base                  | 1.3.2        | hd590300_0            | conda-forge |
| libxcb                        | 1.15         | h0b41bf4_0            | conda-forge |
| libxml2                       | 2.11.5       | h232c23b_1            | conda-forge |
| libzlib                       | 1.2.13       | hd590300_5            | conda-forge |
| llvmlite                      | 0.41.1       | py311ha6695c7_0       | conda-forge |
| locket                        | 1.0.0        | pyhd8ed1ab_0          | conda-forge |
| lz4                           | 4.3.2        | py311h38e4bf4_1       | conda-forge |
| lz4-c                         | 1.9.4        | hcb278e6_0            | conda-forge |
| markupsafe                    | 2.1.3        | py311h459d7ec_1       | conda-forge |
| matplotlib-inline             | 0.1.6        | pyhd8ed1ab_0          | conda-forge |
| mpi                           | 1.0          | mpich                 | conda-forge |
| mpich                         | 4.1.2        | h846660c_100          | conda-forge |
| msgpack-python                | 1.0.6        | py311h9547e67_0       | conda-forge |
| ncurses                       | 6.4          | h59595ed_2            | conda-forge |
| nest-asyncio                  | 1.5.8        | pyhd8ed1ab_0          | conda-forge |
| nomkl                         | 1.0          | h5ca1d4c_0            | conda-forge |
| numba                         | 0.58.1       | py311h96b013e_0       | conda-forge |
| numexpr                       | 2.8.7        | py311h039bad6_104     | conda-forge |
| numpy                         | 1.26.0       | py311h64a7726_0       | conda-forge |
| openjpeg                      | 2.5.0        | h488ebb8_3            | conda-forge |
| openssl                       | 3.1.4        | hd590300_0            | conda-forge |
| orc                           | 1.9.0        | h4b38347_4            | conda-forge |
| packaging                     | 23.2         | pyhd8ed1ab_0          | conda-forge |
| pandas                        | 2.1.3        | py311h320fe9a_0       | conda-forge |
| parso                         | 0.8.3        | pyhd8ed1ab_0          | conda-forge |
| partd                         | 1.4.1        | pyhd8ed1ab_0          | conda-forge |
| pexpect                       | 4.8.0        | pyh1a96a4e_2          | conda-forge |
| pickleshare                   | 0.7.5        | py_1003               | conda-forge |
| pillow                        | 10.1.0       | py311ha6c5da5_0       | conda-forge |
| pip                           | 23.3.1       | pyhd8ed1ab_0          | conda-forge |
| platformdirs                  | 4.0.0        | pyhd8ed1ab_0          | conda-forge |
| prompt-toolkit                | 3.0.40       | pyha770c72_0          | conda-forge |
| prompt_toolkit                | 3.0.40       | hd8ed1ab_0            | conda-forge |
| psutil                        | 5.9.5        | py311h459d7ec_1       | conda-forge |
| psycopg2                      | 2.9.7        | py311h03dec38_1       | conda-forge |
| psycopg2-binary               | 2.9.7        | pyhd8ed1ab_1          | conda-forge |
| pthread-stubs                 | 0.4          | h36c2ea0_1001         | conda-forge |
| ptyprocess                    | 0.7.0        | pyhd3deb0d_0          | conda-forge |
| pure_eval                     | 0.2.2        | pyhd8ed1ab_0          | conda-forge |
| pyarrow                       | 14.0.1       | py311h39c9aba_1_cpu   | conda-forge |
| pyarrow-hotfix                | 0.4          | pyhd8ed1ab_0          | conda-forge |
| pygments                      | 2.16.1       | pyhd8ed1ab_0          | conda-forge |
| pysocks                       | 1.7.1        | pyha2e5f31_6          | conda-forge |
| python                        | 3.11.6       | hab00c5b_0_cpython    | conda-forge |
| python-dateutil               | 2.8.2        | pyhd8ed1ab_0          | conda-forge |
| python-tzdata                 | 2023.3       | pyhd8ed1ab_0          | conda-forge |
| python_abi                    | 3.11         | 4_cp311               | conda-forge |
| pytz                          | 2023.3.post1 | pyhd8ed1ab_0          | conda-forge |
| pyyaml                        | 6.0.1        | py311h459d7ec_1       | conda-forge |
| pyzmq                         | 25.1.1       | py311h34ded2d_2       | conda-forge |
| rdma-core                     | 28.9         | h59595ed_1            | conda-forge |
| re2                           | 2023.06.02   | h2873b5e_0            | conda-forge |
| readline                      | 8.2          | h8228510_1            | conda-forge |
| requests                      | 2.31.0       | pyhd8ed1ab_0          | conda-forge |
| s2n                           | 1.3.56       | h06160fa_0            | conda-forge |
| s3transfer                    | 0.7.0        | pyhd8ed1ab_0          | conda-forge |
| scikit-learn                  | 1.3.2        | py311hc009520_1       | conda-forge |
| scikit-learn-intelex          | 2023.2.1     | py311h38be061_0       | conda-forge |
| scipy                         | 1.11.3       | py311h64a7726_1       | conda-forge |
| setuptools                    | 68.2.2       | pyhd8ed1ab_0          | conda-forge |
| six                           | 1.16.0       | pyh6c4a22f_0          | conda-forge |
| snappy                        | 1.1.10       | h9fff704_0            | conda-forge |
| sortedcontainers              | 2.4.0        | pyhd8ed1ab_0          | conda-forge |
| sqlalchemy                    | 2.0.23       | py311h459d7ec_0       | conda-forge |
| stack_data                    | 0.6.2        | pyhd8ed1ab_0          | conda-forge |
| tabulate                      | 0.9.0        | pyhd8ed1ab_1          | conda-forge |
| tbb                           | 2021.10.0    | h00ab1b0_2            | conda-forge |
| tblib                         | 2.0.0        | pyhd8ed1ab_0          | conda-forge |
| threadpoolctl                 | 3.2.0        | pyha21a80b_0          | conda-forge |
| tk                            | 8.6.13       | noxft_h4845f30_101    | conda-forge |
| toolz                         | 0.12.0       | pyhd8ed1ab_0          | conda-forge |
| tornado                       | 6.3.3        | py311h459d7ec_1       | conda-forge |
| traitlets                     | 5.13.0       | pyhd8ed1ab_0          | conda-forge |
| typing-extensions             | 4.8.0        | hd8ed1ab_0            | conda-forge |
| typing_extensions             | 4.8.0        | pyha770c72_0          | conda-forge |
| tzdata                        | 2023c        | h71feb2d_0            | conda-forge |
| ucx                           | 1.15.0       | h64cca9d_0            | conda-forge |
| urllib3                       | 1.26.18      | pyhd8ed1ab_0          | conda-forge |
| wcwidth                       | 0.2.9        | pyhd8ed1ab_0          | conda-forge |
| wheel                         | 0.41.3       | pyhd8ed1ab_0          | conda-forge |
| xorg-libxau                   | 1.0.11       | hd590300_0            | conda-forge |
| xorg-libxdmcp                 | 1.1.3        | h7f98852_0            | conda-forge |
| xyzservices                   | 2023.10.1    | pyhd8ed1ab_0          | conda-forge |
| xz                            | 5.2.6        | h166bdaf_0            | conda-forge |
| yaml                          | 0.2.5        | h7f98852_2            | conda-forge |
| zeromq                        | 4.3.5        | h59595ed_0            | conda-forge |
| zict                          | 3.0.0        | pyhd8ed1ab_0          | conda-forge |
| zipp                          | 3.17.0       | pyhd8ed1ab_0          | conda-forge |
| zstd                          | 1.5.5        | hfc55251_0            | conda-forge |",,https://api.github.com/repos/dask/dask/issues/10628/timeline,,,idanhazan,19217750,MDQ6VXNlcjE5MjE3NzUw,https://avatars.githubusercontent.com/u/19217750?v=4,,https://api.github.com/users/idanhazan,https://github.com/idanhazan,https://api.github.com/users/idanhazan/followers,https://api.github.com/users/idanhazan/following{/other_user},https://api.github.com/users/idanhazan/gists{/gist_id},https://api.github.com/users/idanhazan/starred{/owner}{/repo},https://api.github.com/users/idanhazan/subscriptions,https://api.github.com/users/idanhazan/orgs,https://api.github.com/users/idanhazan/repos,https://api.github.com/users/idanhazan/events{/privacy},https://api.github.com/users/idanhazan/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10628/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
953,https://api.github.com/repos/dask/dask/issues/10629,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10629/labels{/name},https://api.github.com/repos/dask/dask/issues/10629/comments,https://api.github.com/repos/dask/dask/issues/10629/events,https://github.com/dask/dask/issues/10629,1989498562,I_kwDOAbcwm852lVbC,10629,partition_by column changes type,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,2,2023-11-12T17:29:58Z,2023-12-12T11:42:50Z,,NONE,,"I have a string column comprised of strings ('01','02'....) (these are US state codes, all 2 digit string). When I save a parquet and partition by this column, and then read the parquet back, it strings become integers. Is this behavior expected? If column `state_code` is a string column, once read it should also be a string column. Trying to specify the schema in the `.to_parquet` call does not help. 

```
import dask.dataframe as dd
import pandas as pd
data = dd.from_pandas(pd.DataFrame({'state_code': ['01','01','02','02'], 'value': [1,2,3,4]}), npartitions=1)
data.to_parquet('test.parquet', partition_on=['state_code'], engine='pyarrow', write_index=False)
data = pd.read_parquet('test.parquet', engine='pyarrow')
print(data.state_code)

0    1
1    1
2    2
3    2
Name: state_code, dtype: category
Categories (2, int64): [1, 2]
```
I would like to return a string column. (Of course I can solve this by changing the type of the column once it has been read which is what I am currently doing)
",,https://api.github.com/repos/dask/dask/issues/10629/timeline,,,marcdelabarrera,49533815,MDQ6VXNlcjQ5NTMzODE1,https://avatars.githubusercontent.com/u/49533815?v=4,,https://api.github.com/users/marcdelabarrera,https://github.com/marcdelabarrera,https://api.github.com/users/marcdelabarrera/followers,https://api.github.com/users/marcdelabarrera/following{/other_user},https://api.github.com/users/marcdelabarrera/gists{/gist_id},https://api.github.com/users/marcdelabarrera/starred{/owner}{/repo},https://api.github.com/users/marcdelabarrera/subscriptions,https://api.github.com/users/marcdelabarrera/orgs,https://api.github.com/users/marcdelabarrera/repos,https://api.github.com/users/marcdelabarrera/events{/privacy},https://api.github.com/users/marcdelabarrera/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10629/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
954,https://api.github.com/repos/dask/dask/issues/10631,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10631/labels{/name},https://api.github.com/repos/dask/dask/issues/10631/comments,https://api.github.com/repos/dask/dask/issues/10631/events,https://github.com/dask/dask/issues/10631,1994805615,I_kwDOAbcwm8525lFv,10631,Improper conversions of object dtype to string[pyarrow],"[{'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 6137710172, 'node_id': 'LA_kwDOAbcwm88AAAABbdYGXA', 'url': 'https://api.github.com/repos/dask/dask/labels/convert-string', 'name': 'convert-string', 'color': 'd93f0b', 'default': False, 'description': ''}]",open,False,,[],,7,2023-11-15T13:43:30Z,2024-01-29T19:31:11Z,,MEMBER,,"I'm really happy about the use of pyarrow string by default for strings.  I think that it solves a lot of performance problems that made things unusable.  

However, it seems like there are also frequent user errors about this feature, probably not enough to warrant turning it off, but enough that we should maybe think about it at a high level.  My sense is that people have various code that creates non-string objects and that we overly eagerly convert those to string[pyarrow] type.  Situations that I've observed:

- types like 
    - decimal
    - list
    - date
    - struct
-  when ...
    - reading parquet
    - specifying `meta=(""name"", object)`
    - shuffling?

I suspect/hope that there are ways to reduce some of these errant conversions that don't stop the general benefit of using pyarrow strings.  For example, I suspect that we could add mappings to the arrow type mapper when reading parquet.  I did this in https://github.com/dask-contrib/dask-expr/pull/373 and it worked fine I think?  Probably if the user specifies `object` as a dtype then we should respect it.  

I'm curious to learn more about what's possible and not possible when solving this problem.  My guess is that that we can improve the situation, even if we don't solve it entirely.

cc @phofl @jrbourbeau @fjetter ",,https://api.github.com/repos/dask/dask/issues/10631/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10631/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
955,https://api.github.com/repos/dask/dask/issues/10632,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10632/labels{/name},https://api.github.com/repos/dask/dask/issues/10632/comments,https://api.github.com/repos/dask/dask/issues/10632/events,https://github.com/dask/dask/issues/10632,1996806724,I_kwDOAbcwm853BNpE,10632,Support SeriesGroupBy.nlargest,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,0,2023-11-16T13:00:17Z,2023-12-12T11:40:34Z,,MEMBER,,"Equivalent pandas API: https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.SeriesGroupBy.nlargest.html

Will help a lot with the DuckDB benchmarks, [specifically query 8.](https://github.com/duckdblabs/db-benchmark/blob/49016238fdd78dcbc4e5119bb0cd34487ca5419c/dask/groupby-dask2.py#L251)

xref: https://github.com/duckdblabs/db-benchmark/pull/64
",,https://api.github.com/repos/dask/dask/issues/10632/timeline,,,milesgranger,13764397,MDQ6VXNlcjEzNzY0Mzk3,https://avatars.githubusercontent.com/u/13764397?v=4,,https://api.github.com/users/milesgranger,https://github.com/milesgranger,https://api.github.com/users/milesgranger/followers,https://api.github.com/users/milesgranger/following{/other_user},https://api.github.com/users/milesgranger/gists{/gist_id},https://api.github.com/users/milesgranger/starred{/owner}{/repo},https://api.github.com/users/milesgranger/subscriptions,https://api.github.com/users/milesgranger/orgs,https://api.github.com/users/milesgranger/repos,https://api.github.com/users/milesgranger/events{/privacy},https://api.github.com/users/milesgranger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10632/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
956,https://api.github.com/repos/dask/dask/issues/10633,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10633/labels{/name},https://api.github.com/repos/dask/dask/issues/10633/comments,https://api.github.com/repos/dask/dask/issues/10633/events,https://github.com/dask/dask/issues/10633,1997194382,I_kwDOAbcwm853CsSO,10633,Toggle to switch DataFrame API to use dask-expr (but not as default),"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3468123446, 'node_id': 'LA_kwDOAbcwm87Ot102', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20attention', 'name': 'needs attention', 'color': '6d626c', 'default': False, 'description': ""It's been a while since this was pushed on. Needs attention from the owner or a maintainer.""}]",open,False,,[],,0,2023-11-16T15:58:27Z,2023-12-18T01:46:48Z,,MEMBER,,"There's been a lot of momentum around [`dask-expr`](https://github.com/dask-contrib/dask-expr) recently and we posted already a couple of blog posts ([introduction](https://blog.dask.org/2023/08/25/dask-expr-introduction) and [tpch benchmarks](https://blog.coiled.io/blog/dask-expr-tpch-dask.html)) that show how this new approach can be transformative to the performance and usability of the dataframe.

The project is not quite feature complete but the core API is implemented and functioning well enough for us to make the first step and add this to the main project via a feature toggle.

Implementing a feature toggle like this presents us with a certain challenge from an implementation POV since we have plenty of submodules in the `dask.dataframe` module that will be sensitive to such a switch. Many functions that can be imported from those modules will likely not work on a dask-expr DataFrame.

One proposal would be to drop all submodules in favor of allowing only imports from `dask.dataframe.__init__.py` and renaming all submodules s.t. they have an underscore signaling it to be private API.

The feature toggle could then easily be implemented at this central place and we could introduce proper deprecation warnings.

xref https://github.com/dask-contrib/dask-expr/issues/374",,https://api.github.com/repos/dask/dask/issues/10633/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10633/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
957,https://api.github.com/repos/dask/dask/issues/10635,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10635/labels{/name},https://api.github.com/repos/dask/dask/issues/10635/comments,https://api.github.com/repos/dask/dask/issues/10635/events,https://github.com/dask/dask/issues/10635,1999328474,I_kwDOAbcwm853K1Ta,10635,Dask requires read permission for writing dataframe parquet to s3,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-11-17T15:03:00Z,2023-11-20T09:46:54Z,,NONE,,"**Describe the issue**:
I cannot write a dataframe to an s3 bucket without READ permission to that bucket. Is that expected behavior? I cannot find anything anywhere regarding this.

**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import dask.dataframe as dd

bucket_name = ""my-amazing-bucket""
object_key = ""banana.parquet""
df = pd.DataFrame({""A"": [0, 1, 2], ""B"": [""ba"", ""na"", ""na""]})
df = dd.from_pandas(df, npartitions=2)
df.to_parquet(f""s3://{bucket_name}/{object_key}"")
```

If the corresponding role only has write permission like so it doesn't work:
```
{
    ""Version"": ""2012-10-17"",
    ""Statement"": [
        {
            ""Action"": [
                ""s3:PutObject"",
                ""s3:PutObjectLegalHold"",
                ""s3:PutObjectRetention"",
                ""s3:PutObjectTagging"",
                ""s3:PutObjectVersionTagging"",
                ""s3:Abort*""
            ],
            ""Resource"": ""arn:aws:s3:::my-amazing-bucket/*"",
            ""Effect"": ""Allow""
        }
    ]
}
```

Giving the following error:
```
Traceback (most recent call last):
File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 110, in _error_wrapper
return await func(*args, **kwargs)
File ""/usr/local/lib/python3.9/site-packages/aiobotocore/client.py"", line 265, in _make_api_call
raise error_class(parsed_response, operation_name)
botocore.exceptions.ClientError: An error occurred (403) when calling the HeadObject operation: Forbidden
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
File ""/work/src/banana.py"", line 8, in <module>
df.to_parquet(f""s3://{bucket_name}/{key}"")
File ""/usr/local/lib/python3.9/site-packages/dask/dataframe/core.py"", line 5721, in to_parquet
return to_parquet(self, path, *args, **kwargs)
File ""/usr/local/lib/python3.9/site-packages/dask/dataframe/io/parquet/core.py"", line 868, in to_parquet
if fs.exists(path) and fs.isdir(path):
File ""/usr/local/lib/python3.9/site-packages/fsspec/asyn.py"", line 111, in wrapper
return sync(self.loop, func, *args, **kwargs)
File ""/usr/local/lib/python3.9/site-packages/fsspec/asyn.py"", line 96, in sync
raise return_result
File ""/usr/local/lib/python3.9/site-packages/fsspec/asyn.py"", line 53, in _runner
result[0] = await coro
File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 888, in _exists
await self._info(path, bucket, key, version_id=version_id)
File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 1140, in _info
out = await self._call_s3(
File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 332, in _call_s3
return await _error_wrapper(
File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 137, in _error_wrapper
raise err
PermissionError: Forbidden
```

But if the role also has read permission to the bucket, it works:
```
{
    ""Version"": ""2012-10-17"",
    ""Statement"": [
        {
            ""Action"": [
                ""s3:GetObject*"",
                ""s3:GetBucket*"",
                ""s3:List*""
            ],
            ""Resource"": [
                ""arn:aws:s3:::my-amazing-bucket"",
                ""arn:aws:s3:::my-amazing-bucket/*""
            ],
            ""Effect"": ""Allow""
        },
        {
            ""Action"": [
                ""s3:PutObject"",
                ""s3:PutObjectLegalHold"",
                ""s3:PutObjectRetention"",
                ""s3:PutObjectTagging"",
                ""s3:PutObjectVersionTagging"",
                ""s3:Abort*""
            ],
            ""Resource"": ""arn:aws:s3:::my-amazing-bucket/*"",
            ""Effect"": ""Allow""
        }
    ]
}
```

**Anything else we need to know?**:
Writing a dataframe with pandas only requires write permission. (Comment the line `df = dd.from_pandas(df, npartitions=2)`)

**Environment**:

- Dask version: 2023.11.0
- Python version: Python 3.9.18
- Operating System: Linux - docker base image: `public.ecr.aws/docker/library/python:3.9-slim`
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10635/timeline,,,trgmg,142340341,U_kgDOCHvw9Q,https://avatars.githubusercontent.com/u/142340341?v=4,,https://api.github.com/users/trgmg,https://github.com/trgmg,https://api.github.com/users/trgmg/followers,https://api.github.com/users/trgmg/following{/other_user},https://api.github.com/users/trgmg/gists{/gist_id},https://api.github.com/users/trgmg/starred{/owner}{/repo},https://api.github.com/users/trgmg/subscriptions,https://api.github.com/users/trgmg/orgs,https://api.github.com/users/trgmg/repos,https://api.github.com/users/trgmg/events{/privacy},https://api.github.com/users/trgmg/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10635/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
958,https://api.github.com/repos/dask/dask/issues/10639,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10639/labels{/name},https://api.github.com/repos/dask/dask/issues/10639/comments,https://api.github.com/repos/dask/dask/issues/10639/events,https://github.com/dask/dask/pull/10639,2004641356,PR_kwDOAbcwm85gClUa,10639,Fix bug in map_overlap when after creates an empty partition,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,0,2023-11-21T16:04:05Z,2023-11-21T16:47:40Z,,MEMBER,,"Found in dask-expr development
",,https://api.github.com/repos/dask/dask/issues/10639/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10639/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10639,https://github.com/dask/dask/pull/10639,https://github.com/dask/dask/pull/10639.diff,https://github.com/dask/dask/pull/10639.patch,,,,,,,,,,,,,,,,,,,
959,https://api.github.com/repos/dask/dask/issues/10641,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10641/labels{/name},https://api.github.com/repos/dask/dask/issues/10641/comments,https://api.github.com/repos/dask/dask/issues/10641/events,https://github.com/dask/dask/issues/10641,2005605447,I_kwDOAbcwm853ixxH,10641,Dask dataframe from doubly delayed tasks causing error when being merged with another dask dataframe,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-11-22T05:31:46Z,2023-11-22T09:25:05Z,,NONE,,"```python
import dask
import dask.dataframe as dd

def process_df(df):
    return df

def make_df():
    return pd.DataFrame([[1, 3], [2, 3], [3, 4]] , columns=['A', 'B'])

a = dd.from_delayed([dask.delayed(make_df)() for n in range(1)], meta={'A': int, 'B': int})
b = dd.from_delayed([dask.delayed(process_df)(dask.delayed(make_df)()) for n in range(3)], meta={'A': int, 'B': int})

dd.merge(a, b, on='B').compute()
```
Here b is a dask dataframe made up of 3 delayed tasks (`process_df`) on top of delayed tasks (`make_df`), and as described it looks like part of the partitions of b will be missing when calling `dask.dataframe.merge`. Confusingly this only happens when the dataframe that it's merged with (in this case `a`) has a partition of 1. It works fine when both dataframes have more than 1 partition. Dask dataframe made up of pandas dataframe doesn't seem to have this issue.

- Dask version: 2023.11.0
- Python version: 3.11.6
- Operating System: Linux
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/10641/timeline,,,yiliema,6669228,MDQ6VXNlcjY2NjkyMjg=,https://avatars.githubusercontent.com/u/6669228?v=4,,https://api.github.com/users/yiliema,https://github.com/yiliema,https://api.github.com/users/yiliema/followers,https://api.github.com/users/yiliema/following{/other_user},https://api.github.com/users/yiliema/gists{/gist_id},https://api.github.com/users/yiliema/starred{/owner}{/repo},https://api.github.com/users/yiliema/subscriptions,https://api.github.com/users/yiliema/orgs,https://api.github.com/users/yiliema/repos,https://api.github.com/users/yiliema/events{/privacy},https://api.github.com/users/yiliema/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10641/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
960,https://api.github.com/repos/dask/dask/issues/10647,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10647/labels{/name},https://api.github.com/repos/dask/dask/issues/10647/comments,https://api.github.com/repos/dask/dask/issues/10647/events,https://github.com/dask/dask/pull/10647,2009834522,PR_kwDOAbcwm85gUICk,10647,Change default parquet compression format from Snappy to LZ4,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,0,2023-11-24T14:41:36Z,2023-11-24T14:41:52Z,,MEMBER,,"Snappy's status as default is maybe just due to history.  Snappy had better Java support and LZ4 wasn't always available in systems like Spark.  Today Spark and other systems support LZ4 as well, and LZ4 generally performs a bit better, especially on decompression.

This is a significant change, but I think the only reason not to do it is historical, which I think maybe isn't a good enough reason these days.",,https://api.github.com/repos/dask/dask/issues/10647/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10647/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10647,https://github.com/dask/dask/pull/10647,https://github.com/dask/dask/pull/10647.diff,https://github.com/dask/dask/pull/10647.patch,,,,,,,,,,,,,,,,,,,
961,https://api.github.com/repos/dask/dask/issues/10648,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10648/labels{/name},https://api.github.com/repos/dask/dask/issues/10648/comments,https://api.github.com/repos/dask/dask/issues/10648/events,https://github.com/dask/dask/pull/10648,2009965245,PR_kwDOAbcwm85gUka5,10648,Speed up normalize_chunks,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,2,2023-11-24T16:27:27Z,2023-11-25T14:22:12Z,,CONTRIBUTOR,,"This PR attempts to speed up `normalize_chunks` a bit because it was one of the more significant bottlenecks when initailizing many dask arrays.
* Removes a lot of duplicated checks.
* Adds type hints to further make sure things work as intended.

- [x] Closes #xxxx
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

Performance comparison:
```python
chunks = ((3, 3), (4, 4))
shape = (6, 8)
%timeit normalize_chunks(chunks, shape)
6.02 s  312 ns per loop (mean  std. dev. of 7 runs, 100000 loops each) PR
13.1 s  204 ns per loop (mean  std. dev. of 7 runs, 100000 loops each) Main

chunks = (3, (4, 4))
shape = (6, 8)
%timeit normalize_chunks(chunks, shape)
17.6 s  282 ns per loop (mean  std. dev. of 7 runs, 100000 loops each) PR
26.1 s  1.05 s per loop (mean  std. dev. of 7 runs, 10000 loops each) Main

chunks = (""auto"", (4, 4))
shape = (6, 8)
dtype=np.dtype(np.int32)
%timeit normalize_chunks(chunks, shape, dtype=dtype)
53.5 s  566 ns per loop (mean  std. dev. of 7 runs, 10000 loops each) PR
63.5 s  3.26 s per loop (mean  std. dev. of 7 runs, 10000 loops each) Main
```

",,https://api.github.com/repos/dask/dask/issues/10648/timeline,,,Illviljan,14371165,MDQ6VXNlcjE0MzcxMTY1,https://avatars.githubusercontent.com/u/14371165?v=4,,https://api.github.com/users/Illviljan,https://github.com/Illviljan,https://api.github.com/users/Illviljan/followers,https://api.github.com/users/Illviljan/following{/other_user},https://api.github.com/users/Illviljan/gists{/gist_id},https://api.github.com/users/Illviljan/starred{/owner}{/repo},https://api.github.com/users/Illviljan/subscriptions,https://api.github.com/users/Illviljan/orgs,https://api.github.com/users/Illviljan/repos,https://api.github.com/users/Illviljan/events{/privacy},https://api.github.com/users/Illviljan/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10648/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10648,https://github.com/dask/dask/pull/10648,https://github.com/dask/dask/pull/10648.diff,https://github.com/dask/dask/pull/10648.patch,,,,,,,,,,,,,,,,,,,
962,https://api.github.com/repos/dask/dask/issues/10654,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10654/labels{/name},https://api.github.com/repos/dask/dask/issues/10654/comments,https://api.github.com/repos/dask/dask/issues/10654/events,https://github.com/dask/dask/issues/10654,2014376310,I_kwDOAbcwm854EPF2,10654,Mechanism to indicate a task is only executed for side-effects to prevent re-execution upon worker restart,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,6,2023-11-28T12:54:20Z,2023-11-29T14:20:03Z,,CONTRIBUTOR,,"I have a function `parse_chunk` which writes it's output to disk and returns `None`. Running this function in the classic dask way:

```python
tasks = []
for c in chunks:
  tasks.append(dask.delayed(parse_chunk)(c))
dask.compute(*tasks)
```
On the dashboard I see the progress bar move forward as chunks are processed, but when a worker is rotated out (they have to be due to cluster time limits) the progress bar skips backward as all the results of the tasks done by that worker are lost. The results are not needed as the function just returns `None`.

One solution I have tried is this:

```python
futures = []
for c in chunks:
    futures.append(client.submit(parse_chunk,c))
for future in distributed.as_completed(futures):
        future.result()
        client.cancel(future)
```
Which works  - the work is no longer redone. But now the progress bar is very confusing for users as it stays at zero, but the work left to be done slowly decreases to zero.

Could there be a way to indicate that the results of a task are not needed and don't need to be held in cluster memory to the end of the `compute` call?

Many thanks!",,https://api.github.com/repos/dask/dask/issues/10654/timeline,,,benjeffery,8552,MDQ6VXNlcjg1NTI=,https://avatars.githubusercontent.com/u/8552?v=4,,https://api.github.com/users/benjeffery,https://github.com/benjeffery,https://api.github.com/users/benjeffery/followers,https://api.github.com/users/benjeffery/following{/other_user},https://api.github.com/users/benjeffery/gists{/gist_id},https://api.github.com/users/benjeffery/starred{/owner}{/repo},https://api.github.com/users/benjeffery/subscriptions,https://api.github.com/users/benjeffery/orgs,https://api.github.com/users/benjeffery/repos,https://api.github.com/users/benjeffery/events{/privacy},https://api.github.com/users/benjeffery/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10654/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
963,https://api.github.com/repos/dask/dask/issues/10655,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10655/labels{/name},https://api.github.com/repos/dask/dask/issues/10655/comments,https://api.github.com/repos/dask/dask/issues/10655/events,https://github.com/dask/dask/issues/10655,2014964859,I_kwDOAbcwm854Gex7,10655,Resampling to Time Period End Fails,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-11-28T17:38:28Z,2023-11-28T17:38:40Z,,NONE,,"**Describe the issue**:
Resampling to end of period frequencies (end of quarter, end of month -- `Q`, `M`) fails when the last day in the period is included in the to-be-resampled dask dataframe.

**Minimal Complete Verifiable Example**:

```python
# the following demonstrates the error
# while the index is a bit wonky, the same error occurs if it is a
# ""complete"" date_range generated index from 01-01 to 01-31
index =pd.DatetimeIndex(['2023-01-01', '2023-01-31'])
df = pd.DataFrame({'value':[1,2]}, index=index)
ddf = dd.from_pandas(df, npartitions=1)
print(""month (start):"")
print(ddf.resample('MS').size().compute())
print(""month (end):"")
print(ddf.resample('M').size().compute())
```
```
month (start):
2023-01-01    2
Freq: MS, dtype: int64
month (end):
()
```

For comparison, consider the following with only a tiny modification (to include Jan. 30 and not Jan. 31):
```python
# the following works as expected
index =pd.DatetimeIndex(['2023-01-01', '2023-01-30'])
df = pd.DataFrame({'value':[1,2]}, index=index)
ddf = dd.from_pandas(df, npartitions=1)
print(""month (start):"")
print(ddf.resample('MS').size().compute())
print(""month (end):"")
print(ddf.resample('M').size().compute())
```
```
month (start):
2023-01-01    2
Freq: MS, dtype: int64
month (end):
2023-01-31    2
Freq: M, dtype: int64
```

**Anything else we need to know?**:
In trying to track down and/or figure out what's going on with https://github.com/dask/dask/issues/10607, I started playing around with smaller input sizes (and got away from parquet as a moving part).  I've been pointing my debugger at dask/dataframe/tseries/resample.py, namely `_resample_bin_and_out_divs` and `Resampler._agg` ...... however, I haven't pursued that with my recent tiny testcase.  Hoping to get to that in the next couple days.

The same issue occurs with Q (quarter end) resampling.


**Environment**:
- Dask version: dask: 2023.10.1 / pandas: 2.0.3
- Python version: 3.11.5
- Operating System: OSX
- Install method (conda, pip, source): conda + conda-forge for more recent dask
",,https://api.github.com/repos/dask/dask/issues/10655/timeline,,,mfenner1,913036,MDQ6VXNlcjkxMzAzNg==,https://avatars.githubusercontent.com/u/913036?v=4,,https://api.github.com/users/mfenner1,https://github.com/mfenner1,https://api.github.com/users/mfenner1/followers,https://api.github.com/users/mfenner1/following{/other_user},https://api.github.com/users/mfenner1/gists{/gist_id},https://api.github.com/users/mfenner1/starred{/owner}{/repo},https://api.github.com/users/mfenner1/subscriptions,https://api.github.com/users/mfenner1/orgs,https://api.github.com/users/mfenner1/repos,https://api.github.com/users/mfenner1/events{/privacy},https://api.github.com/users/mfenner1/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10655/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
964,https://api.github.com/repos/dask/dask/issues/10659,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10659/labels{/name},https://api.github.com/repos/dask/dask/issues/10659/comments,https://api.github.com/repos/dask/dask/issues/10659/events,https://github.com/dask/dask/issues/10659,2018419293,I_kwDOAbcwm854TqJd,10659,ValueError: Categorical categories cannot be null when reading parquet file with no category,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-11-30T11:15:33Z,2023-11-30T11:15:46Z,,NONE,,"**Describe the issue**:
When reading a parquet file (engine: pyarrow) that contains a categorical column where all values are null, dask throws a ""ValueError: Categorical categories cannot be null"". Pandas also doesn't do great, transforming the column into dtype: object.

For me it happens when a partition doesn't contain a single category but only null values. But below is a smaller example.

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import pandas as pd

file = ""data.parquet""

df = pd.DataFrame({""A"": [None, None, None]})
df[""A""] = df[""A""].astype(""category"")
print(""Pandas dataframe:"")
print(df)

print(""Dask dataframe:"")
print(dd.from_pandas(df, npartitions=2).compute()) # works just fine

df.to_parquet(file) # or stored with dask, doesn't matter

print(""Read with pandas:"")
df = pd.read_parquet(file)
print(df[""A""]) #dtype: object

print(""Read with dask:"")
df = dd.read_parquet(file)
print(df)
print(df.compute()) # Throws ValueError
```

The error:
```
Traceback (most recent call last):
  File ""C:\Users\trgmg\main.py"", line 23, in <module>
    print(df.compute())
  File ""C:\Users\...\lib\site-packages\dask\base.py"", line 342, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""C:\Users\...\lib\site-packages\dask\base.py"", line 628, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""C:\Users\...\lib\site-packages\dask\dataframe\io\parquet\core.py"", line 96, in __call__
    return read_parquet_part(
  File ""C:\Users\...\lib\site-packages\dask\dataframe\io\parquet\core.py"", line 659, in read_parquet_part
    dfs = [
  File ""C:\Users\...\lib\site-packages\dask\dataframe\io\parquet\core.py"", line 660, in <listcomp>
    func(
  File ""C:\Users\...\lib\site-packages\dask\dataframe\io\parquet\arrow.py"", line 645, in read_partition
    df = cls._arrow_table_to_pandas(
  File ""C:\Users\...\lib\site-packages\dask\dataframe\io\parquet\arrow.py"", line 1851, in _arrow_table_to_pandas
    res = arrow_table.to_pandas(categories=categories, **_kwargs)
  File ""pyarrow\array.pxi"", line 867, in pyarrow.lib._PandasConvertible.to_pandas
  File ""pyarrow\table.pxi"", line 4085, in pyarrow.lib.Table._to_pandas
  File ""C:\Users\...\lib\site-packages\pyarrow\pandas_compat.py"", line 772, in table_to_blockmanager
    blocks = _table_to_blocks(options, table, categories, ext_columns_dtypes)
  File ""C:\Users\...\lib\site-packages\pyarrow\pandas_compat.py"", line 1122, in _table_to_blocks
    return [_reconstruct_block(item, columns, extension_columns)
  File ""C:\Users\...\lib\site-packages\pyarrow\pandas_compat.py"", line 1122, in <listcomp>
    return [_reconstruct_block(item, columns, extension_columns)
  File ""C:\Users\...\lib\site-packages\pyarrow\pandas_compat.py"", line 712, in _reconstruct_block
    cat = _pandas_api.categorical_type.from_codes(
  File ""C:\Users\...\lib\site-packages\pandas\core\dtypes\dtypes.py"", line 567, in validate_categories
    raise ValueError(""Categorical categories cannot be null"")
ValueError: Categorical categories cannot be null
```

**Anything else we need to know?** :)

**Environment**:

- Dask version: 2023.9.3
- Python version: Python 3.10.13
- Operating System: Windows 10
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10659/timeline,,,trgmg,142340341,U_kgDOCHvw9Q,https://avatars.githubusercontent.com/u/142340341?v=4,,https://api.github.com/users/trgmg,https://github.com/trgmg,https://api.github.com/users/trgmg/followers,https://api.github.com/users/trgmg/following{/other_user},https://api.github.com/users/trgmg/gists{/gist_id},https://api.github.com/users/trgmg/starred{/owner}{/repo},https://api.github.com/users/trgmg/subscriptions,https://api.github.com/users/trgmg/orgs,https://api.github.com/users/trgmg/repos,https://api.github.com/users/trgmg/events{/privacy},https://api.github.com/users/trgmg/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10659/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
965,https://api.github.com/repos/dask/dask/issues/10663,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10663/labels{/name},https://api.github.com/repos/dask/dask/issues/10663/comments,https://api.github.com/repos/dask/dask/issues/10663/events,https://github.com/dask/dask/pull/10663,2021286721,PR_kwDOAbcwm85g66xs,10663,Run upstream CI build on Python 3.12,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,0,2023-12-01T17:17:25Z,2023-12-01T17:17:38Z,,MEMBER,,So everything (including Python) is on the latest and greatest version ,,https://api.github.com/repos/dask/dask/issues/10663/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10663/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10663,https://github.com/dask/dask/pull/10663,https://github.com/dask/dask/pull/10663.diff,https://github.com/dask/dask/pull/10663.patch,,,,,,,,,,,,,,,,,,,
966,https://api.github.com/repos/dask/dask/issues/10665,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10665/labels{/name},https://api.github.com/repos/dask/dask/issues/10665/comments,https://api.github.com/repos/dask/dask/issues/10665/events,https://github.com/dask/dask/pull/10665,2023574956,PR_kwDOAbcwm85hCgBd,10665,Fix `dask.array.fft` mismatch with Numpy's interface (add support for `norm` argument),"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,3,2023-12-04T10:54:38Z,2024-06-06T07:31:32Z,,CONTRIBUTOR,,"- Closes  #3280 where `norm` argument was needed to match numpy.fft API. 
- Adds tests to validate that the different values for `norm` match NumPy's.
- Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10665/timeline,,,joanrue,13551804,MDQ6VXNlcjEzNTUxODA0,https://avatars.githubusercontent.com/u/13551804?v=4,,https://api.github.com/users/joanrue,https://github.com/joanrue,https://api.github.com/users/joanrue/followers,https://api.github.com/users/joanrue/following{/other_user},https://api.github.com/users/joanrue/gists{/gist_id},https://api.github.com/users/joanrue/starred{/owner}{/repo},https://api.github.com/users/joanrue/subscriptions,https://api.github.com/users/joanrue/orgs,https://api.github.com/users/joanrue/repos,https://api.github.com/users/joanrue/events{/privacy},https://api.github.com/users/joanrue/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10665/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10665,https://github.com/dask/dask/pull/10665,https://github.com/dask/dask/pull/10665.diff,https://github.com/dask/dask/pull/10665.patch,,,,,,,,,,,,,,,,,,,
967,https://api.github.com/repos/dask/dask/issues/10672,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10672/labels{/name},https://api.github.com/repos/dask/dask/issues/10672/comments,https://api.github.com/repos/dask/dask/issues/10672/events,https://github.com/dask/dask/issues/10672,2026834343,I_kwDOAbcwm854zwmn,10672,CI Failing on windows 3.11,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,"[{'login': 'charlesbluca', 'id': 20627856, 'node_id': 'MDQ6VXNlcjIwNjI3ODU2', 'avatar_url': 'https://avatars.githubusercontent.com/u/20627856?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/charlesbluca', 'html_url': 'https://github.com/charlesbluca', 'followers_url': 'https://api.github.com/users/charlesbluca/followers', 'following_url': 'https://api.github.com/users/charlesbluca/following{/other_user}', 'gists_url': 'https://api.github.com/users/charlesbluca/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/charlesbluca/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/charlesbluca/subscriptions', 'organizations_url': 'https://api.github.com/users/charlesbluca/orgs', 'repos_url': 'https://api.github.com/users/charlesbluca/repos', 'events_url': 'https://api.github.com/users/charlesbluca/events{/privacy}', 'received_events_url': 'https://api.github.com/users/charlesbluca/received_events', 'type': 'User', 'site_admin': False}]",,9,2023-12-05T18:07:38Z,2023-12-18T16:10:07Z,,MEMBER,,"https://github.com/dask/dask/actions/runs/7094083759/job/19308695802?pr=10669

```python
____________________________ test_setitem_hardmask ____________________________
[gw0] win32 -- Python 3.11.6 C:\Miniconda3\envs\test-environment\python.exe

    @pytest.mark.xfail(
        sys.platform == ""win32"" and PY_VERSION >= Version(""3.12.0""),
        reason=""https://github.com/dask/dask/issues/10604"",
    )
    def test_setitem_hardmask():
        x = np.ma.array([1, 2, 3, 4], dtype=int)
        x.harden_mask()
    
        y = x.copy()
        assert y.hardmask
    
        x[0] = np.ma.masked
        x[0:2] = np.ma.masked
    
        dx = da.from_array(y)
        dx[0] = np.ma.masked
        dx[0:2] = np.ma.masked
    
>       assert_eq(x, dx)

dask\array\tests\test_array_core.py:3934: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
dask\array\utils.py:315: in assert_eq
    b, bdt, b_meta, b_computed = _get_dt_meta_computed(
dask\array\utils.py:262: in _get_dt_meta_computed
    _check_dsk(x.dask)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsk = HighLevelGraph with 3 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x25500b1fad0>
 0. array-77780c9fdd36e1630360e1a58a2f798c
 1. setitem-3b3740c2d6f44f9f55717df19bf08928
 2. setitem-1fd1e642f60c88ef4752333bec2c3e00


    def _check_dsk(dsk):
        """"""Check that graph is well named and non-overlapping""""""
        if not isinstance(dsk, HighLevelGraph):
            return
    
        dsk.validate()
        assert all(isinstance(k, (tuple, str)) for k in dsk.layers)
        freqs = frequencies(concat(dsk.layers.values()))
        non_one = {k: v for k, v in freqs.items() if v != 1}
>       assert not non_one, non_one
E       AssertionError: {('array-ca2bfc119ac07031ee36eb791623951f',): 2}
E       assert not {('array-ca2bfc119ac07031ee36eb791623951f',): 2}

dask\array\utils.py:213: AssertionError
_____________________________ test_describe_empty _____________________________
[gw2] win32 -- Python 3.11.6 C:\Miniconda3\envs\test-environment\python.exe

    def test_describe_empty():
        df_none = pd.DataFrame({""A"": [None, None]})
        ddf_none = dd.from_pandas(df_none, 2)
        df_len0 = pd.DataFrame({""A"": [], ""B"": []})
        ddf_len0 = dd.from_pandas(df_len0, 2)
        ddf_nocols = dd.from_pandas(pd.DataFrame({}), 2)
    
        # Pandas have different dtypes for resulting describe dataframe if there are only
        # None-values, pre-compute dask df to bypass _meta check
        assert_eq(
            df_none.describe(), ddf_none.describe(percentiles_method=""dask"").compute()
        )
    
>       with pytest.warns(RuntimeWarning):
E       Failed: DID NOT WARN. No warnings of type (<class 'RuntimeWarning'>,) were emitted.
E       The list of emitted warnings is: [].

dask\dataframe\tests\test_dataframe.py:607: Failed
```",,https://api.github.com/repos/dask/dask/issues/10672/timeline,,,mrocklin,306380,MDQ6VXNlcjMwNjM4MA==,https://avatars.githubusercontent.com/u/306380?v=4,,https://api.github.com/users/mrocklin,https://github.com/mrocklin,https://api.github.com/users/mrocklin/followers,https://api.github.com/users/mrocklin/following{/other_user},https://api.github.com/users/mrocklin/gists{/gist_id},https://api.github.com/users/mrocklin/starred{/owner}{/repo},https://api.github.com/users/mrocklin/subscriptions,https://api.github.com/users/mrocklin/orgs,https://api.github.com/users/mrocklin/repos,https://api.github.com/users/mrocklin/events{/privacy},https://api.github.com/users/mrocklin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10672/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,charlesbluca,20627856.0,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False
968,https://api.github.com/repos/dask/dask/issues/10677,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10677/labels{/name},https://api.github.com/repos/dask/dask/issues/10677/comments,https://api.github.com/repos/dask/dask/issues/10677/events,https://github.com/dask/dask/pull/10677,2028267310,PR_kwDOAbcwm85hSgb7,10677,Python bool meta always `numpy.bool_`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,0,2023-12-06T10:50:21Z,2023-12-18T14:40:07Z,,MEMBER,,"we're doing the same thing for floats and integers so bool should not be different


xref https://github.com/dask-contrib/dask-expr/pull/477",,https://api.github.com/repos/dask/dask/issues/10677/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10677/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10677,https://github.com/dask/dask/pull/10677,https://github.com/dask/dask/pull/10677.diff,https://github.com/dask/dask/pull/10677.patch,,,,,,,,,,,,,,,,,,,
969,https://api.github.com/repos/dask/dask/issues/10683,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10683/labels{/name},https://api.github.com/repos/dask/dask/issues/10683/comments,https://api.github.com/repos/dask/dask/issues/10683/events,https://github.com/dask/dask/issues/10683,2032964007,I_kwDOAbcwm855LJGn,10683,Unexpected Results Caused by BigInt ID in numpy linspace,"[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}]",open,False,,[],,1,2023-12-08T16:22:09Z,2023-12-12T11:55:11Z,,NONE,,"https://github.com/dask/dask/blob/191d39177009d2cce25b818878118e35329b6db3/dask/dataframe/io/sql.py#L171-L172

There is an issue with the **np.linspace** function when the values of **maxi** and **mini** are too large (for example, 23849864652850694). It returns an unexpected value, which causes the SQL conditions to be incorrect.


Please check the example below
```
# Please use this code in the terminal to see the result
import numpy as np

np.linspace(23849864652850694, 23849864652850694, 2, dtype=np.int64).tolist()
# expected [23849864652850694, 23849864652850694]
# result   [23849864652850696, 23849864652850696]
```",,https://api.github.com/repos/dask/dask/issues/10683/timeline,,,hungtn1297,56312980,MDQ6VXNlcjU2MzEyOTgw,https://avatars.githubusercontent.com/u/56312980?v=4,,https://api.github.com/users/hungtn1297,https://github.com/hungtn1297,https://api.github.com/users/hungtn1297/followers,https://api.github.com/users/hungtn1297/following{/other_user},https://api.github.com/users/hungtn1297/gists{/gist_id},https://api.github.com/users/hungtn1297/starred{/owner}{/repo},https://api.github.com/users/hungtn1297/subscriptions,https://api.github.com/users/hungtn1297/orgs,https://api.github.com/users/hungtn1297/repos,https://api.github.com/users/hungtn1297/events{/privacy},https://api.github.com/users/hungtn1297/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10683/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
970,https://api.github.com/repos/dask/dask/issues/10686,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10686/labels{/name},https://api.github.com/repos/dask/dask/issues/10686/comments,https://api.github.com/repos/dask/dask/issues/10686/events,https://github.com/dask/dask/pull/10686,2035547306,PR_kwDOAbcwm85hrNxy,10686,Document the behavior of converting a Dask array to a Python number,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,3,2023-12-11T12:15:24Z,2024-01-17T15:00:38Z,,CONTRIBUTOR,,"Document the behavior when converting Dask arrays to Python numbers (bool/int/float/complex): https://dask--10686.org.readthedocs.build/en/10686/array-api.html#array

I noticed that there was some discussion on whether or not this is a desirable feature in #9387, but I thought it would be useful to document it anyway as this will help to avoid confusion.

For us, this feature is quite useful because it allows us to write e.g.
```python
if a.any():
    do_something()
```
and that will work regardless of whether `a` is a numpy or a Dask array.


- [ ] Closes #xxxx
- [ ] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10686/timeline,,,bouweandela,5430937,MDQ6VXNlcjU0MzA5Mzc=,https://avatars.githubusercontent.com/u/5430937?v=4,,https://api.github.com/users/bouweandela,https://github.com/bouweandela,https://api.github.com/users/bouweandela/followers,https://api.github.com/users/bouweandela/following{/other_user},https://api.github.com/users/bouweandela/gists{/gist_id},https://api.github.com/users/bouweandela/starred{/owner}{/repo},https://api.github.com/users/bouweandela/subscriptions,https://api.github.com/users/bouweandela/orgs,https://api.github.com/users/bouweandela/repos,https://api.github.com/users/bouweandela/events{/privacy},https://api.github.com/users/bouweandela/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10686/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10686,https://github.com/dask/dask/pull/10686,https://github.com/dask/dask/pull/10686.diff,https://github.com/dask/dask/pull/10686.patch,,,,,,,,,,,,,,,,,,,
971,https://api.github.com/repos/dask/dask/issues/10703,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10703/labels{/name},https://api.github.com/repos/dask/dask/issues/10703/comments,https://api.github.com/repos/dask/dask/issues/10703/events,https://github.com/dask/dask/issues/10703,2041220033,I_kwDOAbcwm855qovB,10703,linalg.solve has unexpected TypeError with cupy,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,3,2023-12-14T08:44:44Z,2023-12-15T11:42:58Z,,NONE,,"While running 

    z = da.linalg.solve(Om, D).compute()

I got the following error:

  python3.10/site-packages/dask/base.py"", line 342, in compute
    (result,) = compute(self, traverse=False, **kwargs)
 /dask/base.py"", line 628, in compute
    results = schedule(dsk, keys, **kwargs)
  /dask/array/routines.py"", line 269, in _tensordot
    x = tensordot(a, b, axes=axes)
  /cupy/linalg/_product.py"", line 333, in tensordot
    return _core.tensordot_core(a, b, None, n, m, k, ret_shape)
TypeError: Argument 'a' has incorrect type (expected cupy._core.core._ndarray_base, got numpy.ndarray)

Checking for errors I ran:        
            
            print('Shape Om',Om)
            print(""Shape D"", D)
            print('Chunks Om',Om.chunks)
            z = da.linalg.solve(Om, D).compute()

Chunksizes and Types match the requirements for running linalg.solve as cupy:

Shape Om dask.array<setitem, shape=(22000, 22000), dtype=float64, chunksize=(2000, 2000), chunktype=cupy.ndarray>
Shape D dask.array<setitem, shape=(22000,), dtype=float64, chunksize=(22000,), chunktype=cupy.ndarray>
Chunks Om ((2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000), (2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000))

**Environment**:
rapids-23.12
- Dask version:2 023.11.0
- Python version: python3.10
- Operating System: WSL2
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/10703/timeline,,,Michaw1985,88505452,MDQ6VXNlcjg4NTA1NDUy,https://avatars.githubusercontent.com/u/88505452?v=4,,https://api.github.com/users/Michaw1985,https://github.com/Michaw1985,https://api.github.com/users/Michaw1985/followers,https://api.github.com/users/Michaw1985/following{/other_user},https://api.github.com/users/Michaw1985/gists{/gist_id},https://api.github.com/users/Michaw1985/starred{/owner}{/repo},https://api.github.com/users/Michaw1985/subscriptions,https://api.github.com/users/Michaw1985/orgs,https://api.github.com/users/Michaw1985/repos,https://api.github.com/users/Michaw1985/events{/privacy},https://api.github.com/users/Michaw1985/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10703/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
972,https://api.github.com/repos/dask/dask/issues/10707,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10707/labels{/name},https://api.github.com/repos/dask/dask/issues/10707/comments,https://api.github.com/repos/dask/dask/issues/10707/events,https://github.com/dask/dask/issues/10707,2042282607,I_kwDOAbcwm855usJv,10707,Applying `functools.partial()` to a `@delayed`-decorated function changes the execution behavior,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-12-14T18:50:29Z,2024-02-24T19:30:01Z,,CONTRIBUTOR,,"**Describe the issue**:

Applying `functools.partial()` to a `@dask.delayed`-decorated function can change a workflow's behavior in various circumstances, particularly when passing `@dask.delayed`-decorated functions as arguments to other `@dask.delayed`-decorated functions. I have been observing a lot of bizarre behavior, and I've provided one simple example below. One would expect `partial()` to not change the functionality. Everything works as-expected without `functools.partial`.

**Minimal Complete Verifiable Example**:

Note: I know there are arguably ""better"" ways to accomplish the example below. It is simply a means of displaying a change in behavior.

```python
from functools import partial
from dask.distributed import Client
from dask import delayed

client = Client()

@delayed
def increment(x, verbose=False):
    if verbose:
        print(""I <3 Dask"")
    return x + 1

@delayed
def runner(x, op):
    vals = [x] * 3
    results = []
    for val in vals:
        result = op(val)
        results.append(result)
    return results

runner(1,increment).compute() # returns [2, 2, 2]
runner(1,partial(increment, verbose=True)).compute() # returns List[Delayed]
```

In general, one would expect `functools.partial()` to only influence the args or kwargs to the underlying function, without changing the execution behavior or anything else about the workflow.

**Anything else we need to know?**:

I imagine this has to do, at least in part, with `isinstance()` checks on the `partial`, which isn't a `Delayed` object until the arguments have been supplied.

The following is a way to use `functools.partial` without changing behavior now that #10695 was merged since you're basically stripping off the original `@delayed` decorator to re-add it later, but this is clunky, and I'd argue the behavior of `functools.partial()` is still not as expected.

```python
runner(1,delayed(partial(increment.__wrapped__, verbose=True))).compute()
```

**Environment**:

- Dask version: 2023.12.0
- Python version: 3.11+
- Operating System: Linux
- Install method (conda, pip, source): Pip
",,https://api.github.com/repos/dask/dask/issues/10707/timeline,,,Andrew-S-Rosen,8674072,MDQ6VXNlcjg2NzQwNzI=,https://avatars.githubusercontent.com/u/8674072?v=4,,https://api.github.com/users/Andrew-S-Rosen,https://github.com/Andrew-S-Rosen,https://api.github.com/users/Andrew-S-Rosen/followers,https://api.github.com/users/Andrew-S-Rosen/following{/other_user},https://api.github.com/users/Andrew-S-Rosen/gists{/gist_id},https://api.github.com/users/Andrew-S-Rosen/starred{/owner}{/repo},https://api.github.com/users/Andrew-S-Rosen/subscriptions,https://api.github.com/users/Andrew-S-Rosen/orgs,https://api.github.com/users/Andrew-S-Rosen/repos,https://api.github.com/users/Andrew-S-Rosen/events{/privacy},https://api.github.com/users/Andrew-S-Rosen/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10707/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
973,https://api.github.com/repos/dask/dask/issues/10713,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10713/labels{/name},https://api.github.com/repos/dask/dask/issues/10713/comments,https://api.github.com/repos/dask/dask/issues/10713/events,https://github.com/dask/dask/issues/10713,2044308922,I_kwDOAbcwm8552a26,10713,"`read_parquet` doesn't handle nested objects (dicts, arrays)","[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2023-12-15T20:05:31Z,2023-12-15T20:36:02Z,,NONE,,"Instead of a nested object (e.g. `dict` or `list`) I get a string, which although looks slightly like JSON, isn't valid for `json.loads` (it's probably result of calling `str(...)` on some object).
Unfortunately, many real-life parquet files use nested objects for some columns. One such toy example is public blockchain data: https://github.com/aws-solutions-library-samples/guidance-for-digital-assets-on-aws/blob/main/analytics/consumer/schema/btc.md#table-transactions (`transactions.inputs` is an array of dicts)

For example Spark supports such nested objects: https://stackoverflow.com/questions/29948789/how-to-parse-nested-json-objects-in-spark-sql, Google BigQuery as well",,https://api.github.com/repos/dask/dask/issues/10713/timeline,,,iirekm,789523,MDQ6VXNlcjc4OTUyMw==,https://avatars.githubusercontent.com/u/789523?v=4,,https://api.github.com/users/iirekm,https://github.com/iirekm,https://api.github.com/users/iirekm/followers,https://api.github.com/users/iirekm/following{/other_user},https://api.github.com/users/iirekm/gists{/gist_id},https://api.github.com/users/iirekm/starred{/owner}{/repo},https://api.github.com/users/iirekm/subscriptions,https://api.github.com/users/iirekm/orgs,https://api.github.com/users/iirekm/repos,https://api.github.com/users/iirekm/events{/privacy},https://api.github.com/users/iirekm/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10713/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
974,https://api.github.com/repos/dask/dask/issues/10717,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10717/labels{/name},https://api.github.com/repos/dask/dask/issues/10717/comments,https://api.github.com/repos/dask/dask/issues/10717/events,https://github.com/dask/dask/issues/10717,2047264929,I_kwDOAbcwm856Bsih,10717,Docs page for dask.dataframe.to_parquet doesn't include None option for compression param,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-12-18T19:00:05Z,2023-12-18T19:00:18Z,,NONE,,"**Describe the issue**: Not really a bug, just wanted to report that the documentation doesn't mention that `None` is also an option for `compression` when running `dask.dataframe.to_parquet`.

**Minimal Complete Verifiable Example**:
Assuming `Table` is a Dask dataframe, the code snippet below generates uncompressed Parquet files when the `SNAPPY_COMPRESSION` env var is `False`:

```python
Table.to_parquet(
    path = dir,
    compression = 'snappy' if SNAPPY_COMPRESSION else None,
    write_index = False,
    overwrite = True,
    partition_on = partition_cols)
```

**Anything else we need to know?**:
Docs page: https://docs.dask.org/en/stable/generated/dask.dataframe.to_parquet.html#dask.dataframe.to_parquet

**Environment**:

- Dask version: 2023.12.0
- Python version: 3.11
- Operating System: Docker image: public.ecr.aws/lambda/python:3.11.2023.12.06.11
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10717/timeline,,,bascheibler,18239335,MDQ6VXNlcjE4MjM5MzM1,https://avatars.githubusercontent.com/u/18239335?v=4,,https://api.github.com/users/bascheibler,https://github.com/bascheibler,https://api.github.com/users/bascheibler/followers,https://api.github.com/users/bascheibler/following{/other_user},https://api.github.com/users/bascheibler/gists{/gist_id},https://api.github.com/users/bascheibler/starred{/owner}{/repo},https://api.github.com/users/bascheibler/subscriptions,https://api.github.com/users/bascheibler/orgs,https://api.github.com/users/bascheibler/repos,https://api.github.com/users/bascheibler/events{/privacy},https://api.github.com/users/bascheibler/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10717/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
975,https://api.github.com/repos/dask/dask/issues/10720,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10720/labels{/name},https://api.github.com/repos/dask/dask/issues/10720/comments,https://api.github.com/repos/dask/dask/issues/10720/events,https://github.com/dask/dask/pull/10720,2048250071,PR_kwDOAbcwm85iWQ06,10720,bump approx threshold for test_quantile,[],open,False,,[],,0,2023-12-19T09:21:51Z,2023-12-19T10:59:05Z,,MEMBER,,"This failed on main, see https://github.com/dask/dask/actions/runs/7250252918/job/19750018247

```
E       assert 0.3946495992341462 == 0.35667494393873245  3.6e-02
E         comparison failed
E         Obtained: 0.3946495992341462
E         Expected: 0.35667494393873245  3.6e-02
```

The 10% threshold is at `0.39234243833260574` so very close. I think we can be more forgiving here.",,https://api.github.com/repos/dask/dask/issues/10720/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10720/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10720,https://github.com/dask/dask/pull/10720,https://github.com/dask/dask/pull/10720.diff,https://github.com/dask/dask/pull/10720.patch,,,,,,,,,,,,,,,,,,,
976,https://api.github.com/repos/dask/dask/issues/10721,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10721/labels{/name},https://api.github.com/repos/dask/dask/issues/10721/comments,https://api.github.com/repos/dask/dask/issues/10721/events,https://github.com/dask/dask/issues/10721,2048254802,I_kwDOAbcwm856FeNS,10721,`test_split_adaptive_aggregate_files` failing on main,"[{'id': 1887344368, 'node_id': 'MDU6TGFiZWwxODg3MzQ0MzY4', 'url': 'https://api.github.com/repos/dask/dask/labels/tests', 'name': 'tests', 'color': 'a0f9b4', 'default': False, 'description': 'Unit tests and/or continuous integration'}]",open,False,,[],,4,2023-12-19T09:24:43Z,2023-12-20T14:36:36Z,,MEMBER,,"I only saw this pop up once so far but the `test_split_adaptive_aggregate_files` was failing on main


https://github.com/dask/dask/actions/runs/7226871563/job/19693365591


```python-traceback
        ddf1.to_parquet(
            str(tmpdir),
            engine=write_engine,
            partition_on=partition_on,
            write_index=False,
        )
        with pytest.warns(FutureWarning, match=""Behavior may change""):
            ddf2 = dd.read_parquet(
                str(tmpdir),
                engine=read_engine,
                blocksize=blocksize,
                split_row_groups=""adaptive"",
                aggregate_files=aggregate_files,
            )
    
        # Check that files where aggregated as expected
        if aggregate_files == ""a"":
            assert ddf2.npartitions == 3
        elif aggregate_files == ""b"":
            assert ddf2.npartitions == 6
    
        # Check that the final data is correct
        df2 = ddf2.compute().sort_values([""c"", ""d""])
        df1 = df1.sort_values([""c"", ""d""])
>       assert_eq(df1[[""c"", ""d""]], df2[[""c"", ""d""]], check_index=False)

dask\dataframe\io\tests\test_parquet.py:3134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

a =            c   d
0   0.001898  15
1   0.007386  30
2   0.028712  14
3   0.038563  44
4   0.044161   6
..       ...  ..
95  0.948483  83
96  0.959911  49
97  0.970251  32
98  0.995297  82
99  0.999792  65

[100 rows x 2 columns]
b =            c   d
0   0.007386  30
1   0.044161   6
2   0.049735  76
3   0.083297  57
4   0.095994  47
..       ...  ..
92  0.940960  97
93  0.948483  83
94  0.959911  49
95  0.995297  82
96  0.999792  65

[97 rows x 2 columns]
check_names = True, check_dtype = True, check_divisions = True
check_index = False, sort_results = True, scheduler = 'sync', kwargs = {}

    def assert_eq(
        a,
        b,
        check_names=True,
        check_dtype=True,
        check_divisions=True,
        check_index=True,
        sort_results=True,
        scheduler=""sync"",
        **kwargs,
    ):
        if check_divisions:
            assert_divisions(a, scheduler=scheduler)
            assert_divisions(b, scheduler=scheduler)
            if hasattr(a, ""divisions"") and hasattr(b, ""divisions""):
                at = type(np.asarray(a.divisions).tolist()[0])  # numpy to python
                bt = type(np.asarray(b.divisions).tolist()[0])  # scalar conversion
                assert at == bt, (at, bt)
        assert_sane_keynames(a)
        assert_sane_keynames(b)
        a = _check_dask(
            a, check_names=check_names, check_dtypes=check_dtype, scheduler=scheduler
        )
        b = _check_dask(
            b, check_names=check_names, check_dtypes=check_dtype, scheduler=scheduler
        )
        if hasattr(a, ""to_pandas""):
            a = a.to_pandas()
        if hasattr(b, ""to_pandas""):
            b = b.to_pandas()
    
        a, b = _maybe_convert_string(a, b)
    
        if isinstance(a, (pd.DataFrame, pd.Series)) and sort_results:
            a = _maybe_sort(a, check_index)
            b = _maybe_sort(b, check_index)
        if not check_index:
            a = a.reset_index(drop=True)
            b = b.reset_index(drop=True)
        if isinstance(a, pd.DataFrame):
>           tm.assert_frame_equal(
                a, b, check_names=check_names, check_dtype=check_dtype, **kwargs
E               AssertionError: DataFrame are different
E               
E               DataFrame shape mismatch
E               [left]:  (100, 2)
E               [right]: (97, 2)
```

I find this failure particularly concerning since this looks like data loss is possible even if it doesn't happen reliably. @rjzamora do you have time to poke at this?",,https://api.github.com/repos/dask/dask/issues/10721/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10721/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
977,https://api.github.com/repos/dask/dask/issues/10722,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10722/labels{/name},https://api.github.com/repos/dask/dask/issues/10722/comments,https://api.github.com/repos/dask/dask/issues/10722/events,https://github.com/dask/dask/pull/10722,2048418456,PR_kwDOAbcwm85iW1vq,10722,ensure drop_duplicates with keep is stable,[],open,False,,[],,5,2023-12-19T10:59:53Z,2023-12-19T16:38:13Z,,MEMBER,,"Closes https://github.com/dask/dask/issues/10708

cc @rjzamora",,https://api.github.com/repos/dask/dask/issues/10722/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10722/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10722,https://github.com/dask/dask/pull/10722,https://github.com/dask/dask/pull/10722.diff,https://github.com/dask/dask/pull/10722.patch,,,,,,,,,,,,,,,,,,,
978,https://api.github.com/repos/dask/dask/issues/10731,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10731/labels{/name},https://api.github.com/repos/dask/dask/issues/10731/comments,https://api.github.com/repos/dask/dask/issues/10731/events,https://github.com/dask/dask/issues/10731,2050351032,I_kwDOAbcwm856Nd-4,10731,Boolean logic with shift seems broken,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2023-12-20T11:18:38Z,2023-12-20T11:18:52Z,,CONTRIBUTOR,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

Using boolean logic on a shifted Series gives wrong results.

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import pandas as pd
import dask
import numpy as np

dask.config.set({""dataframe.convert-string"": False})

ser = pd.Series(2 * [False] + 1 * [True] + 2 * [False])
ser = dd.from_pandas(ser, npartitions=2)

s1 = ser.shift(1).fillna(False).astype(bool)
s2 = ser.shift(-1).fillna(False).astype(bool)

(s1 | s2).compute()  # [False, False, False, False, False]
(s1.compute() | s2.compute())  # [False, True, False, True, False]  - Correct result
np.logical_or(s1, s2).compute  # [NaN, NaN, NaN, False, False]

```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2023.12.1
- Python version: 3.11
- Operating System: Linux
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/10731/timeline,,,hoxbro,19758978,MDQ6VXNlcjE5NzU4OTc4,https://avatars.githubusercontent.com/u/19758978?v=4,,https://api.github.com/users/hoxbro,https://github.com/hoxbro,https://api.github.com/users/hoxbro/followers,https://api.github.com/users/hoxbro/following{/other_user},https://api.github.com/users/hoxbro/gists{/gist_id},https://api.github.com/users/hoxbro/starred{/owner}{/repo},https://api.github.com/users/hoxbro/subscriptions,https://api.github.com/users/hoxbro/orgs,https://api.github.com/users/hoxbro/repos,https://api.github.com/users/hoxbro/events{/privacy},https://api.github.com/users/hoxbro/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10731/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
979,https://api.github.com/repos/dask/dask/issues/10733,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10733/labels{/name},https://api.github.com/repos/dask/dask/issues/10733/comments,https://api.github.com/repos/dask/dask/issues/10733/events,https://github.com/dask/dask/issues/10733,2051094768,I_kwDOAbcwm856QTjw,10733,Breaking of concurrency when calling `dask.delayed` inside a `@dask.delayed`-decorated function,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,5,2023-12-20T18:45:24Z,2024-01-10T16:12:24Z,,CONTRIBUTOR,,"**Describe the issue**:

While not always advised, there are valid cases where `@dask.delayed` functions can have a call to `dask.delayed` inside of it. I am happy to elaborate on such scenarios (see brief justification below), but if we take that at face value for the moment, there is some undesirable behavior in Dask in terms of breaking concurrency when this scenario does arise.

As a minimal example, the following breaks concurrency between the `add` tasks:

```python
import time
import dask
from dask.distributed import Client

client = Client()

@dask.delayed
def add(x, y):
    print(""Sleeping..."")
    time.sleep(2)
    return x + y

@dask.delayed
def do_math(x, y, op):
    results = []
    for _ in range(4):
        results.append(op(x, y))
    return results

dask.compute(do_math(1, 2, add))
```

I would argue that the behavior of Dask here is at the very least undesirable. Ideally, Dask should recognize that the inner `add` operations are delayed and should not be carried out sequentially.

**Alternate Approaches**:

One could rewrite the above several ways, one of which is as follows:

```python
import time
import dask

def add(x, y):
    print(""Sleeping..."")
    time.sleep(2)
    return x + y

@dask.delayed
def do_math(x, y, op):
    results = []
    for _ in range(4):
        results.append(dask.delayed(op)(x, y))
    return results
```

This does not break concurrency, but it does imply the aforementioned scenario is a bug. The workaround also has several issues that makes it undesirable to rely on:
1. It is clearly much more complicated from a syntax standpoint. The output is also harder to parse.
2. It starts introducing Dask-specific logic within the functions, which is generally undesirable from a philosophical standpoint at least.
3. The high-compute task `add` is no longer decorated, such that this function can't be imported in some other module and be used as a standalone, delayed task (without redecorating).

**Anything else we need to know?**:

This stems from my slightly more complex example described on the [Dask discourse page](https://dask.discourse.group/t/passing-delayed-functions-to-other-delayed-functions/2400/1).

You might be asking ""why would you want to do this in the first place?"" There are many ways to answer that. In short, if `add` is a high-compute task, it needs to be delayed. Additionally, while in this example there is no strict need for `do_math` to be delayed, in a real-world scenario where the logic flow (e.g. the number of iterations in the `for` loop) is not known until runtime, then that function also needs to be delayed. See the [Discourse post](https://dask.discourse.group/t/passing-delayed-functions-to-other-delayed-functions/2400) for an example of that.

**Environment**:

- Dask version: 2023.12.1
- Python version: 3.9-3.12
- Operating System: Linux
- Install method (conda, pip, source): pip",,https://api.github.com/repos/dask/dask/issues/10733/timeline,,,Andrew-S-Rosen,8674072,MDQ6VXNlcjg2NzQwNzI=,https://avatars.githubusercontent.com/u/8674072?v=4,,https://api.github.com/users/Andrew-S-Rosen,https://github.com/Andrew-S-Rosen,https://api.github.com/users/Andrew-S-Rosen/followers,https://api.github.com/users/Andrew-S-Rosen/following{/other_user},https://api.github.com/users/Andrew-S-Rosen/gists{/gist_id},https://api.github.com/users/Andrew-S-Rosen/starred{/owner}{/repo},https://api.github.com/users/Andrew-S-Rosen/subscriptions,https://api.github.com/users/Andrew-S-Rosen/orgs,https://api.github.com/users/Andrew-S-Rosen/repos,https://api.github.com/users/Andrew-S-Rosen/events{/privacy},https://api.github.com/users/Andrew-S-Rosen/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10733/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
980,https://api.github.com/repos/dask/dask/issues/10739,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10739/labels{/name},https://api.github.com/repos/dask/dask/issues/10739/comments,https://api.github.com/repos/dask/dask/issues/10739/events,https://github.com/dask/dask/pull/10739,2054116842,PR_kwDOAbcwm85iqXka,10739,Ensure `map_partitions` returns `Series` object if function returns scalar,[],open,False,,[],,3,2023-12-22T16:00:50Z,2024-01-29T12:09:19Z,,MEMBER,,"- [x] Closes https://github.com/dask-contrib/dask-expr/issues/625
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10739/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10739/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10739,https://github.com/dask/dask/pull/10739,https://github.com/dask/dask/pull/10739.diff,https://github.com/dask/dask/pull/10739.patch,,,,,,,,,,,,,,,,,,,
981,https://api.github.com/repos/dask/dask/issues/10740,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10740/labels{/name},https://api.github.com/repos/dask/dask/issues/10740/comments,https://api.github.com/repos/dask/dask/issues/10740/events,https://github.com/dask/dask/pull/10740,2054510381,PR_kwDOAbcwm85irwgo,10740,Add `dask.array.array_equal`,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3798450414, 'node_id': 'LA_kwDOAbcwm87iZ8Du', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20review', 'name': 'needs review', 'color': '8c918c', 'default': False, 'description': 'Needs review from a contributor.'}, {'id': 3798450420, 'node_id': 'LA_kwDOAbcwm87iZ8D0', 'url': 'https://api.github.com/repos/dask/dask/labels/feature', 'name': 'feature', 'color': 'b0f0fa', 'default': False, 'description': 'Something is missing'}]",open,False,,[],,4,2023-12-22T21:12:11Z,2024-01-30T10:20:57Z,,CONTRIBUTOR,,"Add the function `dask.array.array_equal`.

- [x] Closes a small part of #2911
- [ ] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10740/timeline,,,bouweandela,5430937,MDQ6VXNlcjU0MzA5Mzc=,https://avatars.githubusercontent.com/u/5430937?v=4,,https://api.github.com/users/bouweandela,https://github.com/bouweandela,https://api.github.com/users/bouweandela/followers,https://api.github.com/users/bouweandela/following{/other_user},https://api.github.com/users/bouweandela/gists{/gist_id},https://api.github.com/users/bouweandela/starred{/owner}{/repo},https://api.github.com/users/bouweandela/subscriptions,https://api.github.com/users/bouweandela/orgs,https://api.github.com/users/bouweandela/repos,https://api.github.com/users/bouweandela/events{/privacy},https://api.github.com/users/bouweandela/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10740/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10740,https://github.com/dask/dask/pull/10740,https://github.com/dask/dask/pull/10740.diff,https://github.com/dask/dask/pull/10740.patch,,,,,,,,,,,,,,,,,,,
982,https://api.github.com/repos/dask/dask/issues/10742,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10742/labels{/name},https://api.github.com/repos/dask/dask/issues/10742/comments,https://api.github.com/repos/dask/dask/issues/10742/events,https://github.com/dask/dask/issues/10742,2062773999,I_kwDOAbcwm856827v,10742,DataFrame interchange protocol support,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-01-02T18:11:32Z,2024-01-02T18:11:43Z,,NONE,,"<!-- Please do a quick search of existing issues to make sure that this has not been asked before. -->

Supporting [this protocol](https://data-apis.org/dataframe-protocol/latest/purpose_and_scope.html) allows users to convert any dataframes that support the protocol into Dask dataframes.

As an example, how this is done in pyarrow: https://arrow.apache.org/docs/python/generated/pyarrow.interchange.from_dataframe.html.

I would like to know the following:
* What do you think about it?
* Are there any plans regarding this?

Thank you!",,https://api.github.com/repos/dask/dask/issues/10742/timeline,,,anmyachev,45976948,MDQ6VXNlcjQ1OTc2OTQ4,https://avatars.githubusercontent.com/u/45976948?v=4,,https://api.github.com/users/anmyachev,https://github.com/anmyachev,https://api.github.com/users/anmyachev/followers,https://api.github.com/users/anmyachev/following{/other_user},https://api.github.com/users/anmyachev/gists{/gist_id},https://api.github.com/users/anmyachev/starred{/owner}{/repo},https://api.github.com/users/anmyachev/subscriptions,https://api.github.com/users/anmyachev/orgs,https://api.github.com/users/anmyachev/repos,https://api.github.com/users/anmyachev/events{/privacy},https://api.github.com/users/anmyachev/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10742/reactions,2,2,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
983,https://api.github.com/repos/dask/dask/issues/10761,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10761/labels{/name},https://api.github.com/repos/dask/dask/issues/10761/comments,https://api.github.com/repos/dask/dask/issues/10761/events,https://github.com/dask/dask/issues/10761,2071970101,I_kwDOAbcwm857f8E1,10761,pylint raises no-value-for-the-parameter rule with dask.delayed used as decorator with keyword arguments,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-01-09T09:30:27Z,2024-01-09T09:31:12Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

Hey, I stumbled upon this issue that pylint incorrectly raises for the rule `E1120: No value for argument 'obj' in function call (no-value-for-parameter)` when using dask.delayed as a decorator with some keyword arguments.

**Minimal Complete Verifiable Example**:

requirements.txt
```txt
astroid==3.0.2
click==8.1.7
cloudpickle==3.0.0
dask==2023.5.0
dill==0.3.7
fsspec==2023.12.2
importlib-metadata==7.0.1
isort==5.13.2
locket==1.0.0
mccabe==0.7.0
packaging==23.2
partd==1.4.1
platformdirs==4.1.0
pylint==3.0.3
PyYAML==6.0.1
tomli==2.0.1
tomlkit==0.12.3
toolz==0.12.0
typing_extensions==4.9.0
zipp==3.17.0
```

main.py
```python
import dask

@dask.delayed(pure=False)
def some_fn(a: dict):
    a[""b""] = ""c""
    return a

some_dict = {}
task = some_fn(some_dict)
result = dask.compute(task)

print(result[0])
```

Pylint on main:
```bash
pylint main.py
************* Module main
main.py:1:0: C0114: Missing module docstring (missing-module-docstring)
main.py:4:0: C0116: Missing function or method docstring (missing-function-docstring)
main.py:3:1: E1120: No value for argument 'obj' in function call (no-value-for-parameter)

------------------------------------------------------------------
Your code has been rated at 1.25/10 (previous run: 1.25/10, +0.00)
```

**Environment**:

- Dask version: 2023.5.0
- Python version: 3.8.18
- Operating System: ubuntu 22.04
- Install method (conda, pip, source): pip 
",,https://api.github.com/repos/dask/dask/issues/10761/timeline,,,KsawerySmoczynski,31616749,MDQ6VXNlcjMxNjE2NzQ5,https://avatars.githubusercontent.com/u/31616749?v=4,,https://api.github.com/users/KsawerySmoczynski,https://github.com/KsawerySmoczynski,https://api.github.com/users/KsawerySmoczynski/followers,https://api.github.com/users/KsawerySmoczynski/following{/other_user},https://api.github.com/users/KsawerySmoczynski/gists{/gist_id},https://api.github.com/users/KsawerySmoczynski/starred{/owner}{/repo},https://api.github.com/users/KsawerySmoczynski/subscriptions,https://api.github.com/users/KsawerySmoczynski/orgs,https://api.github.com/users/KsawerySmoczynski/repos,https://api.github.com/users/KsawerySmoczynski/events{/privacy},https://api.github.com/users/KsawerySmoczynski/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10761/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
984,https://api.github.com/repos/dask/dask/issues/10770,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10770/labels{/name},https://api.github.com/repos/dask/dask/issues/10770/comments,https://api.github.com/repos/dask/dask/issues/10770/events,https://github.com/dask/dask/issues/10770,2074439633,I_kwDOAbcwm857pW_R,10770,Remove usage of pandas grouper in groupby,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2024-01-10T14:00:04Z,2024-01-10T17:31:30Z,,MEMBER,,"The method ``_compute_sum_of_squares`` accesses the grouper from pandas which is deprecated with 2.2 and will be removed soonish


This whole method looks odd to me, like it isn't really necessary. Can someone from cudf (@rjzamora maybe?) comment what the cudf comment in this function refers to? Maybe we can get rid of this method altogether?",,https://api.github.com/repos/dask/dask/issues/10770/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10770/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
985,https://api.github.com/repos/dask/dask/issues/10811,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10811/labels{/name},https://api.github.com/repos/dask/dask/issues/10811/comments,https://api.github.com/repos/dask/dask/issues/10811/events,https://github.com/dask/dask/issues/10811,2085681809,I_kwDOAbcwm858UPqR,10811,`dask.array.tensordot` bug: negative values in argument `axes`  give wrong results.,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-01-17T08:37:21Z,2024-01-17T08:37:33Z,,CONTRIBUTOR,,"**Describe the issue**:
While `numpy.tensordot` accepts negative axes, negative axes in `dask.array.tensordot`  give wrong results.

**Minimal Complete Verifiable Example**:

```python
import numpy as np
import dask.array as da

rng = np.random.default_rng()
a = rng.normal(size=(30, 10))
b = rng.normal(size=(10, 20))

kwargs = dict(axes=[[-1], [0]])
np_z = np.tensordot(a, b, **kwargs)
da_z = da.tensordot(da.array(a), da.array(b), **kwargs)
print(np_z.shape) 
# (30, 20) 
print(da_z.shape)
# (30, 1)
```
",,https://api.github.com/repos/dask/dask/issues/10811/timeline,,,joanrue,13551804,MDQ6VXNlcjEzNTUxODA0,https://avatars.githubusercontent.com/u/13551804?v=4,,https://api.github.com/users/joanrue,https://github.com/joanrue,https://api.github.com/users/joanrue/followers,https://api.github.com/users/joanrue/following{/other_user},https://api.github.com/users/joanrue/gists{/gist_id},https://api.github.com/users/joanrue/starred{/owner}{/repo},https://api.github.com/users/joanrue/subscriptions,https://api.github.com/users/joanrue/orgs,https://api.github.com/users/joanrue/repos,https://api.github.com/users/joanrue/events{/privacy},https://api.github.com/users/joanrue/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10811/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
986,https://api.github.com/repos/dask/dask/issues/10812,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10812/labels{/name},https://api.github.com/repos/dask/dask/issues/10812/comments,https://api.github.com/repos/dask/dask/issues/10812/events,https://github.com/dask/dask/pull/10812,2085693576,PR_kwDOAbcwm85kSW6g,10812,`dask.array.tensordot` bugfix: ensure `axes` are positive / add tests for negative axes,[],open,False,,[],,3,2024-01-17T08:44:38Z,2024-06-06T07:31:54Z,,CONTRIBUTOR,," While `numpy.tensordot` accepts negative axes, negative axes in `dask.array.tensordot` were giving wrong results. This bug is easily fixed by ensuring that the left axes are positive before the sum-reduction step. 

- [x] Closes #10811
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

Co-authored-by: Sepand Kashani <sepand@kashani.ch>",,https://api.github.com/repos/dask/dask/issues/10812/timeline,,,joanrue,13551804,MDQ6VXNlcjEzNTUxODA0,https://avatars.githubusercontent.com/u/13551804?v=4,,https://api.github.com/users/joanrue,https://github.com/joanrue,https://api.github.com/users/joanrue/followers,https://api.github.com/users/joanrue/following{/other_user},https://api.github.com/users/joanrue/gists{/gist_id},https://api.github.com/users/joanrue/starred{/owner}{/repo},https://api.github.com/users/joanrue/subscriptions,https://api.github.com/users/joanrue/orgs,https://api.github.com/users/joanrue/repos,https://api.github.com/users/joanrue/events{/privacy},https://api.github.com/users/joanrue/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10812/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10812,https://github.com/dask/dask/pull/10812,https://github.com/dask/dask/pull/10812.diff,https://github.com/dask/dask/pull/10812.patch,,,,,,,,,,,,,,,,,,,
987,https://api.github.com/repos/dask/dask/issues/10816,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10816/labels{/name},https://api.github.com/repos/dask/dask/issues/10816/comments,https://api.github.com/repos/dask/dask/issues/10816/events,https://github.com/dask/dask/issues/10816,2086032496,I_kwDOAbcwm858VlRw,10816,Wrong `string[pyarrow]` dtype after using `unique()` with pyarrow as an engine,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-01-17T11:54:48Z,2024-01-17T11:55:00Z,,NONE,,"**Describe the issue**:

Hey, I think unique() is return the wrong dtype in the following example.

**Minimal Complete Verifiable Example**:
```python
>>> import dask.dataframe as dd
>>> ddf = dd.DataFrame.from_dict({""num1"": [1, 1, 1, 2], ""num2"": [5, 5, 6, 7]}, npartitions=2)
>>> ddf
Dask DataFrame Structure:
                num1   num2
npartitions=2              
0              int64  int64
2                ...    ...
3                ...    ...
Dask Name: from_pandas, 1 graph layer
>>> a = ddf.groupby(""num1"")[""num2""].unique().compute()
>>> a
num1
1    [5 6]
2      [7]
Name: num2, dtype: string
>>> a.dtypes
string[pyarrow]
```

**Anything else we need to know?**:

When I'm using fastparquet as the engine it works as expected and I get a list of integers.

**Environment**:

- Dask version: 2024.1.0
- Python version: 3.10.12
- Operating System: Ubuntu 22.04
- Install method (conda, pip, source): pip
- pyarrow version: 14.0.2
- fastparquet version: 2023.10.1
",,https://api.github.com/repos/dask/dask/issues/10816/timeline,,,piebro,17904272,MDQ6VXNlcjE3OTA0Mjcy,https://avatars.githubusercontent.com/u/17904272?v=4,,https://api.github.com/users/piebro,https://github.com/piebro,https://api.github.com/users/piebro/followers,https://api.github.com/users/piebro/following{/other_user},https://api.github.com/users/piebro/gists{/gist_id},https://api.github.com/users/piebro/starred{/owner}{/repo},https://api.github.com/users/piebro/subscriptions,https://api.github.com/users/piebro/orgs,https://api.github.com/users/piebro/repos,https://api.github.com/users/piebro/events{/privacy},https://api.github.com/users/piebro/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10816/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
988,https://api.github.com/repos/dask/dask/issues/10826,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10826/labels{/name},https://api.github.com/repos/dask/dask/issues/10826/comments,https://api.github.com/repos/dask/dask/issues/10826/events,https://github.com/dask/dask/issues/10826,2088284502,I_kwDOAbcwm858eLFW,10826,_compute_sum_of_squares uses pandas.DataFrame.groupby without `observed`,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2024-01-18T13:24:44Z,2024-01-18T14:40:34Z,,NONE,,"The old default is deprecated

https://github.com/dask/dask/blob/e72f93e4942fbc4cc70170cf1192e3dd0a69275a/dask/dataframe/groupby.py#L1228",,https://api.github.com/repos/dask/dask/issues/10826/timeline,,,flying-sheep,291575,MDQ6VXNlcjI5MTU3NQ==,https://avatars.githubusercontent.com/u/291575?v=4,,https://api.github.com/users/flying-sheep,https://github.com/flying-sheep,https://api.github.com/users/flying-sheep/followers,https://api.github.com/users/flying-sheep/following{/other_user},https://api.github.com/users/flying-sheep/gists{/gist_id},https://api.github.com/users/flying-sheep/starred{/owner}{/repo},https://api.github.com/users/flying-sheep/subscriptions,https://api.github.com/users/flying-sheep/orgs,https://api.github.com/users/flying-sheep/repos,https://api.github.com/users/flying-sheep/events{/privacy},https://api.github.com/users/flying-sheep/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10826/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
989,https://api.github.com/repos/dask/dask/issues/10836,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10836/labels{/name},https://api.github.com/repos/dask/dask/issues/10836/comments,https://api.github.com/repos/dask/dask/issues/10836/events,https://github.com/dask/dask/issues/10836,2090631436,I_kwDOAbcwm858nIEM,10836,`SeriesGroupBy.agg` does not accept `Aggregate`s when passed as kwargs,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450413, 'node_id': 'LA_kwDOAbcwm87iZ8Dt', 'url': 'https://api.github.com/repos/dask/dask/labels/bug', 'name': 'bug', 'color': 'faadaf', 'default': True, 'description': 'Something is broken'}]",open,False,,[],,3,2024-01-19T13:59:46Z,2024-01-23T10:16:22Z,,NONE,,"It uses pandas validation function, which doesnt recognize dasks `Aggregate` class:

https://github.com/dask/dask/blob/99036c42083fa77fe974fc38a58391340566baaa/dask/dataframe/groupby.py#L2279",,https://api.github.com/repos/dask/dask/issues/10836/timeline,,,flying-sheep,291575,MDQ6VXNlcjI5MTU3NQ==,https://avatars.githubusercontent.com/u/291575?v=4,,https://api.github.com/users/flying-sheep,https://github.com/flying-sheep,https://api.github.com/users/flying-sheep/followers,https://api.github.com/users/flying-sheep/following{/other_user},https://api.github.com/users/flying-sheep/gists{/gist_id},https://api.github.com/users/flying-sheep/starred{/owner}{/repo},https://api.github.com/users/flying-sheep/subscriptions,https://api.github.com/users/flying-sheep/orgs,https://api.github.com/users/flying-sheep/repos,https://api.github.com/users/flying-sheep/events{/privacy},https://api.github.com/users/flying-sheep/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10836/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
990,https://api.github.com/repos/dask/dask/issues/10842,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10842/labels{/name},https://api.github.com/repos/dask/dask/issues/10842/comments,https://api.github.com/repos/dask/dask/issues/10842/events,https://github.com/dask/dask/issues/10842,2093423525,I_kwDOAbcwm858xxul,10842,"`make_meta` over a Dask Dataframe returns a reference, not a new object","[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-01-22T09:08:36Z,2024-01-22T09:08:47Z,,NONE,,"**Describe the issue**:

Reading the documentation of [`make_meta`](https://docs.dask.org/en/stable/generated/dask.dataframe.utils.make_meta.html) it states that

> This method creates meta-data based on the type of x

so my understanding is that a new object is returned. However, one can check that when running `make_meta` over a Dask Dataframe a reference to the dataframe meta is returned. Thus, if any change is made to the returned meta, the meta of the Dataframe is modified as well.

**Minimal Complete Verifiable Example**:

```python
import dask.dataframe as dd
import pandas as pd

df = pd.DataFrame({
    ""col1"": [1, 2, 3],
    ""col2"": [4, 5, 6],
})
df = dd.from_pandas(df, npartitions=2)

print(df.columns)  # returns Index(['col1', 'col2'], dtype='object')

from dask.dataframe.utils import make_meta
meta = make_meta(df)
meta[""flag""] = pd.Series([], dtype=""bool"")
print(df.columns)  # returns Index(['col1', 'col2', 'flag'], dtype='object')
```

**Anything else we need to know?**:

In my experience `make_meta` is very useful to obtain the current meta of a Dataframe and then update it with the necessary changes to provide appropriate meta information to methods such as  `map_partitions` or `assign`, so that Dask knows how you intend to change the structure of the Dataframe. But since `make_meta` returns a reference it seems we are forced to make changes to a copy of this meta object, which is inconvenient. Is there any design reason for returning a reference instead of a copy?

**Environment**:

- Dask version: 2024.1.0
- Python version: 3.12.1
- Operating System: Ubuntu 22.04.3 LTS
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10842/timeline,,,albarji,9654655,MDQ6VXNlcjk2NTQ2NTU=,https://avatars.githubusercontent.com/u/9654655?v=4,,https://api.github.com/users/albarji,https://github.com/albarji,https://api.github.com/users/albarji/followers,https://api.github.com/users/albarji/following{/other_user},https://api.github.com/users/albarji/gists{/gist_id},https://api.github.com/users/albarji/starred{/owner}{/repo},https://api.github.com/users/albarji/subscriptions,https://api.github.com/users/albarji/orgs,https://api.github.com/users/albarji/repos,https://api.github.com/users/albarji/events{/privacy},https://api.github.com/users/albarji/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10842/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
991,https://api.github.com/repos/dask/dask/issues/10853,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10853/labels{/name},https://api.github.com/repos/dask/dask/issues/10853/comments,https://api.github.com/repos/dask/dask/issues/10853/events,https://github.com/dask/dask/issues/10853,2095721593,I_kwDOAbcwm8586ix5,10853,SeriesGroupBy.agg does not accept `Aggregate` when paired with `'median'`,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-01-23T10:11:35Z,2024-01-23T10:16:05Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

See title and example code. This is *not* #10836.
That issue can be worked around by using a list instead of `kwargs`, but then I run into this:

**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import dask.dataframe as dd

custom_sum = dd.Aggregation(
    name='custom_sum',
    chunk=lambda s: s.sum(),
    agg=lambda s0: s0.sum()
)

df = pd.DataFrame(dict(a=[1, 1, 1, 1, 1], g=[5, 6, 6, 6, 7]))
ddf = dd.from_pandas(df, npartitions=2)

ddf.groupby('g')['a'].agg([""median""], shuffle=True).compute()  # works
ddf.groupby('g')['a'].agg([custom_sum], shuffle=True).compute()  # works
ddf.groupby('g')['a'].agg([custom_sum, 'median'], shuffle=True).compute()  # broken
```

**Anything else we need to know?**:

<details>
<summary>Traceback</summary>

```pytb
In [4]: ddf.groupby('g')['a'].agg([custom_sum, 'median'], shuffle=True).compute()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/utils.py:194, in raise_on_meta_error(funcname, udf)
    193 try:
--> 194     yield
    195 except Exception as e:

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/core.py:7103, in _emulate(func, udf, *args, **kwargs)
   7102 with raise_on_meta_error(funcname(func), udf=udf), check_numeric_only_deprecation():
-> 7103     return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/groupby.py:439, in _groupby_aggregate_spec(df, spec, levels, dropna, sort, observed, **kwargs)
    438 observed = {""observed"": observed} if observed is not None else {}
--> 439 return df.groupby(level=levels, sort=sort, **observed, **dropna).aggregate(
    440     spec, **kwargs
    441 )

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py:1445, in DataFrameGroupBy.aggregate(self, func, engine, engine_kwargs, *args, **kwargs)
   1444 op = GroupByApply(self, func, args=args, kwargs=kwargs)
-> 1445 result = op.agg()
   1446 if not is_dict_like(func) and result is not None:
   1447     # GH #52849

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/apply.py:178, in Apply.agg(self)
    176 elif is_list_like(func):
    177     # we require a list, but not a 'str'
--> 178     return self.agg_list_like()
    180 if callable(func):

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/apply.py:311, in Apply.agg_list_like(self)
    304 """"""
    305 Compute aggregation in the case of a list-like argument.
    306 
   (...)
    309 Result of aggregation.
    310 """"""
--> 311 return self.agg_or_apply_list_like(op_name=""agg"")

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/apply.py:1353, in GroupByApply.agg_or_apply_list_like(self, op_name)
   1350 with com.temp_setattr(
   1351     obj, ""as_index"", True, condition=hasattr(obj, ""as_index"")
   1352 ):
-> 1353     keys, results = self.compute_list_like(op_name, selected_obj, kwargs)
   1354 result = self.wrap_results_list_like(keys, results)

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/apply.py:370, in Apply.compute_list_like(self, op_name, selected_obj, kwargs)
    365 args = (
    366     [self.axis, *self.args]
    367     if include_axis(op_name, colg)
    368     else self.args
    369 )
--> 370 new_res = getattr(colg, op_name)(func, *args, **kwargs)
    371 results.append(new_res)

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py:255, in SeriesGroupBy.aggregate(self, func, engine, engine_kwargs, *args, **kwargs)
    254 kwargs[""engine_kwargs""] = engine_kwargs
--> 255 ret = self._aggregate_multiple_funcs(func, *args, **kwargs)
    256 if relabeling:
    257     # columns is not narrowed by mypy from relabeling flag

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py:360, in SeriesGroupBy._aggregate_multiple_funcs(self, arg, *args, **kwargs)
    359         key = base.OutputKey(label=name, position=idx)
--> 360         results[key] = self.aggregate(func, *args, **kwargs)
    362 if any(isinstance(x, DataFrame) for x in results.values()):

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py:292, in SeriesGroupBy.aggregate(self, func, engine, engine_kwargs, *args, **kwargs)
    291 try:
--> 292     return self._python_agg_general(func, *args, **kwargs)
    293 except KeyError:
    294     # KeyError raised in test_groupby.test_basic is bc the func does
    295     #  a dictionary lookup on group.name, but group name is not
    296     #  pinned in _python_agg_general, only in _aggregate_named

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py:325, in SeriesGroupBy._python_agg_general(self, func, *args, **kwargs)
    324 obj = self._obj_with_exclusions
--> 325 result = self.grouper.agg_series(obj, f)
    326 res = obj._constructor(result, name=obj.name)

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/ops.py:849, in BaseGrouper.agg_series(self, obj, func, preserve_dtype)
    847     preserve_dtype = True
--> 849 result = self._aggregate_series_pure_python(obj, func)
    851 if len(obj) == 0 and len(result) == 0 and isinstance(obj.dtype, ExtensionDtype):

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/ops.py:877, in BaseGrouper._aggregate_series_pure_python(self, obj, func)
    876 for i, group in enumerate(splitter):
--> 877     res = func(group)
    878     res = extract_result(res)

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py:322, in SeriesGroupBy._python_agg_general.<locals>.<lambda>(x)
    321     warn_alias_replacement(self, orig_func, alias)
--> 322 f = lambda x: func(x, *args, **kwargs)
    324 obj = self._obj_with_exclusions

TypeError: 'Aggregation' object is not callable
```

> The above exception was the direct cause of the following exception:

```pytb
ValueError                                Traceback (most recent call last)
Cell In[4], line 1
----> 1 ddf.groupby('g')['a'].agg([custom_sum, 'median'], shuffle=True).compute()

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/groupby.py:3043, in SeriesGroupBy.agg(self, arg, split_every, split_out, shuffle, **kwargs)
   3041 @_aggregate_docstring(based_on=""pd.core.groupby.SeriesGroupBy.agg"")
   3042 def agg(self, arg=None, split_every=None, split_out=1, shuffle=None, **kwargs):
-> 3043     return self.aggregate(
   3044         arg=arg,
   3045         split_every=split_every,
   3046         split_out=split_out,
   3047         shuffle=shuffle,
   3048         **kwargs,
   3049     )

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/groupby.py:3019, in SeriesGroupBy.aggregate(self, arg, split_every, split_out, shuffle, **kwargs)
   3015 @_aggregate_docstring(based_on=""pd.core.groupby.SeriesGroupBy.aggregate"")
   3016 def aggregate(
   3017     self, arg=None, split_every=None, split_out=1, shuffle=None, **kwargs
   3018 ):
-> 3019     result = super().aggregate(
   3020         arg=arg,
   3021         split_every=split_every,
   3022         split_out=split_out,
   3023         shuffle=shuffle,
   3024         **kwargs,
   3025     )
   3026     if self._slice:
   3027         try:

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/groupby.py:2327, in _GroupBy.aggregate(self, arg, split_every, split_out, shuffle, **kwargs)
   2316 if shuffle:
   2317     # Shuffle-based aggregation
   2318     #
   (...)
   2324     # If we have a median in the spec, we cannot do an initial
   2325     # aggregation.
   2326     if has_median:
-> 2327         result = _shuffle_aggregate(
   2328             chunk_args,
   2329             chunk=_non_agg_chunk,
   2330             chunk_kwargs={
   2331                 ""key"": [
   2332                     c for c in _obj.columns.tolist() if c not in group_columns
   2333                 ],
   2334                 **self.observed,
   2335                 **self.dropna,
   2336             },
   2337             aggregate=_groupby_aggregate_spec,
   2338             aggregate_kwargs={
   2339                 ""spec"": arg,
   2340                 ""levels"": _determine_levels(self.by),
   2341                 **self.observed,
   2342                 **self.dropna,
   2343             },
   2344             token=""aggregate"",
   2345             split_every=split_every,
   2346             split_out=split_out,
   2347             shuffle_method=shuffle,
   2348             sort=self.sort,
   2349         )
   2350     else:
   2351         result = _shuffle_aggregate(
   2352             chunk_args,
   2353             chunk=_groupby_apply_funcs,
   (...)
   2372             sort=self.sort,
   2373         )

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/groupby.py:3314, in _shuffle_aggregate(args, chunk, aggregate, token, chunk_kwargs, aggregate_kwargs, split_every, split_out, sort, ignore_index, shuffle_method)
   3306     result = chunked.shuffle(
   3307         chunked.index,
   3308         ignore_index=ignore_index,
   3309         npartitions=shuffle_npartitions,
   3310         shuffle_method=shuffle_method,
   3311     )
   3313 # Aggregate
-> 3314 result = result.map_partitions(aggregate, **aggregate_kwargs)
   3316 if convert_back_to_series:
   3317     result = result[""__series__""].rename(series_name)

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/core.py:1152, in _Frame.map_partitions(self, func, *args, **kwargs)
   1024 @insert_meta_param_description(pad=12)
   1025 def map_partitions(self, func, *args, **kwargs):
   1026     """"""Apply Python function on each DataFrame partition.
   1027 
   1028     Note that the index and divisions are assumed to remain unchanged.
   (...)
   1150     None as the division.
   1151     """"""
-> 1152     return map_partitions(func, self, *args, **kwargs)

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/core.py:7173, in map_partitions(func, meta, enforce_metadata, transform_divisions, align_dataframes, *args, **kwargs)
   7166         raise ValueError(
   7167             f""{e}. If you don't want the partitions to be aligned, and are ""
   7168             ""calling `map_partitions` directly, pass `align_dataframes=False`.""
   7169         ) from e
   7171 dfs = [df for df in args if isinstance(df, _Frame)]
-> 7173 meta = _get_meta_map_partitions(args, dfs, func, kwargs, meta, parent_meta)
   7174 if all(isinstance(arg, Scalar) for arg in args):
   7175     layer = {
   7176         (name, 0): (
   7177             apply,
   (...)
   7181         )
   7182     }

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/core.py:7284, in _get_meta_map_partitions(args, dfs, func, kwargs, meta, parent_meta)
   7280     parent_meta = dfs[0]._meta
   7281 if meta is no_default:
   7282     # Use non-normalized kwargs here, as we want the real values (not
   7283     # delayed values)
-> 7284     meta = _emulate(func, *args, udf=True, **kwargs)
   7285     meta_is_emulated = True
   7286 else:

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/core.py:7102, in _emulate(func, udf, *args, **kwargs)
   7097 def _emulate(func, *args, udf=False, **kwargs):
   7098     """"""
   7099     Apply a function using args / kwargs. If arguments contain dd.DataFrame /
   7100     dd.Series, using internal cache (``_meta``) for calculation
   7101     """"""
-> 7102     with raise_on_meta_error(funcname(func), udf=udf), check_numeric_only_deprecation():
   7103         return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))

File /usr/lib/python3.11/contextlib.py:155, in _GeneratorContextManager.__exit__(self, typ, value, traceback)
    153     value = typ()
    154 try:
--> 155     self.gen.throw(typ, value, traceback)
    156 except StopIteration as exc:
    157     # Suppress StopIteration *unless* it's the same exception that
    158     # was passed to throw().  This prevents a StopIteration
    159     # raised inside the ""with"" statement from being suppressed.
    160     return exc is not value

File ~/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/utils.py:215, in raise_on_meta_error(funcname, udf)
    206 msg += (
    207     ""Original error is below:\n""
    208     ""------------------------\n""
   (...)
    212     ""{2}""
    213 )
    214 msg = msg.format(f"" in `{funcname}`"" if funcname else """", repr(e), tb)
--> 215 raise ValueError(msg) from e

ValueError: Metadata inference failed in `_groupby_aggregate_spec`.
```

> You have supplied a custom function and Dask is unable to 
> determine the type of output that that function returns. 
> 
> To resolve this please provide a meta= keyword.
> The docstring of the Dask function you ran should have more information.
> 
> Original error is below:

```pytb
------------------------
TypeError(""'Aggregation' object is not callable"")

Traceback:
---------
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/utils.py"", line 194, in raise_on_meta_error
    yield
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/core.py"", line 7103, in _emulate
    return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/dask/dataframe/groupby.py"", line 439, in _groupby_aggregate_spec
    return df.groupby(level=levels, sort=sort, **observed, **dropna).aggregate(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py"", line 1445, in aggregate
    result = op.agg()
             ^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/apply.py"", line 178, in agg
    return self.agg_list_like()
           ^^^^^^^^^^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/apply.py"", line 311, in agg_list_like
    return self.agg_or_apply_list_like(op_name=""agg"")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/apply.py"", line 1353, in agg_or_apply_list_like
    keys, results = self.compute_list_like(op_name, selected_obj, kwargs)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/apply.py"", line 370, in compute_list_like
    new_res = getattr(colg, op_name)(func, *args, **kwargs)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py"", line 255, in aggregate
    ret = self._aggregate_multiple_funcs(func, *args, **kwargs)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py"", line 360, in _aggregate_multiple_funcs
    results[key] = self.aggregate(func, *args, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py"", line 292, in aggregate
    return self._python_agg_general(func, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py"", line 325, in _python_agg_general
    result = self.grouper.agg_series(obj, f)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/ops.py"", line 849, in agg_series
    result = self._aggregate_series_pure_python(obj, func)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/ops.py"", line 877, in _aggregate_series_pure_python
    res = func(group)
          ^^^^^^^^^^^
  File ""/home/phil/.local/share/hatch/env/virtual/scanpy/q4In3tK-/test.py3.11/lib/python3.11/site-packages/pandas/core/groupby/generic.py"", line 322, in <lambda>
    f = lambda x: func(x, *args, **kwargs)
                  ^^^^^^^^^^^^^^^^^^^^^^^^
```

</details>

**Environment**:

- Dask version: 2024.1.0
- Python version: 3.11
- Operating System: Arch Linux
- Install method (conda, pip, source): pip, source
",,https://api.github.com/repos/dask/dask/issues/10853/timeline,,,flying-sheep,291575,MDQ6VXNlcjI5MTU3NQ==,https://avatars.githubusercontent.com/u/291575?v=4,,https://api.github.com/users/flying-sheep,https://github.com/flying-sheep,https://api.github.com/users/flying-sheep/followers,https://api.github.com/users/flying-sheep/following{/other_user},https://api.github.com/users/flying-sheep/gists{/gist_id},https://api.github.com/users/flying-sheep/starred{/owner}{/repo},https://api.github.com/users/flying-sheep/subscriptions,https://api.github.com/users/flying-sheep/orgs,https://api.github.com/users/flying-sheep/repos,https://api.github.com/users/flying-sheep/events{/privacy},https://api.github.com/users/flying-sheep/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10853/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
992,https://api.github.com/repos/dask/dask/issues/10869,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10869/labels{/name},https://api.github.com/repos/dask/dask/issues/10869/comments,https://api.github.com/repos/dask/dask/issues/10869/events,https://github.com/dask/dask/issues/10869,2105277906,I_kwDOAbcwm859e_3S,10869,Moto 5 results in timeouts in s3 tests:,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-01-29T11:28:48Z,2024-01-29T13:39:48Z,,MEMBER,,"AssertionError: Timed out waiting for moto server


https://github.com/dask/dask/actions/runs/7695124573/job/20967340207?pr=10868

pinning for now
",,https://api.github.com/repos/dask/dask/issues/10869/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10869/reactions,1,0,0,0,0,0,0,0,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
993,https://api.github.com/repos/dask/dask/issues/10881,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10881/labels{/name},https://api.github.com/repos/dask/dask/issues/10881/comments,https://api.github.com/repos/dask/dask/issues/10881/events,https://github.com/dask/dask/issues/10881,2112779935,I_kwDOAbcwm8597naf,10881,applying tuple with pyarrow,"[{'id': 6137710172, 'node_id': 'LA_kwDOAbcwm88AAAABbdYGXA', 'url': 'https://api.github.com/repos/dask/dask/labels/convert-string', 'name': 'convert-string', 'color': 'd93f0b', 'default': False, 'description': ''}]",open,False,,[],,2,2024-02-01T15:20:45Z,2024-02-02T08:38:50Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

When applying tuple to a dask dataframe without pyarrow installed, it gives a column with tuples as expected. If instead we apply it with pyarrow installed, we get string dtypes instead.

The problem can be reproduced by the following commands in the console:
```bash
$ pyenv deactivate
$ pyenv virtualenv --clear 3.10.12 tuple10 # create a clear environment
$ pyenv activate tuple10
$ pip install dask[dataframe]==2024.1.1
$ python tuple_test.py # we expect a tuple to be the result
                 d
0  <class 'tuple'>
$ pip install pyarrow
$ python tuple_test.py # but with pyarrow we get a string instead
               d
0  <class 'str'>
```
with tuple_test.py

```python
import dask.dataframe as dd
import pandas as pd


def apply_tuple_on_two_cols(
    counts_df: dd.DataFrame,
):
    counts_df[""d""] = counts_df[[""b"", ""c""]].apply(
        tuple, axis=1, meta=pd.Series(dtype=object)
    )
    counts_df[""d""] = counts_df[""d""].apply(
        type,
        meta=pd.Series(dtype=object),
    )
    return counts_df[[""d""]]


def test_tuple_application():
    counts = dd.from_pandas(
        pd.DataFrame({""a"": [""1""], ""b"": [""2""], ""c"": [3]}), npartitions=1
    )
    result = apply_tuple_on_two_cols(counts)
    print(result.compute())


if __name__ == ""__main__"":
    test_tuple_application()
```

**Environment**:

- Dask version:2024.1.1
- Pyarrow version: 15.0.0
- Python version:3.10.12
- Operating System:Ubuntu 22.04
- Install method (conda, pip, source):pip
",,https://api.github.com/repos/dask/dask/issues/10881/timeline,,,SurkynRik,108475308,U_kgDOBnczrA,https://avatars.githubusercontent.com/u/108475308?v=4,,https://api.github.com/users/SurkynRik,https://github.com/SurkynRik,https://api.github.com/users/SurkynRik/followers,https://api.github.com/users/SurkynRik/following{/other_user},https://api.github.com/users/SurkynRik/gists{/gist_id},https://api.github.com/users/SurkynRik/starred{/owner}{/repo},https://api.github.com/users/SurkynRik/subscriptions,https://api.github.com/users/SurkynRik/orgs,https://api.github.com/users/SurkynRik/repos,https://api.github.com/users/SurkynRik/events{/privacy},https://api.github.com/users/SurkynRik/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10881/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
994,https://api.github.com/repos/dask/dask/issues/10893,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10893/labels{/name},https://api.github.com/repos/dask/dask/issues/10893/comments,https://api.github.com/repos/dask/dask/issues/10893/events,https://github.com/dask/dask/pull/10893,2118826672,PR_kwDOAbcwm85mCdn-,10893,Test against pandas 2.0,[],open,False,,"[{'login': 'crusaderky', 'id': 6213168, 'node_id': 'MDQ6VXNlcjYyMTMxNjg=', 'avatar_url': 'https://avatars.githubusercontent.com/u/6213168?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/crusaderky', 'html_url': 'https://github.com/crusaderky', 'followers_url': 'https://api.github.com/users/crusaderky/followers', 'following_url': 'https://api.github.com/users/crusaderky/following{/other_user}', 'gists_url': 'https://api.github.com/users/crusaderky/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/crusaderky/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/crusaderky/subscriptions', 'organizations_url': 'https://api.github.com/users/crusaderky/orgs', 'repos_url': 'https://api.github.com/users/crusaderky/repos', 'events_url': 'https://api.github.com/users/crusaderky/events{/privacy}', 'received_events_url': 'https://api.github.com/users/crusaderky/received_events', 'type': 'User', 'site_admin': False}]",,4,2024-02-05T15:26:02Z,2024-02-23T16:13:26Z,,MEMBER,,"- Blocked by and incorporates #10891
- Blocked by and incorporates #10939

Now that the 3.12 environment is complete of all its dependencies; we can use the 3.11 one to pin numpy, pandas, and pyarrow in the ",,https://api.github.com/repos/dask/dask/issues/10893/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10893/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10893,https://github.com/dask/dask/pull/10893,https://github.com/dask/dask/pull/10893.diff,https://github.com/dask/dask/pull/10893.patch,,crusaderky,6213168.0,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False
995,https://api.github.com/repos/dask/dask/issues/10895,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10895/labels{/name},https://api.github.com/repos/dask/dask/issues/10895/comments,https://api.github.com/repos/dask/dask/issues/10895/events,https://github.com/dask/dask/pull/10895,2119594600,PR_kwDOAbcwm85mFHz3,10895,[WIP] Bump codecov/codecov-action from 3 to 4,"[{'id': 4625175122, 'node_id': 'LA_kwDOAbcwm88AAAABE66SUg', 'url': 'https://api.github.com/repos/dask/dask/labels/dependencies', 'name': 'dependencies', 'color': '0366d6', 'default': False, 'description': 'Pull requests that update a dependency file'}]",open,False,,[],,2,2024-02-05T22:39:30Z,2024-03-07T10:40:54Z,,CONTRIBUTOR,,"Bumps [codecov/codecov-action](https://github.com/codecov/codecov-action) from 3 to 4.
<details>
<summary>Release notes</summary>
<p><em>Sourced from <a href=""https://github.com/codecov/codecov-action/releases"">codecov/codecov-action's releases</a>.</em></p>
<blockquote>
<h2>v4.0.0</h2>
<p>v4 of the Codecov Action uses the <a href=""https://docs.codecov.com/docs/the-codecov-cli"">CLI</a> as the underlying upload. The CLI has helped to power new features including local upload, the global upload token, and new upcoming features.</p>
<h2>Breaking Changes</h2>
<ul>
<li>The Codecov Action runs as a <code>node20</code> action due to <code>node16</code> deprecation. See <a href=""https://github.blog/changelog/2023-09-22-github-actions-transitioning-from-node-16-to-node-20/"">this post from GitHub</a> on how to migrate.</li>
<li>Tokenless uploading is unsupported. However, PRs made from forks to the upstream public repos will support tokenless (e.g. contributors to OS projects do not need the upstream repo's Codecov token). This <a href=""https://docs.codecov.com/docs/adding-the-codecov-token#github-actions"">doc</a> shows instructions on how to add the Codecov token.</li>
<li>OS platforms have been added, though some may not be automatically detected. To see a list of platforms, see our <a href=""https://cli.codecov.io"">CLI download page</a></li>
<li>Various arguments to the Action have been changed. Please be aware that the arguments match with the CLI's needs</li>
</ul>
<p><code>v3</code> versions and below will not have access to CLI features (e.g. global upload token, ATS).</p>
<h2>What's Changed</h2>
<ul>
<li>build(deps): bump openpgp from 5.8.0 to 5.9.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/985"">codecov/codecov-action#985</a></li>
<li>build(deps): bump actions/checkout from 3.0.0 to 3.5.3 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1000"">codecov/codecov-action#1000</a></li>
<li>build(deps): bump ossf/scorecard-action from 2.1.3 to 2.2.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1006"">codecov/codecov-action#1006</a></li>
<li>build(deps): bump tough-cookie from 4.0.0 to 4.1.3 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1013"">codecov/codecov-action#1013</a></li>
<li>build(deps-dev): bump word-wrap from 1.2.3 to 1.2.4 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1024"">codecov/codecov-action#1024</a></li>
<li>build(deps): bump node-fetch from 3.3.1 to 3.3.2 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1031"">codecov/codecov-action#1031</a></li>
<li>build(deps-dev): bump <code>@types/node</code> from 20.1.4 to 20.4.5 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1032"">codecov/codecov-action#1032</a></li>
<li>build(deps): bump github/codeql-action from 1.0.26 to 2.21.2 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1033"">codecov/codecov-action#1033</a></li>
<li>build commit,report and upload args based on codecovcli by <a href=""https://github.com/dana-yaish""><code>@dana-yaish</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/943"">codecov/codecov-action#943</a></li>
<li>build(deps-dev): bump <code>@types/node</code> from 20.4.5 to 20.5.3 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1055"">codecov/codecov-action#1055</a></li>
<li>build(deps): bump github/codeql-action from 2.21.2 to 2.21.4 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1051"">codecov/codecov-action#1051</a></li>
<li>build(deps-dev): bump <code>@types/node</code> from 20.5.3 to 20.5.4 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1058"">codecov/codecov-action#1058</a></li>
<li>chore(deps): update outdated deps by <a href=""https://github.com/thomasrockhu-codecov""><code>@thomasrockhu-codecov</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1059"">codecov/codecov-action#1059</a></li>
<li>build(deps-dev): bump <code>@types/node</code> from 20.5.4 to 20.5.6 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1060"">codecov/codecov-action#1060</a></li>
<li>build(deps-dev): bump <code>@typescript-eslint/parser</code> from 6.4.1 to 6.5.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1065"">codecov/codecov-action#1065</a></li>
<li>build(deps-dev): bump <code>@typescript-eslint/eslint-plugin</code> from 6.4.1 to 6.5.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1064"">codecov/codecov-action#1064</a></li>
<li>build(deps): bump actions/checkout from 3.5.3 to 3.6.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1063"">codecov/codecov-action#1063</a></li>
<li>build(deps-dev): bump eslint from 8.47.0 to 8.48.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1061"">codecov/codecov-action#1061</a></li>
<li>build(deps-dev): bump <code>@types/node</code> from 20.5.6 to 20.5.7 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1062"">codecov/codecov-action#1062</a></li>
<li>build(deps): bump openpgp from 5.9.0 to 5.10.1 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1066"">codecov/codecov-action#1066</a></li>
<li>build(deps-dev): bump <code>@types/node</code> from 20.5.7 to 20.5.9 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1070"">codecov/codecov-action#1070</a></li>
<li>build(deps): bump github/codeql-action from 2.21.4 to 2.21.5 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1069"">codecov/codecov-action#1069</a></li>
<li>build(deps-dev): bump <code>@typescript-eslint/eslint-plugin</code> from 6.5.0 to 6.6.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1072"">codecov/codecov-action#1072</a></li>
<li>Update README.md by <a href=""https://github.com/thomasrockhu-codecov""><code>@thomasrockhu-codecov</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1073"">codecov/codecov-action#1073</a></li>
<li>build(deps-dev): bump <code>@typescript-eslint/parser</code> from 6.5.0 to 6.6.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1071"">codecov/codecov-action#1071</a></li>
<li>build(deps-dev): bump <code>@vercel/ncc</code> from 0.36.1 to 0.38.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1074"">codecov/codecov-action#1074</a></li>
<li>build(deps): bump <code>@actions/core</code> from 1.10.0 to 1.10.1 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1081"">codecov/codecov-action#1081</a></li>
<li>build(deps-dev): bump <code>@typescript-eslint/eslint-plugin</code> from 6.6.0 to 6.7.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1080"">codecov/codecov-action#1080</a></li>
<li>build(deps): bump actions/checkout from 3.6.0 to 4.0.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1078"">codecov/codecov-action#1078</a></li>
<li>build(deps): bump actions/upload-artifact from 3.1.2 to 3.1.3 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1077"">codecov/codecov-action#1077</a></li>
<li>build(deps-dev): bump <code>@types/node</code> from 20.5.9 to 20.6.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1075"">codecov/codecov-action#1075</a></li>
<li>build(deps-dev): bump <code>@typescript-eslint/parser</code> from 6.6.0 to 6.7.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1079"">codecov/codecov-action#1079</a></li>
<li>build(deps-dev): bump eslint from 8.48.0 to 8.49.0 by <a href=""https://github.com/dependabot""><code>@dependabot</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1076"">codecov/codecov-action#1076</a></li>
<li>use cli instead of node uploader by <a href=""https://github.com/dana-yaish""><code>@dana-yaish</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1068"">codecov/codecov-action#1068</a></li>
<li>chore(release): 4.0.0-beta.1 by <a href=""https://github.com/thomasrockhu-codecov""><code>@thomasrockhu-codecov</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1084"">codecov/codecov-action#1084</a></li>
<li>not adding -n if empty to do-upload command by <a href=""https://github.com/dana-yaish""><code>@dana-yaish</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1085"">codecov/codecov-action#1085</a></li>
<li>4.0.0-beta.2 by <a href=""https://github.com/thomasrockhu-codecov""><code>@thomasrockhu-codecov</code></a> in <a href=""https://redirect.github.com/codecov/codecov-action/pull/1086"">codecov/codecov-action#1086</a></li>
</ul>
<!-- raw HTML omitted -->
</blockquote>
<p>... (truncated)</p>
</details>
<details>
<summary>Changelog</summary>
<p><em>Sourced from <a href=""https://github.com/codecov/codecov-action/blob/main/CHANGELOG.md"">codecov/codecov-action's changelog</a>.</em></p>
<blockquote>
<h2>4.0.0-beta.2</h2>
<h3>Fixes</h3>
<ul>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/1085"">#1085</a> not adding -n if empty to do-upload command</li>
</ul>
<h2>4.0.0-beta.1</h2>
<p><code>v4</code> represents a move from the <a href=""https://github.com/codecov/uploader"">universal uploader</a> to the <a href=""https://github.com/codecov/codecov-cli"">Codecov CLI</a>. Although this will unlock new features for our users, the CLI is not yet at feature parity with the universal uploader.</p>
<h3>Breaking Changes</h3>
<ul>
<li>No current support for <code>aarch64</code> and <code>alpine</code> architectures.</li>
<li>Tokenless uploading is unsuported</li>
<li>Various arguments to the Action have been removed</li>
</ul>
<h2>3.1.4</h2>
<h3>Fixes</h3>
<ul>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/967"">#967</a> Fix typo in README.md</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/971"">#971</a> fix: add back in working dir</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/969"">#969</a> fix: CLI option names for uploader</li>
</ul>
<h3>Dependencies</h3>
<ul>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/970"">#970</a> build(deps-dev): bump <code>@types/node</code> from 18.15.12 to 18.16.3</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/979"">#979</a> build(deps-dev): bump <code>@types/node</code> from 20.1.0 to 20.1.2</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/981"">#981</a> build(deps-dev): bump <code>@types/node</code> from 20.1.2 to 20.1.4</li>
</ul>
<h2>3.1.3</h2>
<h3>Fixes</h3>
<ul>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/960"">#960</a> fix: allow for aarch64 build</li>
</ul>
<h3>Dependencies</h3>
<ul>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/957"">#957</a> build(deps-dev): bump jest-junit from 15.0.0 to 16.0.0</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/958"">#958</a> build(deps): bump openpgp from 5.7.0 to 5.8.0</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/959"">#959</a> build(deps-dev): bump <code>@types/node</code> from 18.15.10 to 18.15.12</li>
</ul>
<h2>3.1.2</h2>
<h3>Fixes</h3>
<ul>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/718"">#718</a> Update README.md</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/851"">#851</a> Remove unsupported path_to_write_report argument</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/898"">#898</a> codeql-analysis.yml</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/901"">#901</a> Update README to contain correct information - inputs and negate feature</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/955"">#955</a> fix: add in all the extra arguments for uploader</li>
</ul>
<h3>Dependencies</h3>
<ul>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/819"">#819</a> build(deps): bump openpgp from 5.4.0 to 5.5.0</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/835"">#835</a> build(deps): bump node-fetch from 3.2.4 to 3.2.10</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/840"">#840</a> build(deps): bump ossf/scorecard-action from 1.1.1 to 2.0.4</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/841"">#841</a> build(deps): bump <code>@actions/core</code> from 1.9.1 to 1.10.0</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/843"">#843</a> build(deps): bump <code>@actions/github</code> from 5.0.3 to 5.1.1</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/869"">#869</a> build(deps): bump node-fetch from 3.2.10 to 3.3.0</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/872"">#872</a> build(deps-dev): bump jest-junit from 13.2.0 to 15.0.0</li>
<li><a href=""https://redirect.github.com/codecov/codecov-action/issues/879"">#879</a> build(deps): bump decode-uri-component from 0.2.0 to 0.2.2</li>
</ul>
<!-- raw HTML omitted -->
</blockquote>
<p>... (truncated)</p>
</details>
<details>
<summary>Commits</summary>
<ul>
<li><a href=""https://github.com/codecov/codecov-action/commit/e0b68c6749509c5f83f984dd99a76a1c1a231044""><code>e0b68c6</code></a> fix: show both token uses in readme (<a href=""https://redirect.github.com/codecov/codecov-action/issues/1250"">#1250</a>)</li>
<li><a href=""https://github.com/codecov/codecov-action/commit/1f9f5573d12d0967fe14551018a4b25610226551""><code>1f9f557</code></a> Add all args (<a href=""https://redirect.github.com/codecov/codecov-action/issues/1245"">#1245</a>)</li>
<li><a href=""https://github.com/codecov/codecov-action/commit/09686fcfcb6453414a5acd7f3a939670a7a77826""><code>09686fc</code></a> Update README.md (<a href=""https://redirect.github.com/codecov/codecov-action/issues/1243"">#1243</a>)</li>
<li><a href=""https://github.com/codecov/codecov-action/commit/f30e4959ba63075080d4f7f90cacc18d9f3fafd7""><code>f30e495</code></a> fix: update action.yml (<a href=""https://redirect.github.com/codecov/codecov-action/issues/1240"">#1240</a>)</li>
<li><a href=""https://github.com/codecov/codecov-action/commit/a7b945cea47ad44d8340fae2b004cb982191264f""><code>a7b945c</code></a> fix: allow for other archs (<a href=""https://redirect.github.com/codecov/codecov-action/issues/1239"">#1239</a>)</li>
<li><a href=""https://github.com/codecov/codecov-action/commit/98ab2c591b94478f4c3606d68ff73601df85ec43""><code>98ab2c5</code></a> Update package.json (<a href=""https://redirect.github.com/codecov/codecov-action/issues/1238"">#1238</a>)</li>
<li><a href=""https://github.com/codecov/codecov-action/commit/43235cc5aeeafd8aeb836fe7d647599acead161c""><code>43235cc</code></a> Update README.md (<a href=""https://redirect.github.com/codecov/codecov-action/issues/1237"">#1237</a>)</li>
<li><a href=""https://github.com/codecov/codecov-action/commit/0cf8684c821546a4e0c8c9a4cf4f21a7a0c5014b""><code>0cf8684</code></a> chore(ci): bump to node20 (<a href=""https://redirect.github.com/codecov/codecov-action/issues/1236"">#1236</a>)</li>
<li><a href=""https://github.com/codecov/codecov-action/commit/8e1e730371bf82c744e8ca9aa469e2b7011542ce""><code>8e1e730</code></a> build(deps-dev): bump <code>@typescript-eslint/eslint-plugin</code> from 6.19.1 to 6.20.0 ...</li>
<li><a href=""https://github.com/codecov/codecov-action/commit/61293af0e8288c75266030376a088c781ec81c18""><code>61293af</code></a> build(deps-dev): bump <code>@typescript-eslint/parser</code> from 6.19.1 to 6.20.0 (<a href=""https://redirect.github.com/codecov/codecov-action/issues/1235"">#1235</a>)</li>
<li>Additional commits viewable in <a href=""https://github.com/codecov/codecov-action/compare/v3...v4"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=codecov/codecov-action&package-manager=github_actions&previous-version=3&new-version=4)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

You can trigger a rebase of this PR by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>

> **Note**
> Automatic rebases have been disabled on this pull request as it has been open for over 30 days.
",,https://api.github.com/repos/dask/dask/issues/10895/timeline,,,dependabot[bot],49699333,MDM6Qm90NDk2OTkzMzM=,https://avatars.githubusercontent.com/in/29110?v=4,,https://api.github.com/users/dependabot%5Bbot%5D,https://github.com/apps/dependabot,https://api.github.com/users/dependabot%5Bbot%5D/followers,https://api.github.com/users/dependabot%5Bbot%5D/following{/other_user},https://api.github.com/users/dependabot%5Bbot%5D/gists{/gist_id},https://api.github.com/users/dependabot%5Bbot%5D/starred{/owner}{/repo},https://api.github.com/users/dependabot%5Bbot%5D/subscriptions,https://api.github.com/users/dependabot%5Bbot%5D/orgs,https://api.github.com/users/dependabot%5Bbot%5D/repos,https://api.github.com/users/dependabot%5Bbot%5D/events{/privacy},https://api.github.com/users/dependabot%5Bbot%5D/received_events,Bot,False,https://api.github.com/repos/dask/dask/issues/10895/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/10895,https://github.com/dask/dask/pull/10895,https://github.com/dask/dask/pull/10895.diff,https://github.com/dask/dask/pull/10895.patch,,,,,,,,,,,,,,,,,,,
996,https://api.github.com/repos/dask/dask/issues/10899,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10899/labels{/name},https://api.github.com/repos/dask/dask/issues/10899/comments,https://api.github.com/repos/dask/dask/issues/10899/events,https://github.com/dask/dask/pull/10899,2120727519,PR_kwDOAbcwm85mI_UM,10899,Adjust for enforced deprecations in pandas,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}]",open,False,,[],,1,2024-02-06T13:02:19Z,2024-02-07T11:22:48Z,,MEMBER,,"- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`

Those deprecations were already merged",,https://api.github.com/repos/dask/dask/issues/10899/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10899/reactions,0,0,0,0,0,0,0,0,0,phofl,61934744.0,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,False,https://api.github.com/repos/dask/dask/pulls/10899,https://github.com/dask/dask/pull/10899,https://github.com/dask/dask/pull/10899.diff,https://github.com/dask/dask/pull/10899.patch,,,,,,,,,,,,,,,,,,,
997,https://api.github.com/repos/dask/dask/issues/10906,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10906/labels{/name},https://api.github.com/repos/dask/dask/issues/10906/comments,https://api.github.com/repos/dask/dask/issues/10906/events,https://github.com/dask/dask/pull/10906,2122838209,PR_kwDOAbcwm85mQH7s,10906,Rename futures to tasks,[],open,False,,[],,1,2024-02-07T11:43:15Z,2024-04-04T10:08:56Z,,MEMBER,,"- [x] Part of https://github.com/dask/distributed/pull/8497 and https://github.com/dask/distributed/issues/8028
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10906/timeline,,,milesgranger,13764397,MDQ6VXNlcjEzNzY0Mzk3,https://avatars.githubusercontent.com/u/13764397?v=4,,https://api.github.com/users/milesgranger,https://github.com/milesgranger,https://api.github.com/users/milesgranger/followers,https://api.github.com/users/milesgranger/following{/other_user},https://api.github.com/users/milesgranger/gists{/gist_id},https://api.github.com/users/milesgranger/starred{/owner}{/repo},https://api.github.com/users/milesgranger/subscriptions,https://api.github.com/users/milesgranger/orgs,https://api.github.com/users/milesgranger/repos,https://api.github.com/users/milesgranger/events{/privacy},https://api.github.com/users/milesgranger/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10906/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10906,https://github.com/dask/dask/pull/10906,https://github.com/dask/dask/pull/10906.diff,https://github.com/dask/dask/pull/10906.patch,,,,,,,,,,,,,,,,,,,
998,https://api.github.com/repos/dask/dask/issues/10923,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10923/labels{/name},https://api.github.com/repos/dask/dask/issues/10923/comments,https://api.github.com/repos/dask/dask/issues/10923/events,https://github.com/dask/dask/pull/10923,2134370675,PR_kwDOAbcwm85m3HQ_,10923,feat(Series) - Added `items()` method,[],open,False,,[],,2,2024-02-14T13:34:34Z,2024-02-20T10:02:47Z,,FIRST_TIME_CONTRIBUTOR,,"- [ ] Sub task of #1259
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/10923/timeline,,,mobley-trent,67474838,MDQ6VXNlcjY3NDc0ODM4,https://avatars.githubusercontent.com/u/67474838?v=4,,https://api.github.com/users/mobley-trent,https://github.com/mobley-trent,https://api.github.com/users/mobley-trent/followers,https://api.github.com/users/mobley-trent/following{/other_user},https://api.github.com/users/mobley-trent/gists{/gist_id},https://api.github.com/users/mobley-trent/starred{/owner}{/repo},https://api.github.com/users/mobley-trent/subscriptions,https://api.github.com/users/mobley-trent/orgs,https://api.github.com/users/mobley-trent/repos,https://api.github.com/users/mobley-trent/events{/privacy},https://api.github.com/users/mobley-trent/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10923/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10923,https://github.com/dask/dask/pull/10923,https://github.com/dask/dask/pull/10923.diff,https://github.com/dask/dask/pull/10923.patch,,,,,,,,,,,,,,,,,,,
999,https://api.github.com/repos/dask/dask/issues/10931,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10931/labels{/name},https://api.github.com/repos/dask/dask/issues/10931/comments,https://api.github.com/repos/dask/dask/issues/10931/events,https://github.com/dask/dask/issues/10931,2138538190,I_kwDOAbcwm85_d4DO,10931,combine_first: conditional type-cast to rhs's dtype,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450422, 'node_id': 'LA_kwDOAbcwm87iZ8D2', 'url': 'https://api.github.com/repos/dask/dask/labels/p3', 'name': 'p3', 'color': 'ffff33', 'default': False, 'description': 'Affects a small number of users or is largely cosmetic'}]",open,False,,[],,6,2024-02-16T12:34:12Z,2024-02-16T16:30:06Z,,MEMBER,,"- XREF https://github.com/pandas-dev/pandas/pull/52532

`test_combine_first` is flaky. This is because the test randomly generates the test data, and if a chunk ends up being full of NaNs it will improperly trigger a FutureWarning in pandas that should only trigger when the whole Series is full of NaNs.

Reproducer linked below.

Additionally, if lhs is of dtype='datetime64[s]' and full of NaTs, while rhs has dtype='datetime64[ns]', the output dtype is rhs's dtype in pandas, but lhs's dtype in dask. This can't be fixed due to the dtype being eager in dask.
",,https://api.github.com/repos/dask/dask/issues/10931/timeline,,,crusaderky,6213168,MDQ6VXNlcjYyMTMxNjg=,https://avatars.githubusercontent.com/u/6213168?v=4,,https://api.github.com/users/crusaderky,https://github.com/crusaderky,https://api.github.com/users/crusaderky/followers,https://api.github.com/users/crusaderky/following{/other_user},https://api.github.com/users/crusaderky/gists{/gist_id},https://api.github.com/users/crusaderky/starred{/owner}{/repo},https://api.github.com/users/crusaderky/subscriptions,https://api.github.com/users/crusaderky/orgs,https://api.github.com/users/crusaderky/repos,https://api.github.com/users/crusaderky/events{/privacy},https://api.github.com/users/crusaderky/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10931/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1000,https://api.github.com/repos/dask/dask/issues/10933,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10933/labels{/name},https://api.github.com/repos/dask/dask/issues/10933/comments,https://api.github.com/repos/dask/dask/issues/10933/events,https://github.com/dask/dask/issues/10933,2138800457,I_kwDOAbcwm85_e4FJ,10933,Explode method does not work for object column with DatetimeInterval values,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,4,2024-02-16T15:02:18Z,2024-02-16T19:42:07Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**: 
It seems that dask `explode()` method does not work with non-list values and throws unclear error. However, there is a comment in the code that in case of non-list values it fallbacks to pandas implementation but it fails.

**Minimal Complete Verifiable Example**:

Pandas woking example:
```python
import pandas as pd

df = (pd.DataFrame({
    'A': [1, 2, 3], 
    'start': [pd.to_datetime('2024-01-01'), pd.to_datetime('2024-02-01'), pd.to_datetime('2024-03-01')], 
    'end': [pd.to_datetime('2024-01-3'), pd.to_datetime('2024-02-3'), pd.to_datetime('2024-03-3')]})
    .assign(DateRange= lambda x: x.apply(lambda row: pd.date_range(start=row['start'], end=row['end'], freq='D'), axis=1)))

display(df)

df.explode('DateRange')
```

Dask failing example:
```python
from dask.distributed import LocalCluster
import dask.dataframe as dd
cluster = LocalCluster()          # Fully-featured local Dask cluster
client = cluster.get_client()

df = dd.from_pandas(pd.DataFrame({
    'A': [1, 2, 3], 
    'start': [pd.to_datetime('2024-01-01'), pd.to_datetime('2024-02-01'), pd.to_datetime('2024-03-01')], 
    'end': [pd.to_datetime('2024-01-3'), pd.to_datetime('2024-02-3'), pd.to_datetime('2024-03-3')]}), npartitions=2)


(df.assign(DateRange= lambda x: x.apply(lambda row: pd.date_range(start=row['start'], end=row['end'], freq='D'), axis=1))
 .explode('DateRange'))
 ```
```text
{
	""name"": ""AttributeError"",
	""message"": ""'StringDtype' object has no attribute 'pyarrow_dtype'"",
	""stack"": ""---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Cell In[49], line 13
      4 client = cluster.get_client()
      6 df = dd.from_pandas(pd.DataFrame({
      7     'A': [1, 2, 3], 
      8     'start': [pd.to_datetime('2024-01-01'), pd.to_datetime('2024-02-01'), pd.to_datetime('2024-03-01')], 
      9     'end': [pd.to_datetime('2024-01-3'), pd.to_datetime('2024-02-3'), pd.to_datetime('2024-03-3')]}), npartitions=2)
     12 (df.assign(DateRange= lambda x: x.apply(lambda row: pd.date_range(start=row['start'], end=row['end'], freq='D'), axis=1))
---> 13  .explode('DateRange'))

File ~/src/demand-forecasting/.venv/lib/python3.10/site-packages/dask/dataframe/core.py:5754, in DataFrame.explode(self, column)
   5752 @derived_from(pd.DataFrame)
   5753 def explode(self, column):
-> 5754     meta = self._meta.explode(column)
   5755     return self.map_partitions(M.explode, column, meta=meta, enforce_metadata=False)

File ~/src/demand-forecasting/.venv/lib/python3.10/site-packages/pandas/core/frame.py:9819, in DataFrame.explode(self, column, ignore_index)
   9817 df = self.reset_index(drop=True)
   9818 if len(columns) == 1:
-> 9819     result = df[columns[0]].explode()
   9820 else:
   9821     mylen = lambda x: len(x) if (is_list_like(x) and len(x) > 0) else 1

File ~/src/demand-forecasting/.venv/lib/python3.10/site-packages/pandas/core/series.py:4530, in Series.explode(self, ignore_index)
   4477 \""\""\""
   4478 Transform each element of a list-like to a row.
   4479 
   (...)
   4527 dtype: object
   4528 \""\""\""
   4529 if isinstance(self.dtype, ExtensionDtype):
-> 4530     values, counts = self._values._explode()
   4531 elif len(self) and is_object_dtype(self.dtype):
   4532     values, counts = reshape.explode(np.asarray(self._values))

File ~/src/demand-forecasting/.venv/lib/python3.10/site-packages/pandas/core/arrays/arrow/array.py:1781, in ArrowExtensionArray._explode(self)
   1776 \""\""\""
   1777 See Series.explode.__doc__.
   1778 \""\""\""
   1779 # child class explode method supports only list types; return
   1780 # default implementation for non list types.
-> 1781 if not pa.types.is_list(self.dtype.pyarrow_dtype):
   1782     return super()._explode()
   1783 values = self

AttributeError: 'StringDtype' object has no attribute 'pyarrow_dtype'""
}
```

**Environment**:

- Dask version: '2024.1.0'
- Python version: 3.10
- Pandas: 2.2.0
- Operating System: Linux, Ubuntu
- Install method (conda, pip, source): poetry
",,https://api.github.com/repos/dask/dask/issues/10933/timeline,,,dbalabka,1269372,MDQ6VXNlcjEyNjkzNzI=,https://avatars.githubusercontent.com/u/1269372?v=4,,https://api.github.com/users/dbalabka,https://github.com/dbalabka,https://api.github.com/users/dbalabka/followers,https://api.github.com/users/dbalabka/following{/other_user},https://api.github.com/users/dbalabka/gists{/gist_id},https://api.github.com/users/dbalabka/starred{/owner}{/repo},https://api.github.com/users/dbalabka/subscriptions,https://api.github.com/users/dbalabka/orgs,https://api.github.com/users/dbalabka/repos,https://api.github.com/users/dbalabka/events{/privacy},https://api.github.com/users/dbalabka/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10933/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1001,https://api.github.com/repos/dask/dask/issues/10934,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10934/labels{/name},https://api.github.com/repos/dask/dask/issues/10934/comments,https://api.github.com/repos/dask/dask/issues/10934/events,https://github.com/dask/dask/issues/10934,2139572898,I_kwDOAbcwm85_h0qi,10934,[DISCUSSION] What is the timeline for `dask.dataframe` deprecation,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 3798450419, 'node_id': 'LA_kwDOAbcwm87iZ8Dz', 'url': 'https://api.github.com/repos/dask/dask/labels/deprecation', 'name': 'deprecation', 'color': 'f4e49a', 'default': False, 'description': 'Something is being removed'}]",open,False,,[],,8,2024-02-16T22:27:10Z,2024-02-28T13:52:14Z,,MEMBER,,"Many users and down-stream libraries were a bit surprised to see a loud deprecation warning when importing `dask.dataframe` after the `2024.2.0` release. The dask-expr migration was certainly obvious for anyone watching github. However, the discussion/decision over the specific timeline was largely internal to Coiled.

Could we use this issue to establish a basic timeline for users and down-stream libraries to use as a reference? Note that I am not asking that we try to reach a consensus on these kinds of decisions. It would just be very useful to know what the plan is (so it can be communicated easily to others).

Critical Questions:

- What is the earliest date that the `""dataframe.query-planning""` default will change from `""False""` to `""True""`? For example, will it be `2024.2.1`, or is the plan to do this in `2024.3.0` or later?
- What is the earliest date that  `""dataframe.query-planning"": ""False""` will be disabled entirely?",,https://api.github.com/repos/dask/dask/issues/10934/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10934/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1002,https://api.github.com/repos/dask/dask/issues/10937,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10937/labels{/name},https://api.github.com/repos/dask/dask/issues/10937/comments,https://api.github.com/repos/dask/dask/issues/10937/events,https://github.com/dask/dask/issues/10937,2142299739,I_kwDOAbcwm85_sOZb,10937,[DISCUSSION] How to deal with limited annotation support in `dask-expr`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,3,2024-02-19T12:49:36Z,2024-02-19T15:29:49Z,,MEMBER,,"At the moment, `dask-expr` has only limited support for annotations (https://github.com/dask-contrib/dask-expr/issues/13). Specifically, it only supports annotations at graph submission. For example, you can restrict resources for an *entire* computation with

```python
# Define your entire computation graph here
df = ...

with dask.annotate(resources={'GPU': 1}):
    # Submit the graph with resource restrictions  
    res = client.compute(df)

```

Applying resource restrictions at graph creation does not work and will be silently ignored:

```python
with dask.annotate(resources={'GPU': 1}):
    # Define a computation that should run on GPUs here
    df = ...

# Submitting the graph outside of the annotation context will ignore the annotations.
client.compute(df)
```

Before choosing `dask-expr` as the default mechanism (#10934), we should, therefore, reach a consensus on how we want to deal with this lack of support.

Primarily, we need to answer the question: Are we okay with local annotations breaking silently when defaulting to `dask-expr`? If not, what are the minimal requirements that we need to support before the switch?

Generally, there is some contention on what annotation support would ideally look like. The current implementation falls short in multiple regards, e.g., by losing annotations in various codepaths, or the impossibility of having both loose worker restrictions and strict resource restrictions. Some points that have been raised here and can start a discussion are:

- Do we want general-purpose mechanism for all kinds of annotations or should we instead limit this functionality to multiple explicit APIs, e.g., for restricting tasks to workers or resources, and attaching metadata to tasks?
- How do annotations interact with logical plan optimization, e.g., plan rewrites, plan reordering, and fusion?
- What annotation functionality is even used in practice?",,https://api.github.com/repos/dask/dask/issues/10937/timeline,,,hendrikmakait,2699097,MDQ6VXNlcjI2OTkwOTc=,https://avatars.githubusercontent.com/u/2699097?v=4,,https://api.github.com/users/hendrikmakait,https://github.com/hendrikmakait,https://api.github.com/users/hendrikmakait/followers,https://api.github.com/users/hendrikmakait/following{/other_user},https://api.github.com/users/hendrikmakait/gists{/gist_id},https://api.github.com/users/hendrikmakait/starred{/owner}{/repo},https://api.github.com/users/hendrikmakait/subscriptions,https://api.github.com/users/hendrikmakait/orgs,https://api.github.com/users/hendrikmakait/repos,https://api.github.com/users/hendrikmakait/events{/privacy},https://api.github.com/users/hendrikmakait/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10937/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1003,https://api.github.com/repos/dask/dask/issues/10945,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10945/labels{/name},https://api.github.com/repos/dask/dask/issues/10945/comments,https://api.github.com/repos/dask/dask/issues/10945/events,https://github.com/dask/dask/issues/10945,2147478544,I_kwDOAbcwm85__-wQ,10945,Pandas read_sql vs dask read_sql issues,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,3,2024-02-21T18:57:15Z,2024-05-24T19:06:10Z,,NONE,,"Hello guys,
Help here. The same command works on pandas but does not work on dask:

Pandas

```
import pandas as pd
sql = """"""SELECT t1.NR_SEQL_SLCT_CPR
        FROM ORANDPOW0000.SLCT_CPR_PRD_PCR t1
        WHERE ROWNUM <= 1000""""""
pd.read_sql(sql = sql, con=oracle.uri, index_col = 'nr_seql_slct_cpr')
```
It does work and return me the table (I don't know why I cant upload pictures here)

But if I try with dask, it does not find the target table.
```
import dask.dataframe as dd
sql = """"""SELECT t1.NR_SEQL_SLCT_CPR
        FROM ORANDPOW0000.SLCT_CPR_PRD_PCR t1
        WHERE ROWNUM <= 1000""""""
dd.read_sql(sql = sql, con=oracle.uri, index_col = 'nr_seql_slct_cpr')
```
Got ""NoSuchTableError""
```
---------------------------------------------------------------------------
NoSuchTableError                          Traceback (most recent call last)
Cell In[134], [line 5](vscode-notebook-cell:?execution_count=134&line=5)
      [1](vscode-notebook-cell:?execution_count=134&line=1) import dask.dataframe as dd
      [2](vscode-notebook-cell:?execution_count=134&line=2) sql = """"""SELECT t1.NR_SEQL_SLCT_CPR
      [3](vscode-notebook-cell:?execution_count=134&line=3)         FROM ORANDPOW0000.SLCT_CPR_PRD_PCR t1
      [4](vscode-notebook-cell:?execution_count=134&line=4)         WHERE ROWNUM <= 1000""""""
----> [5](vscode-notebook-cell:?execution_count=134&line=5) dd.read_sql(sql = sql, con=oracle.uri, index_col = 'nr_seql_slct_cpr')

File [c:\Users\F3164582\AppData\Local\Programs\Python\Python311\Lib\site-packages\dask\dataframe\io\sql.py:393](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:393), in read_sql(sql, con, index_col, **kwargs)
    [360](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:360) """"""
    [361](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:361) Read SQL query or database table into a DataFrame.
    [362](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:362) 
   (...)
    [390](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:390) read_sql_query : Read SQL query into a DataFrame.
    [391](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:391) """"""
    [392](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:392) if isinstance(sql, str):
--> [393](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:393)     return read_sql_table(sql, con, index_col, **kwargs)
    [394](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:394) else:
    [395](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:395)     return read_sql_query(sql, con, index_col, **kwargs)

File [c:\Users\F3164582\AppData\Local\Programs\Python\Python311\Lib\site-packages\dask\dataframe\io\sql.py:314](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:314), in read_sql_table(table_name, con, index_col, divisions, npartitions, limits, columns, bytes_per_chunk, head_rows, schema, meta, engine_kwargs, **kwargs)
    [312](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:312) m = sa.MetaData()
    [313](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:313) if isinstance(table_name, str):
--> [314](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/dask/dataframe/io/sql.py:314)     table_name = sa.Table(table_name, m, autoload_with=engine, schema=schema)
...
   [1541](file:///C:/Users/F3164582/AppData/Local/Programs/Python/Python311/Lib/site-packages/sqlalchemy/engine/reflection.py:1541) if _reflect_info.table_options:

NoSuchTableError: SELECT t1.NR_SEQL_SLCT_CPR
        FROM ORANDPOW0000.SLCT_CPR_PRD_PCR t1
        WHERE ROWNUM <= 1000
```


**Environment**:
- Dask version: '2023.11.0'
- Python version: 3.11.7
- Operating System:  Windows 10
- Install method (conda, pip, source): PIP
",,https://api.github.com/repos/dask/dask/issues/10945/timeline,,,frbelotto,24688087,MDQ6VXNlcjI0Njg4MDg3,https://avatars.githubusercontent.com/u/24688087?v=4,,https://api.github.com/users/frbelotto,https://github.com/frbelotto,https://api.github.com/users/frbelotto/followers,https://api.github.com/users/frbelotto/following{/other_user},https://api.github.com/users/frbelotto/gists{/gist_id},https://api.github.com/users/frbelotto/starred{/owner}{/repo},https://api.github.com/users/frbelotto/subscriptions,https://api.github.com/users/frbelotto/orgs,https://api.github.com/users/frbelotto/repos,https://api.github.com/users/frbelotto/events{/privacy},https://api.github.com/users/frbelotto/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10945/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1004,https://api.github.com/repos/dask/dask/issues/10946,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10946/labels{/name},https://api.github.com/repos/dask/dask/issues/10946/comments,https://api.github.com/repos/dask/dask/issues/10946/events,https://github.com/dask/dask/issues/10946,2149041845,I_kwDOAbcwm86AF8a1,10946,assert_eq sometimes doesn't raise for differing string dtypes,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-02-22T13:08:43Z,2024-02-22T13:08:55Z,,MEMBER,,See the test case that was added in https://github.com/dask/dask/pull/10942,,https://api.github.com/repos/dask/dask/issues/10946/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10946/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1005,https://api.github.com/repos/dask/dask/issues/10949,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10949/labels{/name},https://api.github.com/repos/dask/dask/issues/10949/comments,https://api.github.com/repos/dask/dask/issues/10949/events,https://github.com/dask/dask/issues/10949,2152435867,I_kwDOAbcwm86AS5Cb,10949,Issue repartitioning a time series by frequency when loaded from parquet file,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,5,2024-02-24T18:30:24Z,2024-04-04T12:56:22Z,,NONE,,"**Describe the issue**:

When loading a parquet file that has a datetime index, I can't repartition based on frequency, getting the following error:
```
Traceback (most recent call last):
  File ""/Users/.../gitrepos/dask-exp/test_dask_issue.py"", line 19, in <module>
    df2 = df2.repartition(freq=""1D"")
  File ""/Users/.../miniconda3/envs/dask/lib/python3.10/site-packages/dask_expr/_collection.py"", line 1184, in repartition
    raise TypeError(""Can only repartition on frequency for timeseries"")
TypeError: Can only repartition on frequency for timeseries
```
Despite the fact the loaded dataframe from parquet file having `datetime64[ns]` dtype.

Note that time series generator dataframe can be repartitioned by frequency.


**Minimal Complete Verifiable Example**:

```python
import dask
dask.config.set({'dataframe.query-planning': True})
import dask.dataframe as dd

df1 = dask.datasets.timeseries(
    start=""2000"",
    end=""2001"",
    freq=""1h"",
    seed=1,
)
df1 = df1.repartition(freq=""1ME"")
df1.to_parquet(""test"")

df2 = dd.read_parquet(
    ""test/*parquet"",
    index=""timestamp"",
    columns=[""x"", ""y""]
)
print(df2.index.dtype)
df2 = df2.repartition(freq=""1D"")
print(df2.compute())

```

**Anything else we need to know?**:

Looking to repartition data loaded via parquet for efficient time series based queries. Default partition results in larger than need memory bloatedness.

**Environment**:

- Dask version: 2024.2.1
- Python version: 3.10.13
- Operating System: Mac OSX
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10949/timeline,,,pvaezi,2073051,MDQ6VXNlcjIwNzMwNTE=,https://avatars.githubusercontent.com/u/2073051?v=4,,https://api.github.com/users/pvaezi,https://github.com/pvaezi,https://api.github.com/users/pvaezi/followers,https://api.github.com/users/pvaezi/following{/other_user},https://api.github.com/users/pvaezi/gists{/gist_id},https://api.github.com/users/pvaezi/starred{/owner}{/repo},https://api.github.com/users/pvaezi/subscriptions,https://api.github.com/users/pvaezi/orgs,https://api.github.com/users/pvaezi/repos,https://api.github.com/users/pvaezi/events{/privacy},https://api.github.com/users/pvaezi/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10949/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1006,https://api.github.com/repos/dask/dask/issues/10962,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10962/labels{/name},https://api.github.com/repos/dask/dask/issues/10962/comments,https://api.github.com/repos/dask/dask/issues/10962/events,https://github.com/dask/dask/issues/10962,2157029917,I_kwDOAbcwm86Akaod,10962,Drop pandas 1.X support?,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}]",open,False,,[],,1,2024-02-27T16:21:40Z,2024-03-14T09:51:16Z,,MEMBER,,"pandas 1.X has been released about 10 months ago and pandas 3.0 is on our doorstep. We're keeping a lot of compatibility code around, both in tests and in actual code. Additionally, we soon want to switch the default backend of `dask.dataframe` to `dask-expr` which **requires** `>=2.X`.

Therefore, I want to propose to drop support for 1.X with the next release.

Thoughts or concerns?",,https://api.github.com/repos/dask/dask/issues/10962/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10962/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1007,https://api.github.com/repos/dask/dask/issues/10980,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10980/labels{/name},https://api.github.com/repos/dask/dask/issues/10980/comments,https://api.github.com/repos/dask/dask/issues/10980/events,https://github.com/dask/dask/issues/10980,2171839358,I_kwDOAbcwm86Bc6N-,10980,Sparse masking throws error,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2024-03-06T15:52:19Z,2024-03-08T07:32:12Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
Computing a masked version of a sparse array throws an error on `compute`.  I am aware than sparse support may not be official but figured I'd report anyway.

**Minimal Complete Verifiable Example**:

```python
from scipy import sparse
import dask.array as da

X = sparse.random(10_000, 1_000, format=""csr"", density=0.1)
X_dask = da.from_array(X)
X_dask[X_dask > 0].compute()
X_dask[X_dask > 0] = 1000
X_dask.compute()
```

**Anything else we need to know?**:

I am happy to help with this (and other things we are loosely aware of surrounding sparse arrays) if you would accept a PR or investigation at least.

**Environment**:

- Dask version: 2024.2.1
- Python version:  3.9.18
- Operating System: Mac
- Install method (conda, pip, source): `pip`
",,https://api.github.com/repos/dask/dask/issues/10980/timeline,,,ilan-gold,43999641,MDQ6VXNlcjQzOTk5NjQx,https://avatars.githubusercontent.com/u/43999641?v=4,,https://api.github.com/users/ilan-gold,https://github.com/ilan-gold,https://api.github.com/users/ilan-gold/followers,https://api.github.com/users/ilan-gold/following{/other_user},https://api.github.com/users/ilan-gold/gists{/gist_id},https://api.github.com/users/ilan-gold/starred{/owner}{/repo},https://api.github.com/users/ilan-gold/subscriptions,https://api.github.com/users/ilan-gold/orgs,https://api.github.com/users/ilan-gold/repos,https://api.github.com/users/ilan-gold/events{/privacy},https://api.github.com/users/ilan-gold/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10980/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1008,https://api.github.com/repos/dask/dask/issues/10982,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10982/labels{/name},https://api.github.com/repos/dask/dask/issues/10982/comments,https://api.github.com/repos/dask/dask/issues/10982/events,https://github.com/dask/dask/issues/10982,2172886118,I_kwDOAbcwm86Bg5xm,10982,Dask Nunique bug under dask 2024.2.1,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,7,2024-03-07T03:50:10Z,2024-04-02T14:14:55Z,,NONE,,"Hello guys,
Take this CSV as an example dataframe. I am sorry but I could set an example dataframe by coding able to reproduce such bug
[teste.csv](https://github.com/dask/dask/files/14518393/teste.csv)

Now, lets open and execute the query on the example dataframe under dask 2023.10.0:

```
import dask.dataframe as dd
ddf = dd.read_csv('teste.csv', dtype = {'status':'category', 'produto':'category','parceiro':'category', 
                                            'mci' : 'Int32','marca':'category', 'sku' :'string', 'cod_transacao': 'string', 'forma_pagamento':'category',
                                            'gmv' : 'Float32', 'receita' : 'Float32', 'cashback':'Float32'})
base_consumo = ddf.groupby(['mci', 'marca'], dropna=False, observed=True)['marca'].nunique().to_frame()
base_consumo.head()
```
![image](https://github.com/dask/dask/assets/24688087/182e3baf-454d-40d7-ab01-04257cff45b7)

Runs ok!

Now, lets do the same test under dask 2024.2.1

```
import dask.dataframe as dd
ddf = dd.read_csv('teste.csv', dtype = {'status':'category', 'produto':'category','parceiro':'category', 
                                            'mci' : 'Int32','marca':'category', 'sku' :'string', 'cod_transacao': 'string', 'forma_pagamento':'category',
                                            'gmv' : 'Float32', 'receita' : 'Float32', 'cashback':'Float32'})
base_consumo = ddf.groupby(['mci', 'marca'], dropna=False, observed=True)['marca'].nunique().to_frame()
base_consumo.head()
```
```

---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
File [c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\dask\dataframe\utils.py:194](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:194), in raise_on_meta_error(funcname, udf)
    [193](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:193) try:
--> [194](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:194)     yield
    [195](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:195) except Exception as e:

File [c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\dask\dataframe\core.py:7174](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7174), in _emulate(func, udf, *args, **kwargs)
   [7173](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7173) with raise_on_meta_error(funcname(func), udf=udf), check_numeric_only_deprecation():
-> [7174](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7174)     return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))

File [c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\dask\dataframe\groupby.py:781](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:781), in _nunique_df_aggregate(df, levels, name, sort)
    [780](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:780) def _nunique_df_aggregate(df, levels, name, sort=False):
--> [781](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:781)     return df.groupby(level=levels, sort=sort, observed=True)[name].nunique()

File [c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\groupby\generic.py:1951](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/pandas/core/groupby/generic.py:1951), in DataFrameGroupBy.__getitem__(self, key)
   [1947](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/pandas/core/groupby/generic.py:1947)     raise ValueError(
   [1948](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/pandas/core/groupby/generic.py:1948)         ""Cannot subset columns with a tuple with more than one element. ""
   [1949](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/pandas/core/groupby/generic.py:1949)         ""Use a list instead.""
   [1950](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/pandas/core/groupby/generic.py:1950)     )
-> [1951](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/pandas/core/groupby/generic.py:1951) return super().__getitem__(key)

File [c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\base.py:244](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/pandas/core/base.py:244), in SelectionMixin.__getitem__(self, key)
    [243](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/pandas/core/base.py:243) if key not in self.obj:
--> [244](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/pandas/core/base.py:244)     raise KeyError(f""Column not found: {key}"")
    [245](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/pandas/core/base.py:245) ndim = self.obj[key].ndim

KeyError: 'Column not found: marca'

The above exception was the direct cause of the following exception:

ValueError                                Traceback (most recent call last)
Cell In[3], [line 1](vscode-notebook-cell:?execution_count=3&line=1)
----> [1](vscode-notebook-cell:?execution_count=3&line=1) base_consumo = ddf.groupby(['mci', 'marca'], dropna=False, observed=True)['marca'].nunique().to_frame()
      [2](vscode-notebook-cell:?execution_count=3&line=2) base_consumo.head()

File [c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\dask\dataframe\groupby.py:3078](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3078), in SeriesGroupBy.nunique(self, split_every, split_out)
   [3075](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3075) else:
   [3076](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3076)     chunk = _nunique_series_chunk
-> [3078](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3078) return aca(
   [3079](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3079)     [self.obj, self.by]
   [3080](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3080)     if not isinstance(self.by, list)
   [3081](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3081)     else [self.obj] + self.by,
   [3082](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3082)     chunk=chunk,
   [3083](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3083)     aggregate=_nunique_df_aggregate,
   [3084](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3084)     combine=_nunique_df_combine,
   [3085](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3085)     token=""series-groupby-nunique"",
   [3086](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3086)     chunk_kwargs={""levels"": levels, ""name"": name},
   [3087](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3087)     aggregate_kwargs={""levels"": levels, ""name"": name},
   [3088](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3088)     combine_kwargs={""levels"": levels},
   [3089](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3089)     split_every=split_every,
   [3090](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3090)     split_out=split_out,
   [3091](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3091)     split_out_setup=split_out_on_index,
   [3092](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3092)     sort=self.sort,
   [3093](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/groupby.py:3093) )

File [c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\dask\dataframe\core.py:7128](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7128), in apply_concat_apply(args, chunk, aggregate, combine, meta, token, chunk_kwargs, aggregate_kwargs, combine_kwargs, split_every, split_out, split_out_setup, split_out_setup_kwargs, sort, ignore_index, **kwargs)
   [7126](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7126) if meta is no_default:
   [7127](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7127)     meta_chunk = _emulate(chunk, *args, udf=True, **chunk_kwargs)
-> [7128](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7128)     meta = _emulate(
   [7129](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7129)         aggregate, _concat([meta_chunk], ignore_index), udf=True, **aggregate_kwargs
   [7130](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7130)     )
   [7131](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7131) meta = make_meta(
   [7132](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7132)     meta,
   [7133](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7133)     index=(getattr(make_meta(dfs[0]), ""index"", None) if dfs else None),
   [7134](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7134)     parent_meta=dfs[0]._meta,
   [7135](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7135) )
   [7137](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7137) graph = HighLevelGraph.from_collections(final_name, layer, dependencies=(chunked,))

File [c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\dask\dataframe\core.py:7173](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7173), in _emulate(func, udf, *args, **kwargs)
   [7168](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7168) def _emulate(func, *args, udf=False, **kwargs):
   [7169](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7169)     """"""
   [7170](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7170)     Apply a function using args / kwargs. If arguments contain dd.DataFrame /
   [7171](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7171)     dd.Series, using internal cache (``_meta``) for calculation
   [7172](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7172)     """"""
-> [7173](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7173)     with raise_on_meta_error(funcname(func), udf=udf), check_numeric_only_deprecation():
   [7174](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/core.py:7174)         return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))

File [c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\contextlib.py:158](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/contextlib.py:158), in _GeneratorContextManager.__exit__(self, typ, value, traceback)
    [156](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/contextlib.py:156)     value = typ()
    [157](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/contextlib.py:157) try:
--> [158](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/contextlib.py:158)     self.gen.throw(value)
    [159](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/contextlib.py:159) except StopIteration as exc:
    [160](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/contextlib.py:160)     # Suppress StopIteration *unless* it's the same exception that
    [161](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/contextlib.py:161)     # was passed to throw().  This prevents a StopIteration
    [162](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/contextlib.py:162)     # raised inside the ""with"" statement from being suppressed.
    [163](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/contextlib.py:163)     return exc is not value

File [c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\dask\dataframe\utils.py:215](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:215), in raise_on_meta_error(funcname, udf)
    [206](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:206) msg += (
    [207](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:207)     ""Original error is below:\n""
    [208](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:208)     ""------------------------\n""
   (...)
    [212](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:212)     ""{2}""
    [213](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:213) )
    [214](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:214) msg = msg.format(f"" in `{funcname}`"" if funcname else """", repr(e), tb)
--> [215](file:///C:/Users/fabio/AppData/Local/Programs/Python/Python312/Lib/site-packages/dask/dataframe/utils.py:215) raise ValueError(msg) from e

ValueError: Metadata inference failed in `_nunique_df_aggregate`.

You have supplied a custom function and Dask is unable to 
determine the type of output that that function returns. 

To resolve this please provide a meta= keyword.
The docstring of the Dask function you ran should have more information.

Original error is below:
------------------------
KeyError('Column not found: marca')

Traceback:
---------
  File ""c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\dask\dataframe\utils.py"", line 194, in raise_on_meta_error
    yield
  File ""c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\dask\dataframe\core.py"", line 7174, in _emulate
    return func(*_extract_meta(args, True), **_extract_meta(kwargs, True))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\dask\dataframe\groupby.py"", line 781, in _nunique_df_aggregate
    return df.groupby(level=levels, sort=sort, observed=True)[name].nunique()
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File ""c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\groupby\generic.py"", line 1951, in __getitem__
    return super().__getitem__(key)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File ""c:\Users\fabio\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\base.py"", line 244, in __getitem__
    raise KeyError(f""Column not found: {key}"")
```

**Environment**:

- Dask version: 2024.2.1
- Python version: 3.11.8 and 3.12.2
- Operating System: windows 11
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10982/timeline,,,frbelotto,24688087,MDQ6VXNlcjI0Njg4MDg3,https://avatars.githubusercontent.com/u/24688087?v=4,,https://api.github.com/users/frbelotto,https://github.com/frbelotto,https://api.github.com/users/frbelotto/followers,https://api.github.com/users/frbelotto/following{/other_user},https://api.github.com/users/frbelotto/gists{/gist_id},https://api.github.com/users/frbelotto/starred{/owner}{/repo},https://api.github.com/users/frbelotto/subscriptions,https://api.github.com/users/frbelotto/orgs,https://api.github.com/users/frbelotto/repos,https://api.github.com/users/frbelotto/events{/privacy},https://api.github.com/users/frbelotto/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10982/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1009,https://api.github.com/repos/dask/dask/issues/10991,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10991/labels{/name},https://api.github.com/repos/dask/dask/issues/10991/comments,https://api.github.com/repos/dask/dask/issues/10991/events,https://github.com/dask/dask/issues/10991,2178797517,I_kwDOAbcwm86B3c_N,10991,Combined save and calculation is using excessive memory,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,3,2024-03-11T10:39:33Z,2024-03-28T11:26:09Z,,NONE,,"Not clear if this is truly a ""bug"", but it seems highly undesirable + I can't work out how to avoid it

# Describe the issue:
We are trying to save large data arrays to file, and *at the same time* check the data for any occurrences of a given value
All while, hopefully, loading and processing each data chunk only once.

For each array, we use a `dask.delayed` function which takes as argument both the (delayed) `da.store` and the collision check computation on the same data.
But this seems to cause Dask to load the entire dataset into memory, 
which, for big enough data, simply crashes. 

### a bit more detail
When saving data to netcdf, we create a file and stream data from Dask arrays into the file variables with 'dask.array.store'.
( typically, out source data is also derived from netcdf files -- but this is not required to provoke the problem ).
We need at the same time to perform a check on the data, which determines whether there are any data points which are masked, or unmasked points matching a proposed ""fill value"".

Our existing code combines a delayed 'store' operation with computing the check function.
Since one is a ""store"" and one a ""compute"", they are combined by creating a delayed function which takes both as arguments.

The aim of this is that the data should only be fetched once, and streamed to the file one chunk at a time, so that we can handle files larger than memory.

What we have found is that in some cases, this operation is using memory equivalent to the size of the ***entire*** data variable, rather than a small number of its chunks

# Minimal Complete Verifiable Example

```python
import tracemalloc
import dask
import dask.array as da
import numpy as np

# construct test data as a stack of random arrays
nt, nd = 50, 1000000
lazydata_all = da.stack([
    da.random.uniform(
        0, 1,
        size=nd
    )
    for _ in range(nt)
])
# existing ""target"" array which we will store the result into
store_target = np.zeros((nt, nd), dtype=np.float64)

def array_size_mb(arr: np.ndarray):
    return arr.nbytes * 1.0e-6

print(f""\nData full size {str(lazydata_all.shape).rjust(16)} = {array_size_mb(lazydata_all):8.1f} Mib"")
print(f"" .. chunk size {str(lazydata_all[0].shape).rjust(16)} = {array_size_mb(lazydata_all[0]):8.1f} Mib"")

# Construct the combined store-and-calculate operation, as a delayed
@dask.delayed
def store_data_and_compute(store_operation, calculation):
    return calculation

delayed_save = da.store(lazydata_all, store_target, compute=False, lock=False)
lazy_calculation = lazydata_all[0, 0]
delayed_result = store_data_and_compute(delayed_save, lazy_calculation)

# Measure peak additional memory claimed by operations
def compute_memory_mb(delayed_calc):
    tracemalloc.start()
    delayed_calc.compute()
    _, peak_mem_bytes = tracemalloc.get_traced_memory()
    tracemalloc.stop()
    return peak_mem_bytes * 1.0e-6

print(""\nCombined calculation:"")
combined_operation_mb = compute_memory_mb(delayed_result)
chunk_mb = array_size_mb(lazydata_all[0])
print(f""Consumed memory ~ {combined_operation_mb:6.2f} Mb."")
print(f""  --> {combined_operation_mb / chunk_mb:.1f} * chunksize"")

```
Sample output :
```
Data full size    (50, 1000000) =    400.0 Mib
 .. chunk size       (1000000,) =      8.0 Mib

Combined calculation:
Consumed memory ~ 400.25 Mb.
  --> 50.0 * chunksize
``` 

### NOTE: the individual operations (store or calculate) do ***not*** consume large amounts of memory
```
store_only_mb = compute_memory_mb(delayed_save)
print(f""\nStore alone, takes {store_only_mb} Mb."")
calc_only_mb = compute_memory_mb(lazy_calculation)
print(f""Calculate alone, takes {calc_only_mb} Mb."")
```
Resulting
```
Store alone, takes 32.230089 Mb.
Calculate alone, takes 8.018998 Mb.
```
**NOTE:** this on a machine with 4 CPUs, 4 dask workers
Hence 32 ~4*8, seems to makes sense

## Anything else we need to know?
### Environment

- Dask version: 2023.09.01 and 2024.02.01
- Python version: 3.11
- Operating System: linux
- Machine : 4 CPUs
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/10991/timeline,,,pp-mo,2089069,MDQ6VXNlcjIwODkwNjk=,https://avatars.githubusercontent.com/u/2089069?v=4,,https://api.github.com/users/pp-mo,https://github.com/pp-mo,https://api.github.com/users/pp-mo/followers,https://api.github.com/users/pp-mo/following{/other_user},https://api.github.com/users/pp-mo/gists{/gist_id},https://api.github.com/users/pp-mo/starred{/owner}{/repo},https://api.github.com/users/pp-mo/subscriptions,https://api.github.com/users/pp-mo/orgs,https://api.github.com/users/pp-mo/repos,https://api.github.com/users/pp-mo/events{/privacy},https://api.github.com/users/pp-mo/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10991/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1010,https://api.github.com/repos/dask/dask/issues/10992,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10992/labels{/name},https://api.github.com/repos/dask/dask/issues/10992/comments,https://api.github.com/repos/dask/dask/issues/10992/events,https://github.com/dask/dask/pull/10992,2179706050,PR_kwDOAbcwm85pRkOU,10992,Implement setting config variables that contain the dot in name,[],open,False,,[],,2,2024-03-11T17:18:06Z,2024-03-13T14:50:07Z,,FIRST_TIME_CONTRIBUTOR,,"- [x] Closes https://github.com/dask/distributed/issues/8570
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

These changes add the possibility of setting config variables that contain `.` in the name.

Using env variables:
```
DASK_DISTRIBUTED__LOGGING__DISTRIBUTED=info
DASK_DISTRIBUTED__LOGGING__DISTRIBUTED--CLIENT=info
DASK_DISTRIBUTED__LOGGING__DISTRIBUTED--SCHEDULER=info
DASK_DISTRIBUTED__LOGGING__DISTRIBUTED--SHUFFLE=info
```
Using `set(...)`:
```python
dask.config.set({
  'distributed.logging.distributed': 'info',
  'distributed.logging.distributed__client': 'info',
  'distributed.logging.distributed__scheduler': 'info',
  'distributed.logging.distributed__shuffle': 'info',
})
```
Both options results into the following configuration:
```python
dask.config.get(""distributed.logging"")
```
```
{'distributed': 'info', 'distributed.client': 'info', 'distributed.scheduler': 'info', 'distributed.shuffle': 'info'}
```


# Discussion
I see how we can avoid adjusting `dask.config.set()` logic by improving `collect_env()`.
",,https://api.github.com/repos/dask/dask/issues/10992/timeline,,,dbalabka,1269372,MDQ6VXNlcjEyNjkzNzI=,https://avatars.githubusercontent.com/u/1269372?v=4,,https://api.github.com/users/dbalabka,https://github.com/dbalabka,https://api.github.com/users/dbalabka/followers,https://api.github.com/users/dbalabka/following{/other_user},https://api.github.com/users/dbalabka/gists{/gist_id},https://api.github.com/users/dbalabka/starred{/owner}{/repo},https://api.github.com/users/dbalabka/subscriptions,https://api.github.com/users/dbalabka/orgs,https://api.github.com/users/dbalabka/repos,https://api.github.com/users/dbalabka/events{/privacy},https://api.github.com/users/dbalabka/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10992/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/10992,https://github.com/dask/dask/pull/10992,https://github.com/dask/dask/pull/10992.diff,https://github.com/dask/dask/pull/10992.patch,,,,,,,,,,,,,,,,,,,
1011,https://api.github.com/repos/dask/dask/issues/10994,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10994/labels{/name},https://api.github.com/repos/dask/dask/issues/10994/comments,https://api.github.com/repos/dask/dask/issues/10994/events,https://github.com/dask/dask/issues/10994,2180593385,I_kwDOAbcwm86B-Tbp,10994,Array API in Dask,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-03-12T02:26:43Z,2024-03-12T02:26:57Z,,NONE,,"Hey,
I've been working on getting array API support in dask, via array-api-compat.

This mostly works - in fact, I've been able to get some estimators in scikit-learn that support array API to work with dask, but there are some nasty bugs that I've encountered both in scikit-learn, and in general running the array API tests.

Is there anyone on the dask team that's willing to help me work through these issues?
",,https://api.github.com/repos/dask/dask/issues/10994/timeline,,,lithomas1,47963215,MDQ6VXNlcjQ3OTYzMjE1,https://avatars.githubusercontent.com/u/47963215?v=4,,https://api.github.com/users/lithomas1,https://github.com/lithomas1,https://api.github.com/users/lithomas1/followers,https://api.github.com/users/lithomas1/following{/other_user},https://api.github.com/users/lithomas1/gists{/gist_id},https://api.github.com/users/lithomas1/starred{/owner}{/repo},https://api.github.com/users/lithomas1/subscriptions,https://api.github.com/users/lithomas1/orgs,https://api.github.com/users/lithomas1/repos,https://api.github.com/users/lithomas1/events{/privacy},https://api.github.com/users/lithomas1/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10994/reactions,1,0,0,0,0,0,1,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1012,https://api.github.com/repos/dask/dask/issues/10995,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10995/labels{/name},https://api.github.com/repos/dask/dask/issues/10995/comments,https://api.github.com/repos/dask/dask/issues/10995/events,https://github.com/dask/dask/issues/10995,2181216069,I_kwDOAbcwm86CArdF,10995,Feedback - DataFrame query planning,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 1372867996, 'node_id': 'MDU6TGFiZWwxMzcyODY3OTk2', 'url': 'https://api.github.com/repos/dask/dask/labels/discussion', 'name': 'discussion', 'color': 'bebaf4', 'default': False, 'description': 'Discussing a topic with no specific actions yet'}, {'id': 6649512058, 'node_id': 'LA_kwDOAbcwm88AAAABjFeAeg', 'url': 'https://api.github.com/repos/dask/dask/labels/dask-expr', 'name': 'dask-expr', 'color': 'FBCA04', 'default': False, 'description': ''}]",open,False,,[],,15,2024-03-12T10:07:17Z,2024-06-04T10:54:50Z,,MEMBER,,"The latest release `2024.3.0` enabled query planning for `DataFrame`s by default. This issue can be used to report feedback and ask related questions.

If you encountered a bug or unexpected behavior, please check if you got the most recent version of `dask-expr` installed. This is a separate package with a decoupled release process allowing us to roll out hotfixes quickly.
If you are still encountering issues after an update, please open an issue with a reproducer and we will respond as soon as possible.

See below for a list of known issues and/or check the [issue tracker](https://github.com/dask/dask/issues?q=is%3Aopen+is%3Aissue+label%3Adask-expr)

## Brief introduction

The legacy DataFrame implementation did not offer a way to optimize your query and `dask` executed whatever you requested literally. In many situations this was suboptimal and could cause significant performance overhead.

Let's take a simple example by using the NYC Uber/Lyft dataset

```python
df = read_parquet(
    ""s3://coiled-datasets/uber-lyft-tlc/"",
    filesystem='pyarrow',
)
df = df[df.hvfhs_license_num == ""HV0003""] 
result = df.sum(numeric_only=True)[""tips""]

```

This query loads the data, applies a filter on the vendor, calculates a sum and picks a single column for the result. The legacy `DataFrame` would load **all** data, only then apply the filter, compute the sum over all columns and then throw all the data away since we're only interested in a single column.

Advanced users may be tempted to rewrite this to an optimized version that provides the required columns and filters to the ``read_parquet`` call already but this is now done automatically for you. After optimization, the above query is identical to

```python
df_man_opt = dd.read_parquet(
    ""s3://coiled-datasets/uber-lyft-tlc/"",
    columns=[""tips""],
    filters=[(""hvfhs_license_num"", ""=="", ""HV0003"")],
)
result_man_opt = df_man_opt.sum(numeric_only=True)
```

which loads only the required columns from storage and applies filters even on rowgroup level, if applicable.

```python
result.simplify().pprint()

Projection: columns='tips'
  Sum: numeric_only=True
    ReadParquetPyarrowFS: path='s3://coiled-datasets/uber-lyft-tlc/' columns=['tips'] filters=[[('hvfhs_license_num', '==', 'HV0003')]] filesystem='pyarrow'
```

Column projection and predicate pushdown are only some of the most obvious optimizations that are performed automaticaly for you.

See for yourself and let us know what you think.


## Known issues

### `dask-expr` is not installed when updating dask

When using a package manager like `pip` it can happen that an upgrade like `pip update dask` does not pull in the extra dependencies of `dask.dataframe`. To ensure all dependencies are installed, please install `dask[dataframe]` or use `conda install dask`

### Pandas copy-on-write enabled as an import side effect

Prior to version dask-expr==1.0.2, importing dask.dataframe set the pandas option copy-on-write to True

See also https://github.com/dask/dask/issues/10996",,https://api.github.com/repos/dask/dask/issues/10995/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10995/reactions,8,6,0,0,0,0,2,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1013,https://api.github.com/repos/dask/dask/issues/10998,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/10998/labels{/name},https://api.github.com/repos/dask/dask/issues/10998/comments,https://api.github.com/repos/dask/dask/issues/10998/events,https://github.com/dask/dask/issues/10998,2182806957,I_kwDOAbcwm86CGv2t,10998,dask.bag.Bag.to_dataframe behavior change in 2024.3.0 - setting dtype to string rather than object by default,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 6137710172, 'node_id': 'LA_kwDOAbcwm88AAAABbdYGXA', 'url': 'https://api.github.com/repos/dask/dask/labels/convert-string', 'name': 'convert-string', 'color': 'd93f0b', 'default': False, 'description': ''}]",open,False,,[],,4,2024-03-12T22:43:31Z,2024-03-14T09:50:17Z,,NONE,,"**Describe the issue**:

Since the last update dask bag's  to_dataframe generates data frames with a string dtype by default rather than object

**Minimal Complete Verifiable Example**:

```python
>>> import dask.bag as db
>>> import pandas as pd
>>> pd.DataFrame.from_records([{""obj"": range(2)}]).info()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1 entries, 0 to 0
Data columns (total 1 columns):
 #   Column  Non-Null Count  Dtype 
---  ------  --------------  ----- 
 0   obj     1 non-null      object
dtypes: object(1)
memory usage: 140.0+ bytes
>>> db.from_sequence([{""obj"": range(2)}]).to_dataframe().compute().info()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1 entries, 0 to 0
Data columns (total 1 columns):
 #   Column  Non-Null Count  Dtype 
---  ------  --------------  ----- 
 0   obj     1 non-null      string
dtypes: string(1)
memory usage: 151.0 bytes
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2024.3.0
- Python version: 3.11.8
- Operating System: MacOS 14.3.1
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/10998/timeline,,,kbuma,2824957,MDQ6VXNlcjI4MjQ5NTc=,https://avatars.githubusercontent.com/u/2824957?v=4,,https://api.github.com/users/kbuma,https://github.com/kbuma,https://api.github.com/users/kbuma/followers,https://api.github.com/users/kbuma/following{/other_user},https://api.github.com/users/kbuma/gists{/gist_id},https://api.github.com/users/kbuma/starred{/owner}{/repo},https://api.github.com/users/kbuma/subscriptions,https://api.github.com/users/kbuma/orgs,https://api.github.com/users/kbuma/repos,https://api.github.com/users/kbuma/events{/privacy},https://api.github.com/users/kbuma/received_events,User,False,https://api.github.com/repos/dask/dask/issues/10998/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1014,https://api.github.com/repos/dask/dask/issues/11004,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11004/labels{/name},https://api.github.com/repos/dask/dask/issues/11004/comments,https://api.github.com/repos/dask/dask/issues/11004/events,https://github.com/dask/dask/pull/11004,2186861862,PR_kwDOAbcwm85pqGuQ,11004,Ensure that repack collections only return tuple if necessary,[],open,False,,[],,3,2024-03-14T17:06:18Z,2024-03-14T18:12:21Z,,MEMBER,,"I hit this more often than I'd care to admit when trying to write the dask-expr scheduler integration. This integration inevitably has to touch the code that is dealing with collections parsing and this is part of it.

What's most concerning is that this unpack/repack code is not used consequently such that the unpack/repack in distributed, for instance, is behaving differently than the dask/dask equivalents.

Most endusers will notice this change iff they are using base functions `optimize`, `persist`, `compute`, etc. Most users will not interact with this but instead with the methods on the collections.

```python
# before will always return a tuple no matter what
(d_opt,) = dask.optimize(d)

# With this PR
d_opt = dask.optimize(d)
```

This will help me streamline implementation a little and I'm sure that new users will appreciate this. However, I'm very certain this will cause mild breakage somewhere.",,https://api.github.com/repos/dask/dask/issues/11004/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11004/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/11004,https://github.com/dask/dask/pull/11004,https://github.com/dask/dask/pull/11004.diff,https://github.com/dask/dask/pull/11004.patch,,,,,,,,,,,,,,,,,,,
1015,https://api.github.com/repos/dask/dask/issues/11017,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11017/labels{/name},https://api.github.com/repos/dask/dask/issues/11017/comments,https://api.github.com/repos/dask/dask/issues/11017/events,https://github.com/dask/dask/issues/11017,2202981829,I_kwDOAbcwm86DTtXF,11017,``new_dd_object``'s array logic always assumes the metadata is ``numpy``,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2024-03-22T17:32:26Z,2024-04-04T12:53:07Z,,MEMBER,,"There is a subtle limitation in the `new_dd_object` logic used to produce a `dask.array.Array` collection (important logic is [here](https://github.com/dask/dask/blob/f9310c440b661f1ae96ffd8726404d3c3fe32edc/dask/dataframe/core.py#L8518)).

```python
import cudf
import dask.dataframe as dd

s = cudf.Series(range(10))
ds = dd.from_pandas(s, 1)

def func(x):
    return x.values

meta = func(s)
result = ds.map_partitions(func, meta=meta)

assert type(result._meta) == type(meta)  # Fails, because meta is always a numpy array
assert type(result.compute()) == type(meta)  # Passes
```",,https://api.github.com/repos/dask/dask/issues/11017/timeline,,,rjzamora,20461013,MDQ6VXNlcjIwNDYxMDEz,https://avatars.githubusercontent.com/u/20461013?v=4,,https://api.github.com/users/rjzamora,https://github.com/rjzamora,https://api.github.com/users/rjzamora/followers,https://api.github.com/users/rjzamora/following{/other_user},https://api.github.com/users/rjzamora/gists{/gist_id},https://api.github.com/users/rjzamora/starred{/owner}{/repo},https://api.github.com/users/rjzamora/subscriptions,https://api.github.com/users/rjzamora/orgs,https://api.github.com/users/rjzamora/repos,https://api.github.com/users/rjzamora/events{/privacy},https://api.github.com/users/rjzamora/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11017/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1016,https://api.github.com/repos/dask/dask/issues/11018,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11018/labels{/name},https://api.github.com/repos/dask/dask/issues/11018/comments,https://api.github.com/repos/dask/dask/issues/11018/events,https://github.com/dask/dask/issues/11018,2204040205,I_kwDOAbcwm86DXvwN,11018,`vindex` as outer indexer: memory and time performance,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}, {'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-03-23T20:41:48Z,2024-04-04T12:52:47Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

Emulating outerindexing via `vindex` + `np.ix_` appears to be much slower and more memory intensive (prohibitively so for very large arrays where for an 1,000,000x1,000,000 array, it tried allocating 1.5TB of memory) than twice indexing.   I know this is basically stated in the docs, but maybe there is something to be done here? If not, feel free to close.

**Minimal Complete Verifiable Example**:

```python
%load_ext memory_profiler

import dask.array as da
import numpy as np
import scipy as sp

chunksize = 100
size = 10_000
n_points = 5000

X = da.random.poisson(15, (size, size), chunks = (chunksize, chunksize))

index_0 = np.random.randint(0, X.shape[0], n_points)
index_0.sort()
index_1 = np.random.randint(0, X.shape[1], n_points)
index_1.sort()

print('vindex timing:')
%timeit X.vindex[np.ix_(index_0, index_1)].compute()
print('vindex memory usage:')
%memit X.vindex[np.ix_(index_0, index_1)]
print('double-index timing:')
%timeit X[index_0, :][:, index_1].compute()
print('double-index memory usage:')
%memit X[index_0, :][:, index_1]
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2024.3.1
- Python version: 3.12
- Operating System: mac
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/11018/timeline,,,ilan-gold,43999641,MDQ6VXNlcjQzOTk5NjQx,https://avatars.githubusercontent.com/u/43999641?v=4,,https://api.github.com/users/ilan-gold,https://github.com/ilan-gold,https://api.github.com/users/ilan-gold/followers,https://api.github.com/users/ilan-gold/following{/other_user},https://api.github.com/users/ilan-gold/gists{/gist_id},https://api.github.com/users/ilan-gold/starred{/owner}{/repo},https://api.github.com/users/ilan-gold/subscriptions,https://api.github.com/users/ilan-gold/orgs,https://api.github.com/users/ilan-gold/repos,https://api.github.com/users/ilan-gold/events{/privacy},https://api.github.com/users/ilan-gold/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11018/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1017,https://api.github.com/repos/dask/dask/issues/11019,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11019/labels{/name},https://api.github.com/repos/dask/dask/issues/11019/comments,https://api.github.com/repos/dask/dask/issues/11019/events,https://github.com/dask/dask/issues/11019,2204204903,I_kwDOAbcwm86DYX9n,11019,Hash join transfer with error cannot pickle '_contextvars.ContextVar' object,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 3798450416, 'node_id': 'LA_kwDOAbcwm87iZ8Dw', 'url': 'https://api.github.com/repos/dask/dask/labels/p2', 'name': 'p2', 'color': 'ffc133', 'default': False, 'description': ""Affects more than a few users but doesn't prevent core functions""}]",open,False,,[],,6,2024-03-24T06:37:20Z,2024-04-12T09:15:18Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
Hi
I encountered this error, and don't know what happened under the hood. Therefore, I open it for better tracking.

I have some spatial datasets in parquet format with row group size 64MB that contains nodes and coordinates. I never intend to do any re-partition or shuffle operations, but it could happen during merge, or set index operation, etc.. The hash join issue was found with the dataset bigger more than one row group size enough to create few partitions in dataframe on hash join operations. The error always showed with hash-join-transfer-xxxxxxxxx operation.

To workaround this issue, i changed shuffle method back to ""tasks"".

***Error messages:***
```
Traceback (most recent call last):
  File ""/opt/project/src/main/python/utils/shuffle_test.py"", line 52, in <module>
    main()
  File ""/opt/project/src/main/python/utils/shuffle_test.py"", line 48, in main
    print(nodes[""longitude""].compute())
  File ""/usr/local/lib/python3.10/dist-packages/dask/base.py"", line 375, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File ""/usr/local/lib/python3.10/dist-packages/dask/base.py"", line 661, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/usr/local/lib/python3.10/dist-packages/loky/process_executor.py"", line 370, in _sendback_result
    result_queue.put(
  File ""/usr/local/lib/python3.10/dist-packages/loky/backend/queues.py"", line 230, in put
    obj = dumps(obj, reducers=self._reducers)
  File ""/usr/local/lib/python3.10/dist-packages/loky/backend/reduction.py"", line 215, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File ""/usr/local/lib/python3.10/dist-packages/loky/backend/reduction.py"", line 208, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File ""/usr/local/lib/python3.10/dist-packages/cloudpickle/cloudpickle.py"", line 1245, in dump
    return super().dump(obj)
TypeError: cannot pickle '_contextvars.ContextVar' object

```

**Minimal Complete Verifiable Example**:

```python
import faulthandler
import logging
from concurrent.futures import ThreadPoolExecutor

import dask
import dask.dataframe as dd

from distributed import WorkerPlugin, Worker, LocalCluster, Client, progress, wait
from loky import ProcessPoolExecutor


class TaskExecutorPool(WorkerPlugin):
    def __init__(self, logger, name):
        self.logger = logger
        self.worker = None
        self.name = name

    def setup(self, worker: Worker):
        faulthandler.enable()
        executor = ProcessPoolExecutor(max_workers=worker.state.nthreads)
        worker.executors[self.name] = executor
        self.worker = worker

    def transition(self, key, start, finish, *args, **kwargs):
        if finish == 'error':
            ts = self.worker.tasks[key]
            exc_info = (type(ts.exception), ts.exception, ts.traceback)
            print(f""Task traceback: {ts.traceback}"")
            print(f""Task exception: {exc_info}"")
            self.logger.error(f""Error during computation of {key}, caused by {str(ts.exception)}."")


def main():
    cluster = LocalCluster(processes=False, silence_logs=logging.DEBUG)
    with Client(cluster) as client:
        client.register_plugin(TaskExecutorPool(logging, ""process""), name=""process"")
        with dask.annotate(executor=""process"", retries=10):
            nodes = dd.read_parquet(""node parquet file with multiple row group size"", columns=[""id"", ""tags""])
            node_coordinates = dd.read_parquet(""node parquet file with multiple row group size""
                                               , columns=[""id"", ""latitude"", ""longitude""])
            
            # This re-partition operation can make different partitions to nodes, and later merge operation will have hash join operation inside to make error showed more often
            node_coordinates = node_coordinates.repartition(partition_size=""some size"")
            nodes = nodes.merge(
                node_coordinates, how=""left"", left_on=[""id""], right_on=[""id""], suffixes=(False, False), shuffle_method=""p2p"")
            client.persist(nodes)
            progress(nodes)
            print(nodes[""latitude""].compute())


if __name__ == ""__main__"":
    main()
```

**Anything else we need to know?**:

**Environment**:

- Dask version: 2024.2.1
- Python version: 3.10
- Operating System: Docker installed Ubuntu 22.04, Host is also Ubuntu 22.04
- Install method (conda, pip, source):
  loky 3.4.1
",,https://api.github.com/repos/dask/dask/issues/11019/timeline,,,guozhans,9510342,MDQ6VXNlcjk1MTAzNDI=,https://avatars.githubusercontent.com/u/9510342?v=4,,https://api.github.com/users/guozhans,https://github.com/guozhans,https://api.github.com/users/guozhans/followers,https://api.github.com/users/guozhans/following{/other_user},https://api.github.com/users/guozhans/gists{/gist_id},https://api.github.com/users/guozhans/starred{/owner}{/repo},https://api.github.com/users/guozhans/subscriptions,https://api.github.com/users/guozhans/orgs,https://api.github.com/users/guozhans/repos,https://api.github.com/users/guozhans/events{/privacy},https://api.github.com/users/guozhans/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11019/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1018,https://api.github.com/repos/dask/dask/issues/11021,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11021/labels{/name},https://api.github.com/repos/dask/dask/issues/11021/comments,https://api.github.com/repos/dask/dask/issues/11021/events,https://github.com/dask/dask/issues/11021,2205755857,I_kwDOAbcwm86DeSnR,11021,Preserving divisions when reading/loading dataframes with structs containing multiple fields,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 365513534, 'node_id': 'MDU6TGFiZWwzNjU1MTM1MzQ=', 'url': 'https://api.github.com/repos/dask/dask/labels/io', 'name': 'io', 'color': '6f871c', 'default': False, 'description': ''}]",open,False,,[],,1,2024-03-25T13:21:46Z,2024-04-04T12:51:48Z,,NONE,,"Hi, 

We're facing issue preserving divisions when writing pyarrow structs containing multiple fields, this is better illustrated in the following example: 

```python
data = {
    'id': [""01"", ""02"", ""03"", ""04"", ""05"", ""06"", ""07"", ""08"", ""09"", ""10""],
    'A': [11, 12, 13, 14, 15, 16, 17, 18, 19, 20],

}
df = pd.DataFrame(data)

# Create a Dask DataFrame
ddf = dd.from_pandas(df, npartitions=3)  # Set the number of partitions

# Sort the index
ddf = ddf.set_index('id', drop=True, sorted=True)


def add_nested_struct_multiple_fields(rows):

    example_dict = {
        ""foo"": ""foo"",
        ""bar"": ""bar"",
    }

    return [example_dict, example_dict]

def transform_multiple_fields(dataframe):

    dataframe[""nested_struct""] = dataframe.apply(add_nested_struct_multiple_fields, axis=1)
    
    return dataframe

nested_struct_multiple_fields_schema = pa.list_(
            pa.struct(
                [
                    pa.field(""foo"", pa.string()),
                    pa.field(""bar"", pa.string()),
                ],
        )
)

def create_meta_dict(nested_struct_schema):
    meta_dict = {""id"": pd.Series(dtype=""object"")}
    meta_dict[""A""] = pd.Series(dtype=pd.ArrowDtype(pa.int32()))
    meta_dict[""nested_struct""] = pd.Series(dtype=pd.ArrowDtype(nested_struct_schema))
    meta_df = pd.DataFrame(meta_dict).set_index(""id"")

    return meta_df


schema_nested_struct_multiple_fields = {
    ""A"":pa.int32(),
    ""nested_struct"":nested_struct_multiple_fields_schema
}

ddf_multiple_fields = ddf.map_partitions(
    transform_multiple_fields,
    meta=nested_struct_multiple_fields_meta,
)

ddf_multiple_fields.known_divisions
-> True # Divisions are still preserved before writing 

dd.to_parquet(ddf_multiple_fields, ""multiple_fields"", schema=schema_nested_struct_multiple_fields)

dd.read_parquet(path=""multiple_fields"", index=""id"", calculate_divisions=True).known_divisions
-> False # Division are not known after reading the saved dataframe again 
```

Here, we are writing two new fields (""foo"", ""bar""), when reading the parquet file again, the divisions are not preserved. Oddly enough this does not seem to occur when only one field is added to the struct. See [this notebook](https://colab.research.google.com/drive/1-aAeaU9yZYT7Qguh9EeNO5Gg8Y7A4nHn?usp=sharing) for more clarity on the issue where we compare both scenarios. 

Could you please provide clarity on the issue? Thanks in advance! 

**Environment**:

- Dask version: 2024.2.1
- Python version: 3.11
- Operating System: Linux
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/11021/timeline,,,PhilippeMoussalli,47530815,MDQ6VXNlcjQ3NTMwODE1,https://avatars.githubusercontent.com/u/47530815?v=4,,https://api.github.com/users/PhilippeMoussalli,https://github.com/PhilippeMoussalli,https://api.github.com/users/PhilippeMoussalli/followers,https://api.github.com/users/PhilippeMoussalli/following{/other_user},https://api.github.com/users/PhilippeMoussalli/gists{/gist_id},https://api.github.com/users/PhilippeMoussalli/starred{/owner}{/repo},https://api.github.com/users/PhilippeMoussalli/subscriptions,https://api.github.com/users/PhilippeMoussalli/orgs,https://api.github.com/users/PhilippeMoussalli/repos,https://api.github.com/users/PhilippeMoussalli/events{/privacy},https://api.github.com/users/PhilippeMoussalli/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11021/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1019,https://api.github.com/repos/dask/dask/issues/11022,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11022/labels{/name},https://api.github.com/repos/dask/dask/issues/11022/comments,https://api.github.com/repos/dask/dask/issues/11022/events,https://github.com/dask/dask/issues/11022,2206187361,I_kwDOAbcwm86Df79h,11022,Incorrect shape computation with getitem and structured numpy array,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2024-03-25T16:37:39Z,2024-04-04T12:51:36Z,,NONE,,"Dear all,

When trying to access an element from a numpy structured array in dask, the dask array shape is not correctly estimated. 

On my real world use case, I try to read lazily from a binary file using np.frombuffer/dask and then save my variables in a xarray dataset.

Thanks,

```python
import dask.array as da
import numpy as np

buffer = da.random.randint(10,size=(100,4), dtype=np.uint8)
structured_array = da.map_blocks(np.frombuffer, buffer, "">H, >B, >B"", dtype="">H, >B, >B"")
print(structured_array[""f1""].shape)  # print (100, 4), not ok
print(structured_array[""f1""].compute().shape)  # print (100,), ok
```

**Environment**:

- Dask version: '2023.11.0'
- Python version: 3.12.2
- Operating System: Ubuntu 22.04.4 LTS
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/11022/timeline,,,louisletoumelin,50922714,MDQ6VXNlcjUwOTIyNzE0,https://avatars.githubusercontent.com/u/50922714?v=4,,https://api.github.com/users/louisletoumelin,https://github.com/louisletoumelin,https://api.github.com/users/louisletoumelin/followers,https://api.github.com/users/louisletoumelin/following{/other_user},https://api.github.com/users/louisletoumelin/gists{/gist_id},https://api.github.com/users/louisletoumelin/starred{/owner}{/repo},https://api.github.com/users/louisletoumelin/subscriptions,https://api.github.com/users/louisletoumelin/orgs,https://api.github.com/users/louisletoumelin/repos,https://api.github.com/users/louisletoumelin/events{/privacy},https://api.github.com/users/louisletoumelin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11022/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1020,https://api.github.com/repos/dask/dask/issues/11026,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11026/labels{/name},https://api.github.com/repos/dask/dask/issues/11026/comments,https://api.github.com/repos/dask/dask/issues/11026/events,https://github.com/dask/dask/issues/11026,2209247883,I_kwDOAbcwm86DrnKL,11026,"Poor scheduling with `flox`, leading to high memory usage and eventual failure","[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,13,2024-03-26T20:26:49Z,2024-06-06T15:36:19Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

When performing aggregation with flox, I quickly run out of memory, regardless of the size of a chunk.

It appears that lower nodes (loading data) keep getting run while higher nodes (reduction) sit un-computed.

Opening here as requested in:

* https://github.com/xarray-contrib/flox/issues/346

cc: @dcherian 

**Minimal Complete Verifiable Example**:

```python
import dask.distributed as dd
import dask.array as da
import numpy as np
import flox

cluster = dd.LocalCluster(n_workers=3)
client = dd.Client(cluster)

M, N = 1_000_000, 20_000

# Note that it doesn't seem to matter where X comes from.
# In my real-world use case, it is either generated from `map_blocks` or 
# read directly from a zarr store
X = da.random.normal(size=(M, N), chunks=(5_000, N))
by = np.random.choice(2_000, size=M)

res, codes = flox.groupby_reduce(
    X.T,
    by,
    func=""sum"",
    fill_value=0,
    method=""map-reduce"",
    reindex=True,
)

res_comp = res.compute()
```

**Anything else we need to know?**:


<details>
<summary> As an example, here's how my task graph completes if I run `X.sum(axis=0).compute()` </summary>

<img width=""500"" alt=""image"" src=""https://github.com/dask/dask/assets/8238804/e79e698e-ee21-4732-a856-19c3918492b6"">

</details>



<details>
<summary> Whereas `res.compute()` ends up with something more like: </summary>


<img width=""500"" alt=""image"" src=""https://github.com/dask/dask/assets/8238804/2ba8f855-52db-42d5-81a0-df294161ae1d"">

<img width=""500"" alt=""image"" src=""https://github.com/dask/dask/assets/8238804/cc2d6aec-f134-4c75-a752-e93f5480d576"">



</details>


**Environment**:

- Dask version: '2024.3.1'
- Python version: Python 3.11.7 | packaged by conda-forge | (main, Dec 23 2023, 14:43:09) [GCC 12.3.0]
- Operating System: ubuntu (but can replicate on mac)
- Install method (conda, pip, source): pip (in conda env)


",,https://api.github.com/repos/dask/dask/issues/11026/timeline,,,ivirshup,8238804,MDQ6VXNlcjgyMzg4MDQ=,https://avatars.githubusercontent.com/u/8238804?v=4,,https://api.github.com/users/ivirshup,https://github.com/ivirshup,https://api.github.com/users/ivirshup/followers,https://api.github.com/users/ivirshup/following{/other_user},https://api.github.com/users/ivirshup/gists{/gist_id},https://api.github.com/users/ivirshup/starred{/owner}{/repo},https://api.github.com/users/ivirshup/subscriptions,https://api.github.com/users/ivirshup/orgs,https://api.github.com/users/ivirshup/repos,https://api.github.com/users/ivirshup/events{/privacy},https://api.github.com/users/ivirshup/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11026/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1021,https://api.github.com/repos/dask/dask/issues/11042,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11042/labels{/name},https://api.github.com/repos/dask/dask/issues/11042/comments,https://api.github.com/repos/dask/dask/issues/11042/events,https://github.com/dask/dask/issues/11042,2234556645,I_kwDOAbcwm86FMKDl,11042,Add determinant(like scipy.linalg.det/slogdet) to dask.array.linalg,"[{'id': 242862305, 'node_id': 'MDU6TGFiZWwyNDI4NjIzMDU=', 'url': 'https://api.github.com/repos/dask/dask/labels/array', 'name': 'array', 'color': '006b75', 'default': False, 'description': None}]",open,False,,[],,0,2024-04-10T01:03:15Z,2024-04-11T23:41:22Z,,NONE,,"Just opening this issue to track missing bits from the array API missing in scikit-learn.

There's only one use of ``det``/``slogdet`` in scikit-learn, but I figured others might want to be able to do determinants in dask.

I think this can be implemented by doing a PLU decomp and then getting the determinant of the ``P`` matrix, and the product of diagonals of ``L`` and ``U``.

Calculating the determinant of ``P`` (or more precisely its sign) doesn't seem to be easy, though.
(Maybe pivots, like ``scipy.linalg.lu_factor`` provides are needed?)",,https://api.github.com/repos/dask/dask/issues/11042/timeline,,,lithomas1,47963215,MDQ6VXNlcjQ3OTYzMjE1,https://avatars.githubusercontent.com/u/47963215?v=4,,https://api.github.com/users/lithomas1,https://github.com/lithomas1,https://api.github.com/users/lithomas1/followers,https://api.github.com/users/lithomas1/following{/other_user},https://api.github.com/users/lithomas1/gists{/gist_id},https://api.github.com/users/lithomas1/starred{/owner}{/repo},https://api.github.com/users/lithomas1/subscriptions,https://api.github.com/users/lithomas1/orgs,https://api.github.com/users/lithomas1/repos,https://api.github.com/users/lithomas1/events{/privacy},https://api.github.com/users/lithomas1/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11042/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1022,https://api.github.com/repos/dask/dask/issues/11044,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11044/labels{/name},https://api.github.com/repos/dask/dask/issues/11044/comments,https://api.github.com/repos/dask/dask/issues/11044/events,https://github.com/dask/dask/issues/11044,2237078117,I_kwDOAbcwm86FVxpl,11044,FileExpired exception when reading parquet from a Minio bucket using Dask,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949099791, 'node_id': 'MDU6TGFiZWwyOTQ5MDk5Nzkx', 'url': 'https://api.github.com/repos/dask/dask/labels/parquet', 'name': 'parquet', 'color': '77A66C', 'default': False, 'description': ''}]",open,False,,[],,6,2024-04-11T07:24:36Z,2024-04-18T07:53:51Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

I have a list of dataframes in a Minio bucket that are updated every 15 minutes. My script runs inside a Docker container in a loop and every 15 minutes a list of futures is created to read and preprocess every dataframe in the bucket. When computing the result it happens sometimes that the following exception is triggered:
```
s3fs.utils.FileExpired: [Errno 16] The remote file corresponding to filename filename.part.0.parquet and Etag ""76b9a0ed3044b29e8a326d6f4ade2036"" no longer exists
```

and triggers `TypeError: __init__() missing 1 required positional argument: 'e_tag'`. Even catching the exception does not solve the problem since during the next iteration it is triggered again. I checked on Minio and the Etag effectively does not correspond to that in the exception but I do not know how to solve this problem. The code to read data is this

```
df = dd.read_parquet('s3://{}/{}/{}'.format(bucket, path, filename),
                         storage_options={
                             ""key"": key,
                             ""secret"": secret,
                             ""client_kwargs"": {'endpoint_url': 'http://{}'.format(minio_endpoint)}
                         })
```

**Minimal Complete Verifiable Example**:
Providing a verifiable example is difficult since it runs on Docker and it is the result of various interacting scripts. I tried to replicate it running a simple script outside of docker but the problem does not appear. This is the script I used that is similar to what the original script does.

```
def load_user(bucket, path, file, minio_endpoint, key, secret):
    print(f'Reading {file}...')
    df = dd.read_parquet('s3://{}/{}/{}'.format(bucket, path, hash_filename(file)),
                         storage_options={
                             ""key"": key,
                             ""secret"": secret,
                             ""client_kwargs"": {'endpoint_url': 'http://{}'.format(minio_endpoint)}
                         },
                         ignore_metadata_file=True)

    return df


if __name__ == ""__main__"":
    bucket = bucket name
    path = path
    filenames = list of filenames

    cluster = LocalCluster(silence_logs=logging.CRITICAL)
    dask_client = Client(cluster)
    minio_client = Minio(endpoint, key, secret, secure=False)

    minio_endpoint = minio_client._base_url.host
    key = minio_client._provider._credentials.access_key
    secret = minio_client._provider._credentials.secret_key

    while True:
        futures = []
        for file in filenames:
            future = dask_client.submit(load_user,
                                        bucket,
                                        path,
                                        file,
                                        minio_endpoint,
                                        key,
                                        secret)
            futures.append(future)

        for user, future in zip(filenames, futures):
            df = future.result()
```

**Anything else we need to know?**:

I have tried to use the function `invalidate_cache()` of s3fs and using `ignore_metadata_file=True` when reading data but it didn't worked. Catching the exception works but the problem is not solved during the following iteration.

Here is the complete traceback if you find it useful

```
Traceback (most recent call last):  File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 113, in _error_wrapper    return await func(*args, **kwargs)  File ""/usr/local/lib/python3.9/site-packages/aiobotocore/client.py"", line 408, in _make_api_call    raise error_class(parsed_response, operation_name)botocore.exceptions.ClientError: An error occurred (PreconditionFailed) when calling the GetObject operation: At least one of the pre-conditions you specified did not holdThe above exception was the direct cause of the following exception:Traceback (most recent call last):  File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 2300, in _fetch_range    return _fetch_range(  File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 2462, in _fetch_range    return sync(fs.loop, _inner_fetch, fs, bucket, key, version_id, start, end, req_kw)  File ""/usr/local/lib/python3.9/site-packages/fsspec/asyn.py"", line 103, in sync    raise return_result  File ""/usr/local/lib/python3.9/site-packages/fsspec/asyn.py"", line 56, in _runner    result[0] = await coro  File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 2480, in _inner_fetch    return await _error_wrapper(_call_and_read, retries=fs.retries)  File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 142, in _error_wrapper    raise err  File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 113, in _error_wrapper    return await func(*args, **kwargs)  File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 2467, in _call_and_read    resp = await fs._call_s3(  File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 362, in _call_s3    return await _error_wrapper(  File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 142, in _error_wrapper    raise errOSError: [Errno 22] At least one of the pre-conditions you specified did not holdThe above exception was the direct cause of the following exception:Traceback (most recent call last):  File ""/usr/local/lib/python3.9/site-packages/dask/backends.py"", line 141, in wrapper    return func(*args, **kwargs)  File ""/usr/local/lib/python3.9/site-packages/dask/dataframe/io/parquet/core.py"", line 529, in read_parquet    read_metadata_result = engine.read_metadata(  File ""/usr/local/lib/python3.9/site-packages/dask/dataframe/io/parquet/arrow.py"", line 546, in read_metadata    dataset_info = cls._collect_dataset_info(  File ""/usr/local/lib/python3.9/site-packages/dask/dataframe/io/parquet/arrow.py"", line 1061, in _collect_dataset_info    ds = pa_ds.dataset(  File ""/usr/local/lib/python3.9/site-packages/pyarrow/dataset.py"", line 785, in dataset    return _filesystem_dataset(source, **kwargs)  File ""/usr/local/lib/python3.9/site-packages/pyarrow/dataset.py"", line 475, in _filesystem_dataset    return factory.finish(schema)  File ""pyarrow/_dataset.pyx"", line 3025, in pyarrow._dataset.DatasetFactory.finish  File ""pyarrow/error.pxi"", line 154, in pyarrow.lib.pyarrow_internal_check_status  File ""pyarrow/error.pxi"", line 88, in pyarrow.lib.check_status  File ""/usr/local/lib/python3.9/site-packages/fsspec/spec.py"", line 1846, in read    out = self.cache._fetch(self.loc, self.loc + length)  File ""/usr/local/lib/python3.9/site-packages/fsspec/caching.py"", line 189, in _fetch    self.cache = self.fetcher(start, end)  # new block replaces old  File ""/usr/local/lib/python3.9/site-packages/s3fs/core.py"", line 2312, in _fetch_range    raise FileExpired(s3fs.utils.FileExpired: [Errno 16] The remote file corresponding to filename 16 and Etag The remote file corresponding to filename filename.part.0.parquet and Etag ""76b9a0ed3044b29e8a326d6f4ade2036"" no longer exists. no longer exists.During handling of the above exception, another exception occurred:Traceback (most recent call last):  File ""/python-docker/run.py"", line 19, in     service.start()  File ""/python-docker/chimera_ml_app/services.py"", line 130, in start    self.channel.start_consuming()  File ""/usr/local/lib/python3.9/site-packages/pika/adapters/blocking_connection.py"", line 1883, in start_consuming    self._process_data_events(time_limit=None)  File ""/usr/local/lib/python3.9/site-packages/pika/adapters/blocking_connection.py"", line 2044, in _process_data_events    self.connection.process_data_events(time_limit=time_limit)  File ""/usr/local/lib/python3.9/site-packages/pika/adapters/blocking_connection.py"", line 851, in process_data_events    self._dispatch_channel_events()  File ""/usr/local/lib/python3.9/site-packages/pika/adapters/blocking_connection.py"", line 567, in _dispatch_channel_events    impl_channel._get_cookie()._dispatch_events()  File ""/usr/local/lib/python3.9/site-packages/pika/adapters/blocking_connection.py"", line 1510, in _dispatch_events    consumer_info.on_message_callback(self, evt.method,  File ""/python-docker/chimera_ml_app/services.py"", line 157, in on_request    response = chimera.ml.predict(body=request)  File ""src/dependency_injector/_cwiring.pyx"", line 28, in dependency_injector._cwiring._get_sync_patched._patched  File ""/python-docker/chimera_ml_app/ml.py"", line 20, in predict    predictions = predictor.predict()  File ""/usr/local/lib/python3.9/site-packages/hijacking_detection/pipelines/PipelinePredictorKATANA.py"", line 125, in predict    preprocessing.preprocess(path, save_path)  File ""/usr/local/lib/python3.9/site-packages/hijacking_detection/preprocessing/PreprocessingTestResample.py"", line 55, in preprocess    dataframe = future.result()  File ""/usr/local/lib/python3.9/site-packages/distributed/client.py"", line 323, in result    return self.client.sync(self._result, callback_timeout=timeout)  File ""/usr/local/lib/python3.9/site-packages/hijacking_detection/preprocessing/PreprocessingTestResample.py"", line 91, in load_user    df = dd.read_parquet('s3://{}/{}'.format(bucket, path),  File ""/usr/local/lib/python3.9/site-packages/dask/backends.py"", line 143, in wrapper    raise type(e)(TypeError: __init__() missing 1 required positional argument: 'e_tag'
```

**Environment**:

- Dask version: 2024.2.1
- Python version: 3.9.13
- Operating System: Docker running [python:3.9.17-slim-buster
](https://hub.docker.com/layers/library/python/3.9.17-slim-buster/images/sha256-d5cca64dca485c37ccf06721e36a93bf4331b0404bfd3ef2c7873867965359b7?context=explore)
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/11044/timeline,,,PietroSpalluto,70751487,MDQ6VXNlcjcwNzUxNDg3,https://avatars.githubusercontent.com/u/70751487?v=4,,https://api.github.com/users/PietroSpalluto,https://github.com/PietroSpalluto,https://api.github.com/users/PietroSpalluto/followers,https://api.github.com/users/PietroSpalluto/following{/other_user},https://api.github.com/users/PietroSpalluto/gists{/gist_id},https://api.github.com/users/PietroSpalluto/starred{/owner}{/repo},https://api.github.com/users/PietroSpalluto/subscriptions,https://api.github.com/users/PietroSpalluto/orgs,https://api.github.com/users/PietroSpalluto/repos,https://api.github.com/users/PietroSpalluto/events{/privacy},https://api.github.com/users/PietroSpalluto/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11044/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1023,https://api.github.com/repos/dask/dask/issues/11046,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11046/labels{/name},https://api.github.com/repos/dask/dask/issues/11046/comments,https://api.github.com/repos/dask/dask/issues/11046/events,https://github.com/dask/dask/issues/11046,2237856409,I_kwDOAbcwm86FYvqZ,11046,ValueError: memoryview is too large (dask.array.histogram),"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,4,2024-04-11T14:23:16Z,2024-04-11T16:06:29Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
I'm trying to compute a histogram over a 12 TB array of pairwise distances and it fails.
Returns either `ValueError: memoryview is too large`
<details>

``` 
http://127.0.0.1:8787/status
[/opt/conda/lib/python3.11/site-packages/distributed/client.py:3169](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:3169): UserWarning: Sending large graph of size 12.22 GiB.
This may cause some slowdown.
Consider scattering data ahead of time and using futures.
  warnings.warn(
2024-04-11 16:18:18,764 - distributed.protocol.core - CRITICAL - Failed to Serialize
Traceback (most recent call last):
  File ""/opt/conda/lib/python3.11/site-packages/distributed/protocol/core.py"", line 109, in dumps
    frames[0] = msgpack.dumps(msg, default=_encode_default, use_bin_type=True)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/opt/conda/lib/python3.11/site-packages/msgpack/__init__.py"", line 36, in packb
    return Packer(**kwargs).pack(o)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File ""msgpack/_packer.pyx"", line 294, in msgpack._cmsgpack.Packer.pack
  File ""msgpack/_packer.pyx"", line 300, in msgpack._cmsgpack.Packer.pack
  File ""msgpack/_packer.pyx"", line 297, in msgpack._cmsgpack.Packer.pack
  File ""msgpack/_packer.pyx"", line 264, in msgpack._cmsgpack.Packer._pack
  File ""msgpack/_packer.pyx"", line 231, in msgpack._cmsgpack.Packer._pack
  File ""msgpack/_packer.pyx"", line 264, in msgpack._cmsgpack.Packer._pack
  File ""msgpack/_packer.pyx"", line 272, in msgpack._cmsgpack.Packer._pack
ValueError: memoryview is too large
2024-04-11 16:18:18,768 - distributed.comm.utils - ERROR - memoryview is too large
Traceback (most recent call last):
  File ""/opt/conda/lib/python3.11/site-packages/distributed/comm/utils.py"", line 34, in _to_frames
    return list(protocol.dumps(msg, **kwargs))
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/opt/conda/lib/python3.11/site-packages/distributed/protocol/core.py"", line 109, in dumps
    frames[0] = msgpack.dumps(msg, default=_encode_default, use_bin_type=True)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/opt/conda/lib/python3.11/site-packages/msgpack/__init__.py"", line 36, in packb
    return Packer(**kwargs).pack(o)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File ""msgpack/_packer.pyx"", line 294, in msgpack._cmsgpack.Packer.pack
  File ""msgpack/_packer.pyx"", line 300, in msgpack._cmsgpack.Packer.pack
  File ""msgpack/_packer.pyx"", line 297, in msgpack._cmsgpack.Packer.pack
  File ""msgpack/_packer.pyx"", line 264, in msgpack._cmsgpack.Packer._pack
  File ""msgpack/_packer.pyx"", line 231, in msgpack._cmsgpack.Packer._pack
  File ""msgpack/_packer.pyx"", line 264, in msgpack._cmsgpack.Packer._pack
  File ""msgpack/_packer.pyx"", line 272, in msgpack._cmsgpack.Packer._pack
ValueError: memoryview is too large
2024-04-11 16:18:18,770 - distributed.batched - ERROR - Error in batched write
Traceback (most recent call last):
  File ""/opt/conda/lib/python3.11/site-packages/distributed/batched.py"", line 115, in _background_send
    nbytes = yield coro
             ^^^^^^^^^^
  File ""/opt/conda/lib/python3.11/site-packages/tornado/gen.py"", line 767, in run
    value = future.result()
            ^^^^^^^^^^^^^^^
  File ""/opt/conda/lib/python3.11/site-packages/distributed/comm/tcp.py"", line 264, in write
    frames = await to_frames(
             ^^^^^^^^^^^^^^^^
  File ""/opt/conda/lib/python3.11/site-packages/distributed/comm/utils.py"", line 50, in to_frames
    return _to_frames()
           ^^^^^^^^^^^^
  File ""/opt/conda/lib/python3.11/site-packages/distributed/comm/utils.py"", line 34, in _to_frames
    return list(protocol.dumps(msg, **kwargs))
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/opt/conda/lib/python3.11/site-packages/distributed/protocol/core.py"", line 109, in dumps
    frames[0] = msgpack.dumps(msg, default=_encode_default, use_bin_type=True)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/opt/conda/lib/python3.11/site-packages/msgpack/__init__.py"", line 36, in packb
    return Packer(**kwargs).pack(o)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File ""msgpack/_packer.pyx"", line 294, in msgpack._cmsgpack.Packer.pack
  File ""msgpack/_packer.pyx"", line 300, in msgpack._cmsgpack.Packer.pack
  File ""msgpack/_packer.pyx"", line 297, in msgpack._cmsgpack.Packer.pack
  File ""msgpack/_packer.pyx"", line 264, in msgpack._cmsgpack.Packer._pack
  File ""msgpack/_packer.pyx"", line 231, in msgpack._cmsgpack.Packer._pack
  File ""msgpack/_packer.pyx"", line 264, in msgpack._cmsgpack.Packer._pack
  File ""msgpack/_packer.pyx"", line 272, in msgpack._cmsgpack.Packer._pack
ValueError: memoryview is too large
---------------------------------------------------------------------------
CancelledError                            Traceback (most recent call last)
Cell In[5], [line 4](vscode-notebook-cell:?execution_count=5&line=4)
      [2](vscode-notebook-cell:?execution_count=5&line=2) distances = pairwise_distances(darr, darr.compute(), metric=""cosine"")
      [3](vscode-notebook-cell:?execution_count=5&line=3) hist, bins = da.histogram(distances, bins=100, range=[0,2])
----> [4](vscode-notebook-cell:?execution_count=5&line=4) hist.compute()

File [/opt/conda/lib/python3.11/site-packages/dask/base.py:375](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:375), in DaskMethodsMixin.compute(self, **kwargs)
    [351](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:351) def compute(self, **kwargs):
    [352](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:352)     """"""Compute this dask collection
    [353](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:353) 
    [354](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:354)     This turns a lazy Dask collection into its in-memory equivalent.
   (...)
    [373](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:373)     dask.compute
    [374](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:374)     """"""
--> [375](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:375)     (result,) = compute(self, traverse=False, **kwargs)
    [376](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:376)     return result

File [/opt/conda/lib/python3.11/site-packages/dask/base.py:661](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:661), in compute(traverse, optimize_graph, scheduler, get, *args, **kwargs)
    [658](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:658)     postcomputes.append(x.__dask_postcompute__())
    [660](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:660) with shorten_traceback():
--> [661](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:661)     results = schedule(dsk, keys, **kwargs)
    [663](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:663) return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])

File [/opt/conda/lib/python3.11/site-packages/distributed/client.py:2245](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2245), in Client._gather(self, futures, errors, direct, local_worker)
   [2243](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2243)     else:
   [2244](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2244)         raise exception.with_traceback(traceback)
-> [2245](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2245)     raise exc
   [2246](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2246) if errors == ""skip"":
   [2247](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2247)     bad_keys.add(key)

CancelledError: ('sum-aggregate-147f6c70731d6bcc47a228e1974422e8', 0)
```

</details>

or just cancels

<details>

``` 

[/opt/conda/lib/python3.11/site-packages/distributed/client.py:3169](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:3169): UserWarning: Sending large graph of size 12.22 GiB.
This may cause some slowdown.
Consider scattering data ahead of time and using futures.
  warnings.warn(
---------------------------------------------------------------------------
CancelledError                            Traceback (most recent call last)
Cell In[18], [line 4](vscode-notebook-cell:?execution_count=18&line=4)
      [2](vscode-notebook-cell:?execution_count=18&line=2) distances = pairwise_distances(darr, darr.compute(), metric=""cosine"")
      [3](vscode-notebook-cell:?execution_count=18&line=3) hist, bins = da.histogram(distances, bins=100, range=[0,2])
----> [4](vscode-notebook-cell:?execution_count=18&line=4) hist.compute()

File [/opt/conda/lib/python3.11/site-packages/dask/base.py:375](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:375), in DaskMethodsMixin.compute(self, **kwargs)
    [351](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:351) def compute(self, **kwargs):
    [352](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:352)     """"""Compute this dask collection
    [353](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:353) 
    [354](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:354)     This turns a lazy Dask collection into its in-memory equivalent.
   (...)
    [373](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:373)     dask.compute
    [374](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:374)     """"""
--> [375](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:375)     (result,) = compute(self, traverse=False, **kwargs)
    [376](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:376)     return result

File [/opt/conda/lib/python3.11/site-packages/dask/base.py:661](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:661), in compute(traverse, optimize_graph, scheduler, get, *args, **kwargs)
    [658](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:658)     postcomputes.append(x.__dask_postcompute__())
    [660](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:660) with shorten_traceback():
--> [661](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:661)     results = schedule(dsk, keys, **kwargs)
    [663](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/dask/base.py:663) return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])

File [/opt/conda/lib/python3.11/site-packages/distributed/client.py:2245](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2245), in Client._gather(self, futures, errors, direct, local_worker)
   [2243](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2243)     else:
   [2244](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2244)         raise exception.with_traceback(traceback)
-> [2245](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2245)     raise exc
   [2246](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2246) if errors == ""skip"":
   [2247](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f6a7570797465722d6a7570797465722d31222c2273657474696e6773223a7b22686f7374223a22756e69783a2f2f2f72756e2f757365722f3732373630363637382f646f636b65722e736f636b227d7d-0040ssh-002dremote-002bdgx2.vscode-resource.vscode-cdn.net/opt/conda/lib/python3.11/site-packages/distributed/client.py:2247)     bad_keys.add(key)

CancelledError: ('sum-aggregate-3a00e4279a13a440e2503725c63a585b', 0)

```
</details>

**Minimal Complete Verifiable Example**:

```python
import dask.array as da
from dask_ml.metrics import pairwise_distances
darr = da.random.normal(size=(1281167, 1280))
distances = pairwise_distances(darr, darr.compute(), metric=""cosine"")
hist, bins = da.histogram(distances, bins=100, range=[0,2])
hist.compute() # error
```

**Anything else we need to know?**:
Just computing the histogram of such a large matrix works
```python
darr = da.random.normal(size=(1281167, 1281167))
hist, bins = da.histogram(darr, bins=100, range=[0,2])
hist.compute() # works
```

**Environment**:

- Dask version: 2024.2.1
- Python version: 3.11
- Operating System: Ubuntu 22.04 (in Docker)
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/11046/timeline,,,lsc64,86673488,MDQ6VXNlcjg2NjczNDg4,https://avatars.githubusercontent.com/u/86673488?v=4,,https://api.github.com/users/lsc64,https://github.com/lsc64,https://api.github.com/users/lsc64/followers,https://api.github.com/users/lsc64/following{/other_user},https://api.github.com/users/lsc64/gists{/gist_id},https://api.github.com/users/lsc64/starred{/owner}{/repo},https://api.github.com/users/lsc64/subscriptions,https://api.github.com/users/lsc64/orgs,https://api.github.com/users/lsc64/repos,https://api.github.com/users/lsc64/events{/privacy},https://api.github.com/users/lsc64/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11046/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1024,https://api.github.com/repos/dask/dask/issues/11047,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11047/labels{/name},https://api.github.com/repos/dask/dask/issues/11047/comments,https://api.github.com/repos/dask/dask/issues/11047/events,https://github.com/dask/dask/issues/11047,2238386281,I_kwDOAbcwm86FaxBp,11047,Add static type annotations,"[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}]",open,False,,[],,4,2024-04-11T19:11:23Z,2024-04-15T20:04:22Z,,NONE,,"I am having trouble with using Dask in a project that uses PyRight because Dask does not use static type annotations/

Take, `da.from_array`, for example:
https://github.com/dask/dask/blob/b2ec1e1a2361db1e269ba86c7c59d3f6df70a02d/dask/array/core.py#L3307-L3317

Or `array.rechunk`:
https://github.com/dask/dask/blob/b2ec1e1a2361db1e269ba86c7c59d3f6df70a02d/dask/array/rechunk.py#L268-L275

PyRight complains if you use anything but a `str` for `chunks`:

![image](https://github.com/dask/dask/assets/38672686/009bf48b-2897-40b2-ab23-bc035f0304da)

```py
Argument of type ""tuple[Literal[1], Literal[-1], Literal[-1]]"" cannot be assigned to parameter ""chunks"" of type ""str"" in function ""from_array""
  ""tuple[Literal[1], Literal[-1], Literal[-1]]"" is incompatible with ""str""
```

This happens because in `from_array` and `rechunk`, `chunks=""auto""` infers to a `str` type.

Is there an awareness of this problem? Is there a known solution? If not, is there a plan to fix this?",,https://api.github.com/repos/dask/dask/issues/11047/timeline,,,sam-goodwin,38672686,MDQ6VXNlcjM4NjcyNjg2,https://avatars.githubusercontent.com/u/38672686?v=4,,https://api.github.com/users/sam-goodwin,https://github.com/sam-goodwin,https://api.github.com/users/sam-goodwin/followers,https://api.github.com/users/sam-goodwin/following{/other_user},https://api.github.com/users/sam-goodwin/gists{/gist_id},https://api.github.com/users/sam-goodwin/starred{/owner}{/repo},https://api.github.com/users/sam-goodwin/subscriptions,https://api.github.com/users/sam-goodwin/orgs,https://api.github.com/users/sam-goodwin/repos,https://api.github.com/users/sam-goodwin/events{/privacy},https://api.github.com/users/sam-goodwin/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11047/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1025,https://api.github.com/repos/dask/dask/issues/11051,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11051/labels{/name},https://api.github.com/repos/dask/dask/issues/11051/comments,https://api.github.com/repos/dask/dask/issues/11051/events,https://github.com/dask/dask/issues/11051,2241875527,I_kwDOAbcwm86FoE5H,11051,"db.to_dataframe, throws: TypeError: 'coroutine' object is not iterable","[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,2,2024-04-14T02:56:37Z,2024-04-16T00:31:20Z,,NONE,,"**Describe the issue**:
Using dask bag to normalize the data into a dask dataframe throws: `TypeError: 'coroutine' object is not iterable`

**Minimal Complete Verifiable Example**:
```python
from dask.distributed import Client
import dask.bag as db
import asyncio

async def create_dataframe():
    # Data from sources stuff...
    data = [{'_id': 1, 'name': 'Bob'}]
    data_bag = db.from_sequence(data)
    data_bag = data_bag.map(lambda x: {'id': x['_id'], 'name': x['name'].lower()})

    return data_bag.to_dataframe()

async def main():
    cli = await Client('localhost:8786', asynchronous=True)
    df = await create_dataframe()
    df = await cli.compute(df)
    print(df)
    await cli.close()


if __name__ == '__main__':
    asyncio.run(main())
```

**Anything else we need to know?**:
The error was caused using a `dask.distributed` async client.
I'm also tried using `.flatten()` method and `dd.from_delayed(data_bag.to_delayed())`

**Environment**:

- Dask version: `dask, version 2024.2.0`
- Python version: `Python 3.11.6`
- Operating System: `Docker - Debian GNU/Linux 12 (bookworm)`
- Install method (conda, pip, source): `pip`
",,https://api.github.com/repos/dask/dask/issues/11051/timeline,,,SGT911,61520057,MDQ6VXNlcjYxNTIwMDU3,https://avatars.githubusercontent.com/u/61520057?v=4,,https://api.github.com/users/SGT911,https://github.com/SGT911,https://api.github.com/users/SGT911/followers,https://api.github.com/users/SGT911/following{/other_user},https://api.github.com/users/SGT911/gists{/gist_id},https://api.github.com/users/SGT911/starred{/owner}{/repo},https://api.github.com/users/SGT911/subscriptions,https://api.github.com/users/SGT911/orgs,https://api.github.com/users/SGT911/repos,https://api.github.com/users/SGT911/events{/privacy},https://api.github.com/users/SGT911/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11051/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1026,https://api.github.com/repos/dask/dask/issues/11055,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11055/labels{/name},https://api.github.com/repos/dask/dask/issues/11055/comments,https://api.github.com/repos/dask/dask/issues/11055/events,https://github.com/dask/dask/issues/11055,2250793899,I_kwDOAbcwm86GKGOr,11055,Substantial memory usage in dask.order,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-04-18T14:06:34Z,2024-04-18T14:06:47Z,,MEMBER,,"I'm currently still working on a reproducer but I've seen dask.order taking up a substantial amount of memory 

Particularly, I've seen this set https://github.com/dask/dask/blob/00a5d9200e2cee31e19d4e9fbe88ace8ad41cad0/dask/order.py#L672 grow to several GB of memory

![image](https://github.com/dask/dask/assets/8629629/40dc8a55-4456-4e35-b947-fb3c8260a61f)

This is likely not only slow but can also crash the scheduler",,https://api.github.com/repos/dask/dask/issues/11055/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11055/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1027,https://api.github.com/repos/dask/dask/issues/11067,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11067/labels{/name},https://api.github.com/repos/dask/dask/issues/11067/comments,https://api.github.com/repos/dask/dask/issues/11067/events,https://github.com/dask/dask/issues/11067,2263044231,I_kwDOAbcwm86G41CH,11067,Control order of execution with query planner,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,2,2024-04-25T08:51:31Z,2024-04-29T12:13:58Z,,NONE,,"**Describe the issue**:

We often use dask together with [plateau](https://github.com/data-engineering-collective/plateau) to perform the following task in parallel:
- load a chunk of data
- do a transformation
- write the chunk of data to disk

We typically do this with datasets that don't fit into our machine's RAM. This used to work fine, but with the new query planner, we typically run out of memory, because dask now loads _all_ the data before doing a transformation. Before, dask would operate chunk by chunk.

**Minimal Complete Verifiable Example**:

I tried to come up with a simple example that doesn't involve plateau (or a lot of data):

```python
import dask
import dask.dataframe as dd
import pandas as pd

from dask.distributed import Client, LocalCluster

# load the data from disk
@dask.delayed
def _load(x):
    print(f""Loading chunk {x}"")
    return pd.DataFrame({""x"": x, ""y"": [1, 2, 3]})

# transform and store
def _transform_and_store(df):
    # this example doesn't transform or store anything, but you get the idea
    x = df[""x""].unique().item()
    print(f""Storing chunk {x}"")


if __name__ == ""__main__"":

    ddf = dd.from_delayed([_load(x) for x in range(10)], meta={""x"": ""int64"", ""y"": ""int64""})

    with LocalCluster(n_workers=1, threads_per_worker=1) as cluster:
        with Client(cluster):
            ddf.map_partitions(_transform_and_store, meta={}).compute()
```

The behavior without the query planner is:
```
DASK_DATAFRAME__QUERY_PLANNING=False python example.py 
Loading chunk 9
Storing chunk 9
Loading chunk 8
Storing chunk 8
Loading chunk 7
Storing chunk 7
Loading chunk 6
Storing chunk 6
Loading chunk 5
Storing chunk 5
Loading chunk 4
Storing chunk 4
Loading chunk 3
Storing chunk 3
Loading chunk 2
Storing chunk 2
Loading chunk 1
Storing chunk 1
Loading chunk 0
Storing chunk 0
```

So, we load, transform and store and won't run out of memory.

```
DASK_DATAFRAME__QUERY_PLANNING=True python example.py 
Loading chunk 7
Loading chunk 2
Loading chunk 3
Loading chunk 0
Loading chunk 9
Loading chunk 1
Loading chunk 8
Loading chunk 5
Loading chunk 4
Loading chunk 6
Storing chunk 9
Storing chunk 8
Storing chunk 7
Storing chunk 6
Storing chunk 5
Storing chunk 4
Storing chunk 3
Storing chunk 2
Storing chunk 1
Storing chunk 0
```

Here, we first load everything and so we'll run out of memory.


- Is there a way to tell the query planner to operate chunk-by-chunk when it encounters `map_partitions`?
- Should I not be using `map_partitions` for something like this?
- NB: `DASK_DISTRIBUTED__SCHEDULER__WORKER_SATURATION=1` doesn't help


**Anything else that we should know?**

Note that it's really tricky to turn off the query planner (other than through environment variables). When using `dask.config` from within Python, it's important that the config is set before the first import of `dask.dataframe`, which is difficult to control.

**Environment**:

- Dask version: 2024.4.2
- Python version: 3.12.3
- Operating System: linux
- Install method (conda, pip, source): conda


Thank you!",,https://api.github.com/repos/dask/dask/issues/11067/timeline,,,jtilly,6807275,MDQ6VXNlcjY4MDcyNzU=,https://avatars.githubusercontent.com/u/6807275?v=4,,https://api.github.com/users/jtilly,https://github.com/jtilly,https://api.github.com/users/jtilly/followers,https://api.github.com/users/jtilly/following{/other_user},https://api.github.com/users/jtilly/gists{/gist_id},https://api.github.com/users/jtilly/starred{/owner}{/repo},https://api.github.com/users/jtilly/subscriptions,https://api.github.com/users/jtilly/orgs,https://api.github.com/users/jtilly/repos,https://api.github.com/users/jtilly/events{/privacy},https://api.github.com/users/jtilly/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11067/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1028,https://api.github.com/repos/dask/dask/issues/11069,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11069/labels{/name},https://api.github.com/repos/dask/dask/issues/11069/comments,https://api.github.com/repos/dask/dask/issues/11069/events,https://github.com/dask/dask/issues/11069,2263216439,I_kwDOAbcwm86G5fE3,11069,Backport Python import error patch to 2024.2.1,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-04-25T10:17:37Z,2024-04-25T10:55:28Z,,NONE,,"Currently, 
```
micromamba create dask -n dask=2024.2.1
```
will result in a broken version of dask (because it will pull in the latest Python, see https://github.com/dask/dask/issues/11038):

```
Python 3.12.3 | packaged by conda-forge | (main, Apr 15 2024, 18:35:20) [Clang 16.0.6 ] on darwin
Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.
>>> import dask.dataframe as dd

Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/dataframe/__init__.py"", line 100, in <module>
    from dask.dataframe import backends, dispatch, rolling
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/dataframe/backends.py"", line 15, in <module>
    from dask.dataframe.core import DataFrame, Index, Scalar, Series, _Frame
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/dataframe/core.py"", line 36, in <module>
    from dask.dataframe import methods
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/dataframe/methods.py"", line 34, in <module>
    from dask.dataframe.utils import is_dataframe_like, is_index_like, is_series_like
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/dataframe/utils.py"", line 20, in <module>
    from dask.dataframe import (  # noqa: F401 register pandas extension types
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/dataframe/_dtypes.py"", line 9, in <module>
    from dask.dataframe.extensions import make_array_nonempty, make_scalar
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/dataframe/extensions.py"", line 8, in <module>
    from dask.dataframe.accessor import (
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/dataframe/accessor.py"", line 126, in <module>
    class DatetimeAccessor(Accessor):
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/dataframe/accessor.py"", line 81, in __init_subclass__
    _bind_property(cls, pd_cls, attr, min_version)
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/dataframe/accessor.py"", line 35, in _bind_property
    setattr(cls, attr, property(derived_from(pd_cls, version=min_version)(func)))
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/utils.py"", line 987, in wrapper
    method.__doc__ = _derived_from(
                     ^^^^^^^^^^^^^^
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/utils.py"", line 940, in _derived_from
    method_args = get_named_args(method)
                  ^^^^^^^^^^^^^^^^^^^^^^
  File ""/private/tmp/dask/lib/python3.12/site-packages/dask/utils.py"", line 701, in get_named_args
    s = inspect.signature(func)
        ^^^^^^^^^^^^^^^^^^^^^^^
  File ""/private/tmp/dask/lib/python3.12/inspect.py"", line 3310, in signature
    return Signature.from_callable(obj, follow_wrapped=follow_wrapped,
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/private/tmp/dask/lib/python3.12/inspect.py"", line 3054, in from_callable
    return _signature_from_callable(obj, sigcls=cls,
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/private/tmp/dask/lib/python3.12/inspect.py"", line 2642, in _signature_from_callable
    call = _descriptor_get(call, obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/private/tmp/dask/lib/python3.12/inspect.py"", line 2467, in _descriptor_get
    return get(descriptor, obj, type(obj))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: descriptor '__call__' for 'type' objects doesn't apply to a 'property' object
```

Would you be open to backporting

https://github.com/dask/dask/pull/11035
https://github.com/dask/dask/pull/11039

to 2024.2.1 (and releasing it as 2024.2.**2**)? 

2024.2.1 is the last version of dask that doesn't force the query planner on us (and supports pandas <2.0) and it would be great if it worked with the latest Python releases.

I'm happy to do the work (though I guess most of the work will be the actual release -- including distributed, etc).

Alternatively, I could just add a patch to the conda recipe in the [feedstock repo](https://github.com/conda-forge/dask-feedstock/blob/main/recipe/meta.yaml), which would be sufficient for me and would also ensure that 

```
micromamba create dask -n dask=2024.2.1
```
installs a working version of dask. 

_Edit_: For a proposal to patch via the recipe, see https://github.com/conda-forge/dask-core-feedstock/pull/202",,https://api.github.com/repos/dask/dask/issues/11069/timeline,,,jtilly,6807275,MDQ6VXNlcjY4MDcyNzU=,https://avatars.githubusercontent.com/u/6807275?v=4,,https://api.github.com/users/jtilly,https://github.com/jtilly,https://api.github.com/users/jtilly/followers,https://api.github.com/users/jtilly/following{/other_user},https://api.github.com/users/jtilly/gists{/gist_id},https://api.github.com/users/jtilly/starred{/owner}{/repo},https://api.github.com/users/jtilly/subscriptions,https://api.github.com/users/jtilly/orgs,https://api.github.com/users/jtilly/repos,https://api.github.com/users/jtilly/events{/privacy},https://api.github.com/users/jtilly/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11069/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1029,https://api.github.com/repos/dask/dask/issues/11070,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11070/labels{/name},https://api.github.com/repos/dask/dask/issues/11070/comments,https://api.github.com/repos/dask/dask/issues/11070/events,https://github.com/dask/dask/issues/11070,2263580366,I_kwDOAbcwm86G637O,11070,Turning off query planning is difficult,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2024-04-25T13:24:11Z,2024-04-26T13:34:14Z,,NONE,,"I mentioned this in #11067, but maybe this deserves its own issue: I find it difficult to turn off query planning using the Python API. Using `dask.config.set` only works if `dask.dataframe` hasn't been imported up until that point.

This works (query planner is turned off):

```python
import dask
import pandas as pd

with dask.config.set({""dataframe.query-planning"": False}):
    import dask.dataframe as dd  # delayed import
    ddf = dd.from_pandas(pd.DataFrame({""x"": [1, 2, 3]}), chunksize=1)
    out = ddf.mean()
    print(hasattr(out, ""_expr""))  # False
```

This doesn't work (query planner is turned on):

```python
import dask
import pandas as pd
import dask.dataframe as dd  # I moved this import up

with dask.config.set({""dataframe.query-planning"": False}):
    ddf = dd.from_pandas(pd.DataFrame({""x"": [1, 2, 3]}), chunksize=1)
    out = ddf.mean()
    print(hasattr(out, ""_expr""))  # True
```

When I write library code, I typically can't control what users already imported.

Yes, adding `dd = importlib.reload(dd)` inside the context also fixes the issue in this example, but that doesn't work in all settings. 

E.g., imagine that I write a library with a function that _some user_ can call with a dask dataframe:

```python
# my library code
import dask

def my_func(ddf):
    with dask.config.set({""dataframe.query-planning"": False}):
        # reloading dask.dataframe here of course doesn't make a difference
        out = ddf.mean()
        print(hasattr(out, ""_expr""))  # True
```

```python
# user code
import dask.dataframe as dd
import pandas as pd

from my_library import my_func

ddf = dd.from_pandas(pd.DataFrame({""x"": [1, 2, 3]}), chunksize=1)
my_func(ddf)
```

Is there a clever way around this? I have drastic ideas like building a conda package that sets the `DASK_DATAFRAME__QUERY_PLANNING` environment variable, but that might be a bit much. I would much rather turn the query planner off selectively.

As an aside: maybe all of this is moot once #11067 is fixed.",,https://api.github.com/repos/dask/dask/issues/11070/timeline,,,jtilly,6807275,MDQ6VXNlcjY4MDcyNzU=,https://avatars.githubusercontent.com/u/6807275?v=4,,https://api.github.com/users/jtilly,https://github.com/jtilly,https://api.github.com/users/jtilly/followers,https://api.github.com/users/jtilly/following{/other_user},https://api.github.com/users/jtilly/gists{/gist_id},https://api.github.com/users/jtilly/starred{/owner}{/repo},https://api.github.com/users/jtilly/subscriptions,https://api.github.com/users/jtilly/orgs,https://api.github.com/users/jtilly/repos,https://api.github.com/users/jtilly/events{/privacy},https://api.github.com/users/jtilly/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11070/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1030,https://api.github.com/repos/dask/dask/issues/11075,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11075/labels{/name},https://api.github.com/repos/dask/dask/issues/11075/comments,https://api.github.com/repos/dask/dask/issues/11075/events,https://github.com/dask/dask/pull/11075,2264503169,PR_kwDOAbcwm85txl_A,11075,Add Scheduling section to DataFrame best practices,[],open,False,,[],,1,2024-04-25T21:11:45Z,2024-04-25T21:44:21Z,,MEMBER,,"- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/11075/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11075/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/11075,https://github.com/dask/dask/pull/11075,https://github.com/dask/dask/pull/11075.diff,https://github.com/dask/dask/pull/11075.patch,,,,,,,,,,,,,,,,,,,
1031,https://api.github.com/repos/dask/dask/issues/11076,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11076/labels{/name},https://api.github.com/repos/dask/dask/issues/11076/comments,https://api.github.com/repos/dask/dask/issues/11076/events,https://github.com/dask/dask/pull/11076,2265847681,PR_kwDOAbcwm85t2KNi,11076,Enh/take along axis,[],open,False,,[],,3,2024-04-26T13:57:07Z,2024-04-29T08:43:44Z,,CONTRIBUTOR,,"This PR adds `take_along_axis` that works similarly to [numpy's take_along_axis](https://numpy.org/doc/stable/reference/generated/numpy.take_along_axis.html).

- [x] Closes #3663 
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

# Credit
@zklaus for providing a working solution in [climix](https://git.smhi.se/climix/climix/-/blob/main/climix/dask_take_along_axis.py).

## Example of use
```python
from dask.array import take_along_axis

data: dask.array.Array 
top10_indices = data.argtopk(k=10, axis=-1)
top10 = take_along_axis(data, top10_indices, axis=-1)

# Equivalent to 
top10 = data.topk(k=10, axis=-1)
```

## Performances
This is just a basic benchmark I ran on my laptop to compare how this implementation prerforms against numpy's.
```python

import numpy as np
from dask.array import from_array
from dask.array.slicing import take_along_axis


random_arr = np.random.rand(1000,1000,1000)
dask_random_arr = from_array(random_arr)
top50 = dask_random_arr.argtopk(k=50, axis=0)
top50_np = top50.compute()

# Compute both argtopk and take_along_axis
%timeit take_along_axis(dask_random_arr, top50, axis=0).compute()
# 6.74 s  9.4 ms per loop (mean  std. dev. of 7 runs, 1 loop each)

%timeit np.take_along_axis(random_arr, top50_np, axis=0)
# 864 ms  11.6 ms per loop (mean  std. dev. of 7 runs, 1 loop each)

%timeit take_along_axis(dask_random_arr, from_array(top50_np), axis=0).compute()
# 2.3 s  9.04 ms per loop (mean  std. dev. of 7 runs, 1 loop each)


```
",,https://api.github.com/repos/dask/dask/issues/11076/timeline,,,bzah,16700639,MDQ6VXNlcjE2NzAwNjM5,https://avatars.githubusercontent.com/u/16700639?v=4,,https://api.github.com/users/bzah,https://github.com/bzah,https://api.github.com/users/bzah/followers,https://api.github.com/users/bzah/following{/other_user},https://api.github.com/users/bzah/gists{/gist_id},https://api.github.com/users/bzah/starred{/owner}{/repo},https://api.github.com/users/bzah/subscriptions,https://api.github.com/users/bzah/orgs,https://api.github.com/users/bzah/repos,https://api.github.com/users/bzah/events{/privacy},https://api.github.com/users/bzah/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11076/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/11076,https://github.com/dask/dask/pull/11076,https://github.com/dask/dask/pull/11076.diff,https://github.com/dask/dask/pull/11076.patch,,,,,,,,,,,,,,,,,,,
1032,https://api.github.com/repos/dask/dask/issues/11077,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11077/labels{/name},https://api.github.com/repos/dask/dask/issues/11077/comments,https://api.github.com/repos/dask/dask/issues/11077/events,https://github.com/dask/dask/issues/11077,2266560844,I_kwDOAbcwm86HGPlM,11077,Add a `dask.array.sample` functionality mirroring `dask.dataframe.sample` with an optional `ignore_nan` argument,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-04-26T22:05:22Z,2024-04-27T01:51:34Z,,NONE,,"Hi all,

With @ameliefroessl, we recently spent quite a bit of time trying to understand how to efficiently randomly sample an N-D array in Dask. Somehow it is easy to find this for dataframes in the documentation (https://docs.dask.org/en/latest/generated/dask.dataframe.DataFrame.sample.html) but not mentioned much for arrays.

We finally noticed that combining `vindex[]` with a random subset defined separately by the user works well, and allows flexibility. However, we still had one more problem: we only wanted to sample finite values, and this seemed fairly hard, as it impossible to know where those will be in advance.

We converged towards an implementation here: https://github.com/rhugonnet/geoutils/blob/add_delayed_raster_functions/geoutils/raster/delayed.py#L18 (being implemented here: https://github.com/GlacioHack/geoutils/pull/537), which is inspired by the  `delayed` ragged output blogpost of @GenevieveBuckley (https://blog.dask.org/2021/07/02/ragged-output). It does things in 3 steps: 1/ Compute the number of valid values per chunk, 2/ Create a flattened index for a random subsample among the valid values, 3/ Load the chunks again to sample those specific valid values passing only the 1D indexes belonging to that chunk and a little `block_id` that mirrors that of `dask.array.map_blocks`.

The implementation seems quite efficient memory-wise (as we don't need to extract all indices of all valid values, for instance), the only issue is that the sample does not only depend on the `random_state` but also the `chunksizes` of the input array...

Do you think this feature would be interesting to further develop and have directly in Dask? The ""finite values"" aspect is a bit of a specific case for users dealing a lot with NaNs, but more generically having a `dask.array.sample()` function that does the randomization work for the user could already be useful?",,https://api.github.com/repos/dask/dask/issues/11077/timeline,,,rhugonnet,28896516,MDQ6VXNlcjI4ODk2NTE2,https://avatars.githubusercontent.com/u/28896516?v=4,,https://api.github.com/users/rhugonnet,https://github.com/rhugonnet,https://api.github.com/users/rhugonnet/followers,https://api.github.com/users/rhugonnet/following{/other_user},https://api.github.com/users/rhugonnet/gists{/gist_id},https://api.github.com/users/rhugonnet/starred{/owner}{/repo},https://api.github.com/users/rhugonnet/subscriptions,https://api.github.com/users/rhugonnet/orgs,https://api.github.com/users/rhugonnet/repos,https://api.github.com/users/rhugonnet/events{/privacy},https://api.github.com/users/rhugonnet/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11077/reactions,1,0,0,0,0,0,0,1,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1033,https://api.github.com/repos/dask/dask/issues/11087,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11087/labels{/name},https://api.github.com/repos/dask/dask/issues/11087/comments,https://api.github.com/repos/dask/dask/issues/11087/events,https://github.com/dask/dask/issues/11087,2271069931,I_kwDOAbcwm86HXcbr,11087,test_division_or_partition in test_sql is failing for pandas 3,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,0,2024-04-30T10:15:15Z,2024-04-30T10:15:15Z,,MEMBER,,"The test is broken, the memory usage doesn't work as expected",,https://api.github.com/repos/dask/dask/issues/11087/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11087/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1034,https://api.github.com/repos/dask/dask/issues/11093,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11093/labels{/name},https://api.github.com/repos/dask/dask/issues/11093/comments,https://api.github.com/repos/dask/dask/issues/11093/events,https://github.com/dask/dask/pull/11093,2277734641,PR_kwDOAbcwm85uegIj,11093,Add getting started doc page,[],open,False,,[],,8,2024-05-03T13:54:17Z,2024-05-03T15:21:37Z,,MEMBER,,"- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/11093/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11093/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/11093,https://github.com/dask/dask/pull/11093,https://github.com/dask/dask/pull/11093.diff,https://github.com/dask/dask/pull/11093.patch,,,,,,,,,,,,,,,,,,,
1035,https://api.github.com/repos/dask/dask/issues/11095,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11095/labels{/name},https://api.github.com/repos/dask/dask/issues/11095/comments,https://api.github.com/repos/dask/dask/issues/11095/events,https://github.com/dask/dask/issues/11095,2278409926,I_kwDOAbcwm86HzcbG,11095,Use case focused docs pages,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,2,2024-05-03T20:54:25Z,2024-05-09T19:59:19Z,,MEMBER,,"I'm curious what folks would think about adding use case-specific pages to the Dask docs. Specifically, I was thinking about pages for machine learning and workflow orchestration where there is an especially broad ecosystem of libraries that you can use with Dask, but it'd be hard to find these by looking through the Dask docs. Maybe there are other good use cases too.
I'm not quite sure how these would fit into the current docs.dask.org table of contents. Some ideas:
- add a new ""use cases"" category in the left TOC
- create a use cases drop-down under ""how to use"" that can link out to common use cases
- ...

machine learning
---
We have https://ml.dask.org/, which is nice because it covers many ml-specific libraries that integrate well with Dask. A lot of this information is out of date, though, and I think it would be nice to have a single, concise page in docs.dask.org that links out to examples, relevant libraries (xgboost, lightgbm, rapids, scikit-learn, dask-ml functions that are still used/maintained), etc.

workflows/etl
---
I think the closest thing we have to this right now is the [Prefect example](https://examples.dask.org/applications/prefect-etl.html) in examples.dask.org. I'm imagining this page could link to using Dask with Prefect, but also other workflow orchestration tools like airflow and dagster. Maybe it also mentions things like dask-sql, dask-bigquery, [delta-rs + dask](https://delta-io.github.io/delta-rs/integrations/delta-lake-dask/). 

cc @jrbourbeau @fjetter @mrocklin @jacobtomlinson ",,https://api.github.com/repos/dask/dask/issues/11095/timeline,,,scharlottej13,8620816,MDQ6VXNlcjg2MjA4MTY=,https://avatars.githubusercontent.com/u/8620816?v=4,,https://api.github.com/users/scharlottej13,https://github.com/scharlottej13,https://api.github.com/users/scharlottej13/followers,https://api.github.com/users/scharlottej13/following{/other_user},https://api.github.com/users/scharlottej13/gists{/gist_id},https://api.github.com/users/scharlottej13/starred{/owner}{/repo},https://api.github.com/users/scharlottej13/subscriptions,https://api.github.com/users/scharlottej13/orgs,https://api.github.com/users/scharlottej13/repos,https://api.github.com/users/scharlottej13/events{/privacy},https://api.github.com/users/scharlottej13/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11095/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1036,https://api.github.com/repos/dask/dask/issues/11100,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11100/labels{/name},https://api.github.com/repos/dask/dask/issues/11100/comments,https://api.github.com/repos/dask/dask/issues/11100/events,https://github.com/dask/dask/pull/11100,2280759925,PR_kwDOAbcwm85uoXpG,11100,Getting Started layout,[],open,False,,[],,8,2024-05-06T12:24:01Z,2024-05-08T14:52:04Z,,MEMBER,,"**Context:**

The getting started section is not good currently. It has tons of information that are completely irrelevant for someone who has heard the first time about Dask or just wants to run an example and play around a little bit. The information in there is mostly what I would expect from a 2nd step section.

It's pretty confusing where you should start looking if you are someone who has never done anything with Dask and seems very complex.


**Proposal:**

We create a dedicated getting started section for the most relevant use-cases (currently we have content for bags, dataframes and arrays). They take a user through:

-  Installing -> running a short example -> looking at the Dashboard -> How can I scale out

Descriptions are short and on point without introducing internals or stuff that is very Dask specific. Just get them to the point where they can run something and look at it on the Dashboard


The stuff that we have currently in the getting started section will be trimmed down a little and advertised as further reading (or something similar, I am not married to any of those terms).


This is not meant to be merged, just a proposal for a layout that we can then fill with content",,https://api.github.com/repos/dask/dask/issues/11100/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11100/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,True,https://api.github.com/repos/dask/dask/pulls/11100,https://github.com/dask/dask/pull/11100,https://github.com/dask/dask/pull/11100.diff,https://github.com/dask/dask/pull/11100.patch,,,,,,,,,,,,,,,,,,,
1037,https://api.github.com/repos/dask/dask/issues/11101,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11101/labels{/name},https://api.github.com/repos/dask/dask/issues/11101/comments,https://api.github.com/repos/dask/dask/issues/11101/events,https://github.com/dask/dask/issues/11101,2280998023,I_kwDOAbcwm86H9USH,11101,"TypeError: can only concatenate str (not ""traceback"") to str","[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-05-06T14:19:27Z,2024-05-06T14:19:41Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.
``````
Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

**Minimal Complete Verifiable Example**:

```python
# Put your MCVE code here
import dask
import dask.bag as db
import river
# Create a Dask bag from your data
df=pd.DataFrame([[0]*2],columns=['VendorID','fare_amount'])
data = db.from_sequence(df, npartitions=4)

# Define a function to process and train on each partition
def process_and_train(partition):
    X_train,X_test,y_train,y_test=get_dask_train_test(partition)
    model = river.linear_model.LinearRegression(optimizer=river.optim.SGD(0.01), l2=0.1)
    # Stream learning from the DataFrame
    for _,row in partition.iterrows():
        y = row['fare_amount']       # Target
        x = row.drop('fare_amount')  # Features
        model = model.learn_one(x, y)
    print(""done"")
    return model

# Use Dask to process and train in parallel
models = data.map(process_and_train).compute()
```

**Anything else we need to know?**:

![Screenshot 2024-05-06 at 7 48 57PM](https://github.com/dask/dask/assets/50590413/11edf332-060b-41e8-a209-e3281bc93ccb)

**Environment**:

- Dask version:
- Python version:3.10
- Operating System: 
- Install method (conda, pip, source):pip
",,https://api.github.com/repos/dask/dask/issues/11101/timeline,,,sinsniwal,50590413,MDQ6VXNlcjUwNTkwNDEz,https://avatars.githubusercontent.com/u/50590413?v=4,,https://api.github.com/users/sinsniwal,https://github.com/sinsniwal,https://api.github.com/users/sinsniwal/followers,https://api.github.com/users/sinsniwal/following{/other_user},https://api.github.com/users/sinsniwal/gists{/gist_id},https://api.github.com/users/sinsniwal/starred{/owner}{/repo},https://api.github.com/users/sinsniwal/subscriptions,https://api.github.com/users/sinsniwal/orgs,https://api.github.com/users/sinsniwal/repos,https://api.github.com/users/sinsniwal/events{/privacy},https://api.github.com/users/sinsniwal/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11101/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1038,https://api.github.com/repos/dask/dask/issues/11102,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11102/labels{/name},https://api.github.com/repos/dask/dask/issues/11102/comments,https://api.github.com/repos/dask/dask/issues/11102/events,https://github.com/dask/dask/pull/11102,2281000945,PR_kwDOAbcwm85upLaY,11102,Fixing TypeError,[],open,False,,[],,5,2024-05-06T14:20:34Z,2024-05-07T15:15:10Z,,FIRST_TIME_CONTRIBUTOR,,"---> 64     return str(self.exception) + ""\n\nTraceback\n---------\n"" + self.traceback

TypeError: can only concatenate str (not ""traceback"") to str

- [x] Closes #11101
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/11102/timeline,,,sinsniwal,50590413,MDQ6VXNlcjUwNTkwNDEz,https://avatars.githubusercontent.com/u/50590413?v=4,,https://api.github.com/users/sinsniwal,https://github.com/sinsniwal,https://api.github.com/users/sinsniwal/followers,https://api.github.com/users/sinsniwal/following{/other_user},https://api.github.com/users/sinsniwal/gists{/gist_id},https://api.github.com/users/sinsniwal/starred{/owner}{/repo},https://api.github.com/users/sinsniwal/subscriptions,https://api.github.com/users/sinsniwal/orgs,https://api.github.com/users/sinsniwal/repos,https://api.github.com/users/sinsniwal/events{/privacy},https://api.github.com/users/sinsniwal/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11102/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/11102,https://github.com/dask/dask/pull/11102,https://github.com/dask/dask/pull/11102.diff,https://github.com/dask/dask/pull/11102.patch,,,,,,,,,,,,,,,,,,,
1039,https://api.github.com/repos/dask/dask/issues/11111,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11111/labels{/name},https://api.github.com/repos/dask/dask/issues/11111/comments,https://api.github.com/repos/dask/dask/issues/11111/events,https://github.com/dask/dask/issues/11111,2286746046,I_kwDOAbcwm86ITPm-,11111, Upstream CI failed ,"[{'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}]",open,False,,[],,0,2024-05-09T01:51:01Z,2024-06-06T01:53:18Z,,CONTRIBUTOR,,"[Workflow Run URL](https://github.com/dask/dask/actions/runs/9393681799)
<details><summary>Python 3.12 Test Summary</summary>

```
dask/dataframe/io/tests/test_csv.py::test_late_dtypes: AssertionError: assert 'Mismatched d...ns as floats.' == 'Mismatched d...to_datetime`.'
  
    Mismatched dtypes found in `pd.read_csv`/`pd.read_table`.
    
    +--------------+---------+----------+
    | Column       | Found   | Expected |
    +--------------+---------+----------+
    | more_numbers | float64 | int64    |
    | numbers      | float64 | int64    |
    +--------------+---------+----------+
    
    Usually this is due to dask's dtype inference failing, and
    *may* be fixed by specifying dtypes manually by adding:
    
    dtype={'more_numbers': 'float64',
           'numbers': 'float64'}
    
    to the call to `read_csv`/`read_table`.
    
    Alternatively, provide `assume_missing=True` to interpret
  - all unspecified integer columns as floats.
  ?                                           -
  + all unspecified integer columns as floats.
  - 
  - -------------------------------------------------------------
  - 
  - The following columns also failed to properly parse as dates:
  - 
  - - dates
  - 
  - This is usually due to an invalid value in that column. To
  - diagnose and fix it's recommended to drop these columns from the
  - `parse_dates` keyword, and manually convert them to dates later
  - using `dd.to_datetime`.
dask/dataframe/io/tests/test_parquet.py::test_pyarrow_schema_inference[infer-False]: AssertionError: Attributes of DataFrame.iloc[:, 1] (column name=""date"") are different

Attribute ""dtype"" are different
[left]:  datetime64[s]
[right]: datetime64[ms]
dask/dataframe/io/tests/test_parquet.py::test_pyarrow_schema_inference[infer-True]: AssertionError: Attributes of DataFrame.iloc[:, 0] (column name=""date"") are different

Attribute ""dtype"" are different
[left]:  datetime64[s]
[right]: datetime64[ms]
dask/dataframe/io/tests/test_parquet.py::test_pyarrow_schema_inference[complex-False]: AssertionError: Attributes of DataFrame.iloc[:, 1] (column name=""date"") are different

Attribute ""dtype"" are different
[left]:  datetime64[s]
[right]: datetime64[ms]
dask/dataframe/io/tests/test_parquet.py::test_pyarrow_schema_inference[complex-True]: AssertionError: Attributes of DataFrame.iloc[:, 0] (column name=""date"") are different

Attribute ""dtype"" are different
[left]:  datetime64[s]
[right]: datetime64[ms]
dask/dataframe/io/tests/test_parquet.py::test_roundtrip_decimal_dtype: AssertionError: Attributes of DataFrame.iloc[:, 0] (column name=""ts"") are different

Attribute ""dtype"" are different
[left]:  datetime64[s, UTC]
[right]: datetime64[ms, UTC]
dask/dataframe/io/tests/test_parquet.py::test_roundtrip_date_dtype: AssertionError: Attributes of DataFrame.iloc[:, 0] (column name=""ts"") are different

Attribute ""dtype"" are different
[left]:  datetime64[s, UTC]
[right]: datetime64[ms, UTC]
dask/dataframe/io/tests/test_sql.py::test_needs_rational: AssertionError: assert False
 +  where False = <function assert_dask_dtypes.<locals>.eq_dtypes at 0x7f24cd6c9940>(dtype('<M8[ns]'), dtype('<M8[us]'))
dask/dataframe/io/tests/test_sql.py::test_datetimes: AssertionError: assert False
 +  where False = <function assert_dask_dtypes.<locals>.eq_dtypes at 0x7f24ccce8a40>(dtype('<M8[ns]'), dtype('<M8[us]'))
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_creates_copy_cols[True-0]: TypeError: ufunc 'isnan' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_creates_copy_cols[True-1]: TypeError: ufunc 'isnan' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_creates_copy_cols[False-0]: TypeError: ufunc 'isnan' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_creates_copy_cols[False-1]: TypeError: ufunc 'isnan' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_creates_copy_cols[None-0]: TypeError: ufunc 'isnan' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_creates_copy_cols[None-1]: TypeError: ufunc 'isnan' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_with_larger_dataset[True-True-0]: AssertionError: Series are different

Series values are different (100.0 %)
[index]: [0]
[left]:  [16995710243078]
[right]: [16995710243078000]
At positional index 0, first diff: 16995710243078 != 16995710243078000
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_with_larger_dataset[True-True-1]: AssertionError: Series are different

Series values are different (100.0 %)
[index]: [0]
[left]:  [16995710243078]
[right]: [16995710243078000]
At positional index 0, first diff: 16995710243078 != 16995710243078000
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_with_larger_dataset[False-False-1]: AssertionError: Series are different

Series values are different (94.0 %)
[index]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, ...]
[left]:  [-9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, 618991102789761920, 619017287103613568, 619043471417465344, 619069655731316992, 619095840045168640, 619122024359020288, 619148208672871936, 619174392986723712, 619200577300575232, 619226761614427136, 619252945928278784, 619279130242130432, 619305314555981952, 619331498869833728, 619357683183685376, 619383867497537152, 619410051811388800, 619436236125240576, 619462420439092224, 619488604752943872, 619514789066795392, 619540973380647296, 619567157694498944, 619593342008350464, 619619526322202240, 619645710636054016, 619671894949905792, 619698079263757312, 619724263577608960, 619750447891460736, 619776632205312256, 619802816519163904, 619829000833015680, 619855185146867328, 619881369460719104, 619907553774570624, 619933738088422528, 619959922402274176, 619986106716125696, 620012291029977472, 620038475343829120, 620064659657680768, 620090843971532672, 620117028285384192, 620143212599235840, 620169396913087488, 620195581226939264, 620221765540790912, 620247949854642560, 620274134168494208, 620300318482345984, 620326502796197632, 620352687110049280, 620378871423901056, 620405055737752704, 620431240051604224, 620457424365456000, 620483608679307776, 620509792993159296, 620535977307010944, 620562161620862720, 620588345934714368, 620614530248566144, 620640714562417920, 620666898876269440, 620693083190121216, 620719267503972864, 620745451817824640, 620771636131676160, 620797820445527808, 620824004759379456, 620850189073231232, 620876373387082880, 620902557700934528, 620928742014786304, 620954926328637824, 620981110642489600, 621007294956341376, 621033479270193024, 621059663584044672, 621085847897896192, 621112032211748096, 621138216525599616, 621164400839451264, 621190585153303040, ...]
[right]: [-9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, 1098457150970900, 1030244837688498, 962032524406096, 893820211123694, 825607897841389, 757395584558986, 689183271276584, 620970957994279, 552758644711877, 484546331429475, 416334018147073, 348121704864767, 279909391582365, 211697078299963, 143484765017658, 75272451735256, 7060138452854, 61152174829548, 129364488111853, 197576801394255, 265789114676657, 334001427958963, 402213741241365, 470426054523767, 538638367806169, 606850681088474, 675062994370877, 743275307653278, 811487620935584, 879699934217986, 947912247500388, 1016124560782791, 1084336874065096, 1152549187347498, 1220761500629900, 1288973813912205, 1357186127194608, 1425398440477010, 1493610753759412, 1561823067041717, 1630035380324119, 1698247693606522, 1766460006888827, 1834672320171229, 1902884633453631, 1971096946736033, 2039309260018339, 2107521573300741, 2175733886583143, 2243946199865448, 2312158513147850, 2380370826430253, 2448583139712654, 2516795452994960, 2585007766277362, 2653220079559764, 2721432392842069, 2789644706124472, 2857857019406873, 2926069332689275, 2994281645971581, 3062493959253984, 3130706272536386, 3198918585818691, 3267130899101093, 3335343212383494, 3403555525665897, 3471767838948202, 3539980152230604, 3608192465513007, 3676404778795312, 3744617092077714, 3812829405360117, 3881041718642519, 3949254031924823, 4017466345207227, 4085678658489628, 4153890971771933, 4222103285054335, 4290315598336738, 4358527911619141, 4426740224901446, 4494952538183847, 4563164851466249, 4631377164748554, ...]
At positional index 15, first diff: 618991102789761920 != 1098457150970900
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_with_larger_dataset[False-True-0]: AssertionError: Series are different

Series values are different (100.0 %)
[index]: [0]
[left]:  [16995710243078]
[right]: [16995710243078000]
At positional index 0, first diff: 16995710243078 != 16995710243078000
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_with_larger_dataset[False-True-1]: AssertionError: Series are different

Series values are different (100.0 %)
[index]: [0]
[left]:  [16995710243078]
[right]: [16995710243078000]
At positional index 0, first diff: 16995710243078 != 16995710243078000
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_with_larger_dataset[None-False-1]: AssertionError: Series are different

Series values are different (94.0 %)
[index]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, ...]
[left]:  [-9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, 618991102789761920, 619017287103613568, 619043471417465344, 619069655731316992, 619095840045168640, 619122024359020288, 619148208672871936, 619174392986723712, 619200577300575232, 619226761614427136, 619252945928278784, 619279130242130432, 619305314555981952, 619331498869833728, 619357683183685376, 619383867497537152, 619410051811388800, 619436236125240576, 619462420439092224, 619488604752943872, 619514789066795392, 619540973380647296, 619567157694498944, 619593342008350464, 619619526322202240, 619645710636054016, 619671894949905792, 619698079263757312, 619724263577608960, 619750447891460736, 619776632205312256, 619802816519163904, 619829000833015680, 619855185146867328, 619881369460719104, 619907553774570624, 619933738088422528, 619959922402274176, 619986106716125696, 620012291029977472, 620038475343829120, 620064659657680768, 620090843971532672, 620117028285384192, 620143212599235840, 620169396913087488, 620195581226939264, 620221765540790912, 620247949854642560, 620274134168494208, 620300318482345984, 620326502796197632, 620352687110049280, 620378871423901056, 620405055737752704, 620431240051604224, 620457424365456000, 620483608679307776, 620509792993159296, 620535977307010944, 620562161620862720, 620588345934714368, 620614530248566144, 620640714562417920, 620666898876269440, 620693083190121216, 620719267503972864, 620745451817824640, 620771636131676160, 620797820445527808, 620824004759379456, 620850189073231232, 620876373387082880, 620902557700934528, 620928742014786304, 620954926328637824, 620981110642489600, 621007294956341376, 621033479270193024, 621059663584044672, 621085847897896192, 621112032211748096, 621138216525599616, 621164400839451264, 621190585153303040, ...]
[right]: [-9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, 1098457150970900, 1030244837688498, 962032524406096, 893820211123694, 825607897841389, 757395584558986, 689183271276584, 620970957994279, 552758644711877, 484546331429475, 416334018147073, 348121704864767, 279909391582365, 211697078299963, 143484765017658, 75272451735256, 7060138452854, 61152174829548, 129364488111853, 197576801394255, 265789114676657, 334001427958963, 402213741241365, 470426054523767, 538638367806169, 606850681088474, 675062994370877, 743275307653278, 811487620935584, 879699934217986, 947912247500388, 1016124560782791, 1084336874065096, 1152549187347498, 1220761500629900, 1288973813912205, 1357186127194608, 1425398440477010, 1493610753759412, 1561823067041717, 1630035380324119, 1698247693606522, 1766460006888827, 1834672320171229, 1902884633453631, 1971096946736033, 2039309260018339, 2107521573300741, 2175733886583143, 2243946199865448, 2312158513147850, 2380370826430253, 2448583139712654, 2516795452994960, 2585007766277362, 2653220079559764, 2721432392842069, 2789644706124472, 2857857019406873, 2926069332689275, 2994281645971581, 3062493959253984, 3130706272536386, 3198918585818691, 3267130899101093, 3335343212383494, 3403555525665897, 3471767838948202, 3539980152230604, 3608192465513007, 3676404778795312, 3744617092077714, 3812829405360117, 3881041718642519, 3949254031924823, 4017466345207227, 4085678658489628, 4153890971771933, 4222103285054335, 4290315598336738, 4358527911619141, 4426740224901446, 4494952538183847, 4563164851466249, 4631377164748554, ...]
At positional index 15, first diff: 618991102789761920 != 1098457150970900
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_with_larger_dataset[None-True-0]: AssertionError: Series are different

Series values are different (100.0 %)
[index]: [0]
[left]:  [16995710243078]
[right]: [16995710243078000]
At positional index 0, first diff: 16995710243078 != 16995710243078000
dask/dataframe/tests/test_arithmetics_reduction.py::test_datetime_std_with_larger_dataset[None-True-1]: AssertionError: Series are different

Series values are different (100.0 %)
[index]: [0]
[left]:  [16995710243078]
[right]: [16995710243078000]
At positional index 0, first diff: 16995710243078 != 16995710243078000
dask/dataframe/tests/test_dataframe.py::test_describe[all-None-None-None]: AssertionError: DataFrame.iloc[:, 3] (column name=""e"") are different

DataFrame.iloc[:, 3] (column name=""e"") values are different (83.33333 %)
[index]: [25%, 50%, 75%, count, freq, max, mean, min, std, top, unique]
[left]:  [1970-01-18 07:04:48.000006, 1970-01-18 07:04:58.799472499, 1970-01-18 07:05:11.345168922, 8, 1970-01-18 07:05:16.583858694, 1970-01-18 07:04:48.000006]
[right]: [2017-05-09 00:00:00.006000, 2017-05-09 02:59:59.472499, 2017-05-09 06:29:05.168922, 8, 2017-05-09 07:56:23.858694, 2017-05-09 00:00:00.006000]
At positional index 0, first diff: 1970-01-18 07:04:48.000006 != 2017-05-09 00:00:00.006000
dask/dataframe/tests/test_dataframe.py::test_describe[include6-None-percentiles6-None]: AssertionError: Series are different

Series values are different (83.33333 %)
[index]: [25%, 50%, 75%, count, max, min]
[left]:  [2017-05-09 00:00:00.006000, 2017-05-09 02:59:59.472499, 2017-05-09 06:29:05.168922, 8, 2017-05-09 07:56:23.858694, 2017-05-09 00:00:00.006000]
[right]: [1970-01-18 07:04:48.000006, 1970-01-18 07:04:58.799472499, 1970-01-18 07:05:11.345168922, 8, 1970-01-18 07:05:16.583858694, 1970-01-18 07:04:48.000006]
At positional index 0, first diff: 2017-05-09 00:00:00.006000 != 1970-01-18 07:04:48.000006
dask/dataframe/tests/test_dataframe.py::test_describe[include7-None-None-None]: AssertionError: Series are different

Series values are different (83.33333 %)
[index]: [25%, 50%, 75%, count, max, min]
[left]:  [2017-05-09 00:00:00.006000, 2017-05-09 02:59:59.472499, 2017-05-09 06:29:05.168922, 8, 2017-05-09 07:56:23.858694, 2017-05-09 00:00:00.006000]
[right]: [1970-01-18 07:04:48.000006, 1970-01-18 07:04:58.799472499, 1970-01-18 07:05:11.345168922, 8, 1970-01-18 07:05:16.583858694, 1970-01-18 07:04:48.000006]
At positional index 0, first diff: 2017-05-09 00:00:00.006000 != 1970-01-18 07:04:48.000006
dask/dataframe/tests/test_dataframe.py::test_describe[include8-None-percentiles8-None]: AssertionError: Series are different

Series values are different (83.33333 %)
[index]: [25%, 50%, 75%, count, max, min]
[left]:  [2017-05-09 00:00:00.006000, 2017-05-09 02:59:59.472499, 2017-05-09 06:29:05.168922, 8, 2017-05-09 07:56:23.858694, 2017-05-09 00:00:00.006000]
[right]: [1970-01-18 07:04:48.000006, 1970-01-18 07:04:58.799472499, 1970-01-18 07:05:11.345168922, 8, 1970-01-18 07:05:16.583858694, 1970-01-18 07:04:48.000006]
At positional index 0, first diff: 2017-05-09 00:00:00.006000 != 1970-01-18 07:04:48.000006
dask/dataframe/tests/test_dataframe.py::test_describe[None-exclude9-None-None]: AssertionError: DataFrame.iloc[:, 0] (column name=""e"") are different

DataFrame.iloc[:, 0] (column name=""e"") values are different (83.33333 %)
[index]: [25%, 50%, 75%, count, freq, max, min, top, unique]
[left]:  [1970-01-18 07:04:48.000006, 1970-01-18 07:04:58.799472499, 1970-01-18 07:05:11.345168922, 8, 1970-01-18 07:05:16.583858694, 1970-01-18 07:04:48.000006]
[right]: [2017-05-09 00:00:00.006000, 2017-05-09 02:59:59.472499, 2017-05-09 06:29:05.168922, 8, 2017-05-09 07:56:23.858694, 2017-05-09 00:00:00.006000]
At positional index 0, first diff: 1970-01-18 07:04:48.000006 != 2017-05-09 00:00:00.006000
dask/dataframe/tests/test_dataframe.py::test_describe[include10-None-None-None]: AssertionError: DataFrame.iloc[:, 1] (column name=""e"") are different

DataFrame.iloc[:, 1] (column name=""e"") values are different (83.33333 %)
[index]: [25%, 50%, 75%, count, freq, max, min, top, unique]
[left]:  [1970-01-18 07:04:48.000006, 1970-01-18 07:04:58.799472499, 1970-01-18 07:05:11.345168922, 8, 1970-01-18 07:05:16.583858694, 1970-01-18 07:04:48.000006]
[right]: [2017-05-09 00:00:00.006000, 2017-05-09 02:59:59.472499, 2017-05-09 06:29:05.168922, 8, 2017-05-09 07:56:23.858694, 2017-05-09 00:00:00.006000]
At positional index 0, first diff: 1970-01-18 07:04:48.000006 != 2017-05-09 00:00:00.006000
dask/dataframe/tests/test_indexing.py::test_getitem_integer_slice: Failed: DID NOT WARN. No warnings of type (<class 'FutureWarning'>,) were emitted.
 Emitted warnings: [].
dask/dataframe/tests/test_indexing.py::test_loc_on_numpy_datetimes: KeyError: Timestamp('2015-12-31 23:59:59.999999999')
dask/dataframe/tests/test_indexing.py::test_loc_on_pandas_datetimes: KeyError: Timestamp('2015-12-31 23:59:59.999999999')
dask/dataframe/tests/test_utils_dataframe.py::test_meta_nonempty: assert np.False_
 +  where np.False_ = <bound method Series.all of D     True\nC     True\nB     True\nA     True\nH     True\nG    False\nF     True\nE     True\nI     True\nJ     True\nK     True\ndtype: bool>()
 +    where <bound method Series.all of D     True\nC     True\nB     True\nA     True\nH     True\nG    False\nF     True\nE     True\nI     True\nJ     True\nK     True\ndtype: bool> = D            ...\ndtype: object == D            ...\ndtype: object
      
      Full diff:
      [0m[91m- D                             float32[39;49;00m[90m[39;49;00m
      ?  -[90m[39;49;00m
      [92m+ D                            float32[39;49;00m[90m[39;49;00m
      [91m- C                              object[39;49;00m[90m[39;49;00m
      ?  -[90m[39;49;00m
      [92m+ C                             object[39;49;00m[90m[39;49;00m
      [91m- B                              object[39;49;00m[90m[39;49;00m
      ?  -[90m[39;49;00m
      [92m+ B                             object[39;49;00m[90m[39;49;00m
      [91m- A                            category[39;49;00m[90m[39;49;00m
      ?  -[90m[39;49;00m
      [92m+ A                           category[39;49;00m[90m[39;49;00m
      [91m- H                     timedelta64[ns][39;49;00m[90m[39;49;00m
      ?  -[90m[39;49;00m
      [92m+ H                    timedelta64[ns][39;49;00m[90m[39;49;00m
      [91m- G    datetime64[ns, America/New_York][39;49;00m[90m[39;49;00m
      ?                 -[90m[39;49;00m
      [92m+ G    datetime64[s, America/New_York][39;49;00m[90m[39;49;00m
      [91m- F                       datetime64[s][39;49;00m[90m[39;49;00m
      ?  -[90m[39;49;00m
      [92m+ F                      datetime64[s][39;49;00m[90m[39;49;00m
      [91m- E                               int32[39;49;00m[90m[39;49;00m
      ?  -[90m[39;49;00m
      [92m+ E                              int32[39;49;00m[90m[39;49;00m
      [91m- I                              object[39;49;00m[90m[39;49;00m
      ?  -[90m[39;49;00m
      [92m+ I                             object[39;49;00m[90m[39;49;00m
      [91m- J                            category[39;49;00m[90m[39;49;00m
      ?  -[90m[39;49;00m
      [92m+ J                           category[39;49;00m[90m[39;49;00m
      [91m- K                            category[39;49;00m[90m[39;49;00m
      ?  -[90m[39;49;00m
      [92m+ K                           category[39;49;00m[90m[39;49;00m
      [90m [39;49;00m dtype: object[90m[39;49;00m.all
dask/dataframe/tseries/tests/test_resample.py::test_series_resample_non_existent_datetime: AssertionError: DataFrame.index are different

Attribute ""dtype"" are different
[left]:  datetime64[ns, America/Sao_Paulo]
[right]: datetime64[s, America/Sao_Paulo]
dask/tests/test_tokenize.py::test_tokenize_random_functions[np.random]: AssertionError: assert '5f4f340df8ac...b36da9a558124' == '6ea121fd45b6...8a7c40ace2565'
  
  - 6ea121fd45b6c4f8d638a7c40ace2565
  + 5f4f340df8ac8075fc8b36da9a558124
```

</details>
",,https://api.github.com/repos/dask/dask/issues/11111/timeline,,,github-actions[bot],41898282,MDM6Qm90NDE4OTgyODI=,https://avatars.githubusercontent.com/in/15368?v=4,,https://api.github.com/users/github-actions%5Bbot%5D,https://github.com/apps/github-actions,https://api.github.com/users/github-actions%5Bbot%5D/followers,https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user},https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id},https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo},https://api.github.com/users/github-actions%5Bbot%5D/subscriptions,https://api.github.com/users/github-actions%5Bbot%5D/orgs,https://api.github.com/users/github-actions%5Bbot%5D/repos,https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy},https://api.github.com/users/github-actions%5Bbot%5D/received_events,Bot,False,https://api.github.com/repos/dask/dask/issues/11111/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1040,https://api.github.com/repos/dask/dask/issues/11113,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11113/labels{/name},https://api.github.com/repos/dask/dask/issues/11113/comments,https://api.github.com/repos/dask/dask/issues/11113/events,https://github.com/dask/dask/issues/11113,2287982116,I_kwDOAbcwm86IX9Yk,11113,Mean fails to compute for very large column of pyarrow type,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}]",open,False,,[],,1,2024-05-09T15:52:14Z,2024-05-14T05:00:18Z,,NONE,,"It's not possible to calculate the grouped mean for a very large column of pyarrow type.

```python
import pandas as pd
import numpy as np
import pyarrow as pa

import dask.dataframe
import dask.distributed

df = pd.DataFrame({
    # A series of ones that is larger than the maximum supported by uint32
    'a': pd.Series(np.ones(1 << 32), dtype=pd.ArrowDtype(pa.uint8())),
    # A distribution of values for which to compute the mean for
    'b': pd.Series(np.linspace(0, 1, 1 << 32), dtype=pd.ArrowDtype(pa.float32())),
})
```

It fails to compute with the legacy DataFrame:

```python
with dask.distributed.Client():
    dask.dataframe.io.from_pandas(df, npartitions=5).groupby('a').b.mean().compute()
```

```
2024-05-09 08:33:07,340 - distributed.worker - WARNING - Compute Failed
Key:       ('truediv-8d00596f7743a7ba07a11eb25b3109ae', 0)
Function:  subgraph_callable-f24250c276b80c2c50dfa1c2094ebf85
args:      (a
1    2.147484e+09
Name: b, dtype: float[pyarrow], a
1    4294967296
Name: b, dtype: int64)
kwargs:    {}
Exception: ""ArrowInvalid('Integer value 4294967296 not in range: -16777216 to 16777216')""
```

I tried using the latest DataFrame API but this operation does not seem to be supported yet:

```python
with dask.distributed.Client():
    dask.dataframe.from_pandas(df).groupby('a').b.mean().compute()
```

> NotImplementedError: <class 'pandas.core.arrays.arrow.array.ArrowExtensionArray'> does not support reshape as backed by a 1D pyarrow.ChunkedArray.

Pandas seems to execute this workflow without issues:

```python
df.groupby('a').b.mean()
```

```
a
1    0.5
Name: b, dtype: float[pyarrow]
```

**Environment**:

- Dask version: 2024.5.0
- Python version: 3.10.13
- Operating System: CentOS Linux 7
- Install method (conda, pip, source): pip",,https://api.github.com/repos/dask/dask/issues/11113/timeline,,,camposandro,28362589,MDQ6VXNlcjI4MzYyNTg5,https://avatars.githubusercontent.com/u/28362589?v=4,,https://api.github.com/users/camposandro,https://github.com/camposandro,https://api.github.com/users/camposandro/followers,https://api.github.com/users/camposandro/following{/other_user},https://api.github.com/users/camposandro/gists{/gist_id},https://api.github.com/users/camposandro/starred{/owner}{/repo},https://api.github.com/users/camposandro/subscriptions,https://api.github.com/users/camposandro/orgs,https://api.github.com/users/camposandro/repos,https://api.github.com/users/camposandro/events{/privacy},https://api.github.com/users/camposandro/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11113/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1041,https://api.github.com/repos/dask/dask/issues/11116,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11116/labels{/name},https://api.github.com/repos/dask/dask/issues/11116/comments,https://api.github.com/repos/dask/dask/issues/11116/events,https://github.com/dask/dask/issues/11116,2289370607,I_kwDOAbcwm86IdQXv,11116,"When using PyArrow dtypes, aggregations create NaNs of unexpected type","[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2024-05-10T09:33:59Z,2024-05-10T09:36:32Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:

Under certain conditionsaggregations of groups that have only missing values, when using PyArrow floatsDask creates NaNs of an unexpected type. PyArrow types are nullable, so it should create `<NA>` but it creates `NaN`, which are then incorrectly not treated as missing values. 

**Minimal Complete Verifiable Example**:

```python
import pandas as pd
import dask.dataframe as dd

df = pd.DataFrame({
    ""x"": range(15),
    ""y"": [pd.NA] * 10 + [1.0] * 5,
    ""group"": [""a""] * 5 + [""b""] * 5 + [""c""] * 5
})

ddf = dd.from_pandas(df, npartitions=2).astype({
    ""y"": ""double[pyarrow]""
})
print(ddf.compute())
#      x     y group
# 0    0  <NA>     a
# 1    1  <NA>     a
# 2    2  <NA>     a
# 3    3  <NA>     a
# 4    4  <NA>     a
# 5    5  <NA>     b
# 6    6  <NA>     b
# 7    7  <NA>     b
# 8    8  <NA>     b
# 9    9  <NA>     b
# 10  10   1.0     c
# 11  11   1.0     c
# 12  12   1.0     c
# 13  13   1.0     c
# 14  14   1.0     c

ddf = ddf.groupby(""group"").agg(x=(""x"", ""mean""), y=(""y"", ""mean""))
print(ddf.compute())
#           x    y
# group           
# a       2.0  NaN
# b       7.0  NaN
# c      12.0  1.0
# (Note that groups with <NA> resulted in NaN rather than <NA>)

# These NaNs are then not recognized as missing values
print(ddf[""y""].isnull().sum().compute())
# 0
# (While the expected result is 2).

# This breaks other functions, example further aggregations in Pandas
print(ddf[""y""].compute().mean(skipna=True))
# nan
# (While the exected result is 1.0).

# And also further aggreations in Dask, albeit with a different unexpected result
print(ddf[""y""].mean(skipna=True).compute())
# 0.0
# (While the exected result is 1.0)
```

**Anything else we need to know?**:

If we use Numpy dtypes, i.e. convert `y` to `float64` rather than `double[pyarrow]` everything works as expected. 



**Environment**:

- Dask version: 2024.4.1
- Python version: 3.10.13
- Operating System: MacOS on the client, dask running inside Docker based on ghcr.io/dask/dask image on the cluster. 
- Install method (conda, pip, source): pip on the client, using ghcr.io/dask/dask as the base image on the cluster. 
",,https://api.github.com/repos/dask/dask/issues/11116/timeline,,,nprihodko,67439573,MDQ6VXNlcjY3NDM5NTcz,https://avatars.githubusercontent.com/u/67439573?v=4,,https://api.github.com/users/nprihodko,https://github.com/nprihodko,https://api.github.com/users/nprihodko/followers,https://api.github.com/users/nprihodko/following{/other_user},https://api.github.com/users/nprihodko/gists{/gist_id},https://api.github.com/users/nprihodko/starred{/owner}{/repo},https://api.github.com/users/nprihodko/subscriptions,https://api.github.com/users/nprihodko/orgs,https://api.github.com/users/nprihodko/repos,https://api.github.com/users/nprihodko/events{/privacy},https://api.github.com/users/nprihodko/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11116/reactions,1,1,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1042,https://api.github.com/repos/dask/dask/issues/11118,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11118/labels{/name},https://api.github.com/repos/dask/dask/issues/11118/comments,https://api.github.com/repos/dask/dask/issues/11118/events,https://github.com/dask/dask/pull/11118,2293899046,PR_kwDOAbcwm85vUU57,11118,Fix na casting behavior for groupby.agg with arrow dtypes,[],open,False,,[],,1,2024-05-13T21:44:11Z,2024-05-13T22:16:12Z,,MEMBER,,"- [ ] Closes #11116
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/11118/timeline,,,phofl,61934744,MDQ6VXNlcjYxOTM0NzQ0,https://avatars.githubusercontent.com/u/61934744?v=4,,https://api.github.com/users/phofl,https://github.com/phofl,https://api.github.com/users/phofl/followers,https://api.github.com/users/phofl/following{/other_user},https://api.github.com/users/phofl/gists{/gist_id},https://api.github.com/users/phofl/starred{/owner}{/repo},https://api.github.com/users/phofl/subscriptions,https://api.github.com/users/phofl/orgs,https://api.github.com/users/phofl/repos,https://api.github.com/users/phofl/events{/privacy},https://api.github.com/users/phofl/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11118/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/11118,https://github.com/dask/dask/pull/11118,https://github.com/dask/dask/pull/11118.diff,https://github.com/dask/dask/pull/11118.patch,,,,,,,,,,,,,,,,,,,
1043,https://api.github.com/repos/dask/dask/issues/11119,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11119/labels{/name},https://api.github.com/repos/dask/dask/issues/11119/comments,https://api.github.com/repos/dask/dask/issues/11119/events,https://github.com/dask/dask/issues/11119,2294450426,I_kwDOAbcwm86Iwoj6,11119,aggregate function that operates on vector(array of numeric) data,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,0,2024-05-14T05:38:17Z,2024-05-14T05:38:27Z,,NONE,,"<!-- Please do a quick search of existing issues to make sure that this has not been asked before. -->
I am wondering if `dask` or `pandas` has native or built-in support for aggregate function that run against vector data. Namley, text/image embeddings are stored in the column of `csv/parquet` file. And I'd like to run various aggregate functions such as `mean`, `max` and so on. All these operations are element-wise, namely, it returns the mean of all the values in same index and return an array with same lenght. What's more, I'd like to run `K-Nearest-Neighbor` search as well.

If not natively supported, how to achieve these operations with performance efficient?

example code:
```
import dask.dataframe as dd
import pandas as pd
import numpy as np

# Sample DataFrame with arrays in one of the columns
data = {
    'category': ['A', 'A', 'B', 'B'],
    'values': [np.array([1, 2, 3]), np.array([4, 5, 6]), np.array([7, 8, 9]), np.array([10, 11, 12])],
    'scalar': [1, 2, 3, 4]
}
pdf = pd.DataFrame(data)

# Convert the Pandas DataFrame to a Dask DataFrame
ddf = dd.from_pandas(pdf, npartitions=2)

result = ddf.groupby('category')['values'].mean().compute()

print(result)
```

Expected output
```
category
A     [2.5, 3.5, 4.5]
B    [8.5, 9.5, 10.5]
Name: values, dtype: object
```",,https://api.github.com/repos/dask/dask/issues/11119/timeline,,,Rhett-Ying,85214957,MDQ6VXNlcjg1MjE0OTU3,https://avatars.githubusercontent.com/u/85214957?v=4,,https://api.github.com/users/Rhett-Ying,https://github.com/Rhett-Ying,https://api.github.com/users/Rhett-Ying/followers,https://api.github.com/users/Rhett-Ying/following{/other_user},https://api.github.com/users/Rhett-Ying/gists{/gist_id},https://api.github.com/users/Rhett-Ying/starred{/owner}{/repo},https://api.github.com/users/Rhett-Ying/subscriptions,https://api.github.com/users/Rhett-Ying/orgs,https://api.github.com/users/Rhett-Ying/repos,https://api.github.com/users/Rhett-Ying/events{/privacy},https://api.github.com/users/Rhett-Ying/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11119/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1044,https://api.github.com/repos/dask/dask/issues/11122,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11122/labels{/name},https://api.github.com/repos/dask/dask/issues/11122/comments,https://api.github.com/repos/dask/dask/issues/11122/events,https://github.com/dask/dask/issues/11122,2297389042,I_kwDOAbcwm86I71_y,11122,"API docs missing for `read_csv`, `read_fwf` and `read_table`","[{'id': 162914698, 'node_id': 'MDU6TGFiZWwxNjI5MTQ2OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/good%20first%20issue', 'name': 'good first issue', 'color': '159818', 'default': True, 'description': 'Clearly described and easy to accomplish. Good for beginners to the project.'}, {'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,3,2024-05-15T09:47:14Z,2024-05-22T02:41:41Z,,MEMBER,,"I believe there are still plenty of doc strings missing since the dask-expr migration

For example https://docs.dask.org/en/latest/generated/dask_expr.read_csv.html

![image](https://github.com/dask/dask/assets/8629629/280413f4-5a65-4429-a54f-7c94fcf439e5)
",,https://api.github.com/repos/dask/dask/issues/11122/timeline,,,fjetter,8629629,MDQ6VXNlcjg2Mjk2Mjk=,https://avatars.githubusercontent.com/u/8629629?v=4,,https://api.github.com/users/fjetter,https://github.com/fjetter,https://api.github.com/users/fjetter/followers,https://api.github.com/users/fjetter/following{/other_user},https://api.github.com/users/fjetter/gists{/gist_id},https://api.github.com/users/fjetter/starred{/owner}{/repo},https://api.github.com/users/fjetter/subscriptions,https://api.github.com/users/fjetter/orgs,https://api.github.com/users/fjetter/repos,https://api.github.com/users/fjetter/events{/privacy},https://api.github.com/users/fjetter/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11122/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1045,https://api.github.com/repos/dask/dask/issues/11124,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11124/labels{/name},https://api.github.com/repos/dask/dask/issues/11124/comments,https://api.github.com/repos/dask/dask/issues/11124/events,https://github.com/dask/dask/issues/11124,2298282664,I_kwDOAbcwm86I_QKo,11124,Overlap with `new_axis` option is not trimmed correctly,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,1,2024-05-15T15:51:51Z,2024-05-17T13:17:32Z,,NONE,,"<!-- Please include a self-contained copy-pastable example that generates the issue if possible.

Please be concise with code posted. See guidelines below on how to provide a good bug report:

- Craft Minimal Bug Reports http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports
- Minimal Complete Verifiable Examples https://stackoverflow.com/help/mcve

Bug reports that follow these guidelines are easier to diagnose, and so are often handled much more quickly.
-->

**Describe the issue**:
I would like to expand a 3D array of chunk size (32,128,128) to a 4D array of chunk size (3,32,128,128) with a computation that relies on an overlap (chunk sizes (52,148,148) and (3,52,148,148)), then trimming the overlap (chunk size (3,32,128,128)). 

I would prefer not to have to deal with the overlap myself in the gufunc.

**Minimal Complete Verifiable Example**:

```python
import numpy as np
import dask, dask.array
import cupy as cp

def create_color(u):
    return np.stack([u*1.0,u*0.5,u*0.0])

x = np.ones((32, 128, 128))
y = dask.array.from_array(x)

overlap_depth = 10

colors_preview_overlap = dask.array.overlap.overlap(y.astype(np.float64),(overlap_depth, overlap_depth, overlap_depth),'reflect')
colors_preview_map = dask.array.core.map_blocks(create_color,colors_preview_overlap,meta=cp.array(()),chunks=(3,32+2*overlap_depth,128+2*overlap_depth,128+2*overlap_depth),new_axis=[0])
colors_preview_trimmed = dask.array.overlap.trim_overlap(colors_preview_map, (0,overlap_depth, overlap_depth, overlap_depth)) # same return with `trim_internal`

colors_preview_1 = colors_preview_trimmed.compute()
print(colors_preview_1.shape)

colors_preview_2 = y.astype(np.float64).map_overlap(create_color,overlap_depth,'reflect',meta=cp.array(()),chunks=(3,32+2*overlap_depth,128+2*overlap_depth,128+2*overlap_depth),new_axis=[0])
colors_preview_2 = colors_preview_2.compute()
print(colors_preview_2.shape)

colors_preview_3 = y.astype(np.float64).map_overlap(create_color,(overlap_depth, overlap_depth, overlap_depth),'reflect',meta=cp.array(()),chunks=(3,32+2*overlap_depth,128+2*overlap_depth,128+2*overlap_depth),new_axis=[0])
colors_preview_3 = colors_preview_3.compute()
print(colors_preview_3.shape)

colors_preview_4 = y.astype(np.float64).map_overlap(create_color,(0,overlap_depth, overlap_depth, overlap_depth),'reflect',meta=cp.array(()),chunks=(3,32+2*overlap_depth,128+2*overlap_depth,128+2*overlap_depth),new_axis=[0])
colors_preview_4 = colors_preview_4.compute()
print(colors_preview_4.shape)
```

These will return:

> (3, 52, 148, 148)
> (0, 32, 128, 148)
> (0, 32, 128, 148)
> (3, 12, 128, 148)

whereas I would like them to return:

> (3, 32, 128, 128)

**Anything else we need to know?**:

No

**Environment**:

- Dask version: 2024.5.0
- Python version: Python 3.11.5
- Operating System: Windows 11
- Install method (conda, pip, source): pip
",,https://api.github.com/repos/dask/dask/issues/11124/timeline,,,chourroutm,83714683,MDQ6VXNlcjgzNzE0Njgz,https://avatars.githubusercontent.com/u/83714683?v=4,,https://api.github.com/users/chourroutm,https://github.com/chourroutm,https://api.github.com/users/chourroutm/followers,https://api.github.com/users/chourroutm/following{/other_user},https://api.github.com/users/chourroutm/gists{/gist_id},https://api.github.com/users/chourroutm/starred{/owner}{/repo},https://api.github.com/users/chourroutm/subscriptions,https://api.github.com/users/chourroutm/orgs,https://api.github.com/users/chourroutm/repos,https://api.github.com/users/chourroutm/events{/privacy},https://api.github.com/users/chourroutm/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11124/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1046,https://api.github.com/repos/dask/dask/issues/11127,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11127/labels{/name},https://api.github.com/repos/dask/dask/issues/11127/comments,https://api.github.com/repos/dask/dask/issues/11127/events,https://github.com/dask/dask/issues/11127,2302809618,I_kwDOAbcwm86JQhYS,11127,map_blocks returning pd.DataFrame fails with block_info parameter,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,4,2024-05-17T13:49:11Z,2024-05-23T14:08:28Z,,NONE,,"```python
import dask.array as da
import dask.dataframe as dd
import numpy as np
import pandas as pd

np.random.seed(42)
a = da.random.random(size=(100, 100), chunks=(10, 10))


def test1(x):
    return pd.DataFrame({""x"": np.arange(4), ""y"": np.arange(4), ""z"": [""a"", ""b"", ""c"", ""d""]})


def test2(x, block_info=None):
    return pd.DataFrame({""x"": np.arange(4), ""y"": np.arange(4), ""z"": [""a"", ""b"", ""c"", ""d""]})


meta = dd.utils.make_meta([(""x"", np.int64), (""y"", np.int64), (""z"", object)])
df1 = da.map_blocks(test1, a, drop_axis=1, meta=meta).compute()  # works
df2 = da.map_blocks(test2, a, drop_axis=1, meta=meta).compute()  # fails with AttributeError: 'DataFrame' object has no attribute 'chunks'
```

",,https://api.github.com/repos/dask/dask/issues/11127/timeline,,,joshua-gould,5237151,MDQ6VXNlcjUyMzcxNTE=,https://avatars.githubusercontent.com/u/5237151?v=4,,https://api.github.com/users/joshua-gould,https://github.com/joshua-gould,https://api.github.com/users/joshua-gould/followers,https://api.github.com/users/joshua-gould/following{/other_user},https://api.github.com/users/joshua-gould/gists{/gist_id},https://api.github.com/users/joshua-gould/starred{/owner}{/repo},https://api.github.com/users/joshua-gould/subscriptions,https://api.github.com/users/joshua-gould/orgs,https://api.github.com/users/joshua-gould/repos,https://api.github.com/users/joshua-gould/events{/privacy},https://api.github.com/users/joshua-gould/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11127/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1047,https://api.github.com/repos/dask/dask/issues/11128,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11128/labels{/name},https://api.github.com/repos/dask/dask/issues/11128/comments,https://api.github.com/repos/dask/dask/issues/11128/events,https://github.com/dask/dask/pull/11128,2303284588,PR_kwDOAbcwm85v0kWC,11128,Fix map_overlap with new_axis,[],open,False,,[],,2,2024-05-17T17:42:01Z,2024-06-01T11:17:15Z,,FIRST_TIME_CONTRIBUTOR,,"- [x] Closes #xxxx
- [x] Tests added / passed
- [x] Passes `pre-commit run --all-files`

Fixes https://github.com/dask/dask/issues/11124.

This does not feel like the nicest or best tested code, so suggestions for improvements to the code or extra tests I could add would be appreciated.",,https://api.github.com/repos/dask/dask/issues/11128/timeline,,,dstansby,6197628,MDQ6VXNlcjYxOTc2Mjg=,https://avatars.githubusercontent.com/u/6197628?v=4,,https://api.github.com/users/dstansby,https://github.com/dstansby,https://api.github.com/users/dstansby/followers,https://api.github.com/users/dstansby/following{/other_user},https://api.github.com/users/dstansby/gists{/gist_id},https://api.github.com/users/dstansby/starred{/owner}{/repo},https://api.github.com/users/dstansby/subscriptions,https://api.github.com/users/dstansby/orgs,https://api.github.com/users/dstansby/repos,https://api.github.com/users/dstansby/events{/privacy},https://api.github.com/users/dstansby/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11128/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/11128,https://github.com/dask/dask/pull/11128,https://github.com/dask/dask/pull/11128.diff,https://github.com/dask/dask/pull/11128.patch,,,,,,,,,,,,,,,,,,,
1048,https://api.github.com/repos/dask/dask/issues/11146,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11146/labels{/name},https://api.github.com/repos/dask/dask/issues/11146/comments,https://api.github.com/repos/dask/dask/issues/11146/events,https://github.com/dask/dask/issues/11146,2315925688,I_kwDOAbcwm86KCji4,11146,Dask 2024.5.1 removed `.attrs`,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,4,2024-05-24T17:50:52Z,2024-06-06T13:45:49Z,,NONE,,"The latest release removed `.attrs`. This breaks backward compatibility and also Pandas still uses it, so I kindly ask if it can be reinstated.

To reproduce, the last assert should pass.
```python
import dask.dataframe as dd
df = dd.from_pandas(pd.DataFrame())
assert hasattr(df.compute(), 'attrs') == True
assert hasattr(df, 'attrs') == True
```

**Environment**:

- Dask version: 2024.5.1
- Python version: 3.12.2
- Operating System: macOS Sonoma 14.5
- Install method (conda, pip, source): conda
",,https://api.github.com/repos/dask/dask/issues/11146/timeline,,,LucaMarconato,2664412,MDQ6VXNlcjI2NjQ0MTI=,https://avatars.githubusercontent.com/u/2664412?v=4,,https://api.github.com/users/LucaMarconato,https://github.com/LucaMarconato,https://api.github.com/users/LucaMarconato/followers,https://api.github.com/users/LucaMarconato/following{/other_user},https://api.github.com/users/LucaMarconato/gists{/gist_id},https://api.github.com/users/LucaMarconato/starred{/owner}{/repo},https://api.github.com/users/LucaMarconato/subscriptions,https://api.github.com/users/LucaMarconato/orgs,https://api.github.com/users/LucaMarconato/repos,https://api.github.com/users/LucaMarconato/events{/privacy},https://api.github.com/users/LucaMarconato/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11146/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1049,https://api.github.com/repos/dask/dask/issues/11149,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11149/labels{/name},https://api.github.com/repos/dask/dask/issues/11149/comments,https://api.github.com/repos/dask/dask/issues/11149/events,https://github.com/dask/dask/issues/11149,2318461767,I_kwDOAbcwm86KMOtH,11149,a tutorial for distributed text deduplication,"[{'id': 386719598, 'node_id': 'MDU6TGFiZWwzODY3MTk1OTg=', 'url': 'https://api.github.com/repos/dask/dask/labels/documentation', 'name': 'documentation', 'color': 'f9d0c4', 'default': True, 'description': 'Improve or add to documentation'}]",open,False,,[],,5,2024-05-27T07:38:30Z,2024-06-03T07:29:57Z,,NONE,,"Can you provide an example of distributed text deduplication based on dask, such as
- https://github.com/xorbitsai/xorbits/blob/main/python/xorbits/experimental/dedup.py
- https://github.com/ChenghaoMou/text-dedup/blob/main/text_dedup/minhash_spark.py
- https://github.com/FlagOpen/FlagData/blob/main/flagdata/deduplication/minhash.py",,https://api.github.com/repos/dask/dask/issues/11149/timeline,,,simplew2011,66729924,MDQ6VXNlcjY2NzI5OTI0,https://avatars.githubusercontent.com/u/66729924?v=4,,https://api.github.com/users/simplew2011,https://github.com/simplew2011,https://api.github.com/users/simplew2011/followers,https://api.github.com/users/simplew2011/following{/other_user},https://api.github.com/users/simplew2011/gists{/gist_id},https://api.github.com/users/simplew2011/starred{/owner}{/repo},https://api.github.com/users/simplew2011/subscriptions,https://api.github.com/users/simplew2011/orgs,https://api.github.com/users/simplew2011/repos,https://api.github.com/users/simplew2011/events{/privacy},https://api.github.com/users/simplew2011/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11149/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1050,https://api.github.com/repos/dask/dask/issues/11150,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11150/labels{/name},https://api.github.com/repos/dask/dask/issues/11150/comments,https://api.github.com/repos/dask/dask/issues/11150/events,https://github.com/dask/dask/pull/11150,2321835367,PR_kwDOAbcwm85wznQv,11150,Modify left semi/anti test to cover CPU query planning,[],open,False,,[],,1,2024-05-28T20:10:38Z,2024-06-06T04:09:43Z,,MEMBER,,"Noticed that dask-expr added support for left semi joins on CPU, but the test for it here is still xfailing because pandas doesn't natively support this join type.

Modified this test to compute the pandas leftsemi join similarly to how it's done in dask-expr's test suite ([link](https://github.com/dask/dask-expr/blob/97de2ab16d0999a74d6e108504dde503caee2ab9/dask_expr/tests/test_merge.py#L981)), so that we can at least verify that the graph computes successfully in this case.

EDIT:

Following up on discussion in https://github.com/dask/dask-expr/pull/1073#discussion_r1619366034, also pushing some changes here to unblock left anti joins on CPU with query planning.

- [ ] Closes #xxxx
- [ ] Tests added / passed
- [ ] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/11150/timeline,,,charlesbluca,20627856,MDQ6VXNlcjIwNjI3ODU2,https://avatars.githubusercontent.com/u/20627856?v=4,,https://api.github.com/users/charlesbluca,https://github.com/charlesbluca,https://api.github.com/users/charlesbluca/followers,https://api.github.com/users/charlesbluca/following{/other_user},https://api.github.com/users/charlesbluca/gists{/gist_id},https://api.github.com/users/charlesbluca/starred{/owner}{/repo},https://api.github.com/users/charlesbluca/subscriptions,https://api.github.com/users/charlesbluca/orgs,https://api.github.com/users/charlesbluca/repos,https://api.github.com/users/charlesbluca/events{/privacy},https://api.github.com/users/charlesbluca/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11150/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/11150,https://github.com/dask/dask/pull/11150,https://github.com/dask/dask/pull/11150.diff,https://github.com/dask/dask/pull/11150.patch,,,,,,,,,,,,,,,,,,,
1051,https://api.github.com/repos/dask/dask/issues/11153,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11153/labels{/name},https://api.github.com/repos/dask/dask/issues/11153/comments,https://api.github.com/repos/dask/dask/issues/11153/events,https://github.com/dask/dask/issues/11153,2323604866,I_kwDOAbcwm86Kf2WC,11153,`dask/dataframe/tests/test_indexing.py::test_getitem_integer_slice` failing with nightly `pandas`,"[{'id': 242862289, 'node_id': 'MDU6TGFiZWwyNDI4NjIyODk=', 'url': 'https://api.github.com/repos/dask/dask/labels/dataframe', 'name': 'dataframe', 'color': 'fbca04', 'default': False, 'description': None}, {'id': 2949860090, 'node_id': 'MDU6TGFiZWwyOTQ5ODYwMDkw', 'url': 'https://api.github.com/repos/dask/dask/labels/upstream', 'name': 'upstream', 'color': 'DDF8B0', 'default': False, 'description': ''}]",open,False,,[],,0,2024-05-29T15:25:06Z,2024-05-29T15:25:06Z,,MEMBER,,"`dask/dataframe/tests/test_indexing.py::test_getitem_integer_slice` has been failing against nightly `pandas` for a while now. Looks like https://github.com/pandas-dev/pandas/pull/58646 is related upstream. @phofl do you have bandwidth to look into this one? 

```
__________________________ test_getitem_integer_slice __________________________
[gw2] linux -- Python 3.12.3 /home/runner/miniconda3/envs/test-environment/bin/python3.12

    def test_getitem_integer_slice():
        df = pd.DataFrame({""A"": range(6)})
        ddf = dd.from_pandas(df, 2)
        # integer slicing is iloc based
        with pytest.raises(NotImplementedError):
            ddf[1:3]
    
        df = pd.DataFrame({""A"": range(6)}, index=[1.0, 2.0, 3.0, 5.0, 10.0, 11.0])
        ddf = dd.from_pandas(df, 2)
        # except for float dtype indexes
        ctx = contextlib.nullcontext()
        if PANDAS_GE_210:
            ctx = pytest.warns(FutureWarning, match=""float-dtype index"")
        with ctx:
>           assert_eq(ddf[2:8], df[2:8])

dask/dataframe/tests/test_indexing.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a =      A
2.0  1
3.0  2
5.0  3, b =       A
3.0   2
5.0   3
10.0  4
11.0  5
check_names = True, check_dtype = True, check_divisions = True
check_index = True, sort_results = True, scheduler = 'sync', kwargs = {}

    def assert_eq(
        a,
        b,
        check_names=True,
        check_dtype=True,
        check_divisions=True,
        check_index=True,
        sort_results=True,
        scheduler=""sync"",
        **kwargs,
    ):
        if check_divisions:
            assert_divisions(a, scheduler=scheduler)
            assert_divisions(b, scheduler=scheduler)
            if hasattr(a, ""divisions"") and hasattr(b, ""divisions""):
                at = type(np.asarray(a.divisions).tolist()[0])  # numpy to python
                bt = type(np.asarray(b.divisions).tolist()[0])  # scalar conversion
                assert at == bt, (at, bt)
        assert_sane_keynames(a)
        assert_sane_keynames(b)
        a = _check_dask(
            a, check_names=check_names, check_dtypes=check_dtype, scheduler=scheduler
        )
        b = _check_dask(
            b, check_names=check_names, check_dtypes=check_dtype, scheduler=scheduler
        )
        if hasattr(a, ""to_pandas""):
            a = a.to_pandas()
        if hasattr(b, ""to_pandas""):
            b = b.to_pandas()
    
        a, b = _maybe_convert_string(a, b)
    
        if isinstance(a, (pd.DataFrame, pd.Series)) and sort_results:
            a = _maybe_sort(a, check_index)
            b = _maybe_sort(b, check_index)
        if not check_index:
            a = a.reset_index(drop=True)
            b = b.reset_index(drop=True)
        if isinstance(a, pd.DataFrame):
>           tm.assert_frame_equal(
                a, b, check_names=check_names, check_dtype=check_dtype, **kwargs
E               AssertionError: DataFrame are different
E               
E               DataFrame shape mismatch
E               [left]:  (3, 1)
E               [right]: (4, 1)

dask/dataframe/utils.py:603: AssertionError

During handling of the above exception, another exception occurred:

    def test_getitem_integer_slice():
        df = pd.DataFrame({""A"": range(6)})
        ddf = dd.from_pandas(df, 2)
        # integer slicing is iloc based
        with pytest.raises(NotImplementedError):
            ddf[1:3]
    
        df = pd.DataFrame({""A"": range(6)}, index=[1.0, 2.0, 3.0, 5.0, 10.0, 11.0])
        ddf = dd.from_pandas(df, 2)
        # except for float dtype indexes
        ctx = contextlib.nullcontext()
        if PANDAS_GE_210:
            ctx = pytest.warns(FutureWarning, match=""float-dtype index"")
>       with ctx:
E       Failed: DID NOT WARN. No warnings of type (<class 'FutureWarning'>,) were emitted.
E        Emitted warnings: [].

dask/dataframe/tests/test_indexing.py:356: Failed
```",,https://api.github.com/repos/dask/dask/issues/11153/timeline,,,jrbourbeau,11656932,MDQ6VXNlcjExNjU2OTMy,https://avatars.githubusercontent.com/u/11656932?v=4,,https://api.github.com/users/jrbourbeau,https://github.com/jrbourbeau,https://api.github.com/users/jrbourbeau/followers,https://api.github.com/users/jrbourbeau/following{/other_user},https://api.github.com/users/jrbourbeau/gists{/gist_id},https://api.github.com/users/jrbourbeau/starred{/owner}{/repo},https://api.github.com/users/jrbourbeau/subscriptions,https://api.github.com/users/jrbourbeau/orgs,https://api.github.com/users/jrbourbeau/repos,https://api.github.com/users/jrbourbeau/events{/privacy},https://api.github.com/users/jrbourbeau/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11153/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1052,https://api.github.com/repos/dask/dask/issues/11155,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11155/labels{/name},https://api.github.com/repos/dask/dask/issues/11155/comments,https://api.github.com/repos/dask/dask/issues/11155/events,https://github.com/dask/dask/issues/11155,2325180025,I_kwDOAbcwm86Kl255,11155,'SeriesGroupBy' object has no attribute 'nunique_approx',"[{'id': 1342320181, 'node_id': 'MDU6TGFiZWwxMzQyMzIwMTgx', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20info', 'name': 'needs info', 'color': 'd0cfcc', 'default': False, 'description': 'Needs further information from the user'}]",open,False,,[],,6,2024-05-30T09:22:32Z,2024-06-05T15:42:09Z,,NONE,,"Please add 'nunique_approx' feature for 'SeriesGroupBy' object
",,https://api.github.com/repos/dask/dask/issues/11155/timeline,,,LeilaGold,60102289,MDQ6VXNlcjYwMTAyMjg5,https://avatars.githubusercontent.com/u/60102289?v=4,,https://api.github.com/users/LeilaGold,https://github.com/LeilaGold,https://api.github.com/users/LeilaGold/followers,https://api.github.com/users/LeilaGold/following{/other_user},https://api.github.com/users/LeilaGold/gists{/gist_id},https://api.github.com/users/LeilaGold/starred{/owner}{/repo},https://api.github.com/users/LeilaGold/subscriptions,https://api.github.com/users/LeilaGold/orgs,https://api.github.com/users/LeilaGold/repos,https://api.github.com/users/LeilaGold/events{/privacy},https://api.github.com/users/LeilaGold/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11155/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1053,https://api.github.com/repos/dask/dask/issues/11156,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11156/labels{/name},https://api.github.com/repos/dask/dask/issues/11156/comments,https://api.github.com/repos/dask/dask/issues/11156/events,https://github.com/dask/dask/pull/11156,2326241330,PR_kwDOAbcwm85xCtT1,11156,"[#11122] updated API doc template generators for read_csv, read_fwf a",[],open,False,,[],,3,2024-05-30T17:50:44Z,2024-05-30T18:23:33Z,,FIRST_TIME_CONTRIBUTOR,,"nd read_table

- [x] Closes #11122 
- [ ] Tests added / passed
- [x] Passes `pre-commit run --all-files`
",,https://api.github.com/repos/dask/dask/issues/11156/timeline,,,joehiggi1758,46200959,MDQ6VXNlcjQ2MjAwOTU5,https://avatars.githubusercontent.com/u/46200959?v=4,,https://api.github.com/users/joehiggi1758,https://github.com/joehiggi1758,https://api.github.com/users/joehiggi1758/followers,https://api.github.com/users/joehiggi1758/following{/other_user},https://api.github.com/users/joehiggi1758/gists{/gist_id},https://api.github.com/users/joehiggi1758/starred{/owner}{/repo},https://api.github.com/users/joehiggi1758/subscriptions,https://api.github.com/users/joehiggi1758/orgs,https://api.github.com/users/joehiggi1758/repos,https://api.github.com/users/joehiggi1758/events{/privacy},https://api.github.com/users/joehiggi1758/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11156/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,False,https://api.github.com/repos/dask/dask/pulls/11156,https://github.com/dask/dask/pull/11156,https://github.com/dask/dask/pull/11156.diff,https://github.com/dask/dask/pull/11156.patch,,,,,,,,,,,,,,,,,,,
1054,https://api.github.com/repos/dask/dask/issues/11160,https://api.github.com/repos/dask/dask,https://api.github.com/repos/dask/dask/issues/11160/labels{/name},https://api.github.com/repos/dask/dask/issues/11160/comments,https://api.github.com/repos/dask/dask/issues/11160/events,https://github.com/dask/dask/issues/11160,2332832601,I_kwDOAbcwm86LDDNZ,11160,Can not process datasets created by the older version of Dask,"[{'id': 3880424463, 'node_id': 'LA_kwDOAbcwm87nSpQP', 'url': 'https://api.github.com/repos/dask/dask/labels/needs%20triage', 'name': 'needs triage', 'color': 'eeeeee', 'default': False, 'description': 'Needs a response from a contributor'}]",open,False,,[],,2,2024-06-04T08:02:39Z,2024-06-04T09:40:11Z,,NONE,,"**Describe the issue**:
After upgrading the Dask from `2023.9.3` to the latest version `2024.5.2` or `2024.4.1`, we can not load the existing parquet files created by the previous version.

I'm getting an error during `to_parquet` operation (when `dask-expr` is enabled):
```
.../.venv/lib/python3.10/site-packages/dask_expr/_collection.py:301: UserWarning: Dask annotations {'retries': 5} detected. Annotations will be ignored when using query-planning.
  warnings.warn(
Traceback (most recent call last):
  File "".../demand_forecasting/dask/data.py"", line 292, in _write_to_gcs
    ddf.to_parquet(url, **kwargs)
  File "".../.venv/lib/python3.10/site-packages/dask_expr/_collection.py"", line 3266, in to_parquet
    return to_parquet(self, path, **kwargs)
  File "".../.venv/lib/python3.10/site-packages/dask_expr/io/parquet.py"", line 653, in to_parquet
    out = out.compute(**compute_kwargs)
  File "".../.venv/lib/python3.10/site-packages/dask_expr/_collection.py"", line 476, in compute
    return DaskMethodsMixin.compute(out, **kwargs)
  File "".../.venv/lib/python3.10/site-packages/dask/base.py"", line 375, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File "".../.venv/lib/python3.10/site-packages/dask/base.py"", line 661, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/opt/conda/lib/python3.10/site-packages/dask/dataframe/dispatch.py"", line 68, in concat
  File ""/opt/conda/lib/python3.10/site-packages/dask/dataframe/backends.py"", line 688, in concat_pandas
  File ""/opt/conda/lib/python3.10/site-packages/pandas/core/reshape/concat.py"", line 489, in _get_ndims
TypeError: cannot concatenate object of type '<class 'tuple'>'; only Series and DataFrame objs are valid
```

Disabling the `dask-expr` leads to different error during repartition operation:
```
Traceback (most recent call last):
  File "".../dataset/partition.py"", line 142, in repartition
    ddf = ddf.repartition(partition_size=partition_size)
  File "".../.venv/lib/python3.10/site-packages/dask/dataframe/core.py"", line 1802, in repartition
    return repartition_size(self, partition_size)
  File "".../.venv/lib/python3.10/site-packages/dask/dataframe/core.py"", line 8104, in repartition_size
    mem_usages = df.map_partitions(total_mem_usage, deep=True).compute()
  File "".../.venv/lib/python3.10/site-packages/dask/base.py"", line 375, in compute
    (result,) = compute(self, traverse=False, **kwargs)
  File "".../.venv/lib/python3.10/site-packages/dask/base.py"", line 661, in compute
    results = schedule(dsk, keys, **kwargs)
  File ""/opt/conda/lib/python3.10/site-packages/dask/dataframe/shuffle.py"", line 839, in partitioning_index
  File ""/opt/conda/lib/python3.10/site-packages/dask/dataframe/backends.py"", line 523, in hash_object_pandas
  File ""/opt/conda/lib/python3.10/site-packages/pandas/core/common.py"", line 573, in require_length_match
ValueError: Length of values (0) does not match length of index (12295809)
```

The dataset consists of parquet 3 files (e.g., `dataset.parquet/part.X.parquet`) with the following Dask dtypes:
```
Col1, Int64
Col2, Int16
Col3, Int32
Col4, datetime64[us]
```
Pandas dtypes:
```
Col1, int64[pyarrow]
Col2, int16[pyarrow]
Col3, int32[pyarrow]
Col4, timestamp[ns][pyarrow]
```

The index is named as `__null_dask_index__`. 

The important observation is that **TypeError error disappears** if I take only part of the dataset as follows:
```python
ddf.loc[:100000]
``` 
However, disabling the `dask-expr` still leads to an error:
```
ValueError: Length of values (0) does not match length of index (100001)
```

**Minimal Complete Verifiable Example**:

TBD: I'm still in the process of creating a MRE. 

**Anything else we need to know?**:

**Environment**:

- Dask version: 2024.5.2
- Python version: 3.10
- Operating System: WSL, Ubuntu 22.04
- Install method (conda, pip, source): poetry

```
pandas==2.2.2
pyarrow==14.0.2
```
",,https://api.github.com/repos/dask/dask/issues/11160/timeline,,,dbalabka,1269372,MDQ6VXNlcjEyNjkzNzI=,https://avatars.githubusercontent.com/u/1269372?v=4,,https://api.github.com/users/dbalabka,https://github.com/dbalabka,https://api.github.com/users/dbalabka/followers,https://api.github.com/users/dbalabka/following{/other_user},https://api.github.com/users/dbalabka/gists{/gist_id},https://api.github.com/users/dbalabka/starred{/owner}{/repo},https://api.github.com/users/dbalabka/subscriptions,https://api.github.com/users/dbalabka/orgs,https://api.github.com/users/dbalabka/repos,https://api.github.com/users/dbalabka/events{/privacy},https://api.github.com/users/dbalabka/received_events,User,False,https://api.github.com/repos/dask/dask/issues/11160/reactions,0,0,0,0,0,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
