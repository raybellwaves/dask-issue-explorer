[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1408532251",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1408532251",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1408532251,
        "node_id": "IC_kwDOAbcwm85T9H8b",
        "user": {
            "login": "crusaderky",
            "id": 6213168,
            "node_id": "MDQ6VXNlcjYyMTMxNjg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6213168?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/crusaderky",
            "html_url": "https://github.com/crusaderky",
            "followers_url": "https://api.github.com/users/crusaderky/followers",
            "following_url": "https://api.github.com/users/crusaderky/following{/other_user}",
            "gists_url": "https://api.github.com/users/crusaderky/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/crusaderky/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/crusaderky/subscriptions",
            "organizations_url": "https://api.github.com/users/crusaderky/orgs",
            "repos_url": "https://api.github.com/users/crusaderky/repos",
            "events_url": "https://api.github.com/users/crusaderky/events{/privacy}",
            "received_events_url": "https://api.github.com/users/crusaderky/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-30T12:28:44Z",
        "updated_at": "2023-01-30T12:36:56Z",
        "author_association": "MEMBER",
        "body": "If I understood correctly:\r\n1. x is in memory on a\r\n2. a receives the stimulus to compute y, which depends on x. y transitions to executing.\r\n3. before y can reach `_prepare_args_for_execution`, y is cancelled and x is released (which deletes it from the SpillBuffer).\r\n4. before `Worker.execute` can complete, a receives a stimulus to execute a new task, which has the same key as y but different spec and crucially no dependency on x.\r\n5. y goes into resumed state\r\n6. `Worker.execute` terminates with KeyError, raised by `_prepare_args_for_execution`. If the task was still cancelled this would not be a problem as the error would be ignored.\r\n\r\nI don't think this should be in dask/dask. This is (yet another) fragility of the cancelled state and the dask/dask graph shouldn't work around it. _It should be OK_ to submit to the scheduler a new, different task with the same key as a released future.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1408532251/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1408605395",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1408605395",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1408605395,
        "node_id": "IC_kwDOAbcwm85T9ZzT",
        "user": {
            "login": "crusaderky",
            "id": 6213168,
            "node_id": "MDQ6VXNlcjYyMTMxNjg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6213168?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/crusaderky",
            "html_url": "https://github.com/crusaderky",
            "followers_url": "https://api.github.com/users/crusaderky/followers",
            "following_url": "https://api.github.com/users/crusaderky/following{/other_user}",
            "gists_url": "https://api.github.com/users/crusaderky/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/crusaderky/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/crusaderky/subscriptions",
            "organizations_url": "https://api.github.com/users/crusaderky/orgs",
            "repos_url": "https://api.github.com/users/crusaderky/repos",
            "events_url": "https://api.github.com/users/crusaderky/events{/privacy}",
            "received_events_url": "https://api.github.com/users/crusaderky/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-30T13:09:57Z",
        "updated_at": "2023-01-30T13:12:49Z",
        "author_association": "MEMBER",
        "body": "Actually - I don't think you need to change the graph. You can get this error if you resubmit the same exact tasks.\r\n\r\n1. x is in memory on a\r\n2. a receives the stimulus to compute y, which depends on x. y transitions to executing.\r\n3. before y can reach `_prepare_args_for_execution`, y is cancelled and x is released (which deletes it from the SpillBuffer).\r\n4. client resubmits x and y\r\n5. x transitions to memory on b\r\n6. before Worker.execute can complete on a, a receives `{op: compute-task, key: y, who_has: {x: b.address}}`\r\n7. y transitions back to executing (`_transition_cancelled_waiting`)\r\n8. Worker.execute terminates with KeyError, raised by `_prepare_args_for_execution`.\r\n\r\nThis requires x to go through its whole lifecycle between client, scheduler, and worker b before a has had the chance of doing even a single round of the event loop. The easiest way to achieve this is to hamstring a's event loop by spilling many GiBs worth of data.\r\n\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1408605395/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1408657523",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1408657523",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1408657523,
        "node_id": "IC_kwDOAbcwm85T9mhz",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-30T13:45:44Z",
        "updated_at": "2023-01-30T13:45:44Z",
        "author_association": "MEMBER",
        "body": "TLDR The current system assumes strongly, in many places, that a key uniquely identifies a task, not just the output. Reusing a key for a different task violates this and distributed can fail on multiple levels.\r\n\r\n---\r\n\r\nThe scheduler doesn't have the possibility to understand that the tasks are new and different. The problem has nothing to do with the Worker, this error is just surfacing there. As stated above, if validation is on, this raises in various places on the scheduler (I found three different assertion that could be triggered depending on queuing/no-queuing and some timing; [here](https://github.com/dask/distributed/blob/9f2fa9b7b67f5e077d7f72aab3a6baf512d15da0/distributed/scheduler.py#L3281-L3282), [here](https://github.com/dask/distributed/blob/9f2fa9b7b67f5e077d7f72aab3a6baf512d15da0/distributed/scheduler.py#L3075) and _I forgot where the third one was_).\r\n\r\nIf you inspect closely what happens if you are executing the above script (and the del is not necessary, the del is merely there for being explicit) is that the second `update-graph` contains a key `assign-*` with a different `runspec` but the same key as in the first `update-graph`. This new state is then not properly handled by the scheduler since the scheduler assumes in many places that keys are uniquely identifying a task.\r\n\r\nWhat happens here is that the scheduler knows a certain task A already that doesn't have any dependencies (first persist, w/ task fusion). Then a subsequent `update-graph` submits the same task but *with* dependencies now. This causes the previous TaskState object to be _updated_, i.e if task A/wout dependencies is in state `ready` it is updated to now have dependencies. The TaskState object after this update is now corrupt and would be caught by the scheduler validation rules but instead we're submitting this to the worker where it somehow ends up being executed.\r\n\r\nIt may be true that the worker _could_ handle this better but the scheduler is also corrupted already.\r\n\r\n> It should be OK to submit to the scheduler a new, different task with the same key as a released future.\r\n\r\nI believe this is where the first fallacy is hidden. In the code above, what actually happens is\r\n\r\n- update-graph (from the persist)\r\n- Client gets NPartitions future handles\r\n- update-graph (from compute; uses same keys with different spec+topologies)\r\nand only then...\r\n- client-releases-keys for every future\r\n\r\ni.e. the scheduler doesn't even know that the futures were released. This timing is unavoidable due to how refcounting works.\r\n\r\nEven if you disregard this release-chain, the same issue can very very easily be constructed with a second client and different graphs.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1408657523/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1408672695",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1408672695",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1408672695,
        "node_id": "IC_kwDOAbcwm85T9qO3",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-30T13:57:46Z",
        "updated_at": "2023-01-30T13:57:46Z",
        "author_association": "MEMBER",
        "body": "@crusaderky I can't truly follow your example [here](https://github.com/dask/dask/issues/9888#issuecomment-1408605395) but it is a different issue. I'm talking about a guarantee that the task has to be uniquely identifiable by the key which is violated here which causes all sorts of failures in distributed. If you found something else, I would like you to open a new ticket, please.\r\n\r\n---\r\n\r\nI believe this issue is cause by this line reusing `root` instead of generating a new key.\r\n\r\nhttps://github.com/dask/dask/blob/a8327a35c056656830bb8e60f730f6c6c099b44c/dask/blockwise.py#L1589\r\n\r\n\r\n@rjzamora @jrbourbeau Can either one of you motivate why blockwise fusion layers cannot generate a new key? @jrbourbeau you mentioned this recently as a UX problem that could be solved by a \"better version of HLGs\". I feel like I'm missing some context",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1408672695/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1408742177",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1408742177",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1408742177,
        "node_id": "IC_kwDOAbcwm85T97Mh",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-30T14:42:30Z",
        "updated_at": "2023-01-30T14:42:30Z",
        "author_association": "MEMBER",
        "body": ">Can either one of you motivate why blockwise fusion layers cannot generate a new key?\r\n\r\nAgree that this is a significant problem with HLGs. The reason is the simple fact that there is no (formal/robust) mechanism to \"replay\" the construction of a graph after the names/properties for a subset of its tasks has been changed. That is, you can't really change the name of a `Blockwise` layer from `\"operation-c-*\"` to `\"operation-abc-*\"` after it has been fused with its dependencies, because you would also need to materialize the rest of the graph and **manually** replace all task keys beginning with `\"operation-c-*\"` to `\"operation-abc-*\"`.  So, to clarify: You **can** change the name, but it forces graph materialization.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1408742177/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1408827603",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1408827603",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1408827603,
        "node_id": "IC_kwDOAbcwm85T-QDT",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-30T15:27:45Z",
        "updated_at": "2023-01-30T15:27:45Z",
        "author_association": "MEMBER",
        "body": "> The reason is the simple fact that there is no (formal/robust) mechanism to \"replay\" the construction of a graph after the names/properties for a subset of its tasks has been changed.\r\n\r\nSo this is a limitation because there might've been an \"accidental\" materialization before the fusing?",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1408827603/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1408845976",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1408845976",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1408845976,
        "node_id": "IC_kwDOAbcwm85T-UiY",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-30T15:38:39Z",
        "updated_at": "2023-01-30T15:45:52Z",
        "author_association": "MEMBER",
        "body": ">So this is a limitation because there might've been an \"accidental\" materialization before the fusing?\r\n\r\nYes and no - The limitation is that there is no API to replace a layer in the HLG (e.g. `hlg_graph.replace(<old-key>=new_layer)`), because ~(1) there is no formal rule linking the output task names to the Layer name, and (2)~ [**EDIT: *Mostly* just this second reason**] many HLG Layers are simply wrapping already-materialized dictionaries (on purpose). Therefore, renaming the output tasks of a `Blockwise` Layer will often require you to materialized the entire graph.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1408845976/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1409053232",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1409053232",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1409053232,
        "node_id": "IC_kwDOAbcwm85T_HIw",
        "user": {
            "login": "gjoseph92",
            "id": 3309802,
            "node_id": "MDQ6VXNlcjMzMDk4MDI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3309802?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/gjoseph92",
            "html_url": "https://github.com/gjoseph92",
            "followers_url": "https://api.github.com/users/gjoseph92/followers",
            "following_url": "https://api.github.com/users/gjoseph92/following{/other_user}",
            "gists_url": "https://api.github.com/users/gjoseph92/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/gjoseph92/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/gjoseph92/subscriptions",
            "organizations_url": "https://api.github.com/users/gjoseph92/orgs",
            "repos_url": "https://api.github.com/users/gjoseph92/repos",
            "events_url": "https://api.github.com/users/gjoseph92/events{/privacy}",
            "received_events_url": "https://api.github.com/users/gjoseph92/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-30T17:46:02Z",
        "updated_at": "2023-01-30T17:46:02Z",
        "author_association": "MEMBER",
        "body": "xref https://github.com/dask/dask/issues/8635. Like @rjzamora said:\r\n\r\n> if you change the name of the layer, you also have to change the names referenced in the dependent layers. That's just not currently possible with HLG layers\u2014we could feasibly do it to MaterializedLayers, but in general, there's no `rename_input_key` interface on a Layer.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1409053232/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1410198490",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1410198490",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1410198490,
        "node_id": "IC_kwDOAbcwm85UDeva",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-31T11:34:13Z",
        "updated_at": "2023-01-31T11:34:13Z",
        "author_association": "MEMBER",
        "body": "> > xref https://github.com/dask/dask/issues/8635. Like @rjzamora said:\r\n> \r\n> if you change the name of the layer, you also have to change the names referenced in the dependent layers.  That's just not currently possible with HLG layers\u2014we could feasibly do it to MaterializedLayers, but in general, there's no rename_input_key interface on a Layer.\r\n\r\nI'm still trying to wrap my head around it but I'm getting there. \r\n\r\nIIUC this is mostly about *layer dependencies*? Best case, layer dependencies is simply exchanging a single key; Worst case would be if the layer dependent of that Blockwise layer is a MaterializedLayer in which case we'd need to walk the entire graph to rename the key. is this roughly correct?",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1410198490/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1410771405",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1410771405",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1410771405,
        "node_id": "IC_kwDOAbcwm85UFqnN",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-31T17:18:22Z",
        "updated_at": "2023-01-31T17:18:22Z",
        "author_association": "MEMBER",
        "body": ">IIUC this is mostly about layer dependencies?\r\n\r\nYes. The problem is that you would need to regenerate all dependent layers, and there is no clear way to do this.\r\n\r\nWhy there is no clear way to do this: There is no formal mechanism to change the dependencies for an existing Layer. The *required* [Layer API](https://github.com/dask/dask/blob/db5b2178a79cacc1c882d60a82bf86e2e188eccb/dask/highlevelgraph.py#L35) is very limited, and does not provide a way to set the dependencies. Therefore, different logic would need to be used to change dependencies for different layers. For the `MaterializedLayer` case we can do this manually. However, we can't use the same logic for other layers unless we materialize them first.\r\n\r\nGiven that the logic here would be \"ugly\" with the existing Layer API, the ideal solution is probably to update the Layer API to include a clear mechanism for tracking dependencies. However, we have been waiting to clean up serialization. I have personally been waiting to remove the `Mapping` foundation as well.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1410771405/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1410828179",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1410828179",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1410828179,
        "node_id": "IC_kwDOAbcwm85UF4eT",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-31T17:59:40Z",
        "updated_at": "2023-01-31T17:59:40Z",
        "author_association": "MEMBER",
        "body": "Thanks, that clears things up for me.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1410828179/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1929747150",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1929747150",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1929747150,
        "node_id": "IC_kwDOAbcwm85zBZrO",
        "user": {
            "login": "crusaderky",
            "id": 6213168,
            "node_id": "MDQ6VXNlcjYyMTMxNjg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6213168?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/crusaderky",
            "html_url": "https://github.com/crusaderky",
            "followers_url": "https://api.github.com/users/crusaderky/followers",
            "following_url": "https://api.github.com/users/crusaderky/following{/other_user}",
            "gists_url": "https://api.github.com/users/crusaderky/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/crusaderky/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/crusaderky/subscriptions",
            "organizations_url": "https://api.github.com/users/crusaderky/orgs",
            "repos_url": "https://api.github.com/users/crusaderky/repos",
            "events_url": "https://api.github.com/users/crusaderky/events{/privacy}",
            "received_events_url": "https://api.github.com/users/crusaderky/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2024-02-06T14:05:46Z",
        "updated_at": "2024-02-06T14:05:46Z",
        "author_association": "MEMBER",
        "body": "Found a nice textbook example in the distributed tests https://github.com/dask/distributed/pull/8185/files#r1479864806",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1929747150/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1936183059",
        "html_url": "https://github.com/dask/dask/issues/9888#issuecomment-1936183059",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9888",
        "id": 1936183059,
        "node_id": "IC_kwDOAbcwm85zZ88T",
        "user": {
            "login": "crusaderky",
            "id": 6213168,
            "node_id": "MDQ6VXNlcjYyMTMxNjg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6213168?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/crusaderky",
            "html_url": "https://github.com/crusaderky",
            "followers_url": "https://api.github.com/users/crusaderky/followers",
            "following_url": "https://api.github.com/users/crusaderky/following{/other_user}",
            "gists_url": "https://api.github.com/users/crusaderky/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/crusaderky/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/crusaderky/subscriptions",
            "organizations_url": "https://api.github.com/users/crusaderky/orgs",
            "repos_url": "https://api.github.com/users/crusaderky/repos",
            "events_url": "https://api.github.com/users/crusaderky/events{/privacy}",
            "received_events_url": "https://api.github.com/users/crusaderky/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2024-02-09T16:00:03Z",
        "updated_at": "2024-02-09T16:00:03Z",
        "author_association": "MEMBER",
        "body": "(repost from https://github.com/dask/distributed/pull/8185#issuecomment-1930341114)\r\nFound another use case:\r\n\r\n```python\r\nddf = dd.from_pandas(df, npartitions=4)\r\nwith dask.config.set({\"dataframe.shuffle.method\": \"p2p\"}):\r\n    ddf = ddf.set_index(\"a\").sort_values(\"b\")\r\n    result = ddf.compute()\r\n```\r\n\r\nThis code:\r\n1. sends some keys to the scheduler on `set_index`,\r\n2. waits for the result to return,\r\n3. then sends keys to the scheduler on `sort_values`,\r\n4. waits for the result to return,\r\n5. and finally sends the computation proper with `compute`.\r\n\r\nSome keys are the same, but run_spec changes; this occasionally triggers a race condition where the scheduler didn't have the time to forget those keys yet. \r\n\r\nThis is (fortuitously) not causing failures because the key is always close to its released->forgotten transition when this happens (although in other cases it may be in memory; I'm not sure).\r\n\r\nIf I add a line `print(tokenize(ts.run_spec))` to `_generate_taskstates`, you'll get:\r\n```\r\n('assign-f0dc4405b24a6c54160e65ddfeb867eb', 0) 60dfef541bc8fe30d091a769b90d6fae\r\n('assign-f0dc4405b24a6c54160e65ddfeb867eb', 0) 6d2d7e33c168fc1a0d0902905b811aca\r\n('assign-f0dc4405b24a6c54160e65ddfeb867eb', 1) 4c91541c56f2890b6a7dce01aa06fab9\r\n('assign-f0dc4405b24a6c54160e65ddfeb867eb', 1) 81485c4a5cf24f8cedf4fe5dcf84acee\r\n('assign-f0dc4405b24a6c54160e65ddfeb867eb', 2) 96326838be2ca074533222b80e986acd\r\n('assign-f0dc4405b24a6c54160e65ddfeb867eb', 2) f0096bf0edd773d5a48fe6f8495ac4f2\r\n('assign-f0dc4405b24a6c54160e65ddfeb867eb', 3) 153143fb0b822dbeeb17601e883b1e45\r\n('assign-f0dc4405b24a6c54160e65ddfeb867eb', 3) c0fb8a09ad926986969e39adf100a1a3\r\n```",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1936183059/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]