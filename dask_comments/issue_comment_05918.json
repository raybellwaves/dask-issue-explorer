[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/589522268",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-589522268",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 589522268,
        "node_id": "MDEyOklzc3VlQ29tbWVudDU4OTUyMjI2OA==",
        "user": {
            "login": "mrocklin",
            "id": 306380,
            "node_id": "MDQ6VXNlcjMwNjM4MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/306380?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mrocklin",
            "html_url": "https://github.com/mrocklin",
            "followers_url": "https://api.github.com/users/mrocklin/followers",
            "following_url": "https://api.github.com/users/mrocklin/following{/other_user}",
            "gists_url": "https://api.github.com/users/mrocklin/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mrocklin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mrocklin/subscriptions",
            "organizations_url": "https://api.github.com/users/mrocklin/orgs",
            "repos_url": "https://api.github.com/users/mrocklin/repos",
            "events_url": "https://api.github.com/users/mrocklin/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mrocklin/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-02-21T06:46:44Z",
        "updated_at": "2020-02-21T06:46:44Z",
        "author_association": "MEMBER",
        "body": "My apologies for the delay in response @bmerry .  I've been somewhat pre-occupied recently.  \r\n\r\nIn general I share your desire that we be able to calculate the graph of `arr[index]` in a time proportional to the size of the output, rather than the full input graph.  \r\n\r\nSomething like what you propose seems sensible on the surface, although I'll admit that I haven't thought deeply about it yet.  If we can make `Blockwise.__getitem__` fast enough without caching then maybe this makes sense.\r\n\r\n> I'm guessing that key lookups on a HLG are slower because the key has to be searched in every layer, so doing ensure_dict early speeds things up in general. So if we walk the dependencies on the HLG we'd need to speed up lookup: \r\n\r\nI suspect that it made sense at the time, but it could have been a shortcut.  If we can make this fast so that we don't need caching.  Then great.\r\n\r\n> can we assume that keys always either match the layer name or are a tuple starting with the layer name?\r\n\r\nI hope so?  But I don't know.  You would need to check.  Unfortunately you may quickly be becoming the expert here :)\r\n\r\nAnother option, which I'm not sure I like as much as what you're proposing here, would be to treat slicing as a new specialized layer type, and start defining optimizations that mix Blockwise and Slicing.  My guess is that that will be hard to make as robust though.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/589522268/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/589530358",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-589530358",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 589530358,
        "node_id": "MDEyOklzc3VlQ29tbWVudDU4OTUzMDM1OA==",
        "user": {
            "login": "bmerry",
            "id": 1963944,
            "node_id": "MDQ6VXNlcjE5NjM5NDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1963944?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bmerry",
            "html_url": "https://github.com/bmerry",
            "followers_url": "https://api.github.com/users/bmerry/followers",
            "following_url": "https://api.github.com/users/bmerry/following{/other_user}",
            "gists_url": "https://api.github.com/users/bmerry/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bmerry/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bmerry/subscriptions",
            "organizations_url": "https://api.github.com/users/bmerry/orgs",
            "repos_url": "https://api.github.com/users/bmerry/repos",
            "events_url": "https://api.github.com/users/bmerry/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bmerry/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-02-21T07:19:21Z",
        "updated_at": "2020-02-21T07:19:21Z",
        "author_association": "MEMBER",
        "body": "> My apologies for the delay in response @bmerry\r\n\r\nNo problem, I think this is something I'm going to have to keep in the back of my mind and mull over for a few months before I'll find time to try implementing things.\r\n\r\n> > can we assume that keys always either match the layer name or are a tuple starting with the layer name?\r\n\r\n> I hope so? But I don't know. You would need to check. Unfortunately you may quickly be becoming the expert here :)\r\n\r\nThat sounds like it wasn't an explicit goal of the HLG design then? I can poke around in the array code (which I'm now somewhat familiar with), but I have no experience with DataFrame, Bag or Delayed. Who are the experts there? (even though the optimisation might only apply to Array, there could presumably be graph layers from other collections in the graph)\r\n\r\nIs there any sort of benchmark suite or collection of performance corner cases that one could use to check that I'm not optimising my own corner case at the expense of overall performance?\r\n\r\n> Another option, which I'm not sure I like as much as what you're proposing here, would be to treat slicing as a new specialized layer type, and start defining optimizations that mix Blockwise and Slicing. My guess is that that will be hard to make as robust though.\r\n\r\nI'd thought about that as well. It might still have some merits, but it's a lot less general. For example we have input datasets with different chunking schemes leading to rechunking layers in the graph.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/589530358/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/589530951",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-589530951",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 589530951,
        "node_id": "MDEyOklzc3VlQ29tbWVudDU4OTUzMDk1MQ==",
        "user": {
            "login": "mrocklin",
            "id": 306380,
            "node_id": "MDQ6VXNlcjMwNjM4MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/306380?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mrocklin",
            "html_url": "https://github.com/mrocklin",
            "followers_url": "https://api.github.com/users/mrocklin/followers",
            "following_url": "https://api.github.com/users/mrocklin/following{/other_user}",
            "gists_url": "https://api.github.com/users/mrocklin/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mrocklin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mrocklin/subscriptions",
            "organizations_url": "https://api.github.com/users/mrocklin/orgs",
            "repos_url": "https://api.github.com/users/mrocklin/repos",
            "events_url": "https://api.github.com/users/mrocklin/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mrocklin/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-02-21T07:21:29Z",
        "updated_at": "2020-02-21T07:21:29Z",
        "author_association": "MEMBER",
        "body": "> Is there any sort of benchmark suite or collection of performance corner cases that one could use to check that I'm not optimising my own corner case at the expense of overall performance?\r\n\r\nThere is a repository in github.com/dask/dask-benchmarks I think.  It never really got much love though.\r\n\r\n> but I have no experience with DataFrame, Bag or Delayed. Who are the experts there?\r\n\r\n@TomAugspurger is the resident Panda.  Bag and Delayed aren't that complex.  No one really specializes in them.  You can probably get a sense for them in an hour or so.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/589530951/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/767597021",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-767597021",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 767597021,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc2NzU5NzAyMQ==",
        "user": {
            "login": "bmerry",
            "id": 1963944,
            "node_id": "MDQ6VXNlcjE5NjM5NDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1963944?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bmerry",
            "html_url": "https://github.com/bmerry",
            "followers_url": "https://api.github.com/users/bmerry/followers",
            "following_url": "https://api.github.com/users/bmerry/following{/other_user}",
            "gists_url": "https://api.github.com/users/bmerry/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bmerry/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bmerry/subscriptions",
            "organizations_url": "https://api.github.com/users/bmerry/orgs",
            "repos_url": "https://api.github.com/users/bmerry/repos",
            "events_url": "https://api.github.com/users/bmerry/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bmerry/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-01-26T14:53:55Z",
        "updated_at": "2021-01-26T14:53:55Z",
        "author_association": "MEMBER",
        "body": "@rjzamora I'm not sure if you're aware of this issue. I've been out of touch with Dask development for quite a while, but looking at the recent changelogs it seems you've been busy making improvements to avoid materialising high-level layers. What's your take on this - once you get I/O Blockwise layers back in will the problem be solved or is that only part of the puzzle?",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/767597021/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/768085570",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-768085570",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 768085570,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc2ODA4NTU3MA==",
        "user": {
            "login": "bmerry",
            "id": 1963944,
            "node_id": "MDQ6VXNlcjE5NjM5NDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1963944?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bmerry",
            "html_url": "https://github.com/bmerry",
            "followers_url": "https://api.github.com/users/bmerry/followers",
            "following_url": "https://api.github.com/users/bmerry/following{/other_user}",
            "gists_url": "https://api.github.com/users/bmerry/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bmerry/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bmerry/subscriptions",
            "organizations_url": "https://api.github.com/users/bmerry/orgs",
            "repos_url": "https://api.github.com/users/bmerry/repos",
            "events_url": "https://api.github.com/users/bmerry/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bmerry/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-01-27T07:13:20Z",
        "updated_at": "2021-01-27T07:13:20Z",
        "author_association": "MEMBER",
        "body": "I had another look at the current status. With this sample code it still takes time proportional to the number of chunks in `z`:\r\n```python\r\nimport numpy as np\r\nimport dask.array as da\r\n\r\nx = da.from_array(np.arange(3000), chunks=1)\r\ny = da.from_array(np.arange(3000) + 1, chunks=1)\r\nz = da.blockwise(np.outer, 'ij', x, 'i', y, 'j', dtype=x.dtype)\r\nprint(z[123, 456].compute())\r\n```\r\n\r\nLooking at a profile I can see two steps that scale with the full graph size:\r\n1. `fuse_roots` is materialising the Blockwise.\r\n2. HighLevelGraph.cull extracts a list of all keys from all layers.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/768085570/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/768790606",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-768790606",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 768790606,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc2ODc5MDYwNg==",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-01-28T04:25:49Z",
        "updated_at": "2021-01-28T04:25:49Z",
        "author_association": "MEMBER",
        "body": ">@rjzamora I'm not sure if you're aware of this issue. I've been out of touch with Dask development for quite a while, but looking at the recent changelogs it seems you've been busy making improvements to avoid materialising high-level layers. What's your take on this - once you get I/O Blockwise layers back in will the problem be solved or is that only part of the puzzle?\r\n\r\nThanks for the ping here!  We are in the process of improving HLG layers, expanding their use, and moving dict materialization out of `optimize` and onto the scheduler.  I have indeed done some work with `Blockwise`, and #7042 will be modifying some IO-based APIs to use `Blockwise` (I have been delayed with parquet-related work, but hope to get the Blockwise+IO functionality back in soon).  One goal of the general `Blockwise` work is to improve performance by removing optimizations that were previously performed on the full (materialized) graph, and to turn them into HLG optimizations.\r\n\r\nNote that none of the HLG optimizations will be very helpful until we can remove `fuse_roots`.  The goal is to replace this with some combination of HLG fusion and speculative task scheduling.  Right now you can skip this optimization, and move graph materialization to the scheduler, if you [explicitly deactivate fusion](https://github.com/dask/dask/blob/9bb586a6b8fac1983b7cea3ab399719f93dbbb29/dask/dataframe/optimize.py#L25).  Note that @madsbk did most of the work needed to move graph materialization to the scheduler.\r\n\r\nEven if we assume `fuse_roots`/`ensure_dict` is removed, there is still a bit of work left to do with `Blockwise`.  More specifically,  there is probably room for improvement in both culling and HLG fusion, and there are various IO/creation routines that need to be moved to `Blockwise`.\r\n\r\nI would expect the general HLG/Blockwise work to help with the array-slicing problem, but I haven't spent a much time thinking on this yet.  With that said, I agree that this is an important issue, and your feedback/help is very welcome :)  ",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/768790606/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/771088441",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-771088441",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 771088441,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc3MTA4ODQ0MQ==",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-02-01T19:09:52Z",
        "updated_at": "2021-02-01T19:09:52Z",
        "author_association": "MEMBER",
        "body": "@bmerry - I will try to clean up #7042 and get it ready for review today.  That PR will be a step in the right direction for [the slicing problem you show above](https://github.com/dask/dask/issues/5918#issuecomment-768085570).  A bit  more work will be needed (in a separate PR) to move `from_array` into `Blockwise`, but we do see a big performance bump for cases that **are** already covered (like `full`).  For example:\r\n\r\n```python\r\nimport dask.config\r\nimport numpy as np\r\nimport dask.array as da\r\n\r\nx = da.full(3000, 1, chunks=(1,))\r\ny = da.full(3000, 2, chunks=(1,))\r\nz = da.blockwise(np.outer, 'ij', x, 'i', y, 'j', dtype=x.dtype)\r\nz2 = z[123, 256]\r\nwith dask.config.set({'optimization.fuse.active': False}):\r\n    z2.compute()\r\n```\r\n\r\ngoes from ~37s to 11s on my local machine when you use #7042 (and >1min to 11s when you don't disable fusion).  So, it does seem that there is more work do do besides moving IO into `Blockwise`, but it certainly helps that we can avoid IO-graph materialization by fusing it with the `np.outer` layer in HLG form.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/771088441/reactions",
            "total_count": 1,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 1,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/771405173",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-771405173",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 771405173,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc3MTQwNTE3Mw==",
        "user": {
            "login": "bmerry",
            "id": 1963944,
            "node_id": "MDQ6VXNlcjE5NjM5NDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1963944?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bmerry",
            "html_url": "https://github.com/bmerry",
            "followers_url": "https://api.github.com/users/bmerry/followers",
            "following_url": "https://api.github.com/users/bmerry/following{/other_user}",
            "gists_url": "https://api.github.com/users/bmerry/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bmerry/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bmerry/subscriptions",
            "organizations_url": "https://api.github.com/users/bmerry/orgs",
            "repos_url": "https://api.github.com/users/bmerry/repos",
            "events_url": "https://api.github.com/users/bmerry/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bmerry/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-02-02T06:41:35Z",
        "updated_at": "2021-02-02T06:41:35Z",
        "author_association": "MEMBER",
        "body": "Great, that sounds like good news.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/771405173/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/775326421",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-775326421",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 775326421,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc3NTMyNjQyMQ==",
        "user": {
            "login": "crusaderky",
            "id": 6213168,
            "node_id": "MDQ6VXNlcjYyMTMxNjg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6213168?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/crusaderky",
            "html_url": "https://github.com/crusaderky",
            "followers_url": "https://api.github.com/users/crusaderky/followers",
            "following_url": "https://api.github.com/users/crusaderky/following{/other_user}",
            "gists_url": "https://api.github.com/users/crusaderky/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/crusaderky/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/crusaderky/subscriptions",
            "organizations_url": "https://api.github.com/users/crusaderky/orgs",
            "repos_url": "https://api.github.com/users/crusaderky/repos",
            "events_url": "https://api.github.com/users/crusaderky/events{/privacy}",
            "received_events_url": "https://api.github.com/users/crusaderky/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-02-08T17:51:10Z",
        "updated_at": "2021-02-08T17:51:10Z",
        "author_association": "MEMBER",
        "body": ">  In fact, cull can already work from a HLG (since it is a Mapping), so I'm not entirely sure why ensure_dict is needed. I'm guessing that key lookups on a HLG are slower because the key has to be searched in every layer, so doing ensure_dict early speeds things up in general.\r\n\r\nUntil less than a week ago, ``HighLevelGraph.__getitem__`` used to have a sluggish O(n) performance. \r\nhttps://github.com/dask/dask/pull/7160 has been just merged, which drops it to O(1) in most cases with a fallback to O(n) in exceptional cases. However, even at O(1) there is a sizeable amount of pure-python code involved and, if you start hitting it a few million times, the microseconds of overhead that it brings with it will compound very quickly. If you're unlucky, you'll hit the O(n) fallback and everything will slow down to a crawl for very large graphs.\r\n\r\nI didn't fully reflect on your proposal but making optimization hit ``Layer.__getitem__`` surely makes a lot of sense.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/775326421/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/775337837",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-775337837",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 775337837,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc3NTMzNzgzNw==",
        "user": {
            "login": "bmerry",
            "id": 1963944,
            "node_id": "MDQ6VXNlcjE5NjM5NDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1963944?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bmerry",
            "html_url": "https://github.com/bmerry",
            "followers_url": "https://api.github.com/users/bmerry/followers",
            "following_url": "https://api.github.com/users/bmerry/following{/other_user}",
            "gists_url": "https://api.github.com/users/bmerry/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bmerry/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bmerry/subscriptions",
            "organizations_url": "https://api.github.com/users/bmerry/orgs",
            "repos_url": "https://api.github.com/users/bmerry/repos",
            "events_url": "https://api.github.com/users/bmerry/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bmerry/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-02-08T18:08:46Z",
        "updated_at": "2021-02-08T18:08:46Z",
        "author_association": "MEMBER",
        "body": "> Until less than a week ago, HighLevelGraph.__getitem__ used to have a sluggish O(n) performance.\r\n#7160 has been just merged, which drops it to O(1) in most cases with a fallback to O(n) in exceptional cases.\r\n\r\nThat's good news. Is it just determining the layer that drops to O(1), or does BlockwiseLayer also implement a fast path? The latter is something I considered for this issue, but I worry that the *amortized* cost (over querying every key in the BlockwiseLayer) would end up much slower compared to just materialising the layer on the first call.\r\n\r\nIncidentally, are you just assuming that a layer name will never match a key name that's in a different layer?",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/775337837/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/775352920",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-775352920",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 775352920,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc3NTM1MjkyMA==",
        "user": {
            "login": "crusaderky",
            "id": 6213168,
            "node_id": "MDQ6VXNlcjYyMTMxNjg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6213168?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/crusaderky",
            "html_url": "https://github.com/crusaderky",
            "followers_url": "https://api.github.com/users/crusaderky/followers",
            "following_url": "https://api.github.com/users/crusaderky/following{/other_user}",
            "gists_url": "https://api.github.com/users/crusaderky/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/crusaderky/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/crusaderky/subscriptions",
            "organizations_url": "https://api.github.com/users/crusaderky/orgs",
            "repos_url": "https://api.github.com/users/crusaderky/repos",
            "events_url": "https://api.github.com/users/crusaderky/events{/privacy}",
            "received_events_url": "https://api.github.com/users/crusaderky/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-02-08T18:32:23Z",
        "updated_at": "2021-02-08T18:32:23Z",
        "author_association": "MEMBER",
        "body": "I did not touch ``Layer.__getitem__`` or any of its overrides.\r\n\r\n> Incidentally, are you just assuming that a layer name will never match a key name that's in a different layer?\r\n\r\nNo.\r\nhttps://github.com/dask/dask/blob/2640241fbdf0c5efbcf35d96eb8cc9c3df4de2fd/dask/highlevelgraph.py#L500-L520",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/775352920/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/775354612",
        "html_url": "https://github.com/dask/dask/issues/5918#issuecomment-775354612",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/5918",
        "id": 775354612,
        "node_id": "MDEyOklzc3VlQ29tbWVudDc3NTM1NDYxMg==",
        "user": {
            "login": "bmerry",
            "id": 1963944,
            "node_id": "MDQ6VXNlcjE5NjM5NDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1963944?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bmerry",
            "html_url": "https://github.com/bmerry",
            "followers_url": "https://api.github.com/users/bmerry/followers",
            "following_url": "https://api.github.com/users/bmerry/following{/other_user}",
            "gists_url": "https://api.github.com/users/bmerry/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bmerry/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bmerry/subscriptions",
            "organizations_url": "https://api.github.com/users/bmerry/orgs",
            "repos_url": "https://api.github.com/users/bmerry/repos",
            "events_url": "https://api.github.com/users/bmerry/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bmerry/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2021-02-08T18:35:13Z",
        "updated_at": "2021-02-08T18:35:13Z",
        "author_association": "MEMBER",
        "body": "> >    Incidentally, are you just assuming that a layer name will never match a key name that's in a different layer?\r\n\r\n> No.\r\n\r\nOh right, I'd misread it the first time.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/775354612/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]