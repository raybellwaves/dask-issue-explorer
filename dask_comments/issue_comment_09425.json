[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1226511441",
        "html_url": "https://github.com/dask/dask/issues/9425#issuecomment-1226511441",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9425",
        "id": 1226511441,
        "node_id": "IC_kwDOAbcwm85JGxRR",
        "user": {
            "login": "ian-r-rose",
            "id": 5728311,
            "node_id": "MDQ6VXNlcjU3MjgzMTE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/5728311?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ian-r-rose",
            "html_url": "https://github.com/ian-r-rose",
            "followers_url": "https://api.github.com/users/ian-r-rose/followers",
            "following_url": "https://api.github.com/users/ian-r-rose/following{/other_user}",
            "gists_url": "https://api.github.com/users/ian-r-rose/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/ian-r-rose/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ian-r-rose/subscriptions",
            "organizations_url": "https://api.github.com/users/ian-r-rose/orgs",
            "repos_url": "https://api.github.com/users/ian-r-rose/repos",
            "events_url": "https://api.github.com/users/ian-r-rose/events{/privacy}",
            "received_events_url": "https://api.github.com/users/ian-r-rose/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-08-24T22:25:23Z",
        "updated_at": "2022-08-24T22:25:23Z",
        "author_association": "MEMBER",
        "body": "Another use-case for something like this would be reading in hive-partitioned parquet datasets. That partitioning scheme doesn't fit in well with dask's `divisions` tracking, and it makes certain very obvious operations more difficult than they should be (including merges, groupbys, filters).\r\n\r\nAlso xref https://github.com/dask/dask/issues/8980",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1226511441/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1227705778",
        "html_url": "https://github.com/dask/dask/issues/9425#issuecomment-1227705778",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9425",
        "id": 1227705778,
        "node_id": "IC_kwDOAbcwm85JLU2y",
        "user": {
            "login": "jsignell",
            "id": 4806877,
            "node_id": "MDQ6VXNlcjQ4MDY4Nzc=",
            "avatar_url": "https://avatars.githubusercontent.com/u/4806877?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jsignell",
            "html_url": "https://github.com/jsignell",
            "followers_url": "https://api.github.com/users/jsignell/followers",
            "following_url": "https://api.github.com/users/jsignell/following{/other_user}",
            "gists_url": "https://api.github.com/users/jsignell/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jsignell/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jsignell/subscriptions",
            "organizations_url": "https://api.github.com/users/jsignell/orgs",
            "repos_url": "https://api.github.com/users/jsignell/repos",
            "events_url": "https://api.github.com/users/jsignell/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jsignell/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-08-25T20:05:03Z",
        "updated_at": "2022-08-25T20:05:03Z",
        "author_association": "MEMBER",
        "body": "This is another example of per-partition metadata (like length) that if-tracked could provide useful fast paths. This idea has been discussed before and kind of fizzled out in high-level expressions discussions. Maybe the time is ripe to find a middle ground in between divisions and a full high level expression system?",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1227705778/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1227820265",
        "html_url": "https://github.com/dask/dask/issues/9425#issuecomment-1227820265",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9425",
        "id": 1227820265,
        "node_id": "IC_kwDOAbcwm85JLwzp",
        "user": {
            "login": "gjoseph92",
            "id": 3309802,
            "node_id": "MDQ6VXNlcjMzMDk4MDI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3309802?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/gjoseph92",
            "html_url": "https://github.com/gjoseph92",
            "followers_url": "https://api.github.com/users/gjoseph92/followers",
            "following_url": "https://api.github.com/users/gjoseph92/following{/other_user}",
            "gists_url": "https://api.github.com/users/gjoseph92/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/gjoseph92/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/gjoseph92/subscriptions",
            "organizations_url": "https://api.github.com/users/gjoseph92/orgs",
            "repos_url": "https://api.github.com/users/gjoseph92/repos",
            "events_url": "https://api.github.com/users/gjoseph92/events{/privacy}",
            "received_events_url": "https://api.github.com/users/gjoseph92/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-08-25T22:27:26Z",
        "updated_at": "2022-08-25T22:27:26Z",
        "author_association": "MEMBER",
        "body": "I don't think this is even per-partition though\u2014it would be metadata about all the partitions, overall. So hopefully much simpler than that, and wouldn't need to involve high-level expressions at all. I'm imagining:\r\n\r\n```python\r\nclass DataFrame:\r\n    @property\r\n    def partitioned_by(self) -> tuple[str, ...] | None:\r\n        \"\"\"Column name(s) the DataFrame is partitioned by\r\n\r\n        If `partitioned_by` is not None, then each unique value of those\r\n        columns will be found in exactly one partition.\r\n        \r\n        The \"value\" is considered as the tuple of all those columns.\r\n        That is, if `partitioned_by` is ``('a', 'b')``, then each unique\r\n        combination of ``a`` and ``b`` will be found in one partition. But\r\n        unique values of ``a`` or ``b``, on their own, may be found in multiple\r\n        partitions. In other words, `partitioned_by` is not hierarchical.\r\n\r\n        If `known_divisions` is True, `partitioned_by` will be ``[\"_index\"]``.\r\n        \"\"\"\r\n        return self._partitioned_by\r\n```\r\n\r\nAfter writing this out, I realize why doing this through an expression system would be a bit nicer. Because it's not hierarchical, I think tracking this would only be useful for a groupby or merge subsequent to a shuffle, on the exact same columns. So it's maybe an overly niche thing to track broadly.\r\n\r\nBut there are also datasets that I'm sure are partitioned by multiple columns hierarchically (and someday, maybe multi-indexes), which would probably also be useful to track. But since our shuffle is non-hierarchical, we'd need some way of representing both cases in order to make this more generic. You could imagine `partitioned_by` being a list, tuple, or set to represent the different possibilities:\r\n1. list: hierarchical\r\n2. tuple: non-hierarchical\r\n3. set: each column is, independently, guaranteed to be partitioned (I'm not sure if this is even possible without also being hierarchical, and probably not at all common; I just made it up?)",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1227820265/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1228184234",
        "html_url": "https://github.com/dask/dask/issues/9425#issuecomment-1228184234",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9425",
        "id": 1228184234,
        "node_id": "IC_kwDOAbcwm85JNJqq",
        "user": {
            "login": "jorloplaz",
            "id": 12827365,
            "node_id": "MDQ6VXNlcjEyODI3MzY1",
            "avatar_url": "https://avatars.githubusercontent.com/u/12827365?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jorloplaz",
            "html_url": "https://github.com/jorloplaz",
            "followers_url": "https://api.github.com/users/jorloplaz/followers",
            "following_url": "https://api.github.com/users/jorloplaz/following{/other_user}",
            "gists_url": "https://api.github.com/users/jorloplaz/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jorloplaz/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jorloplaz/subscriptions",
            "organizations_url": "https://api.github.com/users/jorloplaz/orgs",
            "repos_url": "https://api.github.com/users/jorloplaz/repos",
            "events_url": "https://api.github.com/users/jorloplaz/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jorloplaz/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-08-26T08:03:29Z",
        "updated_at": "2022-08-26T08:05:09Z",
        "author_association": "CONTRIBUTOR",
        "body": "Sounds reasonable, but we should be careful with some cases:\r\n\r\n> If `known_divisions` is True, `partitioned_by` will be ``[\"_index\"]``.\r\n\r\nIt's not so simple. In theory the frame should always be sorted by its index (even if we don't know its `divisions`), but there are some cases where this doesn't hold. For example, when you do `ddf = dd.from_pandas(df, sort=False)` and `df` already has an index which is NOT sorted, this index is passed on, and the result is that `ddf.known_divisions = False`, but we cannot say either that `partitioned_by` is the index (because that index is still unsorted). \r\n\r\nI guess the same can happen when reading from some files? The current situation is that you can only be sure that the index is sorted if `ddf.known_divisions is True`.\r\n\r\nMoreover, I'd return `[\"_index\"]` only when `self.index.name is None`, because that's the case when the index isn't a column of the original dataframe. When it is indeed a column of the data, I'd return `self.index.name`, because the idea is \"OK, this frame is sorted by this column\". The fact that the column is also acting as the index is a different thing.\r\n\r\nSo I propose the following as return:\r\n- `None`: no idea about sortedness, not even about index sortedness.\r\n- `[\"_index\"]`: frame sorted on its anonymous index; rest of columns may be sorted but we don't know.\r\n- `[index.name]`: frame sorted on the column acting current as index; rest of columns may be sorted but we don't know.\r\n- `[\"_index\", \"col1\", ...]`: frame sorted on its anonymous index, plus on some additional columns which are still columns.\r\n- `[index.name, \"col1\", ...]`: frame sorted on the column acting current as index, plus on some additional columns which are still columns.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1228184234/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1228563691",
        "html_url": "https://github.com/dask/dask/issues/9425#issuecomment-1228563691",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9425",
        "id": 1228563691,
        "node_id": "IC_kwDOAbcwm85JOmTr",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2022-08-26T14:30:25Z",
        "updated_at": "2022-08-26T14:31:45Z",
        "author_association": "MEMBER",
        "body": "> Maybe the time is ripe to find a middle ground in between divisions and a full high level expression system?\r\n\r\nThe HLG/HLE concern was that the existing practice of defining and tracking `meta` and `divisions` outside of the HLG/HLE was problematic for graph optimization and regeneration. Therefore, it seemed reasonable to wait for `meta` and `divisions` to be moved into the HLG/HLE before redesigning them.\r\n\r\n\u2028\u2028I still think we need to **move** `meta` and `divisions` into `HighLevelGraph`, and I will try to write up a clear proposal for this in #9159. However, I don\u2019t think it is very important that we do that first.  That said, I think the \u201chappy middle ground\u201d would be to introduce a `CollectionMetadata` class where things like `meta`, `divisions`, and `partitioned_by` (and maybe even *custom* metadata) can all be managed in one place. For example:\r\n\r\n\r\n```python\r\nclass DataFrame:\r\n\r\n    def __init__(self, dask, name, meta, divisions, **metadata_kwargs):\r\n        self.name = name\r\n        self.dask = dask\r\n        self.collection_metadata = DataFrameCollectionMetadata(\r\n            meta=meta,  # Move meta into self.collection_metadata\r\n            divisions=divisions,  # Move divisions into self.collection_metadata\r\n            **metadata_kwargs,\r\n        )\r\n\r\n    @property\r\n    def meta(self):\r\n        return self.collection_metadata.meta\r\n\r\n    @property\r\n    def divisions(self):\r\n        return self.collection_metadata.divisions\r\n        \r\nclass CollectionMetadata:\r\n    # Any properties shared by DataFrame/Array/Bag?\r\n    pass\r\n\r\nclass DataFrameCollectionMetadata(CollectionMetadata):\r\n\r\n    def __init__(\r\n        self,\r\n        meta,\r\n        divisions,\r\n        partitioned_by=None,\r\n        partition_lens=None,\r\n        **custom_metadata,\r\n    ):\r\n        # Traditional metadata\r\n        self._meta = meta\r\n        self._divisions = divisions\r\n        # New and/or custom metadata\r\n        self._partitioned_by = partitioned_by\r\n        self._partition_lens = partition_lens\r\n        self._custom_metadata = custom_metadata\r\n        \r\n    @property\r\n    def meta(self):\r\n        return self.meta\r\n\r\n    @property\r\n    def divisions(self):\r\n        return self.divisions\r\n        \r\n    @property\r\n    def partitioned_by(self):\r\n        return self._partitioned_by\r\n        \r\n    @property\r\n    def partition_lens(self):\r\n        return self._partition_lens\r\n        \r\n    def custom_metadata(self, key):\r\n        return self._custom_metadata[key]\r\n```\r\n\r\nIn the long run, I\u2019d like both collection metadata and graph materialization logic to live in `HighLevelGraph`. Introducing a `CollectionMetadataClass` (or something like it) should make it a bit easier to accomplish this without needing to change how collections are constructed throughout the entire code base:\r\n\r\n```python\r\nclass DataFrame:\r\n\r\n    def __init__(self, dask, name, meta, divisions, **metadata_kwargs):\r\n        self.dask = dask\r\n        self.dask.validate_name(name)\r\n        self.dask.set_collection_metadata(\r\n            DataFrameCollectionMetadata(\r\n                meta=meta,\r\n                divisions=divisions,\r\n                **metadata_kwargs,\r\n            )\r\n        )\r\n\r\n    @property\r\n    def name(self):\r\n        return self.dask.name\r\n\r\n    @property\r\n    def collection_metadata(self):\r\n        return self.dask.collection_metadata\r\n\r\n    @property\r\n    def meta(self):\r\n        return self.collection_metadata.meta\r\n\r\n    @property\r\n    def divisions(self):\r\n        return self.collection_metadata.divisions\r\n```\r\n\r\n(Note that this second step requires some HLG simplification and redesign work, but the first part could be done right away)",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1228563691/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1396729930",
        "html_url": "https://github.com/dask/dask/issues/9425#issuecomment-1396729930",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9425",
        "id": 1396729930,
        "node_id": "IC_kwDOAbcwm85TQGhK",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-19T10:11:42Z",
        "updated_at": "2023-01-19T10:11:42Z",
        "author_association": "MEMBER",
        "body": "I believe this issue is mixing up a couple of different concepts.\r\n\r\n##  1. Unique partition mapping / primary key\r\n\r\nI believe the property this issue is talking about is whether or not a column can be considered a _primary_ partition _key_ (c.f. primary indices in databases), i.e. there is a bijective mapping between value and partition, e.g.\r\n\r\n| Partition | value |\r\n|-----------|-------|\r\n| 1         | 4     |\r\n| 1         | 10    |\r\n| 1         | 4     |\r\n| 2         | 6     |\r\n| 3         | 1     |\r\n\r\neven if we didn't know the actual values, or rather upper and lower bounds, knowing that there is a unique mapping, i.e. a given value only occurs in a single partition, allows us to perform a trivial aca groupby.\r\n\r\nExample: result of a shuffle\r\n\r\n## 2. Primary key with different mapping\r\n\r\nKnowing that there exists a primary key is not sufficient if we want to compare two different tables. Let's say the above table is TableA and the following is TableB for which `value` also is a primary key\r\n\r\n\r\n| Partition | value |\r\n|-----------|-------|\r\n| 1         | 4     |\r\n| 1         | 4     |\r\n| 2         | 10    |\r\n| 2         | 6     |\r\n| 3         | 1     |\r\n\r\nHowever, as you will notice, the third row has a different partition<->value mapping, i.e. if we wanted to join those two tables we would still not be able to do this trivially\r\n\r\nExample: loading a hive-like parquet dataset\r\n\r\n## 3. Sorted (which one?)\r\n\r\nI think there are a couple of different definitions possible about what it means to have a sorted dataframe. For example, the following could be considered sorted but it still doesn't offer any useful property to pick a fastpath w/out knowing upper/lower boundaries.\r\n\r\n| Partition | value |\r\n|-----------|-------|\r\n| 1         | 1     |\r\n| 2         | 4     |\r\n| 3         | 4     |\r\n| 3         | 6     |\r\n| 3         | 10    |\r\n\r\n\"sorted partitions\" otoh could simply mean (i.e. partition internal sorting)\r\n\r\n| Partition | value |\r\n|-----------|-------|\r\n| 1         | 4     |\r\n| 1         | 4     |\r\n| 1         | 10    |\r\n| 2         | 6     |\r\n| 3         | 1     |\r\n\r\nI think \"sorting\" itself is not that useful unless we have neither property 1.) nor `known_divisions` (even if they were overlapping).\r\n\r\n---\r\n\r\nThe reason why I'm writing this down in this details is because\r\n\r\n- the title of the issue talks about sorted partitions. I don't think we care for any kind of sorting here but rather if a column (or weaker, a tuples of columns) is a primary key.\r\n- Simply knowing that there is a unique mapping as proposed in https://github.com/dask/dask/issues/9425#issuecomment-1227820265 is not necessarily sufficient to perform efficient merges. We would also need to know that the mapping originates from the same function, i.e. merging a shuffled DF to a hive-like partition DF as suggested in https://github.com/dask/dask/issues/9425#issuecomment-1226511441 is not necessarily possible. However, merging two DFs with same Npartitions that passed through a shuffle (i.e. the same hash/modulo function creates a unique mapping) is possible.\r\n\r\nThis would render a `partition_by` property definitely more complex since we'd need to track/know how this partitioning was created or else we will only be able to benefit from this knowledge in single-df operations.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1396729930/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1397109179",
        "html_url": "https://github.com/dask/dask/issues/9425#issuecomment-1397109179",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9425",
        "id": 1397109179,
        "node_id": "IC_kwDOAbcwm85TRjG7",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-19T14:59:41Z",
        "updated_at": "2023-01-19T14:59:41Z",
        "author_association": "MEMBER",
        "body": ">Simply knowing that there is a unique mapping as proposed in https://github.com/dask/dask/issues/9425#issuecomment-1227820265 is not necessarily sufficient to perform efficient merges. We would also need to know that the mapping originates from the same function\r\n\r\nThat is exactly right - In https://github.com/dask/dask/pull/9473, I found that `partitioned_by` needed to return **how** a collection was partitioned by a specific set of columns rather than returning a simple True/False. For example, we can only avoid a shuffle if both sides of a merge are shuffled by the same hash function and divided into the same number of partitions.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1397109179/reactions",
            "total_count": 2,
            "+1": 2,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1409606863",
        "html_url": "https://github.com/dask/dask/issues/9425#issuecomment-1409606863",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9425",
        "id": 1409606863,
        "node_id": "IC_kwDOAbcwm85UBOTP",
        "user": {
            "login": "gjoseph92",
            "id": 3309802,
            "node_id": "MDQ6VXNlcjMzMDk4MDI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3309802?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/gjoseph92",
            "html_url": "https://github.com/gjoseph92",
            "followers_url": "https://api.github.com/users/gjoseph92/followers",
            "following_url": "https://api.github.com/users/gjoseph92/following{/other_user}",
            "gists_url": "https://api.github.com/users/gjoseph92/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/gjoseph92/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/gjoseph92/subscriptions",
            "organizations_url": "https://api.github.com/users/gjoseph92/orgs",
            "repos_url": "https://api.github.com/users/gjoseph92/repos",
            "events_url": "https://api.github.com/users/gjoseph92/events{/privacy}",
            "received_events_url": "https://api.github.com/users/gjoseph92/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-01-31T01:21:07Z",
        "updated_at": "2023-01-31T01:21:07Z",
        "author_association": "MEMBER",
        "body": "Agreed. To get a fastpath with merges, you'd need to know they'd used the same hash function. When I wrote this, I was thinking of `shuffle` as the only operation that would set `partitioned_by`, so you could expect the same hash function (though not if you used different shuffle methods). If you open this up to IO functions being able to set it too, then you definitely need more information.\r\n\r\nFor a groupby, though, you don't need any extra information. By knowing that all values from each group must be in exactly one partition, you can always take the fastpath.\r\n\r\nThe main point here was \"shuffles are expensive; once you've done one, how can we get the most value out of it?\" It still seems like setting `partitioned_by` would be a pretty cheap way to automatically take some fastpaths when they're available.\r\n\r\nHive-partitioned datasets, or hierarchical partitioning, seem like they should be out of scope. No IO function would set `partitioned_by`.  It would only be set by `shuffle`, to a tuple of `(columns_tuple, shuffle_method)`. Then:\r\n- `groupby` would have a fastpath if this is set at all to improve the groupby-post-shuffle case (the groupby-on-a-partitoned-dataset case already needs to be handled via divisions: https://github.com/dask/dask/issues/8361)\r\n- `merge` would have a fastpath iff `partitioned_by` was equal for both inputs, and they had the same number of partitions",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1409606863/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]