{
    "url": "https://api.github.com/repos/dask/dask/issues/2292",
    "repository_url": "https://api.github.com/repos/dask/dask",
    "labels_url": "https://api.github.com/repos/dask/dask/issues/2292/labels{/name}",
    "comments_url": "https://api.github.com/repos/dask/dask/issues/2292/comments",
    "events_url": "https://api.github.com/repos/dask/dask/issues/2292/events",
    "html_url": "https://github.com/dask/dask/issues/2292",
    "id": 226083313,
    "node_id": "MDU6SXNzdWUyMjYwODMzMTM=",
    "number": 2292,
    "title": "Process local variables",
    "user": {
        "login": "jakirkham",
        "id": 3019665,
        "node_id": "MDQ6VXNlcjMwMTk2NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3019665?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jakirkham",
        "html_url": "https://github.com/jakirkham",
        "followers_url": "https://api.github.com/users/jakirkham/followers",
        "following_url": "https://api.github.com/users/jakirkham/following{/other_user}",
        "gists_url": "https://api.github.com/users/jakirkham/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/jakirkham/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/jakirkham/subscriptions",
        "organizations_url": "https://api.github.com/users/jakirkham/orgs",
        "repos_url": "https://api.github.com/users/jakirkham/repos",
        "events_url": "https://api.github.com/users/jakirkham/events{/privacy}",
        "received_events_url": "https://api.github.com/users/jakirkham/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2017-05-03T19:02:06Z",
    "updated_at": "2017-05-03T19:30:08Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "Many forms of parallelism have some mechanism of denoting a variable should be constructed on a per thread basis. This typically goes by the name [Thread-local storage]( https://en.wikipedia.org/wiki/Thread-local_storage ) or TLS. These variables are like their global variable analogues except that except that they are global for the thread they exist in. This allows them to be initialized independently per thread and be appropriately tracked as so. By being thread local, these variables are safe equivalents to global variables as one generally doesn't need to worry about locking before using them.\r\n\r\nFor the most part Dask/Distributed doesn't need things like these or at least doesn't generally need to expose these to the user. Many operations don't necessarily suggest that they are acting in parallel (e.g. addition), but in reality are under the surface. Even operations that do hint they are parallel (e.g. `map_blocks` or `map_overlap`) hide the details of data transfer from the user. Not to mention Dask/Distributed is pretty good at avoiding data transfer. So this is rarely an issue the user needs to think about. Given the data being moved is generally picklable, this just doesn't present a problem in most cases.\r\n\r\nHowever pickling is just not that often a safe thing. In fact many libraries (e.g. `dill`, `cloudpickle`, `tblib`, etc.) are built around the notion that pickling in the core Python library is somehow deficient and it needs to be rectified by allowing something else to be pickled that wouldn't be normally allowed (e.g. closures, tracebacks, etc.). While these different libraries certainly close the gap on what can be pickled safely, inevitably one will want to work with something that doesn't fit nicely in one of these cases (e.g. `h5py` objects).\r\n\r\nIn cases like these, users certainly have some options. First they can try to keep these non-pickle safe object contained in functions that only take picklable objects and return picklable objects. [1] This avoids exposing these objects to Dask/Distributed. This does solve many use cases. However for other users these don't scale to their demands. Second they can specify how to handle serialization. [2] While this definitely seems like a nice option, we encounter issues with it that are challenging to debug and fix. [3]\r\n\r\nGiven the current state of things, it seems we could really benefit from a way to specify and represent a process local variable/operation. In the interest of allowing for cleanup, we could require the process local operation to be a single value generator. This way the user can `yield` the value for use and handle cleanup operations after the `yield` (e.g. closing a file).\r\n\r\nBy allowing for process local variables like this, one can easily reuse the variable in multiple operations and not have to worry about many setup/teardown operations costing on performance. Also one can ensure the variable in question is created on the relevant process only once requested. There is no need to figure out how to transfer this object between processes as each process would have access to a locally defined object. Anything else like accessing a dataset would result in another process local object. To ensure this object could be handled within Dask this could be represented as a Delayed object (potentially special cased). Conversion to a Dask Array should be possible with the same `da.from_delayed` mechanism. Though one may wish to rechunk before proceeding, this is hardly unique to this use of `da.from_delayed`.\r\n\r\n<br>\r\n\r\n1: https://github.com/dask/dask/issues/922#issuecomment-199085431\r\n2: https://github.com/dask/distributed/issues/604\r\n3: https://github.com/dask/dask/issues/1777",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/dask/dask/issues/2292/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/dask/dask/issues/2292/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}