[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/634737629",
        "html_url": "https://github.com/dask/dask/issues/6246#issuecomment-634737629",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/6246",
        "id": 634737629,
        "node_id": "MDEyOklzc3VlQ29tbWVudDYzNDczNzYyOQ==",
        "user": {
            "login": "mrocklin",
            "id": 306380,
            "node_id": "MDQ6VXNlcjMwNjM4MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/306380?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mrocklin",
            "html_url": "https://github.com/mrocklin",
            "followers_url": "https://api.github.com/users/mrocklin/followers",
            "following_url": "https://api.github.com/users/mrocklin/following{/other_user}",
            "gists_url": "https://api.github.com/users/mrocklin/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mrocklin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mrocklin/subscriptions",
            "organizations_url": "https://api.github.com/users/mrocklin/orgs",
            "repos_url": "https://api.github.com/users/mrocklin/repos",
            "events_url": "https://api.github.com/users/mrocklin/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mrocklin/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-05-27T15:24:12Z",
        "updated_at": "2020-05-27T15:24:12Z",
        "author_association": "MEMBER",
        "body": "With the current model I would expect divisions to be equal to `[None] * (df.npartitions + 1)`\r\n\r\nIf it isn't sorted by a particular column then with our current model there isn't much to be gained here I think.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/634737629/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/634969985",
        "html_url": "https://github.com/dask/dask/issues/6246#issuecomment-634969985",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/6246",
        "id": 634969985,
        "node_id": "MDEyOklzc3VlQ29tbWVudDYzNDk2OTk4NQ==",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-05-27T22:10:19Z",
        "updated_at": "2020-05-27T22:10:19Z",
        "author_association": "MEMBER",
        "body": "> If it isn't sorted by a particular column then with our current model there isn't much to be gained here I think.\r\n\r\nThe current model has three limitations here: (1) The divisions refer only to the index, (2) the divisions refer only to a single (index) column, and (3) the divisions refer only to lexicographical ordering.\r\n\r\nFor the hash-based shuffle, all three limitations are a problem. Exending divisions\" to overcome (1) and (2) is pretty simple: Use something like a `dict` or `pd.DataFrame` to allow partitioning on 1+ columns (or a single/multi-colum index).  Overcoming (3) is a bit trickier, because the hash-based divisions will be something like `[0, 1, 2, .., npartitions]` (assuming `hash % npartitions` is used to define the partition index), but you would also need to store the list of columns that correspond to the \"implied hash column\" that the \"simple\" `divisions` actually corresponds to.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/634969985/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/635045576",
        "html_url": "https://github.com/dask/dask/issues/6246#issuecomment-635045576",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/6246",
        "id": 635045576,
        "node_id": "MDEyOklzc3VlQ29tbWVudDYzNTA0NTU3Ng==",
        "user": {
            "login": "TomAugspurger",
            "id": 1312546,
            "node_id": "MDQ6VXNlcjEzMTI1NDY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1312546?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/TomAugspurger",
            "html_url": "https://github.com/TomAugspurger",
            "followers_url": "https://api.github.com/users/TomAugspurger/followers",
            "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
            "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
            "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
            "repos_url": "https://api.github.com/users/TomAugspurger/repos",
            "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
            "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-05-28T01:54:15Z",
        "updated_at": "2020-05-28T01:54:15Z",
        "author_association": "MEMBER",
        "body": "> With the current model I would expect divisions to be equal to [None] * (df.npartitions + 1)\r\n\r\nRight. So `.shuffle()` clears the divisions right now.\r\n\r\nIt's a bit ugly, but do we perhaps avoid overloading `divisions`, since \"index-divisions\" are so different than these \"column-divisions\"?\r\n\r\nThey enable very different things. Index-divisions grant us things like fast random access in `.loc`. The \"column-divisions\" (in principle) open up things like fast boolean filtering.\r\n\r\n```python\r\ndf2 = df.shuffle(column=\"id\")\r\ndf2[df2.id == 1]  # only needs to check partitions where hash(df.id) == hash(1)\r\n```",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/635045576/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/635060270",
        "html_url": "https://github.com/dask/dask/issues/6246#issuecomment-635060270",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/6246",
        "id": 635060270,
        "node_id": "MDEyOklzc3VlQ29tbWVudDYzNTA2MDI3MA==",
        "user": {
            "login": "mrocklin",
            "id": 306380,
            "node_id": "MDQ6VXNlcjMwNjM4MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/306380?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mrocklin",
            "html_url": "https://github.com/mrocklin",
            "followers_url": "https://api.github.com/users/mrocklin/followers",
            "following_url": "https://api.github.com/users/mrocklin/following{/other_user}",
            "gists_url": "https://api.github.com/users/mrocklin/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mrocklin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mrocklin/subscriptions",
            "organizations_url": "https://api.github.com/users/mrocklin/orgs",
            "repos_url": "https://api.github.com/users/mrocklin/repos",
            "events_url": "https://api.github.com/users/mrocklin/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mrocklin/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-05-28T02:40:16Z",
        "updated_at": "2020-05-28T02:40:16Z",
        "author_association": "MEMBER",
        "body": "To help us understand the value here, what other things would per-column\ndivisions metadata open up?\n\nAs in all things, this is mostly a question of weighing potential benefits\n* how often those situations occur against the cost to build and the cost\nto maintain.\n\nIf people would like for Dask dataframe to support this kind of metadata\nthen I think that we need more information on a few cases about when this\nwould be useful, as well as a design that would not be difficult to\nimplement or maintain.\n\nOn Wed, May 27, 2020 at 6:54 PM Tom Augspurger <notifications@github.com>\nwrote:\n\n> With the current model I would expect divisions to be equal to [None] *\n> (df.npartitions + 1)\n>\n> Right. So .shuffle() clears the divisions right now.\n>\n> It's a bit ugly, but do we perhaps avoid overloading divisions, since\n> \"index-divisions\" are so different than these \"column-divisions\"?\n>\n> They enable very different things. Index-divisions grant us things like\n> fast random access in .loc. The \"column-divisions\" (in principle) open up\n> things like fast boolean filtering.\n>\n> df2 = df.shuffle(column=\"id\")df2[df2.id == 1]  # only needs to check partitions where hash(df.id) == hash(1)\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dask/dask/issues/6246#issuecomment-635045576>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AACKZTDRWGCHDGDH5K54GN3RTW75HANCNFSM4NLEIAGQ>\n> .\n>\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/635060270/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/676019793",
        "html_url": "https://github.com/dask/dask/issues/6246#issuecomment-676019793",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/6246",
        "id": 676019793,
        "node_id": "MDEyOklzc3VlQ29tbWVudDY3NjAxOTc5Mw==",
        "user": {
            "login": "jorisvandenbossche",
            "id": 1020496,
            "node_id": "MDQ6VXNlcjEwMjA0OTY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1020496?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jorisvandenbossche",
            "html_url": "https://github.com/jorisvandenbossche",
            "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
            "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
            "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
            "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
            "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
            "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-08-19T09:24:37Z",
        "updated_at": "2020-08-19T09:24:37Z",
        "author_association": "MEMBER",
        "body": "I am interested in this discussion from dask-geopandas' point of view. \r\n\r\nIn https://github.com/jsignell/dask-geopandas/issues/8 / https://github.com/jsignell/dask-geopandas/pull/14, I am trying to add a *partitioning based on the spatial extent* of each partition. \r\nSo it's certainly still a different concept as the hash-based / column-based partitioning, but it's another example where the partitioning is not based on the index and the partitioning information doesn't fit in the current `divisions` attribute (in this case it could actually also be *complementary* to the index based divisions, and does not necessarily need to replace it).\r\n\r\nIn the linked PR, I am currently adding a `spatial_partitions` attribute, which serves a similar purpose as `divisions` to keep track of partitioning information, but does this by storing the spatial extent of each partition (it's a Series with length equal to the number of partitions). \r\nBut one obvious issue that comes up with this approach is how to propagate this information through operations where appropriate (many methods on the dask base class will do something like `new_dd_object(graph, name, meta, divisions)`, without a way to pass additional information, except by overriding each method where this is needed in the subclass).\r\n\r\n\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/676019793/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/676447516",
        "html_url": "https://github.com/dask/dask/issues/6246#issuecomment-676447516",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/6246",
        "id": 676447516,
        "node_id": "MDEyOklzc3VlQ29tbWVudDY3NjQ0NzUxNg==",
        "user": {
            "login": "mrocklin",
            "id": 306380,
            "node_id": "MDQ6VXNlcjMwNjM4MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/306380?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mrocklin",
            "html_url": "https://github.com/mrocklin",
            "followers_url": "https://api.github.com/users/mrocklin/followers",
            "following_url": "https://api.github.com/users/mrocklin/following{/other_user}",
            "gists_url": "https://api.github.com/users/mrocklin/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mrocklin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mrocklin/subscriptions",
            "organizations_url": "https://api.github.com/users/mrocklin/orgs",
            "repos_url": "https://api.github.com/users/mrocklin/repos",
            "events_url": "https://api.github.com/users/mrocklin/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mrocklin/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-08-19T14:27:31Z",
        "updated_at": "2020-08-19T14:27:31Z",
        "author_association": "MEMBER",
        "body": "Thanks @jorisvandenbossche .  I do think that the GeoPandas case is probably the cleanest example of where different partitioning structures are clearly useful.\r\n\r\n> (in this case it could actually also be complementary to the index based divisions, and does not necessarily need to replace it).\r\n\r\nI'm curious about if we should optimize for this case.  My *guess* is that we will rarely find situations where the partitions are cleanly partitioned across two columns like this.  I'm guessing that it will always be one or the other.\r\n\r\n> But one obvious issue that comes up with this approach is how to propagate this information through operations where appropriate (many methods on the dask base class will do something like new_dd_object(graph, name, meta, divisions), without a way to pass additional information, except by overriding each method where this is needed in the subclass)\r\n\r\nRight, so you bring up two points here I think:\r\n\r\n1.  How do we generalize the `new_dd_object` to replace \"divisions\" with \"division-like information\".\r\n2.  How do we change every dask dataframe method to be sensitive to how new division-like metadata behaves with respect to that method\r\n\r\nI think that point two is the largest one.  What should happen when someone adds two spatially partitioned dataframes together?  What happens when they add a spatially partitioned dataframe with an index partitioned dataframe?  What happens when they merge two such dataframes or call rolling-aggregations?  \r\n\r\nIn principle I think that this is the crux of the problem.  There is a matrix of partitioning-schemes vs dataframe methods that we need to fill out.  I think that there are big blocks of this matrix that will fall into place easily, like blockwise/map_partitions, but others that will require some attention.  \r\n\r\n> except by overriding each method where this is needed in the subclass\r\n\r\nIn the end my guess is that a lot of this will be necessary.  We'll need to subclass map_partitions, elemwise, loc, etc, which will handle most operations.  Some operations like shuffle/rolling/groupby we won't implement and so we'll revert to class index-partitioned scheme, which is ok because we've probably lost spatial-indexing here anyway.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/676447516/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/677900013",
        "html_url": "https://github.com/dask/dask/issues/6246#issuecomment-677900013",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/6246",
        "id": 677900013,
        "node_id": "MDEyOklzc3VlQ29tbWVudDY3NzkwMDAxMw==",
        "user": {
            "login": "jorisvandenbossche",
            "id": 1020496,
            "node_id": "MDQ6VXNlcjEwMjA0OTY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1020496?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jorisvandenbossche",
            "html_url": "https://github.com/jorisvandenbossche",
            "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
            "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
            "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
            "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
            "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
            "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
            "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-08-20T20:56:18Z",
        "updated_at": "2020-08-20T20:56:18Z",
        "author_association": "MEMBER",
        "body": "> > (in this case it could actually also be complementary to the index based divisions, and does not necessarily need to replace it).\r\n>\r\n> I'm curious about if we should optimize for this case. My guess is that we will rarely find situations where the partitions are cleanly partitioned across two columns like this. I'm guessing that it will always be one or the other.\r\n\r\nI don't know how common this would be, but one hypothetical use case where I remember this coming up, is large spatial timeseries data where you might want to partition your parquet dataset both in time (which could become the `divisions`) and additionally split eg each day into multiple files sorted spatially. \r\n(@dharhas mentioned some uses cases here: https://github.com/holoviz/spatialpandas/issues/30, but I am not fully sure that those would benefit from such dual partitioning)\r\n\r\n> How do we generalize the new_dd_object to replace \"divisions\" with \"division-like information\".\r\n\r\nFor this, is replacing the current `divisions` tuple with a custom class holding the information a possible route? (@rjzamora mentioned that in https://github.com/dask/dask/pull/6066#issuecomment-634058090) \r\n\r\n> > except by overriding each method where this is needed in the subclass\r\n>\r\n> In the end my guess is that a lot of this will be necessary. \r\n\r\nYes. Now specifically for the geopandas use case, the spatial partitioning is tied to the presence of a geometry column. So many operations (like numerical ones, adding two dataframes/series, selecting non-geometry columns, etc) won't preserve spatial partitioning. And for many of the methods that do need to preserve it will be geometry-related methods that we need to implement in dask-geopandas anyway. \r\n\r\nA typical (general) method I can think of where we want to preserve / propagate custom partitioning information is something like filtering (eg `df[df['col'] == 'val']`)\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/677900013/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/678121940",
        "html_url": "https://github.com/dask/dask/issues/6246#issuecomment-678121940",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/6246",
        "id": 678121940,
        "node_id": "MDEyOklzc3VlQ29tbWVudDY3ODEyMTk0MA==",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2020-08-21T08:44:54Z",
        "updated_at": "2020-08-21T08:44:54Z",
        "author_association": "MEMBER",
        "body": "A usecase I am interested in where this may prove very useful is joining / dealing with multiple similarly partitioned datasets.\r\n\r\nConsider you have multiple partition columns in a hive-like partitioning schema (for simplicity I assume both datasets have the same partition keys but as long as they have a common subset this would be applicable)\r\n\r\n```\r\ndatasetA/X=123/Y=abc/123456.parquet\r\n....\r\n\r\ndatasetB/X=123/Y=abc/987654.parquet\r\n```\r\nIt is rather easy to deal with this as log as there is only one dimension to align on (reconstructing the dask index from the parquet dataset is easy). Dealing with multiple dimensions efficiently is rather difficult with dask since there is only a single index column available. Instead of a multiindex, hash based divisions would work as well, obviously.\r\nThis use case might seem a bit artificial at first glance but we're quite heavily relying on something like this right now and we've built a lot of logic for this alignment joining in https://github.com/JDASoftwareGroup/kartothek since dask didn't support this in the past (We just added this functionality to the OSS repo, proper docs still missing, see https://github.com/JDASoftwareGroup/kartothek/pull/334)\r\n\r\nInstead of hash based divisions, I could also see more advanced algorithms to be quite useful, e.g. z-curves (or room filling curves in general) instead of hashes which would probably allow the efficient implementation of more advanced join methods (e.g. merge_asof) and more.\r\n\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/678121940/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]