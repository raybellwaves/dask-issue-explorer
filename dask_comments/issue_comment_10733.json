[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1883051648",
        "html_url": "https://github.com/dask/dask/issues/10733#issuecomment-1883051648",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10733",
        "id": 1883051648,
        "node_id": "IC_kwDOAbcwm85wPRaA",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2024-01-09T13:26:00Z",
        "updated_at": "2024-01-09T13:27:30Z",
        "author_association": "MEMBER",
        "body": "Thanks for opening this issue. \r\n\r\nFirst of all, there is actually a minor bug in your code since you should be using `dask.compute` inside of the delayed driver function (`do_math`) as well, i.e.\r\n\r\n```python\r\nimport dask, time\r\n\r\n@dask.delayed\r\ndef add(x, y):\r\n    time.sleep(2)\r\n    return x + y\r\n\r\n@dask.delayed\r\ndef do_math(x, y, op):\r\n    results = []\r\n    for _ in range(4):\r\n        results.append(op(x, y))\r\n    return dask.compute(*results)\r\n```\r\n\r\nThe reason why this isn't necessary right now is also the reason why you are experiencing \"broken concurrency\", i.e. the sub tasks are not executed in parallel but sequentially.\r\n\r\nYou are not merely executing nested tasks but you are also using a very functional approach to programming in that you are passing the delayed decorated function `add` to the driver task `do_math`. If I was to type annotate that function it would look like\r\n\r\n```python\r\ndef do_math(x: int, y: int, op: Delayed) -> list[int]:\r\n    ...\r\n```\r\n\r\nThe problem is that there is an ambiguity internally about instances of `Delayed` objects and the results of the functions the delayed objects represent. In short, we are unpacking/unwrapping all `Delayed` instances (e.g. your decorated function) such that the called function receives the wrapped object. I'm not entirely sure but I think this is not something we can change easily.\r\n\r\nThe _intended_ way to define these nested calls is to call the delayed functions directly.\r\n\r\n```python\r\n@dask.delayed\r\ndef do_math(x, y):\r\n    results = []\r\n    for _ in range(4):\r\n        #  `add` here is the decorated delayed function and we're calling it directly, not via the function argument\r\n        results.append(add(x, y))\r\n    return dask.compute(*results)\r\n```\r\n\r\nThere is nothing wrong with defining nested computations ([we recommend not](https://docs.dask.org/en/stable/delayed-best-practices.html#avoid-calling-delayed-within-delayed-functions) doing it because this is an advanced approach where users should know what they are doing to avoid a bad experience) but the particular approach you chose is clashing with some of our internals.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1883051648/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1883060742",
        "html_url": "https://github.com/dask/dask/issues/10733#issuecomment-1883060742",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10733",
        "id": 1883060742,
        "node_id": "IC_kwDOAbcwm85wPToG",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2024-01-09T13:33:55Z",
        "updated_at": "2024-01-09T13:33:55Z",
        "author_association": "MEMBER",
        "body": "FWIW I agree that this is not nice, I'm just not sure if I can offer a fix. I'm looking into one thing right now but can't promise much...",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1883060742/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1883484895",
        "html_url": "https://github.com/dask/dask/issues/10733#issuecomment-1883484895",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10733",
        "id": 1883484895,
        "node_id": "IC_kwDOAbcwm85wQ7Lf",
        "user": {
            "login": "Andrew-S-Rosen",
            "id": 8674072,
            "node_id": "MDQ6VXNlcjg2NzQwNzI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8674072?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/Andrew-S-Rosen",
            "html_url": "https://github.com/Andrew-S-Rosen",
            "followers_url": "https://api.github.com/users/Andrew-S-Rosen/followers",
            "following_url": "https://api.github.com/users/Andrew-S-Rosen/following{/other_user}",
            "gists_url": "https://api.github.com/users/Andrew-S-Rosen/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/Andrew-S-Rosen/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/Andrew-S-Rosen/subscriptions",
            "organizations_url": "https://api.github.com/users/Andrew-S-Rosen/orgs",
            "repos_url": "https://api.github.com/users/Andrew-S-Rosen/repos",
            "events_url": "https://api.github.com/users/Andrew-S-Rosen/events{/privacy}",
            "received_events_url": "https://api.github.com/users/Andrew-S-Rosen/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2024-01-09T17:27:22Z",
        "updated_at": "2024-01-09T17:44:54Z",
        "author_association": "CONTRIBUTOR",
        "body": "@fjetter: Thank you so much for taking the time to reply. The tl;dr here is --- I completely understand and agree. That said, I will be thorough in my reply here for the sake of any future individual who reads this.\r\n\r\n> First of all, there is actually a minor bug in your code since you should be using dask.compute inside of the delayed driver function (do_math) as well, i.e.\r\n\r\nGreat call. You're absolutely right, although it is a bit clunky to have to inject a `dask.compute` call in what is otherwise a Dask-free function. But it is necessary. Some other workflow languages have a dedicated operator for this kind of thing, but with only the `@delayed` decorator in Dask, you are right --- one must call `dask.compute(*results)` inside the function.\r\n\r\n> The problem is that there is an ambiguity internally about instances of Delayed objects and the results of the functions the delayed objects represent. In short, we are unpacking/unwrapping all Delayed instances (e.g. your decorated function) such that the called function receives the wrapped object. I'm not entirely sure but I think this is not something we can change easily.\r\n\r\nIndeed, for my original report here, that is the problem. Dask tries to intelligently unpack the `Delayed` object when, in this functional programming approach, it is meant to just be passed around as-is. It would certainly be nice to be able to support this mechanism, if you find a way.\r\n\r\nAs for right now, I am doing a hack in my own codes where I define a custom `@delayed` decorator (e.g. `@my_delayed`) that behaves as follows:\r\n\r\n```python\r\nfrom dask import delayed\r\nfrom functools import wraps\r\n\r\ndef my_delayed(_func, **kwargs)\r\n\r\n    @wraps(_func)\r\n    def wrapper(*f_args, **f_kwargs):\r\n        return _func(*f_args, **f_kwargs)\r\n\r\n    return Delayed_(delayed(wrapper, **kwargs))\r\n\r\nclass Delayed_:\r\n    \"\"\"\r\n    A small Dask-compatible, serializable object to wrap delayed functions\r\n    that we don't want to execute\r\n    \"\"\"\r\n\r\n    __slots__ = (\"func\",)\r\n\r\n    def __init__(self, func):\r\n        self.func = func\r\n\r\n    def __reduce__(self):\r\n        return (Delayed_, (self.func,))\r\n\r\n    def __call__(self, *args, **kwargs):\r\n        return self.func(*args, **kwargs)\r\n```\r\n\r\nThis \"protects\" my `Delayed` object when no arguments are supplied yet, but it is obviously very hacky.\r\n\r\n> There is nothing wrong with defining nested computations ([we recommend not](https://docs.dask.org/en/stable/delayed-best-practices.html#avoid-calling-delayed-within-delayed-functions) doing it because this is an advanced approach where users should know what they are doing to avoid a bad experience) but the particular approach you chose is clashing with some of our internals.\r\n\r\nGreat! I am fine with it being for advanced users. Edge cases are expected.\r\n\r\nAs a sidenote, there is a related issue that I report on the Discourse page. Namely, the following works:\r\n\r\n```python\r\nimport dask\r\nimport time\r\n\r\ndef job():\r\n    print('Sleeping')\r\n    time.sleep(5)\r\n    return True\r\n\r\n@dask.delayed\r\ndef get_n():\r\n    return 5\r\n\r\n@dask.delayed\r\ndef subflow(op, n):\r\n    results = []\r\n    for _ in range(n):\r\n        results.append(dask.delayed(op)())\r\n    return results\r\n\r\ndef workflow():\r\n    n = get_n()\r\n    return subflow(job, n).compute()\r\n\r\ndask.compute(workflow())\r\n```\r\nHowever, the following breaks concurrency:\r\n\r\n```python\r\nimport dask\r\nimport time\r\n\r\n@dask.delayed\r\ndef job():\r\n    print('Sleeping')\r\n    time.sleep(5)\r\n    return True\r\n\r\n@dask.delayed\r\ndef get_n():\r\n    return 5\r\n\r\n@dask.delayed\r\ndef subflow(op, n):\r\n    results = []\r\n    for _ in range(n):\r\n        results.append(op())\r\n    return results\r\n\r\ndef workflow():\r\n    n = get_n()\r\n    return subflow(job, n).compute()\r\n\r\ndask.compute(workflow())\r\n```\r\nI can't quite tell if it's an unintuitive Dask behavior like before or not, but it's likely related to the above comments. Either way, there are likely better ways to achieve the intended logic regardless.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1883484895/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1884526830",
        "html_url": "https://github.com/dask/dask/issues/10733#issuecomment-1884526830",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10733",
        "id": 1884526830,
        "node_id": "IC_kwDOAbcwm85wU5ju",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2024-01-10T09:56:00Z",
        "updated_at": "2024-01-10T09:56:00Z",
        "author_association": "MEMBER",
        "body": "> Some other workflow languages have a dedicated operator for this kind of thing, but with only the @delayed decorator in Dask, you are right --- one must call dask.compute(*results) inside the function.\r\n\r\nCan you elaborate what you are referring to here? I assume you are not talking about [python operators](https://docs.python.org/3/library/operator.html) are you?\r\nI don't see a way around a collect/gather/compute method/function to get the results of multiple concurrently running tasks (e.g. asyncio is using `asyncio.gather` just like our [Client API](https://distributed.dask.org/en/stable/api.html#distributed.Client.gather))",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1884526830/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1885100625",
        "html_url": "https://github.com/dask/dask/issues/10733#issuecomment-1885100625",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/10733",
        "id": 1885100625,
        "node_id": "IC_kwDOAbcwm85wXFpR",
        "user": {
            "login": "Andrew-S-Rosen",
            "id": 8674072,
            "node_id": "MDQ6VXNlcjg2NzQwNzI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8674072?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/Andrew-S-Rosen",
            "html_url": "https://github.com/Andrew-S-Rosen",
            "followers_url": "https://api.github.com/users/Andrew-S-Rosen/followers",
            "following_url": "https://api.github.com/users/Andrew-S-Rosen/following{/other_user}",
            "gists_url": "https://api.github.com/users/Andrew-S-Rosen/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/Andrew-S-Rosen/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/Andrew-S-Rosen/subscriptions",
            "organizations_url": "https://api.github.com/users/Andrew-S-Rosen/orgs",
            "repos_url": "https://api.github.com/users/Andrew-S-Rosen/repos",
            "events_url": "https://api.github.com/users/Andrew-S-Rosen/events{/privacy}",
            "received_events_url": "https://api.github.com/users/Andrew-S-Rosen/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2024-01-10T15:41:32Z",
        "updated_at": "2024-01-10T16:12:24Z",
        "author_association": "CONTRIBUTOR",
        "body": "@fjetter sure, I can explain. Basically, it is very nice to avoid injecting any Dask specific logic in the underlying functions (other than the applied decorator). However, in the presented scenario, that's not possible, as you nicely highlighted with the `return` statement. Several other workflow tools have a dedicated \"subworkflow\" type of decorator that will take care of the gather operation automatically. A good example is the [@join_app](https://parsl.readthedocs.io/en/latest/userguide/joins.html#usage) in Parsl, but there are other examples as well.\r\n\r\nFor dask, a similar idea would be something like:\r\n\r\n```python\r\nfrom dask import delayed\r\nfrom dask.distributed import worker_client\r\nfrom functools import wraps\r\n\r\ndef join_delayed(_func, **kwargs):\r\n    @wraps(_func)\r\n    def wrapper(*f_args, **f_kwargs):\r\n        with worker_client() as client:\r\n            futures = client.compute(_func(*f_args, **f_kwargs))\r\n            return client.gather(futures)\r\n\r\n    return delayed(wrapper, **kwargs)\r\n```\r\n\r\nAnyway, that comment was a bit tangential to the main point. Didn't mean to get off course. ",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1885100625/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]