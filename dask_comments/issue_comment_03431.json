[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/413970612",
        "html_url": "https://github.com/dask/dask/issues/3431#issuecomment-413970612",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/3431",
        "id": 413970612,
        "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzk3MDYxMg==",
        "user": {
            "login": "groceryheist",
            "id": 113311,
            "node_id": "MDQ6VXNlcjExMzMxMQ==",
            "avatar_url": "https://avatars.githubusercontent.com/u/113311?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/groceryheist",
            "html_url": "https://github.com/groceryheist",
            "followers_url": "https://api.github.com/users/groceryheist/followers",
            "following_url": "https://api.github.com/users/groceryheist/following{/other_user}",
            "gists_url": "https://api.github.com/users/groceryheist/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/groceryheist/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/groceryheist/subscriptions",
            "organizations_url": "https://api.github.com/users/groceryheist/orgs",
            "repos_url": "https://api.github.com/users/groceryheist/repos",
            "events_url": "https://api.github.com/users/groceryheist/events{/privacy}",
            "received_events_url": "https://api.github.com/users/groceryheist/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2018-08-17T19:47:31Z",
        "updated_at": "2018-08-17T19:47:31Z",
        "author_association": "NONE",
        "body": "I had a similar problem. I tried \r\n\r\n    d.index = d.index.astype(CategoricalDtype(ordered=True))\r\n\r\nbefore the merge. \r\nThis seems to work, but my job is also struggling to process efficiently, and running single threaded for a long time. Not sure why. ",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/413970612/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/413973661",
        "html_url": "https://github.com/dask/dask/issues/3431#issuecomment-413973661",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/3431",
        "id": 413973661,
        "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzk3MzY2MQ==",
        "user": {
            "login": "TomAugspurger",
            "id": 1312546,
            "node_id": "MDQ6VXNlcjEzMTI1NDY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1312546?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/TomAugspurger",
            "html_url": "https://github.com/TomAugspurger",
            "followers_url": "https://api.github.com/users/TomAugspurger/followers",
            "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
            "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
            "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
            "repos_url": "https://api.github.com/users/TomAugspurger/repos",
            "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
            "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2018-08-17T20:01:12Z",
        "updated_at": "2018-08-17T20:01:12Z",
        "author_association": "MEMBER",
        "body": "Pandas raises a `ValueError` here.\r\n\r\n```python\r\nIn [32]: df = pd.DataFrame({\"a\": [1, 2]}, index=pd.CategoricalIndex(['A', 'A'], ordered=True))\r\n\r\nIn [33]: df\r\nOut[33]:\r\n   a\r\nA  1\r\nA  2\r\n\r\nIn [34]: df.loc['A':'B']\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\n~/sandbox/pandas/pandas/core/indexes/base.py in get_slice_bound(self, label, side, kind)\r\n   4282             try:\r\n-> 4283                 return self._searchsorted_monotonic(label, side)\r\n   4284             except ValueError:\r\n\r\n~/sandbox/pandas/pandas/core/indexes/base.py in _searchsorted_monotonic(self, label, side)\r\n   4232         if self.is_monotonic_increasing:\r\n-> 4233             return self.searchsorted(label, side=side)\r\n   4234         elif self.is_monotonic_decreasing:\r\n\r\n~/sandbox/pandas/pandas/util/_decorators.py in wrapper(*args, **kwargs)\r\n    176                     kwargs[new_arg_name] = new_arg_value\r\n--> 177             return func(*args, **kwargs)\r\n    178         return wrapper\r\n\r\n~/sandbox/pandas/pandas/core/base.py in searchsorted(self, value, side, sorter)\r\n   1233         # needs coercion on the key (DatetimeIndex does already)\r\n-> 1234         return self.values.searchsorted(value, side=side, sorter=sorter)\r\n   1235\r\n\r\n~/sandbox/pandas/pandas/util/_decorators.py in wrapper(*args, **kwargs)\r\n    176                     kwargs[new_arg_name] = new_arg_value\r\n--> 177             return func(*args, **kwargs)\r\n    178         return wrapper\r\n\r\n~/sandbox/pandas/pandas/core/arrays/categorical.py in searchsorted(self, value, side, sorter)\r\n   1351         if -1 in values_as_codes:\r\n-> 1352             raise ValueError(\"Value(s) to be inserted must be in categories.\")\r\n   1353\r\n\r\nValueError: Value(s) to be inserted must be in categories.\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nKeyError                                  Traceback (most recent call last)\r\n<ipython-input-34-b4269b40a24d> in <module>()\r\n----> 1 df.loc['A':'B']\r\n\r\n~/sandbox/pandas/pandas/core/indexing.py in __getitem__(self, key)\r\n   1500\r\n   1501             maybe_callable = com.apply_if_callable(key, self.obj)\r\n-> 1502             return self._getitem_axis(maybe_callable, axis=axis)\r\n   1503\r\n   1504     def _is_scalar_access(self, key):\r\n\r\n~/sandbox/pandas/pandas/core/indexing.py in _getitem_axis(self, key, axis)\r\n   1867         if isinstance(key, slice):\r\n   1868             self._validate_key(key, axis)\r\n-> 1869             return self._get_slice_axis(key, axis=axis)\r\n   1870         elif com.is_bool_indexer(key):\r\n   1871             return self._getbool_axis(key, axis=axis)\r\n\r\n~/sandbox/pandas/pandas/core/indexing.py in _get_slice_axis(self, slice_obj, axis)\r\n   1533         labels = obj._get_axis(axis)\r\n   1534         indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop,\r\n-> 1535                                        slice_obj.step, kind=self.name)\r\n   1536\r\n   1537         if isinstance(indexer, slice):\r\n\r\n~/sandbox/pandas/pandas/core/indexes/base.py in slice_indexer(self, start, end, step, kind)\r\n   4147         \"\"\"\r\n   4148         start_slice, end_slice = self.slice_locs(start, end, step=step,\r\n-> 4149                                                  kind=kind)\r\n   4150\r\n   4151         # return a slice\r\n\r\n~/sandbox/pandas/pandas/core/indexes/base.py in slice_locs(self, start, end, step, kind)\r\n   4354         end_slice = None\r\n   4355         if end is not None:\r\n-> 4356             end_slice = self.get_slice_bound(end, 'right', kind)\r\n   4357         if end_slice is None:\r\n   4358             end_slice = len(self)\r\n\r\n~/sandbox/pandas/pandas/core/indexes/base.py in get_slice_bound(self, label, side, kind)\r\n   4284             except ValueError:\r\n   4285                 # raise the original KeyError\r\n-> 4286                 raise err\r\n   4287\r\n   4288         if isinstance(slc, np.ndarray):\r\n\r\n~/sandbox/pandas/pandas/core/indexes/base.py in get_slice_bound(self, label, side, kind)\r\n   4278         # we need to look up the label\r\n   4279         try:\r\n-> 4280             slc = self._get_loc_only_exact_matches(label)\r\n   4281         except KeyError as err:\r\n   4282             try:\r\n\r\n~/sandbox/pandas/pandas/core/indexes/base.py in _get_loc_only_exact_matches(self, key)\r\n   4247         get_slice_bound.\r\n   4248         \"\"\"\r\n-> 4249         return self.get_loc(key)\r\n   4250\r\n   4251     def get_slice_bound(self, label, side, kind):\r\n\r\n~/sandbox/pandas/pandas/core/indexes/category.py in get_loc(self, key, method)\r\n    430         array([False,  True, False,  True], dtype=bool)\r\n    431         \"\"\"\r\n--> 432         codes = self.categories.get_loc(key)\r\n    433         if (codes == -1):\r\n    434             raise KeyError(key)\r\n\r\n~/sandbox/pandas/pandas/core/indexes/base.py in get_loc(self, key, method, tolerance)\r\n   3042                 return self._engine.get_loc(key)\r\n   3043             except KeyError:\r\n-> 3044                 return self._engine.get_loc(self._maybe_cast_indexer(key))\r\n   3045\r\n   3046         indexer = self.get_indexer([key], method=method, tolerance=tolerance)\r\n\r\n~/sandbox/pandas/pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()\r\n\r\n~/sandbox/pandas/pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()\r\n\r\n~/sandbox/pandas/pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()\r\n\r\n~/sandbox/pandas/pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()\r\n```\r\n\r\nI *think* that's the correct behavior, since Categoricals can have custom ordering, so there's no way to know where `B` is in the custom ordering... (though I'm not sure about unordered categories).\r\n\r\nRegardless, dask will probably need to work around this when slicing in `boundary_slice`.",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/413973661/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]