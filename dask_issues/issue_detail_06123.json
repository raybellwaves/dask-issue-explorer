{
    "url": "https://api.github.com/repos/dask/dask/issues/6123",
    "repository_url": "https://api.github.com/repos/dask/dask",
    "labels_url": "https://api.github.com/repos/dask/dask/issues/6123/labels{/name}",
    "comments_url": "https://api.github.com/repos/dask/dask/issues/6123/comments",
    "events_url": "https://api.github.com/repos/dask/dask/issues/6123/events",
    "html_url": "https://github.com/dask/dask/issues/6123",
    "id": 605135435,
    "node_id": "MDU6SXNzdWU2MDUxMzU0MzU=",
    "number": 6123,
    "title": "Compile Blockwise array sub graphs",
    "user": {
        "login": "mrocklin",
        "id": 306380,
        "node_id": "MDQ6VXNlcjMwNjM4MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/306380?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mrocklin",
        "html_url": "https://github.com/mrocklin",
        "followers_url": "https://api.github.com/users/mrocklin/followers",
        "following_url": "https://api.github.com/users/mrocklin/following{/other_user}",
        "gists_url": "https://api.github.com/users/mrocklin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/mrocklin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/mrocklin/subscriptions",
        "organizations_url": "https://api.github.com/users/mrocklin/orgs",
        "repos_url": "https://api.github.com/users/mrocklin/repos",
        "events_url": "https://api.github.com/users/mrocklin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/mrocklin/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 242862305,
            "node_id": "MDU6TGFiZWwyNDI4NjIzMDU=",
            "url": "https://api.github.com/repos/dask/dask/labels/array",
            "name": "array",
            "color": "006b75",
            "default": false,
            "description": null
        },
        {
            "id": 2156573524,
            "node_id": "MDU6TGFiZWwyMTU2NTczNTI0",
            "url": "https://api.github.com/repos/dask/dask/labels/highlevelgraph",
            "name": "highlevelgraph",
            "color": "8c24d6",
            "default": false,
            "description": "Issues relating to HighLevelGraphs."
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2020-04-22T23:25:30Z",
    "updated_at": "2021-10-13T04:05:40Z",
    "closed_at": null,
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "We currently collect a broad class of operations into high level graphs.\r\n\r\n```python\r\nIn [1]: import dask.array as da                                                                          \r\n\r\nIn [2]: from dask.blockwise import optimize_blockwise                                                    \r\n\r\nIn [3]: x = da.ones((10, 10), chunks=(5, 5))                                                             \r\n\r\nIn [4]: y = da.cos(x) ** 2 + da.sin(x) ** 2                                                              \r\n\r\nIn [5]: graph = optimize_blockwise(y.dask)                                                               \r\n\r\nIn [6]: {k: type(v) for k, v in graph.layers.items()}                                                    \r\nOut[6]: \r\n{'add-a2d88408268290d7edfe4ede916b05b4': dask.blockwise.Blockwise,\r\n 'ones-b8c5986474b86c6e3a94246ecba1c6e4': dict}\r\n\r\nIn [7]: layer = graph.layers[\"add-a2d88408268290d7edfe4ede916b05b4\"]                                     \r\n\r\nIn [8]: layer                                                                                            \r\nOut[8]: Blockwise<((2, None), ('ones-b8c5986474b86c6e3a94246ecba1c6e4', ('.1', '.0'))) -> add-a2d88408268290d7edfe4ede916b05b4>\r\n\r\nIn [9]: layer.dsk                                                                                        \r\nOut[9]: \r\n{'add-a2d88408268290d7edfe4ede916b05b4': (<function _operator.add(a, b, /)>,\r\n  'pow-235ad71f84352db184f344e57d4ac82d',\r\n  'pow-4f17fda523d5e314cbcdb23b6972e013'),\r\n 'pow-235ad71f84352db184f344e57d4ac82d': (<function _operator.pow(a, b, /)>,\r\n  'cos-58716fab65fe91a0e56f8d12baabec04',\r\n  '_0'),\r\n 'cos-58716fab65fe91a0e56f8d12baabec04': (<ufunc 'cos'>, '_1'),\r\n 'pow-4f17fda523d5e314cbcdb23b6972e013': (<function _operator.pow(a, b, /)>,\r\n  'sin-968a3d0e9b788b4f0cc55ac5c3e938f7',\r\n  '_0'),\r\n 'sin-968a3d0e9b788b4f0cc55ac5c3e938f7': (<ufunc 'sin'>, '_1')}\r\n\r\nIn [10]: layer.__dict__                                                                                  \r\nOut[10]: \r\n{'output': 'add-a2d88408268290d7edfe4ede916b05b4',\r\n 'output_indices': ('.1', '.0'),\r\n 'dsk': {'add-a2d88408268290d7edfe4ede916b05b4': (<function _operator.add(a, b, /)>,\r\n   'pow-235ad71f84352db184f344e57d4ac82d',\r\n   'pow-4f17fda523d5e314cbcdb23b6972e013'),\r\n  'pow-235ad71f84352db184f344e57d4ac82d': (<function _operator.pow(a, b, /)>,\r\n   'cos-58716fab65fe91a0e56f8d12baabec04',\r\n   '_0'),\r\n  'cos-58716fab65fe91a0e56f8d12baabec04': (<ufunc 'cos'>, '_1'),\r\n  'pow-4f17fda523d5e314cbcdb23b6972e013': (<function _operator.pow(a, b, /)>,\r\n   'sin-968a3d0e9b788b4f0cc55ac5c3e938f7',\r\n   '_0'),\r\n  'sin-968a3d0e9b788b4f0cc55ac5c3e938f7': (<ufunc 'sin'>, '_1')},\r\n 'indices': ((2, None),\r\n  ('ones-b8c5986474b86c6e3a94246ecba1c6e4', ('.1', '.0'))),\r\n 'numblocks': {'ones-b8c5986474b86c6e3a94246ecba1c6e4': (2, 2)},\r\n 'concatenate': None,\r\n 'new_axes': {}}\r\n```\r\n\r\nThis includes elementwise operations (as above) and also transpose, the first bits of reductions, tensordot, and so on.  The object `layer.dsk` is a computation to run in a single task.  Normally it gets evaluated by `dask.get` (I think) (a simple single threaded scheduler) by calling these functions in a sensible order on the input chunks.  \r\n\r\nHowever we could also choose to be more intelligent here, and modify this sequence of functions.  This is a good time to perform intelligent optimizations because we know that this one sub-graph is likely both small, and likely to be run many times across all of our chunks.  Two optimizations have come up in the past:\r\n\r\n1.  Using inplace operations, like rewriting `a = a + 1` to `a += 1` when safe to do so\r\n2.  Handing everything to Numba, which maybe does optimizations like the above, and hopefully others.  \r\n3.  Handing everything to Numba, and optionally using some of the fancier flags within numba, like `fastmath=True`\r\n\r\nThis came up briefly in https://github.com/dask/dask/issues/1964 .  @jcrist may also have an experiment lying around\r\n\r\n### GPUs\r\n\r\nAvoiding memory copies becomes more important when the underlying chunks are cupy rather than numpy arrays.  An optimization of this sort may also be interested in knowing what the metadata of the input chunks are.",
    "closed_by": null,
    "reactions": {
        "url": "https://api.github.com/repos/dask/dask/issues/6123/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/dask/dask/issues/6123/timeline",
    "performed_via_github_app": null,
    "state_reason": null
}