[
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1434010484",
        "html_url": "https://github.com/dask/dask/issues/9969#issuecomment-1434010484",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9969",
        "id": 1434010484,
        "node_id": "IC_kwDOAbcwm85VeUN0",
        "user": {
            "login": "rjzamora",
            "id": 20461013,
            "node_id": "MDQ6VXNlcjIwNDYxMDEz",
            "avatar_url": "https://avatars.githubusercontent.com/u/20461013?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rjzamora",
            "html_url": "https://github.com/rjzamora",
            "followers_url": "https://api.github.com/users/rjzamora/followers",
            "following_url": "https://api.github.com/users/rjzamora/following{/other_user}",
            "gists_url": "https://api.github.com/users/rjzamora/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/rjzamora/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/rjzamora/subscriptions",
            "organizations_url": "https://api.github.com/users/rjzamora/orgs",
            "repos_url": "https://api.github.com/users/rjzamora/repos",
            "events_url": "https://api.github.com/users/rjzamora/events{/privacy}",
            "received_events_url": "https://api.github.com/users/rjzamora/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-17T02:31:12Z",
        "updated_at": "2023-02-17T02:31:12Z",
        "author_association": "MEMBER",
        "body": "Thanks for writing this up @fjetter ! I am personally very open to this idea.  We certainly spend a lot of time fighting with the repercussions of having such a \"lax\" task standard. It is certainly nice to be able to say \"a Dask graph is just a dictionary of strings and tuples!\", but I agree that it doesn't seem \"worth it.\"\r\n\r\n>I ran a couple of micro benchmarks to estimate the performance impact of using a slotted class instead of tuples and could indeed see a slowdown during graph generation (maybe a factor of 2) but this appears to be easily amortized by just not walking the graph so often and not recursing into everything and matching strings, etc. since this class exposes everything we'd be interested to know.\r\n\r\nMakes sense that generation itself will take a bit of a hit. We definitely want to make sure that end-to-end performance improves for real-world applications (or remains reasonably flat) - I have my fingers crossed.\r\n\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1434010484/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1434064061",
        "html_url": "https://github.com/dask/dask/issues/9969#issuecomment-1434064061",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9969",
        "id": 1434064061,
        "node_id": "IC_kwDOAbcwm85VehS9",
        "user": {
            "login": "mrocklin",
            "id": 306380,
            "node_id": "MDQ6VXNlcjMwNjM4MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/306380?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mrocklin",
            "html_url": "https://github.com/mrocklin",
            "followers_url": "https://api.github.com/users/mrocklin/followers",
            "following_url": "https://api.github.com/users/mrocklin/following{/other_user}",
            "gists_url": "https://api.github.com/users/mrocklin/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mrocklin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mrocklin/subscriptions",
            "organizations_url": "https://api.github.com/users/mrocklin/orgs",
            "repos_url": "https://api.github.com/users/mrocklin/repos",
            "events_url": "https://api.github.com/users/mrocklin/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mrocklin/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-17T04:00:53Z",
        "updated_at": "2023-02-17T04:00:53Z",
        "author_association": "MEMBER",
        "body": "Historically I used to object to this.  I don't today. I don't expect any\nothers will either.\n\nOn Thu, Feb 16, 2023 at 8:31 PM Richard (Rick) Zamora <\n***@***.***> wrote:\n\n> Thanks for writing this up @fjetter <https://github.com/fjetter> ! I am\n> personally very open to this idea. We certainly spend a lot of time\n> fighting with the repercussions of having such a \"lax\" task standard. It is\n> certainly nice to be able to say \"a Dask graph is just a dictionary of\n> strings and tuples!\", but I agree that it doesn't seem \"worth it.\"\n>\n> I ran a couple of micro benchmarks to estimate the performance impact of\n> using a slotted class instead of tuples and could indeed see a slowdown\n> during graph generation (maybe a factor of 2) but this appears to be easily\n> amortized by just not walking the graph so often and not recursing into\n> everything and matching strings, etc. since this class exposes everything\n> we'd be interested to know.\n>\n> Makes sense that generation itself will take a bit of a hit. We definitely\n> want to make sure that end-to-end performance improves for real-world\n> applications (or remains reasonably flat) - I have my fingers crossed.\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dask/dask/issues/9969#issuecomment-1434010484>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AACKZTA37DMTOD6XXUW6S33WX3PHXANCNFSM6AAAAAAU6EIMO4>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1434064061/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1434064380",
        "html_url": "https://github.com/dask/dask/issues/9969#issuecomment-1434064380",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9969",
        "id": 1434064380,
        "node_id": "IC_kwDOAbcwm85VehX8",
        "user": {
            "login": "mrocklin",
            "id": 306380,
            "node_id": "MDQ6VXNlcjMwNjM4MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/306380?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mrocklin",
            "html_url": "https://github.com/mrocklin",
            "followers_url": "https://api.github.com/users/mrocklin/followers",
            "following_url": "https://api.github.com/users/mrocklin/following{/other_user}",
            "gists_url": "https://api.github.com/users/mrocklin/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/mrocklin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mrocklin/subscriptions",
            "organizations_url": "https://api.github.com/users/mrocklin/orgs",
            "repos_url": "https://api.github.com/users/mrocklin/repos",
            "events_url": "https://api.github.com/users/mrocklin/events{/privacy}",
            "received_events_url": "https://api.github.com/users/mrocklin/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-17T04:01:13Z",
        "updated_at": "2023-02-17T04:01:13Z",
        "author_association": "MEMBER",
        "body": "(not to say that people shouldn't speak up if they do object, please do if\nso)\n\nOn Thu, Feb 16, 2023 at 10:00 PM Matthew Rocklin ***@***.***> wrote:\n\n> Historically I used to object to this.  I don't today. I don't expect any\n> others will either.\n>\n> On Thu, Feb 16, 2023 at 8:31 PM Richard (Rick) Zamora <\n> ***@***.***> wrote:\n>\n>> Thanks for writing this up @fjetter <https://github.com/fjetter> ! I am\n>> personally very open to this idea. We certainly spend a lot of time\n>> fighting with the repercussions of having such a \"lax\" task standard. It is\n>> certainly nice to be able to say \"a Dask graph is just a dictionary of\n>> strings and tuples!\", but I agree that it doesn't seem \"worth it.\"\n>>\n>> I ran a couple of micro benchmarks to estimate the performance impact of\n>> using a slotted class instead of tuples and could indeed see a slowdown\n>> during graph generation (maybe a factor of 2) but this appears to be easily\n>> amortized by just not walking the graph so often and not recursing into\n>> everything and matching strings, etc. since this class exposes everything\n>> we'd be interested to know.\n>>\n>> Makes sense that generation itself will take a bit of a hit. We\n>> definitely want to make sure that end-to-end performance improves for\n>> real-world applications (or remains reasonably flat) - I have my fingers\n>> crossed.\n>>\n>> \u2014\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/dask/dask/issues/9969#issuecomment-1434010484>, or\n>> unsubscribe\n>> <https://github.com/notifications/unsubscribe-auth/AACKZTA37DMTOD6XXUW6S33WX3PHXANCNFSM6AAAAAAU6EIMO4>\n>> .\n>> You are receiving this because you were mentioned.Message ID:\n>> ***@***.***>\n>>\n>\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1434064380/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1434438912",
        "html_url": "https://github.com/dask/dask/issues/9969#issuecomment-1434438912",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9969",
        "id": 1434438912,
        "node_id": "IC_kwDOAbcwm85Vf80A",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-17T10:27:28Z",
        "updated_at": "2023-02-17T10:27:28Z",
        "author_association": "MEMBER",
        "body": "If we truly wanted to avoid deserialization on scheduler side in the context of HLGs we'd need to put some thought into how `runspec=dumps({\"func\": self.func, \"argspec\": self.argspec}),` can be expressed better.\r\nI haven't put much thought into this but from my limited experience with HLGs I think it should be possible. I think we just need a slightly more sophisticated way of describing `argspec/runspec` but I think we can do this in a follow up.\r\n\r\n> Makes sense that generation itself will take a bit of a hit. We definitely want to make sure that end-to-end performance improves for real-world applications (or remains reasonably flat) - I have my fingers crossed.\r\n\r\nI did some benchmarks with graphs of ~100k nodes where every node had ~3-5 arguments of which half are actual dependencies. I think this is a rather dense graph and a \"bad case\" for our current logic. I measured a chain of basically `gen_graph + get_deps` and it was faster end to end (I somehow misplaced the code I was using yesterday, sorry :( ). \r\n\r\nIn terms of performance I'm less worried about speed. If anything, we should be slightly careful when it comes to memory usage. The slotted class itself (as defined above) has the same memory overhead as a (four-)tuple. However, the above naive implementation is using a dict to track dependencies. Dicts require \"a lot\" of memory and this could add up to a couple hundred MBs for large graphs. \r\nNot a deal breaker but still something to keep in mind, especially if we put more things into this object",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1434438912/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1434552704",
        "html_url": "https://github.com/dask/dask/issues/9969#issuecomment-1434552704",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9969",
        "id": 1434552704,
        "node_id": "IC_kwDOAbcwm85VgYmA",
        "user": {
            "login": "crusaderky",
            "id": 6213168,
            "node_id": "MDQ6VXNlcjYyMTMxNjg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6213168?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/crusaderky",
            "html_url": "https://github.com/crusaderky",
            "followers_url": "https://api.github.com/users/crusaderky/followers",
            "following_url": "https://api.github.com/users/crusaderky/following{/other_user}",
            "gists_url": "https://api.github.com/users/crusaderky/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/crusaderky/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/crusaderky/subscriptions",
            "organizations_url": "https://api.github.com/users/crusaderky/orgs",
            "repos_url": "https://api.github.com/users/crusaderky/repos",
            "events_url": "https://api.github.com/users/crusaderky/events{/privacy}",
            "received_events_url": "https://api.github.com/users/crusaderky/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-17T12:09:54Z",
        "updated_at": "2023-02-17T12:09:54Z",
        "author_association": "MEMBER",
        "body": "```python\r\ndsk = {\r\n    \"key-1\": (func, \"a\", \"b\"),\r\n    \"key-2\": (func, \"key-1\", \"b\"),\r\n    \"key-3\": (func, (func2, \"c\", \"key-1\"), \"key-2\")\r\n}\r\n```\r\nFor the sake of completeness, this is missing a fourth and last use case, which is constants. A constant is defined as any value that is either not hashable or does not appear in the keys.\r\n\r\nThat `Task` class you defined above looks a lot like `SubgraphCallable`, minus the actual subgraph.\r\n\r\n> The important piece to take away is that we are iterating and recursing over almost every iterable we can find in the graph and replace matching keys automatically. Multiple times. \r\n\r\nYeah, I recall using dirty hacks like using a `UserList` for my payloads to stop dask from iterating over it.\r\n\r\n> Multiple times. This is very error prone and not particularly performance sensitive [3].\r\n\r\nAre we doing it upstream or downstream of optimization and losing the HLG layers? If it's (or if it were to be) upstream of optimization, it would only be once per layer, right? So is performance an actual problem?\r\nDo we have a measure of how much we're spending on this when we call compute for, say, a 100k keys graph?\r\n\r\nImportant to point out that, if we did this, we'd not be able to remove all complexity related to dealing with tuples any time soon, because of backwards compatibility with third-party dsk's. I mean, today we're still supporting collections with a raw dict as their `__dask_graph__` instead of a HighLevelGraph, and the hlg is old enough that we're considering retiring it.\r\n\r\nIMHO, this feels like a substantial amount of work for... a nice to have? None of the current design feels *on fire* to me, but I may be wrong.\r\n",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1434552704/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    },
    {
        "url": "https://api.github.com/repos/dask/dask/issues/comments/1434606753",
        "html_url": "https://github.com/dask/dask/issues/9969#issuecomment-1434606753",
        "issue_url": "https://api.github.com/repos/dask/dask/issues/9969",
        "id": 1434606753,
        "node_id": "IC_kwDOAbcwm85Vglyh",
        "user": {
            "login": "fjetter",
            "id": 8629629,
            "node_id": "MDQ6VXNlcjg2Mjk2Mjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8629629?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fjetter",
            "html_url": "https://github.com/fjetter",
            "followers_url": "https://api.github.com/users/fjetter/followers",
            "following_url": "https://api.github.com/users/fjetter/following{/other_user}",
            "gists_url": "https://api.github.com/users/fjetter/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/fjetter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/fjetter/subscriptions",
            "organizations_url": "https://api.github.com/users/fjetter/orgs",
            "repos_url": "https://api.github.com/users/fjetter/repos",
            "events_url": "https://api.github.com/users/fjetter/events{/privacy}",
            "received_events_url": "https://api.github.com/users/fjetter/received_events",
            "type": "User",
            "site_admin": false
        },
        "created_at": "2023-02-17T12:53:32Z",
        "updated_at": "2023-02-17T12:53:32Z",
        "author_association": "MEMBER",
        "body": "> That Task class you defined above looks a lot like SubgraphCallable, minus the actual subgraph.\r\n\r\nYes, that's the point. As I stated, the `SubgraphCallable` is a `Task` in this approach. The entire point of this approach is that we're maintaining a collection of dependencies as part of the task definition itself and using this instead of walking the graph. This is exactly what the `SubgraphCallable` is already doing.\r\n\r\n> Do we have a measure of how much we're spending on this when we call compute for, say, a 100k keys graph?\r\n\r\nI don't have a measure but performance is only a secondary point. I'm not concerned about performance. This is about complexity reduction\r\n\r\n> Important to point out that, if we did this, we'd not be able to remove all complexity related to dealing with tuples any time soon, because of backwards compatibility with third-party dsk's.\r\n\r\nThe existing logic that is currently walking the graph can be used to convert to the new format while raising a DeprecationWarning. I agree this is nontrivial work but it can be rolled out incrementally\r\n\r\n> None of the current design feels on fire to me, but I may be wrong.\r\n\r\nWhen dealing with serialization and graph construction/materialization this is a painful issue. Everything I described above comes from pain I encountered while dealing with HLGs, either while writing them old-style but also while working on https://github.com/dask/distributed/pull/6028\r\nApart from a couple of key collision issues like https://github.com/dask/distributed/issues/3965 / https://github.com/dask/distributed/issues/7551 this is mostly about maintenance and developer velocity.\r\n\r\nI also believe that our current serialization protocol could be substantially simplified but I haven't done the work to provide details.\r\n\r\nNote: As most people are likely aware this change would mostly benefit `dask/distributed` but a lot of the work would happen in `dask/dask` which is why I posted it in this repo",
        "reactions": {
            "url": "https://api.github.com/repos/dask/dask/issues/comments/1434606753/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
        },
        "performed_via_github_app": null
    }
]